/*
RequireJS
-------------------------------------------------
MIT
(c) 2010-2011, The Dojo Foundation All Rights Reserved.

jQuery.js
-------------------------------------------------
MIT
(c) 2009 John Resig

Backbone
Underscore.js
-------------------------------------------------
MIT
(c) 2009-2011 Jeremy Ashkenas, DocumentCloud Inc.

Handlebars.js
------------------------------------------------
MIT
(c) Yehuda Katz

json2.js
------------------------------------------------
Public Domain.
NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

Lawnchair
------------------------------------------------
MIT
(c) 2009, 2010, 2011 Brian LeRoux

easyXDM
------------------------------------------------
MIT
(c) 2009-2011, Øyvind Sean Kinsey

Moment.js
------------------------------------------------
MIT
(c) Tim R Wood

Boilerplate-Boilerplate
------------------------------------------------
MIT
(c) 2011 - Adam Sontag

Cohorts
------------------------------------------------
MIT
(c) 2010 James Yu

parseUri 1.2.2
------------------------------------------------
MIT
(c) Steven Levithan <stevenlevithan.com>

FitText.js 1.1
------------------------------------------------
WTFPL
(c) 2011 Dave Rupert http://daverupert.com

usertiming.js
------------------------------------------------
MIT
(c) 2013 Nic Jansma http://nicj.net

asEvented
------------------------------------------------
MIT
(c) 2012, Michal Kuklis
*/

(function() {

  if (window.BV && window.BV.serverRender) {
    return;
  }

  if (typeof window.BV === 'undefined') {
    window.BV = {};
  }

  if (!window.BV.serverRender &&
    window.BV.performance &&
    window.BV.performance.mark
  ) {
    // Mark the start of bv-primary.js.
    window.BV.performance.mark('primaryStart');
    window.BV._internal.primaryStartTime = new Date();
  }

  // require.js library will be inserted here
  /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, jQuery, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.1',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        aps = ap.slice,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    //Allow getting a global that expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite and existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                map: {},
                config: {}
            },
            registry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    if (config.pkgs[baseName]) {
                        //If the baseName is a package name, then just treat it as one
                        //name to concat the name with.
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that 'directory' and not name of the baseName's
                        //module. For instance, baseName of 'one/two/three', maps to
                        //'one/two/three.js', but we want the directory, 'one/two' for
                        //this normalization.
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);

                    //Some use of packages may use a . path to reference the
                    //'main' module name, so normalize for that.
                    pkgConfig = config.pkgs[(pkgName = name[0])];
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if (applyMap && (baseParts || starMap) && map) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = map[baseParts.slice(0, j).join('/')];

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = mapValue[nameSegment];
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = config.paths[id];
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                removeScript(id);
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = defined[prefix];
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = registry[id];

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = registry[id];

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                getModule(depMap).on(name, fn);
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = registry[id];
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return (config.config && config.config[mod.map.id]) || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = registry[depId];

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (traced[depId]) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(registry, function (mod) {
                map = mod.map;
                modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = undefEvents[map.id] || {};
            this.map = map;
            this.shim = config.shim[map.id];
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks is the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error.
                            if (this.events.error) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                //If setting exports via 'module' is in play,
                                //favor that over return value and exports. After that,
                                //favor a non-undefined return value over exports use.
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        //Make sure it is not already the exports value
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = [this.map.id];
                                err.requireType = 'define';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        delete registry[id];

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true,
                            skipMap: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = registry[normalizedMap.id];
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        try {
                            req.exec(text);
                        } catch (e) {
                            throw new Error('fromText eval for ' + moduleName +
                                            ' failed: ' + e);
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = handlers[depMap.id];

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', this.errback);
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!handlers[id] && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = registry[pluginMap.id];
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths and packages since they require special processing,
                //they are additive.
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if (value.exports && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;

                        //Create a brand new object on pkgs, since currentPackages can
                        //be passed in again, and config.pkgs is the internal transformed
                        //state for all package configs.
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            //Remove leading dot in main, so main paths are normalized,
                            //and remove any trailing .js, since different package
                            //envs have different conventions: some use a module name,
                            //some use a file name.
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });

                    //Done with modifications, assing packages back to context config
                    config.pkgs = pkgs;
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || getGlobal(value.exports);
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && handlers[deps]) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var index = moduleNamePlusExt.lastIndexOf('.'),
                            ext = null;

                        if (index !== -1) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = registry[id];

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. parent module is passed in for context,
             * used by the optimizer.
             */
            enable: function (depMap, parent) {
                var mod = registry[depMap.id];
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = config.shim[moduleName] || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = registry[moduleName];

                if (!found && !defined[moduleName] && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = pkgs[parentModule];
                        parentPath = paths[parentModule];
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            //If module name is just the package name, then looking
                            //for the main module.
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/\?/.test(url) ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callack function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = contexts[contextName];
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = function (err) {
        throw err;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = config.xhtml ?
                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                    document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';
            node.async = true;

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEvenListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            //In a web worker, use importScripts. This is not a very
            //efficient use of importScripts, importScripts will block until
            //its script is downloaded and evaluated. However, if web workers
            //are in play, the expectation that a build has been done so that
            //only one script needs to be loaded anyway. This may need to be
            //reevaluated if other use cases become common.
            importScripts(url);

            //Account for anonymous modules
            context.completeLoad(moduleName);
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser) {

        // UIA-3481, do not look for data-main attribute when built because we
        // don't use it in production, and if a customer does use it in production,
        // then we will find it and end up throwing an ugly (but inconsequential)
        // error in the console.
        if (
          // it's not a BV page, so data-main is safe
          // (what are we even doing here? better safe than sorry, though)
          typeof BV === 'undefined' ||

          // it's a firebird sample page, so data-main is safe
          (BV._internal && BV._internal.samplePage) ||

          // it's a firebird page, but we're not built, so data-main is safe
          (BV.options && !BV.options.build)
        ) {

            //Figure out baseUrl. Get it from the script tag with require.js in it.
            eachReverse(scripts(), function (script) {
                //Set the 'head' where we can append children by
                //using the script's parent.
                if (!head) {
                    head = script.parentNode;
                }

                //Look for a data-main attribute to set main script for the page
                //to load. If it is there, the path to data main becomes the
                //baseUrl, if it is not already set.
                dataMain = script.getAttribute('data-main');
                if (dataMain) {
                    //Set final baseUrl if there is not already an explicit one.
                    if (!cfg.baseUrl) {
                        //Pull off the directory of data-main for use as the
                        //baseUrl.
                        src = dataMain.split('/');
                        mainScript = src.pop();
                        subPath = src.length ? src.join('/')  + '/' : './';

                        cfg.baseUrl = subPath;
                        dataMain = mainScript;
                    }

                    //Strip off any trailing .js since dataMain is now
                    //like a module name.
                    dataMain = dataMain.replace(jsSuffixRegExp, '');

                    //Put the data-main script in the files to load.
                    cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];

                    return true;
                }
            });
        }
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = [];
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps.length && isFunction(callback)) {
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));


  BV.requirejs = requirejs;
  BV.require = require;
  BV.define = define;

})();

(function() {

  // per @ceej86, this is necessary for server-render path not to explode
  if (typeof window.BV === 'undefined') {
    window.BV = {};
  }

// Our app will be inserted here
  
/*global require */
/*jshint evil:true */

BV.define('staticAssets',[],function () {
  // This plugin provides a way for modules to require files from
  // the static asset service. It assumes that the static asset service
  // SDK has been intialized elsewhere, creating BV._staticAssetRegistry.
  // Modules that need a module provided by the service can use this plugin
  // as follows:
  //
  // BV.define(['staticAssets!jquery'], function ($) { ... })
  //
  // A list of supported modules (and their corresponding version) should
  // be maintained in the `map` variable below. If updating the entries below,
  // you must also update the corresponding entries in
  // static/dev/scripts/scout/loader.js.
  //
  // As a convenience, this repo provides a jquery module and an underscore
  // module that call through to the static asset service. As a result, other
  // modules can simply request jquery or underscore, and trust that the
  // request will be routed to the static asset service.
  var map = {
    jquery: 'jquery-bv@1.11.1',
    lodash: 'lodash-bv@1.2.0'
  };

  var cache = {};

  return {
    load: function (name, parentRequire, onload, config) {
      
      // For development and production, we simply ask the SDK for the
      // required module. Importantly, this should not actually result
      // in a new request to the static asset service; rather, the request
      // should be created in the scoutfile, and this call will just
      // piggy-back on that request, rather than making a new one. See
      // static/dev/scripts/scout/loader.js for the initial request.
      if (cache[name]) {
        onload(cache[name]);
        return;
      }

      window.BV.staticAssetLoader.require([
        map[name]
      ], function (val) {
        cache[name] = val;
        onload(val);
      });
    }
  };
});

BV.define('window',[],function () {
  return window;
});

BV.define('jquery',[
  'staticAssets!jquery',
  'window'
], function ($, window) {
  // If we are in a server render environment,
  // use a jquery hack to fake the methods we need.
  if (window.BV && window.BV.serverRender) {
    var res = function () {
      return [{}];
    };
    res.Deferred = window.BV.ud.Deferred;
    res.when = window.BV.ud.when;
    res.fn = {};
    res.event = { special : {} };
    res._bvjquery = true;
    return res;
  }
  return $;
});

// All our styles have `!important` directives on them because we need to
// guard against customer CSS. But that means that most of the CSS
// manipulation we do in JavaScript needs `!important` directives as well,
// or else they won't override existing styles. This plugin uses jQuery's
// CSS hooks to ensure that happens for a whitelist of CSS properties.

BV.define('vendor/jquery/importantizer',['jquery'], function($) {

  var CSS_PROPERTIES_TO_OVERRIDE = ['top', 'overflow', 'z-index', 'position', 'display', 'right', 'left', 'bottom', 'width', 'height', 'padding', 'margin', 'overflowY', 'fontSize', 'visibility', 'maxHeight', 'maxWidth'];

  // jQuery camelCases properties before looking up their CSS hook. However,
  // the camelCased version is not valid for the cssText string.
  var UNCAMELCASED_PROPERTIES = {
    fontSize : 'font-size',
    overflowY: 'overflow-y',
    zIndex:    'z-index',
    maxHeight: 'max-height',
    maxWidth: 'max-width'
  };

  function makeSetter (rule, origSet) {
    return {
      set : function (elem, value) {
        if (origSet) {
          origSet.call(this, elem, value);
        }

        var prop = UNCAMELCASED_PROPERTIES[rule] || rule;

        var oldCSS = elem.style.cssText.replace(
          new RegExp(prop + ': [^;]+[;$]', 'i'),
          ''
        );

        var newCSS = oldCSS + '; ' + prop + ': ' + value + ' !important;';
        $(elem).css('cssText', newCSS);
      }
    };
  }

  var DEFERRED = $.Deferred();

  // Expose a promise so that other things can ensure their tasks happen
  // after importantizer has run.
  $.importantizer = DEFERRED.promise();

  // Sadly, we can't add CSS hooks until DOMready.
  $(function() {
    $.each(CSS_PROPERTIES_TO_OVERRIDE, function (i, name) {
      $.cssHooks[name] = $.cssHooks[name] || {};
      var origSet = $.cssHooks[name].set;
      $.extend($.cssHooks[name], makeSetter(name, origSet));
    });

    DEFERRED.resolve();
  });

  return $;

});

BV.define('underscore',[
  'staticAssets!lodash'
], function (lodash) {

  // BVADDED for string manip
  // Based on Underscore.string
  // (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
  // Underscore.strings is freely distributable under the terms of the MIT license.
  // Documentation: https://github.com/epeli/underscore.string
  // Some code is borrowed from MooTools and Alexandru Marasteanu.

  (function (_) {

    var nativeTrim = String.prototype.trim;
    var nativeTrimRight = String.prototype.trimRight;
    var nativeTrimLeft = String.prototype.trimLeft;

    var defaultToWhiteSpace = function(characters) {
      if (characters == null)
        return '\\s';
      else if (characters.source)
        return characters.source;
      else
        return '[' + _s.escapeRegExp(characters) + ']';
    };

    var _s = {

      escapeRegExp : function (str) {
        if (str == null) return '';
        return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
      },

      capitalize : function (str) {
        str = str == null ? '' : String(str);
        return str.charAt(0).toUpperCase() + str.slice(1);
      },

      trim : function (str, characters) {
        if (str == null) return '';
        if (!characters && nativeTrim) return nativeTrim.call(str);
        characters = defaultToWhiteSpace(characters);
        return String(str).replace(new RegExp('\^' + characters + '+|' + characters + '+$', 'g'), '');
      },

      ltrim : function (str, characters) {
        if (str == null) return '';
        if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
        characters = defaultToWhiteSpace(characters);
        return String(str).replace(new RegExp('^' + characters + '+'), '');
      },

      rtrim : function (str, characters) {
        if (str == null) return '';
        if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
        characters = defaultToWhiteSpace(characters);
        return String(str).replace(new RegExp(characters + '+$'), '');
      },

      prune : function (str, length, pruneStr) {
        if (str == null) return '';

        str = String(str); length = ~~length;
        pruneStr = pruneStr != null ? String(pruneStr) : '...';

        if (str.length <= length) return str;

        var tmpl = function (c) { return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
          template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

        if (template.slice(template.length-2).match(/\w\w/))
          template = template.replace(/\s*\S+$/, '');
        else
          template = _s.rtrim(template.slice(0, template.length-1));

        return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;
      },

      stripTags : function (str) {
        if (str == null) return '';
        return String(str).replace(/<\/?[^>]+>/g, '');
      }
    };

    _.string = _.str = _s;

  }(lodash));

  return lodash;

});

(function(g){

    // summary: A simple feature detection function/framework.
    //
    // name: String
    //      The name of the feature to detect, as defined by the overall `has` tests.
    //      Tests can be registered via `has.add(testname, testfunction)`.
    //
    // example:
    //      mylibrary.bind = has("native-bind") ? function(fn, context){
    //          return fn.bind(context);
    //      } : function(fn, context){
    //          return function(){
    //              fn.apply(context, arguments);
    //          }
    //      }

    var NON_HOST_TYPES = { "boolean": 1, "number": 1, "string": 1, "undefined": 1 },
        VENDOR_PREFIXES = ["Webkit", "Moz", "O", "ms", "Khtml"],
        d = isHostType(g, "document") && g.document,
        el = d && isHostType(d, "createElement") && d.createElement("DiV"),
        testCache = {}
    ;

    function has(/* String */name){
        if(typeof testCache[name] == "function"){
            testCache[name] = testCache[name](g, d, el);
        }
        return testCache[name]; // Boolean
    }

    function add(/* String */name, /* Function */test, /* Boolean? */now){
        // summary: Register a new feature detection test for some named feature
        //
        // name: String
        //      The name of the feature to test.
        //
        // test: Function
        //      A test function to register. If a function, queued for testing until actually
        //      needed. The test function should return a boolean indicating
        //      the presence of a feature or bug.
        //
        // now: Boolean?
        //      Optional. Omit if `test` is not a function. Provides a way to immediately
        //      run the test and cache the result.
        // example:
        //      A redundant test, testFn with immediate execution:
        //  |       has.add("javascript", function(){ return true; }, true);
        //
        // example:
        //      Again with the redundantness. You can do this in your tests, but we should
        //      not be doing this in any internal has.js tests
        //  |       has.add("javascript", true);
        //
        // example:
        //      Three things are passed to the testFunction. `global`, `document`, and a generic element
        //      from which to work your test should the need arise.
        //  |       has.add("bug-byid", function(g, d, el){
        //  |           // g  == global, typically window, yadda yadda
        //  |           // d  == document object
        //  |           // el == the generic element. a `has` element.
        //  |           return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
        //  |       });
        testCache[name] = now ? test(g, d, el) : test;
    }

    // cssprop adapted from http://gist.github.com/598008 (thanks, ^pi)
    function cssprop(name, el){
        var supported = false,
            capitalized = name.charAt(0).toUpperCase() + name.slice(1),
            length = VENDOR_PREFIXES.length,
            style = el.style;

        if(typeof style[name] == "string"){
            supported = true;
        }else{
            while(length--){
                if(typeof style[VENDOR_PREFIXES[length] + capitalized] == "string"){
                    supported = true;
                    break;
                }
            }
        }
        return supported;
    }

    function clearElement(el){
        if(el){
            while(el.lastChild){
                el.removeChild(el.lastChild);
            }
        }
        return el;
    }

    // Host objects can return type values that are different from their actual
    // data type. The objects we are concerned with usually return non-primitive
    // types of object, function, or unknown.
    function isHostType(object, property){
        var type = typeof object[property];
        return type == 'object' ? !!object[property] : !NON_HOST_TYPES[type];
    }

        has.add = add;
    has.clearElement = clearElement;
    has.cssprop = cssprop;
    has.isHostType = isHostType;
    has._tests = testCache;

    has.add("dom", function(g, d, el){
        return d && el && isHostType(g, "location") && isHostType(d, "documentElement") &&
            isHostType(d, "getElementById") && isHostType(d, "getElementsByName") &&
            isHostType(d, "getElementsByTagName") && isHostType(d, "createComment") &&
            isHostType(d, "createElement") && isHostType(d, "createTextNode") &&
            isHostType(el, "appendChild") && isHostType(el, "insertBefore") &&
            isHostType(el, "removeChild") && isHostType(el, "getAttribute") &&
            isHostType(el, "setAttribute") && isHostType(el, "removeAttribute") &&
            isHostType(el, "style") && typeof el.style.cssText == "string";
    });

    // Stop repeat background-image requests and reduce memory consumption in IE6 SP1
    // http://misterpixel.blogspot.com/2006/09/forensic-analysis-of-ie6.html
    // http://blogs.msdn.com/b/cwilso/archive/2006/11/07/ie-re-downloading-background-images.aspx?PageIndex=1
    // http://support.microsoft.com/kb/823727
    try{
        document.execCommand("BackgroundImageCache", false, true);
    }catch(e){}

    BV.define('util/has',[],function (){
        return has;
    });

})(this);



BV.define('BV',['window'], function (window) {
  return window.BV;
});

// http://en.wikipedia.org/wiki/Fletcher's_checksum
// https://gist.github.com/1200689
BV.define('util/checksum',[],function () {
  return function(a,b,c,d,e){for(b=c=d=0;e=a.charCodeAt(d++);c=(c+b)%255)b=(b+e)%255;return c<<8|b};
});
/**
 * @fileOverview A module for returning a word in the requested format,
 * according to the rules described by an array.
 */
BV.define('bv/util/grammr',[
  'underscore'
], function (_) {
  /**
   * The function returned by the module, which generates an object
   * that will properly adjust the provided typePairs
   * @param  {Array} typePairs An array of arrays, where each item
   *                           in the "outer" array is an array with
   *                           at least two items. The first item
   *                           must be the singular version of the word;
   *                           the second item must be the plural version
   *                           of the word. For example:
   *
   *                           [
   *                             [ 'review', 'reviews' ]
   *                           ]
   *
   * @return {Object}          An object with the following methods, where
   *                           each method takes the "root" word -- in either
   *                           singular or plural form -- and returns the format
   *                           specified by the method name:
   *                           - noun: returns the lowercase singular
   *                           - nouns: returns the lowercase plural
   *                           - Noun: returns the title-case singular
   *                           - Nouns: returns the title-case plural
   *                           - NOUN: returns the upper-case singular
   *                           - NOUNS: returns the upper-case plural
   */
  return function (typePairs) {
    function _nounOrNouns (type, plural, capitalize) {
      var lowerType = type.toLowerCase();
      var result;

      _(typePairs).forEach(function (typePair) {
        if (lowerType === typePair[0]) {
          result = plural ? typePair[1] : lowerType;
        } else if (lowerType === typePair[1]) {
          result = plural ? lowerType : typePair[0];
        }
      });

      if (result) {
        return capitalize ? _.string.capitalize(result) : result;
      }

      throw new Error('Unknown type: ' + type);
    }

    return {
      noun: _.memoize(function (type) {
        return _nounOrNouns(type);
      }),
      nouns: _.memoize(function (type) {
        return _nounOrNouns(type, true);
      }),
      Noun: _.memoize(function (type) {
        return _nounOrNouns(type, false, true);
      }),
      Nouns: _.memoize(function (type) {
        return _nounOrNouns(type, true, true);
      }),
      NOUN: _.memoize(function (type) {
        return _nounOrNouns(type).toUpperCase();
      }),
      NOUNS: _.memoize(function (type) {
        return _nounOrNouns(type, true).toUpperCase();
      })
    };
  };

});

BV.define('client',{
  load: function (name, req, load, config) {
    if (!config.isServerRender) {
      req([name], function (resource) {
        load(resource);
      });
    }
    else {
      load({});
    }
  }
});

/**
 *  @fileOverview Utility library for reading and manipulating URLs.
 */
BV.define('util/url',[
  'client!window',
  'underscore'
], function (
  window,
  _
) {

  if (!window.location) {
    window.location = { protocol: 'http:' };
  }

  // Like String.prototype.split, except it divides the string into exactly
  // two parts at the _first_ occurrence of the given string. Otherwise
  // things like http://example.com?foo=bar=baz&baz=thud won't get parsed
  // correctly.
  function divideAt (str, divider) {
    var index = str.indexOf(divider);
    var left = str.substring(0, index);
    var right = str.substring(index + 1);
    return [left, right];
  }

  return {
    protocol: window.location.protocol === 'https:' ? 'https:' : 'http:',
    host: window.location.host,
    // IE doesn't support window.location.origin (CCS-208)
    origin: window.location.origin || ( window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '') ),

    /**
     * Build a URL out of multiple paths.
     *
     * @param {Arguments} Any number of path parts.
     * @returns {String} The combined path.
     */
    join: function () {
      var paths = _(arguments).toArray();

      if (paths.length === 0) {
        return '';
      }

      return _(paths).map(function (path, index) {
        path = path.toString();

        // Preserve leading slash if it exists.
        if (index === 0) {
          return path.replace(/\/$/g, '');
        }
        // Preserve trailing slash if it exists.
        else if (index === paths.length - 1) {
          return path.replace(/^\//g, '');
        }
        else {
          return path.replace(/^\/|\/$/g, '');
        }
      }).join('/');
    },

    /**
     * Remove a parameter from a URL.
     * See: http://stackoverflow.com/a/1634841/90091
     * @param  {String} url
     * @param  {String} param
     * @return {String}
     */
    splice: function (url, param) {
      var prefix;
      var params;
      var bvdataParams;
      var bvdataParamsDecoded;
      var bvdataParamsSplit;
      var i;
      var j;

      var hashlessUrl = this.withoutHash(url);
      var hash = this.hash(url);
      var urlparts = hashlessUrl.split('?');

      if (urlparts.length < 2) {
        return url;
      }

      if (param === '*') {
        return urlparts[0] + hash;
      }

      // The param we're searching for.
      prefix = encodeURIComponent(param) + '=';
      params = urlparts[1].split(/[&;]/g);

      // Reverse iteration as may be destructive.
      for (i = params.length; i-- > 0; ) {
        // If we are on the bvdata param, we need to search deeper
        if (params[i].lastIndexOf('bvdata=', 0) === 0) {
          // Get the params stored in 'bvdata='
          bvdataParams = params[i].split('=')[1];
          // Decode the params
          bvdataParamsDecoded = decodeURIComponent(bvdataParams);
          // Split on &
          bvdataParamsSplit = bvdataParamsDecoded.split(/[&;]/g);

          // iterate in reverse, splicing matching prefix params
          for (j = bvdataParamsSplit.length; j-- > 0; ) {
            // Idiom for string.startsWith.
            if (bvdataParamsSplit[j].lastIndexOf(prefix, 0) !== -1) {
              // Remove this parameter from the list of parameters.
              bvdataParamsSplit.splice(j, 1);
            }
          }
          // rewrite bvdata with filtered params
          params[i] = 'bvdata=' + encodeURIComponent( bvdataParamsSplit.join('&') );
        }

        // Idiom for string.startsWith.
        else if (params[i].lastIndexOf(prefix, 0) !== -1) {
          // Remove this parameter from the list of parameters.
          params.splice(i, 1);
        }
      }

      // Rebuild the URL.
      return urlparts[0] + '?' + params.join('&') + hash;
    },

    /**
     * Get a parameter's value from a URL.
     * @param  {String} url   The URL to search for the param
     * @param  {String} param The desired parameter
     * @return {String}       The decoded value of the parameter if we find it, otherwise null
     */
    getParam: function (url, param) {
      var i;
      var prefix;
      var params;
      var undecodedParamValue;

      var hashlessUrl = this.withoutHash(url);
      var urlparts = hashlessUrl.split('?');

      // If the query is empty, bail
      if (urlparts.length < 2) {
        return null;
      }

      // The param we're searching for.
      prefix = encodeURIComponent(param) + '=';
      params = urlparts[1].split(/[&;]/g);

      for (i = params.length; i-- > 0; ) {
        // Idiom for string.startsWith.
        if (params[i].lastIndexOf(prefix, 0) !== -1) {
          undecodedParamValue = divideAt(params[i], '=')[1];
          return decodeURIComponent(undecodedParamValue);
        }
      }

      // return null if we didn't find it
      return null;
    },

    /**
     * Get a bvdata parameter's value from the bvdata parameter of a given URL.
     * @param   {String} url    The URL to search for the param
     * @param   {String} param  The desired parameter
     * @return  {String}        The decoded value of the parameter if we find it, otherwise null
     */
    getBvParam: function getBvParam (url, param) {
      var keyValuePair;
      var key;
      var value;
      var i;

      var bvData = this.getParam(url, 'bvdata');

      if (!bvData) {
        return null;
      }

      // Split into array of 'key=value' strings.
      bvData = bvData.split('&');

      for (i = 0; i < bvData.length; i++) {
        keyValuePair = bvData[i].split('=');
        key = keyValuePair[0];
        value = keyValuePair[1];

        if (key === param) {
          return value;
        }
      }

      return null;
    },

    /**
     * Add a parameter to the URL. (Does not check if the parameter name is
     * already present in the URL, since it is valid for a URL to have
     * multiple params with the same name and different values.)
     * @param  {String} url
     * @param  {String} param
     * @param  {String} value
     * @param  {Object} options Options. Only one so far is `encode`, which
     *   defaults to `true` and controls whether the param name and value get
     *   URL-encoded when they are added to the URL.
     * @return {String}
     */
    push: function (url, param, value, options) {
      var hashlessUrl;
      var pair;
      var newUrl;

      options = _.extend({ encode: true }, options);
      hashlessUrl = this.withoutHash(url);
      if (options.encode) {
        param = encodeURIComponent(param);
        value = encodeURIComponent(value);
      }
      pair = param + '=' + value;
      newUrl = this.caboose(hashlessUrl) + pair + this.hash(url);
      return newUrl;
    },

    caboose: function (url) {
      var index;
      if (!url) {
        return null;
      }
      // Strip the hash. Since this method is meant to return a string onto
      // which one can append URL params directly, it's wrong to keep the
      // hash, even though this is a destructive change to the URL. This is a
      // big behavior change, but it's OK because this was guaranteed not to
      // work correctly for URLs with hashes.
      url = this.withoutHash(url);
      index = url.indexOf('?');
      if (index === url.length - 1) {
        // The ? is the last character in the URL, so it's ready for appending.
        return url;
      }
      return url + ( (index > 0) ? '&' : '?' );
    },

    /**
     * Turns an object into a URL friendly list of key/value parameters.
     * NOTE: This is only meant for a simple map of strings and does not work with more complex objects.
     * @param obj
     * @return {String}
     */
    stringifyObject: function (obj) {
      var result = [];
      _(obj).forEach(function (value, key) {
        if ( !_(value).isUndefined() ) {
          result.push( encodeURIComponent(key) + '=' + encodeURIComponent(value) );
        }
      });
      return result.join('&');
    },

    /**
     * See: http://aganov.github.com/underscore-strings/docs/underscore.strings.html#section-14
     *
     * @param string
     * @param separator
     * @return {*}
     */
    toQueryParams: function (string, separator) {
      var key;
      var value;
      var match = string.match(/([^?#]*)(#.*)?$/);

      if (!match) {
        return {};
      }

      return _( match[1].split(separator || '&') ).reduce(function (hash, pair) {
        if ( ( pair = divideAt(pair, '=') )[0] ) {
          key = decodeURIComponent( pair.shift() );
          value = pair.length > 1 ? pair.join('=') : pair[0];

          if ( !_.isUndefined(value) ) {
            value = decodeURIComponent(value);
          }

          if (key in hash) {
            if ( !_.isArray(hash[key]) ) {
              hash[key] = [hash[key]];
            }
            hash[key].push(value);
          }
          else {
            hash[key] = value;
          }
        }
        return hash;
      }, {});
    },

    /**
     * Returns only the URL fragment (including the octothorpe) if it exists;
     * otherwise returns an empty string.
     *
     * @param url
     * @return {String}
     */
    hash: function (url) {
      var hashIndex = url.indexOf('#');
      if (hashIndex === -1) {
        return '';
      }

      return url.slice(hashIndex);
    },


    withoutHash: function (url) {
      return url.replace(/#.*?$/, '');
    }
  };
});

// # BV API Client - JavaScript
/**
 * Depends on:
 *   jQuery >= 1.7.1
 *   underscore >= 1.2.3
 *
 * MIT License
 * @version 0.1.0 beta
 * @bvapiversion >= 5.0
 * @author Alex Sexton <Alex.Sexton@bazaarvoice.com>
**/
BV.define('bv/api',['underscore', 'util/checksum', 'bv/util/grammr', 'util/url'], function (_, checksum, grammr, Url) {

  var global = this,
  // The `client` is the object that eventually results
  // from this. It's usually added as `BV.api` when using globals instead of
  // modules.
    client = {
    // This is a default configuration
      _config: {
      // The return format (extension)
        format: 'json',
      // Change the data up to be all together (and stuff)
        normalize: true,
      // The api version, duh
        apiversion: '5.5',
      // The date object to do sorts and filters against
        timeKey: 'LastModeratedTime'
      }
    },
  // These are the mappings for common
  // operators to our api keys for the same things
    logicalKeys = {
      '>': 'gt',
      '>=': 'gte',
      '<': 'lt',
      '<=': 'lte',
      '=': 'eq',
      '!=': 'neq'
    },
  // The translation for ascending and descending in sorts
    dirKeys = {
      '+': 'asc',
      '-': 'desc'
    },
  // This is a list of our types in singular and plural.
  // The third string is for it's sugar filter helper
  // and it defaults to 'for'
    typePairs = [
    ['review', 'reviews', 'with'], // from?
    ['question', 'questions'],
    ['answer', 'answers'],
    ['story', 'stories'],
    ['comment', 'comments', 'with'],
    ['reviewcomment', 'reviewcomments', 'with'],
    ['author', 'authors', 'from'],
    ['photo', 'photos', 'with'],
    ['video', 'videos', 'with'],
    ['product', 'products'],
    ['category', 'categories', 'in'],
    ['clientresponse', 'clientresponses'],
    ['statistic', 'statistics']
    ],
  // This function kicks things off. It uses the jQuery
  // pattern of calling a prototype (aliased as `fn`) to actually
  // kick off a new instance. The `new` keyword creates a new instance
  // scope so all the data called on it after a `get` call and it's aliases
  // won't affect other queries.
    get = function (contentType, idList, apiBatch) {
      return new get.fn.init(contentType, idList, apiBatch);
    },
  // These functions are the set that are returned for subqueries.
  // Most of them have to be distinctly different than the core functions
  // because they are built in different ways in the end, so the data is
  // stored accordingly.
    subquerySet = {
    // ## Subquery: `offset`
    // Sets the `offset_<type>` key in the request
    // does not take multiple values. The last one wins.
      offset: function (num) {
        this.mods.offset = num;
        return this;
      },
    // ## Subquery: `limit`
    // Much like offset, this sets `limit_<type>` in the request
    // Last value wins.
      limit: function (num) {
        this.mods.limit = num;
        return this;
      },
    // ## Subquery: `sortBy`
    // This `sortBy` sorts the subtype. So it affects the
    // `sort_<type>` value. It takes a direction (`asc` || `desc`)
    // as shorthand ( `+` || `-` ) or longhand. Then it takes the
    // key to sort by (like rating or something). The direction
    // is optional if you only send in one param it defaults to
    // descending.
      sortBy: function (dir, key) {
      // Support descending by default
      // Check for undefined because we sometimes send in
      // null values, unfortunately. We want it unset.
        if (typeof key === 'undefined') {
          key = dir;
          dir = 'desc';
        }
      // Add this onto the list of sorts (which is ordered).
      // Make everything lowercase as convention and so groupings
      // happen more easily.
        this.mods.sorts.push({
          dir: ('' + dir).toLowerCase(),
          key: ('' + key).toLowerCase()
        });
      // All occurences of `return this` probably mean we're chaining.
      // Don't be annoyed if I don't write this every time.
        return this;
      },

      _forSubmission: function () {
        return this.self._data.contentType.indexOf('submit') === 0;
      },

    // ## Subquery: `filterBy`
    // The subquery `filterBy` affects the `filter_<type>` variable and
    // does the proper grouping based on the key and the operator.
    // e.g. `rating > 3`, `rating > 4` result in a single `filter_<type>=rating:gt:3,4`
    //
    // If you pass in one value, assume it's a boolean, and you want it to equal `true`
    // If you pass in two values, assume that you want them to be equal
      filterBy: function (key, operator, value, keepCase) {
      // Implicit boolean for a single parameter
        if (typeof operator === 'undefined' && typeof value === 'undefined') {
          operator = '=';
        // This ends up as a string, so we might as well oblige.
          value = 'true';
        }
       // Implicit `=` - for two parameters
        else if (typeof value === 'undefined') {
          value = operator;
          operator = '=';
        }

      // Add this filter to the sublist
        this.mods.filters.push({
          key: ('' + key).toLowerCase(),
          operator: ('' + operator).toLowerCase(),
          value: keepCase ? ('' + value) : ('' + value).toLowerCase()
        });

        return this;
      },

    // ## Subquery: `end`
    // This function breaks you out of a subQuery. It is necessary if you use the
    // subQuery syntax : a chained `.get()` call.
      end: function (withoutInclude) {
      // Call this function again in the declarative way, in the correct
      // context;
        return this.self._get.call(this.self, this.type, this.mods, withoutInclude);
      }
    };
  var helperFilters;

  // Static functions on the client.
  // These are the ones that exist before you call a `.get` (so not on
  // the prototype). Basic stuff.
  _.extend(client, {
    // ## `get`
    // The `get` call is a call to `init` with sugar.
    get: get,

    // ## `config`
    // A configuration function that mixes in config for each call
    config: function (configObj) {
      // Use the extend pattern, so we don't lose old stuff.
      // Override entirely with the "undocumented" client._config object.
      client._config = _.extend(client._config, configObj);
      return this;
    },

    // ## `warn`
    // A consistent way to do warnings, only runs if the console
    // is available.
    warn: function (msg, data) {
      // Make sure console logging is possible
      if (global.console && global.console.log) {
        // Log out the message and data
        global.console.log('bvapiclient warning: ' + msg, data);
      }
    }

  });

  // Put in all the shortcut methods for `get`
  // This means we can do: `api.reviews()` instead of
  // `api.get('reviews')` -- byte shaving foreva!
  _(typePairs)
  // Go through each of the pairs
  .forEach(function (typePair) {
    // Create the get sugar functions (they are the same)
    client[typePair[0]] = client[typePair[1]] = function (idList) {
      // Use the arguments array if we're passed raw numbers
      if (idList && !_.isArray(idList)) {
        idList = _.toArray(arguments);
      }
      // Obviously this is just a sham marriage and we call back into
      // the real deal and return it's result.
      return this.get(typePair[1], idList);
    };
  });

  // Everything hinges off of a `get` (or a get sugar function)
  // These are like the jQuery plugins.
  //
  // We alias `get.prototype` because all of the cool kids are doing
  // it. No other reason.
  get.fn = get.prototype = {
    // Link this back up for consistency.
    constructor: get,

    // Creates a new instance and locks in the current configuration
    // to the future query
    init: function (contentType, idList, apiBatch) {
      this.config = _.extend({}, client._config);

      // This is the instance object where we store all
      // the built up query data.
      //
      // We lazily turn that into a serialized request string.
      // Until then, it's just in this object. It's underscored
      // because we don't support touching it, but if you want access
      // reading it probably wouldn't be that harmful. Just be nice.
      this._data = {
        contentType: contentType
      };

      if (!_(['batch', 'products', 'categories', 'authors']).contains(contentType)) {
        _(this.config.contentLocales).forEach(function (locale) {
          this.filterBy('contentlocale_default_filters', '=', locale, true);
        }, this);
      }

      // Filter by the passed in id. Shorthand for `get(type).filterBy('id' ...`
      if (idList) {
        return this.filterBy('id', '=', idList);
      }

      if (contentType === 'batch') {
        this._data.apiBatch = apiBatch;
        this.limit(null);
        this.serialize = this.serializeBatch;
      }

      // Handle no Id(s)
      return this;
    },

    // ## `as`
    // A Bunch of these first functions override
    // config values for single queries. More than
    // likely it's just to save you from having
    // write a config if you're just trying to
    // get going quickly. In the long run, using the
    // config will be quicker and easier, but this
    // is nice and small anyways.

    // Change out the data format
    // This overrides the config `format` value
    // just for this query.
    as: function (format) {
      this.config.format = format;
      return this;
    },

    // ## `label`
    // Label the query so we can find it;
    // internal use only please
    _label: function (label) {
      this.config._label = label;
      return this;
    },

    // ## `withPassKey`
    // This overrides the config `passkey` value
    // just for this query.
    withPasskey: function (passkey) {
      this.config.passkey = passkey;
      return this;
    },

    // ## `withBaseUrl`
    // This overrides the config `baseUrl` value
    // for just this query.
    withBaseUrl: function (baseUrl) {
      this.config.baseUrl = baseUrl;
      return this;
    },

    // ## 'withUser'
    // This overrides the config `user` value
    // for just this query.
    withUser: function (user) {
      this.config.user = user;
      return this;
    },

    // ## 'withContentType'
    // This overrides the config `contentType` value
    // for just this query.
    withContentType: function (contentType) {
      this.config.contentType = contentType;
      return this;
    },

    // ## 'withRandomParameter'
    // Adds a cachebusting random 7 digit number to the query string. eg : &rand=2789446
    withRandomParameter: function () {
      this.config.randomParameter = Math.floor(10000000 * Math.random());
      return this;
    },

    // ## 'withHasSubmitted'
    // Add a single use cache busting parameter onto the query.
    // Should be used if the session remembers have submitted content already
    withHasSubmitted: function () {
      this.config.hasSubmitted = true;
      return this;
    },

    // ## `inLocale`
    // Overrides the `locale` config value for a query.
    inLocale: function (locale) {
      this.config.locale = locale;
      return this;
    },

    // sugar for the `inLocale` function
    locale: function (locale) {
      return this.inLocale(locale);
    },

    // ## `include`
    // This is a direct interpretation of what the api
    // string requires for 'includes'. It just adds in
    // the types that you give here. Order doesn't matter.
    //
    // It accepts lists, params, or a single element (of types)
    //
    // This does not do any special subquerying or anything like
    // that. It does not require end, and by default nothing
    // is filtered in the responses.
    include: function (keys) {
      // More than 1 must mean it's an arg list
      // so convert to array
      if (arguments.length > 1) {
        keys = _.toArray(arguments);
      }
      // Just one is either an array, or a single key
      // so check for array, otherwise convert to
      // single element array
      else if (keys && !_.isArray(keys)) {
        keys = [keys];
      }
      // In the array case, we already have the format we want
      // so, no-op.

      // Consistency of keys is important for grouping,
      // so make sure everything goes in as lower case.
      keys = _(keys).map(function (key) {
        return key.toLowerCase();
      });

      // We allow includes to be defined in the config, since lots of
      // people won't want to consider them later.
      //
      // Anything that we have in config, we might as well override in config
      // so we don't have to look two places for it. Maybe I'll change my mind
      // about this one day, but it's pretty easy to maintain right now.
      this.config.include = _.union(this.config.include || [], keys || []);

      // Add in ContentLocale filters for each included type
      _(keys).forEach(function (type) {
        if (_(['products', 'categories', 'authors']).contains(type)) {
          return;
        }
        _(this.config.contentLocales).forEach(function (locale) {
          this.filterIncluded(type).by('contentlocale_default_filters', '=', locale, true);
        }, this);
      }, this);

      // Chain
      return this;
    },

    // ## 'withoutContentLocaleFilter'
    // Strips out the automatically included contentlocale filters (use with caution)
    withoutContentLocaleFilter: function () {
      delete this._data.filters.contentlocale_default_filters;
      _(this._data.subfilters).forEach(function (subFilter, subType) {
        delete this._data.subfilters[subType].contentlocale_default_filters;
        if (!_(this._data.subfilters[subType]).size()) {
          delete this._data.subfilters[subType];
        }
      }, this);
      return this;
    },

    // ## `offset`
    // Modifies the config `offset` value per query
    offset: function (offset) {
      // only one allowed, always just override
      this.config.offset = offset;
      return this;
    },

    // ## `offsetBy`
    // Just a sugar for `offset()`
    // Sometimes this sounds more like english, and I'm down with that.
    // It also matches the syntax for the included offsets. Consistency-ish.
    offsetBy: function (offset) {
      return this.offset(offset);
    },

    // ## `limit`
    // This is much like `offset`, but for the `limit`
    limit: function (limit) {
      // only one allowed, always just override
      this.config.limit = limit;
      return this;
    },

    // ## `limitTo`
    // Sugar for `limit`
    limitTo: function (limit) {
      return this.limit(limit);
    },

    // ## `page`
    // NOTE :: This is 1 indexed - NOT zero-indexed
    //
    // This a helper for people writing apps with pages.
    // It works a lot more predictably if you've set a limit,
    // because then it makes sense. If you didn't set a limit,
    // we'll send you a warning, and just use 10 (which is the
    // api default).
    //
    // The logic is that a page starts at 1, so it's just the
    // offset multiplied by the limit minus one whole limit.
    // e.g. page 6 of limit 10 is 50 through 59
    // 0-10  10-20  20-30  30-40  40-50  50-60
    // pg1   pg2    pg3    pg4    pg5    pg6
    page: function (pageNum) {
      var res = this;
      if (!this.config.limit) {
        client.warn('You are calling `page` without setting the number per page. Using 10 as your `limit`.');
        // Set a default
        // TODO :: _maybe_ unhardcode this in the middle
        // but it is hardcoded into the api like this
        // and we only want to put it into the request
        // if we actually need it
        res = this.limit(10);
      }
      // This just calls offset under the covers. Remember offset is atomic. The
      // last one set wins. So don't have an offset and a page call in the same query.
      return res.offset((pageNum * this.config.limit) - this.config.limit);
    },

    // ## `onPage`
    // This just reads better sometimes in the query (just sugar for `page`)
    onPage: function (pageNum) {
      return this.page(pageNum);
    },

    // The subquery stuff uses this function when it's all done. This function
    // knows how to take all the modifications of a type and apply them to the global
    // set of data instead of in the subQuery.
    //
    // You probably don't want to call this directly. This is what `.end()` calls
    // when the subquery is done. This is where all the key and operator grouping
    // are done.
    _get: function (type, mods, withoutInclude) {
      var self = this;
      // Bail gracefully if we're broken
      // We need both of these values always.
      if (!type || !mods) {
        client.warn('Invalid use of _get private function.', arguments);
        return this;
      }

      // Consistency of keys is important for grouping,
      // so make sure everything goes in as lower case.
      type = type.toLowerCase();

      // For the filters

      // Create it if it don't exist
      self._data.subfilters = self._data.subfilters || {};

      // Add each of the filters to the sub filter list
      _(mods.filters).forEach(function (filterObj) {
        // Translate the `=` -> `eq` stuff
        filterObj.operator = logicalKeys[filterObj.operator] || filterObj.operator;

        // Create space for this sub filter -- corresponds to `filter_<type>`
        self._data.subfilters[type] = self._data.subfilters[type] || {};
        self._data.subfilters[type][filterObj.key] = self._data.subfilters[type][filterObj.key] || {};
        self._data.subfilters[type][filterObj.key][filterObj.operator] = self._data.subfilters[type][filterObj.key][filterObj.operator] || [];

        // Push the filter onto the unique sub filter
        self._data.subfilters[type][filterObj.key][filterObj.operator].push(filterObj.value);
      });

      // For the sorts

      _(mods.sorts).forEach(function (sortObj) {
        // Translate `+`/`-` to `asc`/`desc` if necessary
        sortObj.dir = dirKeys[sortObj.dir] || sortObj.dir;

        // We don't need to nest as deep since all sorts can be grouped together.
        // Whereas all the filters can only be grouped if the key and the operator are the same.
        self._data.subsorts = self._data.subsorts || {};
        self._data.subsorts[type] = self._data.subsorts[type] || [];

        // Push on the object, we don't need to group since sorts can't be chained the same
        // way as filters can be.
        self._data.subsorts[type].push(sortObj);
      });

      // We only support a single limit, so nothing too complex
      if (mods.limit) {
        // Create a new one or use the old one if it exists.
        self._data.sublimits = self._data.sublimits || {};
        self._data.sublimits[type] = mods.limit;
      }

      // We only support a single offset, so nothing too complex here either.
      if (mods.offset) {
        self._data.suboffsets = self._data.suboffsets || {};
        self._data.suboffsets[type] = mods.offset;
      }
      if (!_(this.config.include).contains(type) && !withoutInclude) {
        return this.include(type);
      }
      return this;
    },

    // ## `get`
    // This is essentially a "subquery" of sorts.
    // It requires an `end` call.
    // The filters and sorts you apply are only applied to the sub query.
    // You do not _also_ need to call `include`.
    // The `filterIncluded` and `filterSorted`, etc. function actually call into these
    // subqueries to keep the logic in one place.
    // It uses it's returned object to keep the chaining alive and then calls
    // the "private" `_get` function that takes the object that's been built up
    // and applies that to the original chain.
    get: function (type, idList) {
      var mods = {
        filters: [],
        sorts: []
      };
      var fn = function () {};
      var res;
      // Do our own little prototypal inheritance
      // essentially `object.create`
      fn.prototype = subquerySet;
      res = new fn();
      res.mods = mods;
      res.type = type;
      res.self = this;
      res.config = this.config;
      this._data.subcontents = this._data.subcontents || [];
      this._data.subcontents.push(type);

      if (idList) {
        return res.filterBy('id', '=', idList);
      }

      return res;
    },

    // ## `filterIncluded`
    // Sugar for subqueries - best for english looking
    // queries. This can actually go in any order you want it to in the
    // query, because it just results in a totally separate key/val in the
    // request. It makes the most sense right after an `include` call.
    //
    // NOTE :: this function is unique because you MUST call the `by`
    // function directly after it. It reads nicely, and the other functions
    // aren't even included (on purpose). Once you call these two functions
    // together, you are put back on the original query.
    //
    // You cannot call this in a subquery because you can't have includes in
    // includes.
    //
    // The signature of `by` is the same as `filterBy` and takes all the same
    // variants ( `filterBy` is called under the covers ). The `filterIncluded`
    // function just takes the content type of the include.
    //
    // TECHNICALLY :: you don't have to call `include` at all. This will auto
    // include it for you. But I'm not suggesting that. It's just too easy
    // to catch for you to not do.
    filterIncluded: function (type, withoutInclude) {
      var self = this;
      // Return an object with the mandatory next function on it, but the
      // closure gives us access to `type` once that is called.
      return {
        // This is the real filter function, but it just creates a subquery
        // and ends it for you behind the scenes.
        by: function (a, b, c, d) {
          // Call the `get` subquery function in the scope of the outer query
          // Make sure we call end to auto-end the subquery for you.
          return self.get.call(self, type).filterBy(a, b, c, d).end(withoutInclude);
        }
      };
    },

    // ## `sortIncluded`
    // All the same rules for `filterIncluded` apply to this, just for
    // sorts. Duh.
    sortIncluded: function (type) {
      var self = this;
      return {
        by: function (a, b) {
          return self.get.call(self, type).sortBy(a, b).end();
        }
      };
    },

    // ## `offsetIncluded`
    // See: filterIncluded
    offsetIncluded: function (type) {
      var self = this;
      return {
        by: function (a) {
          return self.get.call(self, type).offset(a).end();
        }
      };
    },

    // ## `limitIncluded`
    // See: filterIncluded
    // NOTE :: This one's a bit different because sometimes you wanna say
    // `limit TO num` instead of `limit BY num` so we allow both.
    limitIncluded: function (type) {
      var self = this;
      return {
        to: function (a) {
          return self.get.call(self, type).limit(a).end();
        },
        // By is just sugar for `to`
        by: function () {
          return this.by.apply(this, _.toArray(arguments));
        }
      };
    },

    // ## `withStatsOn`
    // This turns on stats for whatever keys you pass in.
    // This is pretty separate from other parts of a request,
    // so there's not a ton of interaction. It can take a single
    // param, multiple params, or an array of params as input.
    //
    // results in stats=type1,type2,type3
    withStatsOn: function (keys) {
      // More than 1 must mean it's an arg list
      // so convert to array
      if (arguments.length > 1) {
        keys = _.toArray(arguments);
      }
      // Just one is either an array, or a single key
      // so check for array, otherwise convert to
      // single element array
      else if (keys && !_.isArray(keys)) {
        keys = [keys];
      }
      // In the array case, we already have the format we want
      // so, no-op.

      // Much like before, we just use the base config stuff here
      this.config.stats = _.union(this.config.stats || [], keys);

      keys = _(keys).map(function (key) {
        return client.nouns(key);
      });

      // always add a secondary content filter if primary are present
      keys = _(keys).union(
        _(keys).contains('questions') ? ['answers'] : [],
        _(keys).contains('reviews') ? ['reviewcomments'] : []
      );

      // Add a contentlocale filter for each stat type (sans include).
      _(keys).forEach(function (type) {
        if (_(['products', 'categories', 'authors']).contains(type)) {
          return;
        }
        _(this.config.contentLocales).forEach(function (locale) {
          this.filterIncluded(type, true).by('contentlocale_default_filters', '=', locale, true);
        }, this);
      }, this);
      return this;
    },

    // ## `stats`
    // Shorter function, less descriptive name for `withStatsOn`. Sugar.
    stats: function () {
      return this.withStatsOn.apply(this, arguments);
    },

    // ## `sortBy`
    // Much like `filterBy` accept for sorting.
    //
    // The only real output difference is that all sorts can be
    // grouped into a single place, as long as they're ordered correctly.
    //
    // This function takes just a key, or a cardinality (direction) and a key.
    //
    // It defaults to `DESC` if you don't set it.
    //
    // You can also use the `+` / `-` syntax for ascending and descending
    // instead of the regular shorthand.
    sortBy: function (dir, key) {
      // Assume `desc` if there is no cardinality given
      if (!key) {
        key = dir;
        dir = 'desc';
      }

      // Set the direction to the real word
      dir = dirKeys[dir] || dir;

      // There can only be one sort per key, so no need for arrays
      // Order does matter though. Unlike filters.
      // TODO :: consider warning when a conflicting sort comes in

      this._data.sorts = this._data.sorts || [];

      // Push on the lowercase versions of these things.
      this._data.sorts.push({
        key: ('' + key).toLowerCase(),
        dir: ('' + dir).toLowerCase()
      });

      // Chain.
      return this;
    },

    // ## `_forSubmission`
    // Are we fetching a submission schema?
    _forSubmission: function () {
      return this._data.contentType.indexOf('submit') === 0;
    },

    // ## `withSubject`
    // For submissions, we don't specify filters, we just specify the subject directly.
    // Example: productid=test1
    withSubject: function (subjectType, id) {
      var self = this;

      this._data.subjects = this._data.subjects || {};
      this._data.subjects[subjectType] = id;

      return self;
    },

    // ## `filterBy`
    // Builds filter statements for the main data type.
    // Defaults to `=` if no operator is sent
    //
    // Takes 1, 2 or 3 arguments.
    //
    // 1 arg is converted to:
    // `<key>:eq:true`
    //
    // 2 args is converted to:
    // `<key>:eq:<val>` (note the value is not the `value` argument named there.
    //
    // 3 args is explicit. Use it as much as feasible.
    //
    // Grouping occurs when key and operator are the same. Orders are FIFO.
    filterBy: function (key, operator, value) {
      var self = this;

      // Let's do lowercase keys
      key = key.toLowerCase();

      // Implicit `=` for shorthand
      if (typeof value === 'undefined') {
        if (operator) {
          value = operator;
          operator = '=';
        }
        // Assume it's a boolean filter if there's no value
        else {
          operator = '=';
          value = 'true';
        }
      }

      // This converts numbers and booleans to a string
      value = '' + value;

      // Allow the use of the real logical operators, but
      // switch them out with the api ones here, instead of
      // later. That way people can use both if they want :/
      if (logicalKeys[operator]) {
        operator = logicalKeys[operator];
      }
      // Instantiate an array of filters to use.
      // Blocked out by id and key (since they have to be grouped that way in the end)
      this._data.filters = this._data.filters || {};
      this._data.filters[key] = this._data.filters[key] || {};
      this._data.filters[key][operator] = this._data.filters[key][operator] || [];

      // Convert value to an array, so we only have to handle it once.
      if (!_.isArray(value)) {
        value = [value];
      }

      // Loop through the values, and add a filter object for each
      _(value).forEach(function (filterValue) {
        self._data.filters[key][operator].push(filterValue);
      });

      // Chain.
      return this;
    },

    // ## 'searchFor'
    // Build search statement for the targeted content type
    searchFor: function (keyword) {
      var contentType = this._data.contentType;
      this._data.searches = this._data.searches || {};
      this._data.searches['search_' + contentType] = this._data.searches['search_' + contentType] || [];
      this._data.searches['search_' + contentType].push(keyword);
      return this;
    },

    // ## `checksum`
    // Returns checksum of the serialization of this request
    //
    checksum: function (extra) {
      return checksum(this.serialize() + (extra || ''));
    },

    // ## `serialize`
    // This is the url serialization function, aka the magic
    //
    // The `raw` argument prevents the keys and values from being URI encoded.
    // This is generally useful when debugging and stuff. The regular `serialize`
    // is likely safer without it.
    serialize: function (raw) {
      var d = this._data,
        path = '',
        protocol = '',
          // This is the ordered sequence of key value params
        query = this.buildQueryArray(d, this.config);

      // Let's get the boring stuff out of the way.
      path += d.contentType;
      path += '.' + this.config.format;

      // Build the query string
      query = _(query).map(function (pair) {
        // Raw is more human readable, but against spec, yo
        if (raw) {
          return pair.key + '=' + pair.val;
        }
        // Safest bet
        return global.encodeURIComponent(pair.key) + '=' + global.encodeURIComponent(pair.val);
      }).join('&');

      if (this.config.baseUrl) {
        if (this.config.baseUrl.indexOf('//') === 0) {
          protocol = Url.protocol;
        }
        return protocol + this.config.baseUrl + path + '?' + query;
      }
      return path + '?' + query;
    },

    serializeBatch: function (raw) {
      var d = this._data;
      var path = '';
      var batchQueryArray = this.buildQueryArray(d, this.config);
      var queryString = '';
      var protocol = '';
      path += d.contentType;
      path += '.' + this.config.format;
      batchQueryArray = _(batchQueryArray).map(function (pair) {
        if (raw) {
          return pair.key + '=' + pair.val;
        }
        return global.encodeURIComponent(pair.key) + '=' + global.encodeURIComponent(pair.val);
      });
      _(d.apiBatch).forEach(function (apiClient, index) {
        var queryIdString = 'q' + index;
        var resourceString = 'resource.' + queryIdString + '=' + apiClient._data.contentType;
        var subQueryArray = apiClient.buildQueryArray(apiClient._data, apiClient.config, true);
        var batchSubQueryArray = [resourceString];
        batchSubQueryArray = batchSubQueryArray.concat(_(subQueryArray).map(function (pair) {
          if (raw) {
            return pair.key + '.' + queryIdString + '=' + pair.val;
          }
          return global.encodeURIComponent(pair.key + '.' + queryIdString) +
            '=' + global.encodeURIComponent(pair.val);
        }));
        batchQueryArray = batchQueryArray.concat(batchSubQueryArray);
      });
      queryString = batchQueryArray.join('&');
      if (this.config.baseUrl) {
        if (this.config.baseUrl.indexOf('//') === 0) {
          protocol = Url.protocol;
        }
        return protocol + this.config.baseUrl + path + '?' + queryString;
      }
      return path + '?' + queryString;
    },

    buildQueryArray: function (data, config, subQuery) {
      var query = [];
      var statsVal;
      if (!subQuery) {
        // Passkey is required
        query.push({
          key: 'passkey',
          val: config.passkey
        });

        // Apiversion is required
        query.push({
          key: 'apiversion',
          val: config.apiversion
        });

        if (config.displaycode) {
          query.push({
            key: 'displaycode',
            val: config.displaycode
          });
        }

        if (config.virtualEnvironment) {
          query.push({
            key: 've',
            val: config.virtualEnvironment
          });
        }
      }

      // Pull in filters

      // If user-created contentlocale filters are present, use those. Otherwise, use the defaults.
      if (data.filters) {
        if (!data.filters.contentlocale && data.filters.contentlocale_default_filters) {
          data.filters.contentlocale = data.filters.contentlocale_default_filters;
        }
        delete data.filters.contentlocale_default_filters;
      }

      if (data.subfilters) {
        _(data.subfilters).forEach(function (typeGroup) {
          if (!typeGroup.contentlocale && typeGroup.contentlocale_default_filters) {
            typeGroup.contentlocale = typeGroup.contentlocale_default_filters;
          }
          delete typeGroup.contentlocale_default_filters;
        });
      }

      // Loop through the top-level filters
      _(data.filters).forEach(function (filterGroup, filterKey) {
        // Loop through each of the logical operators
        _(filterGroup).forEach(function (filterVals, filterOperator) {
          // Push each set of filters on a single operator as a comma delimited list
          if (filterVals.length) {
            query.push({
              key: 'filter',
              val: filterKey + ':' + filterOperator + ':' + _(filterVals).uniq().join(',')
            });
          }
        });
      });

      // If there are sorts, push them all onto the same querystring param
      // separated by commas - ignore dupes
      if (data.sorts && data.sorts.length) {
        query.push({
          key: 'sort',
          val: _(data.sorts).chain()
            .uniq(false, function (obj) {
              // Make it unique by key
              return obj.key;
            })
            .map(function (sort) {
              return sort.key + ':' + sort.dir;
            })
            .value().join(',')
        });
      }

      // Loop through the searches
      _(data.searches).forEach(function (searchVals, searchType) {
        // Loop through each of the logical operators
        if (searchVals.length) {
          query.push({
            key: 'search',
            val: _(searchVals).uniq().join(',').replace(/\"/g, '\\"')
          });
        }
      });

      // Include the stats as a single entity.
      if (config.stats && config.stats.length) {
        statsVal = _(config.stats).chain().map(function (key) { return key.toLowerCase(); }).uniq().value().join(',');
        if (this._data.contentType !== 'reviewcomments') {
          query.push({
            key: 'stats',
            val: statsVal
          });
        }
        if (this._data.contentType !== 'statistics' && this._data.contentType !== 'authors' && this._data.contentType !== 'reviewcomments') {
          query.push({
            key: 'filteredstats',
            val: statsVal
          });
        }
      }

      // Add in the includes
      if (config.include && config.include.length) {
        query.push({
          key: 'include',
          val: _(config.include).chain().map(function (key) { return key.toLowerCase(); }).uniq().value().join(',')
        });
      }

      // Add in the include subfilters
      _(data.subfilters).forEach(function (typeGroup, typeKey) {
        _(typeGroup).forEach(function (filterGroup, filterKey) {
          // Loop through each of the logical operators
          _(filterGroup).forEach(function (filterVals, filterOperator) {
            // Push each set of filters on a single operator as a comma delimited list
            if (filterVals.length) {
              query.push({
                key: 'filter_' + typeKey,
                val: filterKey + ':' + filterOperator + ':' + _(filterVals).uniq().join(',')
              });
            }
          });
        });
      });

      // If there are subsorts, push them all onto the same querystring param
      // per type
      // separated by commas - ignore dupes
      _(data.subsorts).forEach(function (subsorts, type) {
        query.push({
          key: 'sort_' + type,
          val: _(subsorts).chain()
            .uniq(false, function (obj) {
              // Make it unique by key
              return obj.key;
            })
            .map(function (sort) {
              return sort.key + ':' + sort.dir;
            })
            .value().join(',')
        });
      });

      // Limit (zero check for some stupid reason)
      if (config.limit || config.limit === 0) {
        query.push({
          key: 'limit',
          val: config.limit
        });
      }

      // offset (zero check for some stupid reason)
      if (config.offset || config.offset === 0) {
        query.push({
          key: 'offset',
          val: config.offset
        });
      }

      // Sub limit additions
      _(data.sublimits).forEach(function (limit, type) {
        query.push({
          key: 'limit_' + type,
          val: limit
        });
      });

      // Sub offset operations
      _(data.suboffsets).forEach(function (offset, type) {
        query.push({
          key: 'offset_' + type,
          val: offset
        });
      });

      if (config.locale) {
        query.push({
          key: 'locale',
          val: config.locale
        });
      }

      if (config.contentType) {
        query.push({
          key: 'ContentType',
          val: config.contentType
        });
      }

      if (config.user) {
        query.push({
          key: 'user',
          val: config.user
        });
      }

      if (config._label) {
        query.push({
          key: '_label',
          val: config._label
        });
      }

      // random parameter used for cache busting
      if (config.randomParameter) {
        query.push({
          key: 'rand',
          val: config.randomParameter
        });
      }

      // hasSubmitted parameter used for cache busting after submission
      if (config.hasSubmitted) {
        query.push({
          key: 'hasSubmitted',
          val: '1'
        });
      }

      // submission subjects
      if (data.subjects) {
        _(data.subjects).forEach(function (value, key) {
          query.push({
            key: key,
            val: value
          });
        });
      }
      return query;
    }
  };
  // Add in support for easy id filtering for every type
  // forProduct / forProducts / fromAuthor / fromAuthors
  _(typePairs).forEach(function (pair) {
    var singular = pair[0].substr(0, 1).toUpperCase() + pair[0].substr(1),
      plural = pair[1].substr(0, 1).toUpperCase() + pair[1].substr(1),
      helpers = ['for'];

    // This is the third param, which is the custom prefix for the
    // for<Type> type of pattern. Sometimes 'for' doesn't make as much sense
    // as other things.
    if (pair[2]) {
      helpers.push(pair[2]);
    }

    // Add the helper functions for 'for' and special helpers on every type.
    _(helpers).forEach(function (helper) {
      get.fn[helper + plural] = subquerySet[helper + plural] = function (idList) {
        if (!idList) {
          return this;
        }
        // Use the arguments array if we're passed raw numbers
        if (idList && !_.isArray(idList)) {
          idList = _.toArray(arguments);
        }

        // These extra sugar functions actually just call filters.
        return this._forSubmission() ? this.withSubject(pair[0] + 'id', idList[0]) : this.filterBy(pair[0] + 'id', '=', idList);
      };

      // Add em to the prototype
      get.fn[helper + singular] = subquerySet[helper + singular] = function (id) {
        if (!id) {
          return this;
        }
        return this[helper + plural]([id]);
      };
    });
  });

  // I didn't want to definee these twice, so both the query and subquery inherit from the same
  // thing.
  helperFilters = {
    // Filter to things with a date before the given string
    before: function (dateStr, include) {
      // Be inclusive of the before date, by default.
      return this.filterBy(this.config.timeKey, include === false ? '<' : '<=', dateStr);
    },

    // Filter to things after the given string
    after: function (dateStr, include) {
      // Be exclusive of the after date, by default.
      return this.filterBy(this.config.timeKey, include ? '>=' : '>', dateStr);
    }
  };

  // Add to the core `get`
  _.extend(get.fn, helperFilters);

  // Add to the subquery `get`
  _.extend(subquerySet, helperFilters);

  // Chain me, yo.
  get.fn.init.prototype = get.fn;
  subquerySet.constructor = get.fn.get;

  // Put the `get` method on the `client` object
  client.get = get;

  // Put N/noun(s) methods on `client` object
  _.extend(client, grammr(typePairs));

  // Direct access to typePairs
  client.typePairs = typePairs;

  // return the module.
  return client;
});

BV.define('bv/api/util/referenceCache',['underscore', 'jquery', 'window', 'bv/api'], function (_, $, window, api) {

  var referenceCache = {};

  function cleanData (id, data) {
    var shallowCopy = _.extend({ Id: id }, data);
    // Kill some of the nested content. Users of referenceCache shouldn't rely on these being here.
    _(['Content', 'PrimaryContent']).forEach(function (key) {
      delete shallowCopy[key];
    });
    return shallowCopy;
  }

  function fetchReference (type, id) {
    var dfd = $.Deferred();
    // Go easy on the brain and avoid circular dependencies...
    window.BV.require(['ENV', 'util/url', 'bv/api/fetch'], function (ENV, url, api) {
      var apiHolder = api.get(api.nouns(type), id).limitTo(1);
      apiHolder.fetch('reference').done(function (data) {
        data = data.data;
        var subject = data.Results[0];
        dfd.resolve(cleanData(id, subject));
      });
    });
    return dfd;
  }

  return {
    get: function (type, id) {
      var key = api.noun(type) + '/' + id;
      var reference = referenceCache[key] = referenceCache[key] || fetchReference(type, id);
      return reference;
    },
    set: function (type, id, data) {
      var key = api.noun(type) + '/' + id;
      referenceCache[key] = referenceCache[key] || $.Deferred();
      referenceCache[key].resolve(cleanData(id, data));
    }
  };

});

//     Backbone.js 1.0.0
//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
BV.define('backbone',['underscore', 'jquery'], function( _, jQuery ){

// BV NOTE: There is a patch below to mitigate against the potential of a global
// `exports` variable existing in the browser. When updating Backbone, please
// make sure to verify the need still exists for the patch, and to preserve it
// if so.
// For details, see UIA-2894:
// https://bits.bazaarvoice.com/jira/browse/UIA-2894

var root = { "jQuery" : jQuery, "_" : _ };

//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;

  // BV NOTE: The following line contains a small patch to make this
  // CommonJS check a bit more resilient against bad browser environments,
  // where someone may have instantiated a global `exports` object.
  // For details, see UIA-2894:
  // https://bits.bazaarvoice.com/jira/browse/UIA-2894
  if (typeof exports !== 'undefined' && typeof process !== 'undefined' && process.versions && process.versions.node) {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = BV.require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(root);


  return root.Backbone;
});

/**
 * @fileOverview Module for storing global data
 */
BV.define('ENV',[
  'window',
  'BV',
  'bv/api/util/referenceCache',
  'backbone'
], function (
  window,
  BV,
  referenceCache,
  Backbone
) {

  var ENV = new Backbone.Model({

    components: {},

    mappings: {},

    uniq: {
      view: 0
    },

    classPrefix: 'bv-',

    config: window.BV.options,

    initPage: 1,

    keyboardMode: false,

    references: referenceCache
  });

  /**
   * Checks if we're on a container page.
   * This is _intended_ to be a temporary measure, until we figure out what
   * to do with global stuff. Basically, we want to check this flag in a
   * read-only way.
   *
   * @return {Boolean} true if we're on a container page.
   *                   false otherwise.
   */
  ENV.isContainer = function () {
    return Boolean(BV._internal.container);
  };

  return ENV;
});

/**
 * @fileOverview Sets up the API configuration based on the
 * configuration of the application.
 *
 * @returns {function} A function that configures the API
 */
BV.define('bv/clientAPISetup',[
  'ENV',
  'bv/api'
], function (ENV, api) {
  return function () {
    var options = ENV.get('config');
    var apiConfig = options.apiconfig;

    if (options.displaycode && options.displaycode !== 'default') {
      apiConfig.displaycode = options.displaycode + '-' + options.locale.toLowerCase();
    }

    api.config(apiConfig);
  };
});

/*
    http://www.JSON.org/json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

(function (window){

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

// Return the window JSON element if it exists;
var JSON = window.JSON || {};

function captureJSON () {
    // JSON isn't busted, but it could become busted in the future
    // (see CCS-1130). Let's capture its methods now.
    JSON = {
      stringify : JSON.stringify,
      parse : JSON.parse
    };
}

// Let's make sure JSON isn't busted. If it is, use our internal one.
try {

    // Stringify should work
    if (JSON.stringify([]) !== '[]' || JSON.stringify(0) === '{}') {
        throw 'Bad JSON.stringify';
    }

    // Parsing null should work
    if (JSON.parse(null) !== null) {
        throw 'Bad JSON.parse';
    }

    // At this point, we feel good about window.JSON, so capture it.
    captureJSON();
} catch (e) {
    JSON = {};
}

(function () {
    

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    var _toString = Object.prototype.toString;
    function toString(obj) {
      return _toString.call(obj);
    }

    function kind(obj) {
      var str = toString(obj);
      var fromIndex = str.indexOf(' ') + 1;
      var toIndex = str.indexOf(']');
      return str.slice(fromIndex, toIndex).toLowerCase();
    }

    function isBuiltin(obj) {
      return (kind(obj) in TYPE_MAP);
    }

    // Instead of calling `toJSON` on builtin types, we'll use our known safe
    // versions.
    function defaultToJSON(key) {
      return this.valueOf();
    }

    var TYPE_MAP = {
      'date': function(key) {
        return isFinite(this.valueOf())
            ? this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z'
            : null;
      },

      'array':   function(key) {
        return this;
      },
      'string':  defaultToJSON,
      'number':  defaultToJSON,
      'boolean': defaultToJSON
    };

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.
//
// NOTE: We _do not_ want to do this for builtin types. A script on the page
// can BV.define(e.g.) [].toJSON, as Prototype 1.6 does, and screw up
// serialization for all arrays. If it's a builtin, we want predictable
// serialization.

        if ( value && isBuiltin(value) ) {
          value = TYPE_MAP[kind(value)].call(value, key);
        } else if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
          value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

BV.define('vendor/json2',[],function(){
    return JSON;
});
// otherwise just leave it alone

}).call(this, this);

BV.define('components',['underscore', 'vendor/json2'], function (_, JSON) {
  var buildMap = {};
  var customNameExtension = '@components';

  return {
      };
});

BV.define('components!',{"bvRouter1":{"componentId":"bvRouter1","type":"bvRouter","routes":[{"name":"submit","paths":[":contentType/submit/:campaignId"],"params":["contentType","campaignId"],"actions":[{"component":"reviewSubmission1","scope":"rr","action":"submit_review"}]},{"name":"page","paths":[":displayCode/:contentType/:subjectType/:pageNum/:product.htm"],"params":["displayCode","contentType","subjectType","pageNum","product"],"actions":[{"component":"reviewContentList1","event":"pageto"}]},{"name":"bvstateRR","paths":["bvstate/review/:pageNum"],"params":["pageNum"],"actions":[{"component":"reviewContentList1","event":"pageto"}]},{"name":"bvstateQA","paths":["bvstate/question/:pageNum"],"params":["pageNum"],"actions":[{"component":"questionContentList1","event":"pageto"}]},{"name":"deeplink","paths":[":contentType/:id"],"params":["contentType","id"],"actions":[{"component":"reviewContentList1","event":"deeplink"},{"component":"questionContentList1","event":"deeplink"}]},{"name":"bvdata","paths":["bvdata/:urlData"],"params":["urlData"],"actions":[{"bvdata":"bvdata"}]},{"name":"sort","paths":[":contentType/sort/:key/:dir"],"params":["contentType","key","dir"],"actions":[{"component":"reviewContentList1","event":"sort"}]},{"name":"showHelpfulPositive","paths":[":contentType/showHelpfulPositive"],"params":["contentType"],"actions":[{"component":"reviewContentList1","event":"showhelpfulpositive"}]},{"name":"showHelpfulCritical","paths":[":contentType/showHelpfulCritical"],"params":["contentType"],"actions":[{"component":"reviewContentList1","event":"showhelpfulcritical"}]}],"viewUniq":0,"views":{}},"fullProfilePopup1":{"container":"BVContainer","subjectType":"Authors","contentType":"Authors","type":"fullProfile","pageview":{"bvProduct":"Profiles"},"features":{"self":["sidebar","tabs"],"sidebar":[],"tabs":["profileContentList<Reviews>","profileContentList<Questions>","profileContentList<Answers>"],"profileContentList":["contentItemCollection","ugcCount","pagination"],"contentItem":{"contentTypes":{"Reviews":{"features":["has:stars","has:productImage","has:prosCons","has:contentBadges","has:secondarySubmission","secondaryContentList","has:secondaryContentBtn"]},"Questions":{"features":["has:secondaryContentLink","secondaryContentList","has:secondarySubmission","has:secondaryContentBtn"]},"Answers":{"features":["has:secondaryContentLink","has:secondarySubmission"]}}},"secondaryContentList":{"contentTypes":{"Comments":{"features":["secondaryContentItemCollection","loadMore"]},"Answers":{"features":["secondaryContentItemCollection"]}}},"secondaryContentItem":{"contentTypes":{"Comments":{"features":["has:userBadges"]}}}},"outlets":{"showmediaviewer":[{"component":"mediaViewer1","event":"open"}],"showanswersubmission":[{"component":"answerSubmission1_inline","scope":"qa","action":"submit_answer"}],"showcommentsubmission":[{"component":"commentSubmission2","scope":"rr","action":"submit_comment"}]},"componentId":"fullProfilePopup1","createOnce":true,"viewUniq":0,"views":{}},"mediaViewer1":{"container":"BVContainer","subjectType":"Products","contentType":"Products","coverageContentTypes":["Reviews","Questions"],"type":"mediaViewer","componentId":"mediaViewer1","createOnce":true,"viewUniq":0,"views":{}},"rrSubmissionGuidelines1":{"type":"guidelines","subjectType":"Products","contentType":"Reviews","container":"BVGuidelines","features":{"self":["rrSubmissionGuidelines1","has:reviewHelperText"]},"outlets":{},"componentId":"rrSubmissionGuidelines1","autoload":true,"viewUniq":0,"views":{}},"reviewGenericSubmission1":{"type":"genericSubmission","subjectType":"Products","contentType":"Reviews","container":"BVGRSContainer","autoload":true,"features":{"self":["searchBar","categorySelect","ugcCount:filtered","ugcCount:unfiltered","productItemCollection:filtered","productItemCollection:unfiltered","loadMore:filtered","loadMore:unfiltered"],"searchBar":["has:searchOnKeyup"],"loadMore":{"instances":{"filtered":{"features":["has:infiniteScroll","has:instanceNameScope"]},"unfiltered":{"features":["has:infiniteScroll","has:instanceNameScope"]}}},"productItemCollection":{"instances":{"filtered":{"features":["has:filterByCategory","has:instanceNameScope"]},"unfiltered":{"features":["has:filterWithoutCategory","has:searchOnly","has:instanceNameScope"]}}},"ugcCount":{"instances":{"filtered":{"features":["has:instanceNameScope"]},"unfiltered":{"features":["has:instanceNameScope"]}}}},"outlets":{},"componentId":"reviewGenericSubmission1","grsSearchEnabled":true,"productsPerRow":4,"viewUniq":0,"views":{}},"inlineRatingList1":{"subjectType":"Products","contentType":"Statistics","containerPrefix":"BVRRInlineRating","type":"ratingList","features":{"self":["ratingItemCollection"],"ratingItem":["has:stars"]},"componentId":"inlineRatingList1","autoload":true,"viewUniq":0,"views":{}},"contentSearch1":{"serverRender":true,"container":"BVRRSearchContainer","subjectType":"Products","contentType":"Products","coverageContentTypes":["Reviews","Questions"],"submissionContentTypes":["Answers","Comments"],"type":"contentSearch","features":{"self":["searchBar","searchContentList","trustmarkIcon","has:stars","has:overallRating","has:reviewCount","statsPanel"],"searchContentList":["contentItemCollection","ugcCount","searchBar","pagination"],"contentItem":{"contentTypes":{"Reviews":{"features":["has:stars","has:secondaryContentLink","avatar","secondaryContentList","has:secondaryContentBtn"]},"Questions":{"features":["avatar","secondaryContentList","has:secondaryContentBtn","has:secondaryContentLink"]}}},"secondaryContentList":["secondaryContentItemCollection"],"secondaryContentItem":{"contentTypes":{"Comments":{"features":["avatar"]},"Answers":{"features":["feedback","crowdSourcedAnswerBadge"]}}},"avatar":{"contentTypes":{"Reviews":{"features":["has:socialAvatar"]},"Questions":{"features":["has:socialAvatar"]}}}},"outlets":{"showmediaviewer":[{"component":"mediaViewer1","event":"open"}],"showfullprofile":[{"component":"fullProfilePopup1","event":"launchprofile"}],"filtercontent":[{"component":"contentSearch1","event":"filtercontent"}],"showreviews":[{"component":"reviewContentList1","event":"scrolltocontent","scope":"rr","fallback":"doShowContent"}],"scrolltocontent":[{"component":"reviewContentList1","event":"scrolltocontent"}],"filterresults":[{"component":"reviewContentList1","event":"filterresults"}],"showsubmission":[{"component":"questionSubmission2_inline","scope":"qa","action":"submit_question"}],"showanswersubmission":[{"component":"answerSubmission1_inline","scope":"qa","action":"submit_answer"}],"showquestions":[{"component":"questionContentList1","event":"scrolltocontent","scope":"qa","fallback":"doShowContent"}],"showcommentsubmission":[{"component":"commentSubmission2","scope":"rr","action":"submit_comment"}]},"componentId":"contentSearch1","autoload":true,"viewUniq":0,"views":{}},"contentSearch2":{"serverRender":true,"container":"BVQASearchContainer","subjectType":"Products","contentType":"Products","coverageContentTypes":["Reviews","Questions"],"submissionContentTypes":["Answers","Comments"],"type":"contentSearch","features":{"self":["searchBar","searchContentList","has:stars","has:overallRating","has:reviewCount","statsPanel"],"searchContentList":["contentItemCollection","ugcCount","searchBar","pagination"],"contentItem":{"contentTypes":{"Reviews":{"features":["has:stars","has:secondaryContentLink","avatar","secondaryContentList","has:secondaryContentBtn"]},"Questions":{"features":["avatar","secondaryContentList","has:secondaryContentBtn","has:secondaryContentLink"]}}},"secondaryContentList":["secondaryContentItemCollection"],"secondaryContentItem":{"contentTypes":{"Comments":{"features":["avatar"]},"Answers":{"features":["feedback","crowdSourcedAnswerBadge"]}}},"avatar":{"contentTypes":{"Reviews":{"features":["has:socialAvatar"]},"Questions":{"features":["has:socialAvatar"]}}}},"outlets":{"showmediaviewer":[{"component":"mediaViewer1","event":"open"}],"showfullprofile":[{"component":"fullProfilePopup1","event":"launchprofile"}],"filtercontent":[{"component":"contentSearch2","event":"filtercontent"}],"showreviews":[{"component":"reviewContentList1","event":"scrolltocontent","scope":"rr","fallback":"doShowContent"}],"scrolltocontent":[{"component":"reviewContentList1","event":"scrolltocontent"}],"filterresults":[{"component":"reviewContentList1","event":"filterresults"}],"showsubmission":[{"component":"questionSubmission2_inline","scope":"qa","action":"submit_question"}],"showanswersubmission":[{"component":"answerSubmission1_inline","scope":"qa","action":"submit_answer"}],"showquestions":[{"component":"questionContentList1","event":"scrolltocontent","scope":"qa","fallback":"doShowContent"}],"showcommentsubmission":[{"component":"commentSubmission2","scope":"rr","action":"submit_comment"}]},"componentId":"contentSearch2","autoload":true,"viewUniq":0,"views":{}},"reviewSummary1":{"serverRender":true,"container":"BVRRSummaryContainer","subjectType":"Products","contentType":"Products","coverageContentTypes":["Reviews","Questions"],"type":"summary","features":{"self":["has:stars","has:overallRating","has:aggregateRatingTag","histogram","has:writeReviews","has:askQuestions","has:minimalistHorizontal","has:minimalist"],"histogram":["has:filterButton"]},"outlets":{"showreviewsubmission":[{"component":"reviewSubmission1","scope":"rr","action":"submit_review"}],"showreviews":[{"component":"reviewContentList1","event":"scrolltocontent","scope":"rr","fallback":"doShowContent"}],"filtercontent":[{"component":"reviewContentList1","event":"filtercontent"}],"showquestions":[{"component":"questionContentList1","event":"scrolltocontent","scope":"qa","fallback":"doShowContent"}],"showquestionsubmission":[{"component":"questionSubmission1","scope":"qa","action":"submit_question"}]},"componentId":"reviewSummary1","autoload":true,"priority":true,"viewUniq":0,"views":{}},"reviewContentList1":{"subjectType":"Products","type":"contentList","features":{"self":["contentItemCollection","contentFilter","ugcCount","has:contentSort","has:writeReviews","headToHead","inlineHistogram","secondaryRatingSummary","loadMore"],"pagination":["ugcCount"],"contentItem":["has:stars","has:secondaryRatings","has:reviewPhotos","has:reviewVideos","has:tags","has:prosCons","has:userBadges","has:contentBadges","secondaryContentList","has:secondaryContentBtn","has:recommended","inlineProfile","has:fullProfileLink","has:reviewAttribution","has:productFamiliesAttribution"],"secondaryContentList":["secondaryContentItemCollection<ClientResponses>","secondaryContentItemCollection<Comments>","has:inlineSubmission","loadMore"],"secondaryContentItem":["has:userBadges","has:socialAvatar"],"contentFilter":["has:filterButton"],"inlineProfile":["has:socialAvatar","has:fullProfileLink"]},"outlets":{"showmediaviewer":[{"component":"mediaViewer1","event":"open"}],"showfullprofile":[{"component":"fullProfilePopup1","event":"launchprofile"}],"showsubmission":[{"component":"reviewSubmission1","scope":"rr","action":"submit_review"}],"filterresults":[{"component":"reviewContentList1","event":"filterresults"}],"filtercontent":[{"component":"reviewContentList1","event":"filtercontent"}],"linkSort":[{"component":"reviewContentSort1","event":"setupsort"}],"showhelpfulpositive":[{"component":"reviewContentList1","event":"showhelpfulpositive"}],"showhelpfulcritical":[{"component":"reviewContentList1","event":"showhelpfulcritical"}],"showreviews":[{"component":"reviewContentList1","event":"scrolltocontent"}],"showcommentsubmission":[{"component":"commentSubmission1_inline","scope":"rr","action":"submit_comment"}]},"serverRender":true,"container":"BVRRContainer","contentType":"Reviews","secondaryContentType":"Comments","pageview":{"bvProduct":"RatingsAndReviews"},"monitorVisibility":true,"componentId":"reviewContentList1","autoload":true,"viewUniq":0,"views":{}},"reviewSubmission1":{"type":"submission","preload":true,"inline":false,"features":{"self":["thankYouPage","dropdownable","has:submissionPreview"],"thankYouPage":["has:mbox"]},"outlets":{"previewcontent":[{"component":"reviewContentList1","event":"previewcontent"}]},"container":"BVRRContainer","subjectType":"Products","contentType":"Reviews","pageview":{"bvProduct":"RatingsAndReviews"},"componentId":"reviewSubmission1","viewUniq":0,"views":{}},"reviewContentSort1":{"serverRender":true,"subjectType":"Products","type":"contentSort","sortDefault":"mostRecent","sortTypes":["mostHelpful","positive","featured","mostRecent"],"features":{"self":[]},"outlets":{"setupme":[{"component":"reviewContentList1","event":"setupcontentsort"}],"sortcontent":[{"component":"reviewContentList1","event":"sortcontent"}]},"container":"BVRRContainer","contentType":"Reviews","componentId":"reviewContentSort1","viewUniq":0,"views":{}},"questionContentList1":{"subjectType":"Products","type":"contentList","features":{"self":["contentItemCollection","ugcCount","has:contentSort","has:askQuestions","has:inlineSubmission","loadMore"],"pagination":["ugcCount"],"contentItem":["secondaryContentList","has:secondaryContentLink","has:secondarySubmission","has:secondaryContentBtn","has:fullProfileLink","has:reviewAttribution","has:productFamiliesAttribution"],"secondaryContentList":["secondaryContentItemCollection"],"secondaryContentItem":["feedback","crowdSourcedAnswerBadge"]},"outlets":{"showmediaviewer":[{"component":"mediaViewer1","event":"open"}],"showfullprofile":[{"component":"fullProfilePopup1","event":"launchprofile"}],"linkSort":[{"component":"questionContentSort1","event":"setupsort"}],"showsubmission":[{"component":"questionSubmission1","scope":"qa","action":"submit_question"}],"showanswersubmission":[{"component":"answerSubmission1_inline","scope":"qa","action":"submit_answer"}]},"serverRender":true,"container":"BVQAContainer","contentType":"Questions","secondaryContentType":"Answers","pageview":{"bvProduct":"AskAndAnswer"},"monitorVisibility":true,"componentId":"questionContentList1","autoload":true,"viewUniq":0,"views":{}},"questionSubmission1":{"type":"submission","preload":false,"inline":true,"features":{"self":["thankYouPage","has:submissionPreview"],"thankYouPage":["has:mbox"]},"outlets":{"previewcontent":[{"component":"questionContentList1","event":"previewcontent"}],"showanswersubmission":[{"component":"answerSubmission1_inline","scope":"qa","action":"submit_answer"}]},"container":"BVQAContainer","subjectType":"Products","contentType":"Questions","pageview":{"bvProduct":"AskAndAnswer"},"componentId":"questionSubmission1","viewUniq":0,"views":{}},"questionContentSort1":{"serverRender":true,"subjectType":"Products","type":"contentSort","sortDefault":"recentQuestionsFirst","sortTypes":["recentQuestionsFirst","recentAnswersFirst","mostAnsweredQuestionsFirst","mostAnsweredQuestionsLast","answersWithAffiliationStaffFirst","helpfulnessAnswersLast"],"features":{"self":[]},"outlets":{"setupme":[{"component":"questionContentList1","event":"setupcontentsort"}],"sortcontent":[{"component":"questionContentList1","event":"sortcontent"}]},"container":"BVQAContainer","contentType":"Questions","componentId":"questionContentSort1","viewUniq":0,"views":{}},"answerSubmission1_inline":{"type":"submission","preload":false,"inline":false,"features":{"self":["thankYouPage","has:submissionPreview"],"thankYouPage":["has:mbox"]},"outlets":{"previewsecondarycontent":[{"component":"questionContentList1","event":"previewsecondarycontent"}]},"container":"BVQAContainer","subjectType":"Products","contentType":"Answers","componentId":"answerSubmission1_inline","viewUniq":0,"views":{}},"questionSubmission2_inline":{"type":"submission","preload":false,"inline":true,"features":{"self":["has:submissionPreview"],"thankYouPage":[]},"outlets":{"previewcontent":[{"component":"questionContentList1","event":"previewcontent"}]},"container":"BVContainer","subjectType":"Products","contentType":"Questions","pageview":{"bvProduct":"AskAndAnswer"},"componentId":"questionSubmission2_inline","viewUniq":0,"views":{}},"commentSubmission1_inline":{"type":"submission","preload":false,"inline":false,"features":{"self":["has:submissionPreview"],"thankYouPage":[]},"outlets":{"previewsecondarycontent":[{"component":"reviewContentList1","event":"previewsecondarycontent"}]},"container":"BVRRContainer","subjectType":"Products","contentType":"Comments","componentId":"commentSubmission1_inline","viewUniq":0,"views":{}},"commentSubmission2":{"type":"submission","preload":false,"inline":false,"features":{"self":["thankYouPage"],"thankYouPage":["has:mbox"]},"outlets":{},"container":"BVRRContainer","subjectType":"Products","contentType":"Comments","componentId":"commentSubmission2","viewUniq":0,"views":{}}});

BV.define('framework/util/featureHelper',[
  'underscore'
], function (_) {

  /**
   * Extract the name and type from a feature string.
   *
   * Returns an array with:
   *
   * [0] as feature name.
   * [1] as instance name.
   * [2] as feature type.
   *
   * e.g.
   *  contentList => ['contentList', undefined, undefined]
   *  contentList<Reviews> => ['contentList', undefined, 'Reviews']
   *  contentList:instanceName<Questions> => ['contentList', 'instanceName', 'Questions']
   *  has:stars => ['stars', undefined, undefined]
   */
  function _getNameTypeArray (name) {
    var featureName = name.replace('has:', '');
    var matches = featureName.match(/^(\w+)(:\w+)?(<(\w+)>)?$/);

    // Note that IE8 will return '' in place of undefined for non-matched
    // subexpressions. We want to always return undefined.
    var result = [];
    result[0] = matches[1] || undefined;
    result[1] = matches[2] ? matches[2].replace(':', '') : undefined;
    result[2] = matches[3] ? matches[3].replace('<', '').replace('>', '') : undefined;

    return result;
  }

  /**
   * This is a utility class for features.
   * It provides easy helper functions to
   *    - get feature name
   *    - get feature type
   *    - exam if a feature exists
   *    - exam if a feature name matches criteria
   */
  return {
    /**
     * Get the type of a given feature.
     */
    getType: function (name) {
      return _getNameTypeArray(name)[2];
    },

    /**
     * Get the instance name of a given feature
     */
    getInstanceName: function (name) {
      return _getNameTypeArray(name)[1];
    },

    /**
     * Get the name of the given feature.
     */
    getName: function (name) {
      return _getNameTypeArray(name)[0];
    },

    /**
     * Check if a featuer is a "Has" featuer.
     */
    isHas: function (name) {
      return name.split('has:')[1] ? true : false;
    },

    /**
     * Return a full feature string based on given name and type.
     *
     * e.g.
     *  name = contentList
     *  type = Reviews
     *  => contentList<Reviews>
     */
    getFullName: function (name, type, instanceName) {
      if (instanceName) {
        name = name + ':' + instanceName;
      }
      if (type) {
        return name + '<' + type + '>';
      }
      return name;
    },

    /**
     * Check if name matches featureName.
     */
    match: function (featureName, name) {
      var regex = new RegExp('^' + featureName + '<(\\w+)>$');
      return regex.test(name);
    },

    getFeatures: function (features) {
      var allFeatures = [];
      _(features).forEach(function (fts) {
        if (_(fts).isArray()) {
          allFeatures = _.union(allFeatures, fts);
        }
        else if (_(fts).isObject()) {
          allFeatures = _.union(allFeatures, this.getFeatures(fts));
        }
      }, this);
      return allFeatures;
    },

    getFeaturesForInstance: function (featureObj, contentType, instanceName) {
      featureObj = featureObj || [];

      if (_(featureObj).isArray()) {
        return featureObj;
      }

      if (featureObj.instances && featureObj.instances[instanceName]) {
        return featureObj.instances[instanceName].features;
      }

      var contentTypes = featureObj.contentTypes;

      if (contentTypes && contentTypes[contentType]) {
        return contentTypes[contentType].features;
      }

      return [];
    }

  };

});

BV.define('mappings',[
  'underscore',
  'framework/util/featureHelper'
], function (_, Helper) {

  return {
      };

});

BV.define('$BV',['client!window'], function (window) {
  return window.$BV;
});

BV.define('framework/util/scoped',[
  'underscore'
], function (_) {
  return function (key, contentType) {
    if (_(key).isObject()) {
      var _obj = {};

      _(key).each(function (v, k) {
        _obj[contentType + ':' + k] = v;
      });

      return _obj;
    }

    return contentType + ':' + key;
  };
});

/**
 * @fileOverview
 *
 * We determine and store the version of IE in the scout file,
 * so we can look to that stored value here. Returns a function
 * instead of a singleton so mocking is possible in tests.
 */
BV.define('framework/util/ie',[
  'BV'
], function (BV) {
  /**
   * @returns {Number|undefined} Returns a number representing
   * the IE version for versions 8 and 9; undefined otherwise.
   */
  return function () {
    return BV._internal.ie;
  };
});

BV.define('document',['window'], function (window) {
  return window.document;
});

BV.define('util/cookie',[
  'document',
  'window'
], function (document, window) {
  return {
    create: function (name, value, days, domain) {
      var date;
      var expires;

      if (days) {
        date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = '; expires=' + date.toGMTString();
      }
      else {
        expires = '';
      }
      // Set secure flag true. See CCS-31984.
      if (location.protocol === 'https:') {
        document.cookie = name + '=' + value + expires + ';path=/' + (domain ? (';domain=' + domain) : '') + '; secure';
      }
      else {
        document.cookie = name + '=' + value + expires + ';path=/' + (domain ? (';domain=' + domain) : '');
      }
    },

    read: function (name) {
      var nameEQ = name + '=';
      var ca = document.cookie.split(';');
      var c;
      var i;

      for (i = 0; i < ca.length; i++) {
        c = ca[i];
        while (c.charAt(0) === ' ') {
          c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length, c.length);
          }
        }
      }

      return null;
    },

    erase: function (name) {
      this.create(name, '', -1);
    }
  };
});

BV.define('bv/util/isDev',[
  'window',
  'client!util/cookie',
  'underscore'
], function (window, cookie, _) {
  var isDebugCookie = cookie.read && cookie.read('_bvfb_debug');
  var isLocalhost = window.location && window.location.host === 'localhost.bazaarvoice.com';

  var debugCookie = {};

  if (isDebugCookie) {
    _(isDebugCookie.split(',')).each(function (val) {
      val = val.split(':');
      debugCookie[val[0]] = val[1];
    });

    return {
      debugCookie: debugCookie
    };
  }

  if (isLocalhost) {
    return {
      debugCookie: false
    };
  }

  return false;
});

/*jshint expr:true */
/*global console:false */

/**
 * @fileOverview  Module that provides an interface for logging
 * messages to the console at different log levels.
 */
BV.define('framework/util/bvreporter',[
  'underscore',
  'client!window',
  'framework/util/ie',
  'bv/util/isDev'
], function (_, window, IE, isDev) {
  /**
   * BVReporter provides a wrapper around the console object. It should be used for creating
   * messages that will be helpful for developers. BVReporter methods can safely be kept in the
   * code -- that is, you don't need to remove them like you need to remove console.log statements.
   *
   * BVReporter should be used sparingly outside of framework files. When you use it, be thoughtful
   * about the level of logging you choose. Most messages should be at the "debug" or "log" level, so
   * developers can easily silence them. Messages at the info level will generally not be silenced
   * during development, and messages at the warn and error level will almost never be silenced.
   *
   * BVReporter also provides the ability to make assertions. Assertions are useful when other
   * developers may use your code in unpredictable ways. You can write an assertion so a fellow
   * developer will know at a glance what your code expects, and so that they will get a useful
   * error message if they violate those expectations.
   *
   * @type {Object}
   */

  /**
   * Set the log level.
   *
   * -1: debug and greater (so incredibly noisy)
   *  0: log and greater
   *  1: info and greater (this is the recommended level)
   *  2: warn and greater
   *  3: error and greater
   *  4: assertions only (you cannot set a log level that will disable assertions)
   *
   * You can override this here, or you can set it in config/local/server-config.json.
   * You can also pass a "loglevel" param in the URL in order to override any other setting:
   *
   *    http://localhost.bazaarvoice.com/product/product1?clientname=testcustomer-everything&loglevel=3
   *
   * @type {Number}
   */

  IE = IE();
  var logLevel;
  var debugCookie;

  if (isDev && isDev.debugCookie) {
    logLevel = isDev.debugCookie.logLevel;
  }
  else {
    logLevel = window.BV && window.BV._options && window.BV._options.logLevel;
  }

  logLevel = logLevel || 1;

  function logger (level, args) {
    if (!isDev) {
      return;
    }

    if (!window.console) {
      return;
    }

    // If we want to log something that's computationally expensive, we can pass a function
    // to a BVReporter method as its sole argument. The function should return the arguments
    // to be logged; the function will only ever be executed in the development environment.
    args = [].slice.call(args);

    if (_(args[0]).isFunction()) {
      args = args[0]();
    }

    if (IE) {
      console.log(args);
      return;
    }

    try {
      (console[level] || console.log).apply(console, args);
    }
    catch (e) {}
  }

  var BVReporter = {
    // Assign these constants so we don't have to remember them.
    DEBUG: -1,
    LOG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,

    setLogLevel: function (level) {
      logLevel = level || 0;
      logger('log', ['Log level set to', logLevel]);
    },

    debug: function () {
      logLevel < 0 && logger('log', arguments);
    },

    log: function () {
      logLevel < 1 && logger('log', arguments);
    },

    info: function () {
      logLevel < 2 && logger('info', arguments);
    },

    warn: function () {
      logLevel < 3 && logger('warn', arguments);
    },

    error: function () {
      logLevel < 4 && logger('error', arguments);
    },

    count: function () {
      logLevel < 1 && logger('count', arguments);
    },

    time: function () {
      logLevel < 2 && logger('time', arguments);
    },

    timeEnd: function () {
      logLevel < 2 && logger('timeEnd', arguments);
    },

    group: function (maxLevel) {
      var args = _.rest(arguments);
      if (logLevel <= maxLevel) {
        logger('group', args);
        logger('time', args);
      }
    },

    groupEnd: function (maxLevel) {
      var args = _.rest(arguments);
      if (logLevel <= maxLevel) {
        logger('groupEnd', args);
        logger('timeEnd', args);
      }
    },

    /**
     * Assert that an expression is true, and throw the provided message if it is not.
     *
     * @param  {Expression} assertion
     * @param  {String} message
     */
    assert: function (assertion, message) {
      if (!isDev) {
        return;
      }

      // If we want to assert something computationally expensive, we can pass a function
      // as the sole argument to BVReporter.assert. The function should return an array with
      // two items: the assertion, and the message.
      if (_(assertion).isFunction()) {
        BVReporter.assert.apply(null, assertion());
        return;
      }

      if (!assertion) {
        throw new Error('Assertion failed: ' + message);
      }
    }
  };

  return BVReporter;
});

BV.define('framework/bevented',[
  'underscore',
  'framework/util/scoped',
  'framework/util/bvreporter'
], function (_, Scoped, BVReporter) {
  /**
   * This is a mixin for bmodel, bview, and bcollection.
   *
   * The publish, subscribe, and unsubscribe methods are intended for
   * "broadcasting" events. An event that is "publish"-ed will end up being
   * triggered on the view or model's component. The subscribe method allows
   * objects to listen for these events on their own component; unsubscribe stops
   * listening.
   */
  function modelOrCollection (obj) {
    return obj.isCollection ? 'Collection' : 'Model';
  }

  return {
    _scopeArgs: function (args) {
      if (args.length) {
        args[0] = Scoped(args[0], this.getContentType ? this.getContentType() : this.model.getContentType());
      }

      return args;
    },

    /**
     * This method should be used to announce events of interest to arbitrary
     * other parts of the application.
     */
    publish: function (events, data) {
      BVReporter.assert(events, 'events is defined');

      var args = this._scopeArgs([].slice.call(arguments));
      var component = this.getComponent();

      BVReporter.log(modelOrCollection(this), this.getScope() + this.name, 'publishing', args);
      component.trigger.apply(component, args);
    },

    /**
     * This method should be used to listen to events published by other
     * parts of the application. Supports the same syntax as .on() from Backbone.Events,
     * but defaults to this as the scope if one is not provided.
     */
    subscribe: function (events, callback, scope) {
      var component = this.getComponent();
      var args = [].slice.call(arguments);
      args = this._subscribeArgs.apply(this, args);
      return component.on.apply(component, args);
    },

    /**
     * Just like subscribe, but causes the bound callback to only fire once
     * before being removed. Handy for saying "the next time that X happens, do this".
     */
    subscribeOnce: function (events, callback, scope) {
      var component = this.getComponent();
      var args = [].slice.call(arguments);
      args = this._subscribeArgs.apply(this, args);
      return component.once.apply(component, args);
    },

    _subscribeArgs: function (events, callback, scope) {
      BVReporter.assert(events, 'events is defined');

      var args = [].slice.call(arguments);

      if (_(events).isString()) {
        BVReporter.assert(function () { return [_(callback).isFunction(), 'callback is a function']; });
      }

      if (args.length === 2 || (args.length === 1 && _(args[0]).isObject())) {
        args.push(this);
      }

      args = this._scopeArgs(args);

      BVReporter.log(modelOrCollection(this), this.getScope() + this.name, 'subscribing to', args);

      return args;
    },

    /**
     * Undo a subscription. Supports the same syntax as .off() from Backbone.Events,
     * but defaults to this as the scope if one is not provided.
     */
    unsubscribe: function (events, callback, scope) {
      var component = this.getComponent();
      var args = [].slice.call(arguments);

      if (args.length === 2) {
        args.push(this);
      }

      args = this._scopeArgs(args);

      BVReporter.log(modelOrCollection(this), this.getScope() + this.name, 'unsubscribing', args);
      return component.off.apply(component, args);
    }
  };
});

BV.define('framework/bdata',[
  'underscore',
  'jquery',
  'framework/util/bvreporter'
], function (_, $, BVReporter) {
  function doIt (dfd, fn, context) {
    if (!fn) {
      return dfd.promise();
    }

    return dfd.promise().then(context ? _.bind(fn, context) : fn);
  }

  function modelOrCollection (obj) {
    return obj.isCollection ? 'Collection' : 'Model';
  }

  var BData = {
    _initDeferreds: function () {
      // You should never need to interact with these directly.
      this._initializedDfd = $.Deferred();
      this._dataReadyDfd = $.Deferred();
      this._dataProcessedDfd = $.Deferred();
    },

    /**
     * Method to register that a model has been initialized.
     *
     * @param {Object} [data] The model's data.
     */
    initialized: function (obj) {
      BVReporter.debug(modelOrCollection(this), this.getScope(), 'is initialized.');
      return this._initializedDfd.resolve(obj || this);
    },

    /**
     * Method to register that a model's data is ready.
     *
     * @param {Object} [data] The model's data.
     */
    dataReady: function (data) {
      BVReporter.debug(modelOrCollection(this), this.getScope(), 'data is ready.');
      return this._dataReadyDfd.resolve(data);
    },

    /**
     * Method to register that a model's data has been processed.
     *
     * @param {Object} [data] The model's processed data.
     */
    dataProcessed: function (data) {
      BVReporter.debug(modelOrCollection(this), this.getScope(), 'data is processed.');
      return this._dataProcessedDfd.resolve(data);
    },

    /**
     * Method to access the promise associated with the model's data being
     * ready. Use this if you need to attach a done and fail handler;
     * otherwise, just use the onDataReady method.
     *
     * @returns {Promise}
     */
    dataReadyPromise: function () {
      return this._dataReadyDfd.promise();
    },

    /**
     * Method to access the promise associated with the model's data being
     * processed. Use this if you need to attach a done and fail handler;
     * otherwise, just use the onDataProcessed method.
     *
     * @returns {Promise}
     */
    dataProcessedPromise: function () {
      return this._dataProcessedDfd.promise();
    },

    /**
     * Method to access the promise associated with the model being
     * initialized. Use this if you need to attach a done and fail handler;
     * otherwise, just use the onInitialized method.
     *
     * @returns {Promise}
     */
    initializedPromise: function () {
      return this._initializedDfd.promise();
    },

    /**
     * Method to reset the _dataReadyDfd, which is required by some components.
     */
    resetDataReady: function () {
      BVReporter.log(modelOrCollection(this), this.getScope(), 'resetting data ready dfd');
      this._dataReadyDfd = $.Deferred();
      return this._dataReadyDfd.promise();
    },

    /**
     * Method for registering a function to be run when the model's data is
     * ready, now or in the future.
     *
     * @param {Function} fn The function to run
     * @param {Object} [context] The context in which to run the function (its
     * `this`)
     *
     * @returns {Promise} If the function you provide to this method has
     * a return value, the returned promise will be resolved with that value.
     */
    onDataReady: function (fn, context) {
      BVReporter.debug(modelOrCollection(this), this.getScope(), 'registering dataReady handler');
      return doIt(this._dataReadyDfd, fn, context);
    },

    /**
     * Method for registering a function to be run when the model's data has
     * been processed, now or in the future.
     *
     * @param {Function} fn The function to run
     * @param {Object} [context] The context in which to run the function (its
     * `this`)
     *
     * @returns {Promise} If the function you provide to this method has
     * a return value, the returned promise will be resolved with that value.
     */
    onDataProcessed: function (fn, context) {
      BVReporter.debug(modelOrCollection(this), this.getScope(), 'registering dataProcessed handler');
      return doIt(this._dataProcessedDfd, fn, context);
    },

    /**
     * Method for registering a function to be run when the model has
     * been initialized, now or in the future.
     *
     * @param {Function} fn The function to run
     * @param {Object} [context] The context in which to run the function (its
     * `this`)
     *
     * @returns {Promise} If the function you provide to this method has
     * a return value, the returned promise will be resolved with that value.
     */
    onInitialized: function (fn, context) {
      return doIt(this._initializedDfd, fn, context);
    }

  };

  return BData;
});


BV.define('framework/util/bvtrackerqueue',[],function () {
  var queue = [];

  return {
    push: function (args) {
      queue.push(args);
    },

    get: function () {
      return queue;
    },

    override: function (fn) {
      this.push = function () {
        fn.apply(null, arguments);
      };
    }
  };
});

/**
 * @fileOverview BVTracker is a bridge between application code and our analytics code.
 *
 * Calling a method on BVTracker will trigger an event on BVTracker; the
 * analytics code listens for these events and handles them appropriately.
 *
 * The following methods are supported:
 *
 * - error
 * - pageview
 * - conversion
 * - event
 * - impression
 *
 * Arguments passed to these functions will be passed as arguments to any
 * event handler that is registered.
 *
 * Generally, only analytics code -- not application code -- should listen
 * to events on BVTracker.
 */
BV.define('framework/util/bvtracker',[
  'backbone',
  'underscore',
  'jquery',
  'framework/util/bvreporter',
  'framework/util/bvtrackerqueue'
], function (Backbone, _, $, BVReporter, Queue) {
  var BVTracker = {};
  _.forEach(['optIn', 'optOut'], function (inOrOut) {
    BVTracker[inOrOut] = function () {
      var req = '//network.bazaarvoice.com/' + inOrOut.toLowerCase() + '.json?callback=?';
      return $.getJSON(req);
    };
  });

  _([
    // Public, supported events.
    'error',
    'pageview',
    'conversion',
    'event',
    'impression',

    // Internal, private events.
    'rendered',
    'loaded',
    'completed',
    'waited',
    'feature',
    'inView',
    'viewedUGC',
    'performance'
  ]).each(function (event) {
    BVTracker[event] = function () {
      var args = [].slice.call(arguments);
      args = [event].concat(args);
      this.trigger.apply(this, args);

      if (event === 'error') {
        BVReporter.error(args);
      }
    };
  });

  _.extend(BVTracker, Backbone.Events);

  var queue = Queue.get();
  var args;
  var event;

  function handleQueueItem (queueItem) {
    var event = queueItem.shift();
    BVTracker[event].apply(BVTracker, queueItem);
  }

  while (queue.length) {
    handleQueueItem(queue.shift());
  }

  Queue.override(handleQueueItem);

  return BVTracker;
});

BV.define('bv/strings',{
  errors: {
    IMPLEMENTATION: 'Implementation Error',
    API: 'API Error',
    FORM: 'Form Error',
    UNCAUGHT: 'Uncaught Exception',
    CONFIG: 'Configuration Error',
    THIRD_PARTY: 'Third Party Service Error',
    TIMEOUT: 'Request Timeout',
    UI: 'User Interface Error',
    FRAMEWORK: 'Framework Error',
    BV_LOCAL_API_ERROR: 'BV Local API error',
    BV_LOCAL_API_FAILURE: 'BV Local API failure'
  },
  rpc: {
    // This value is now hard-coded in the API code. It
    // should not be changed without consultation with the
    // API team.
    postCallback: 'parent.rpc.returnSubmissionResponse',
    localCallback: 'returnSubmissionResponse'
  }
});

BV.define('framework/bmodelbase',[
  'underscore',
  'backbone',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'framework/util/scoped',
  'bv/strings'
], function (_, Backbone, BVReporter, BVTracker, Scoped, str) {
  /**
   * This is a mixin for bmode and bcollection.
   * It has shared methods that are used by both bmodel and bcollection
   */
  var BModelBase = {

    getScope: function () {
      var contentType = this.getContentType();
      var component;

      if (!this.isCollection) {
        component = this.getComponent();

        if (!component) {
          BVReporter.warn('Did not find component for', this.name || this.get('name'));
          return 'unknown';
        }

        if (!contentType) {
          BVReporter.warn('Did not find content type for', this.name || this.get('name'));
          return 'unknown';
        }

        return component.getScope(contentType);
      }

      if (!this.parent) {
        BVTracker.error({
          name: str.errors.FRAMEWORK,
          detail1: 'Missing parent in collection: ' + this.name
        });
        return this.getComponent().getScope(contentType);
      }

      return this.parent.getScope();
    },

    getStatsTypes: function () {
      if (!this.statsTypes || _(this.statsTypes).isEmpty()) {
        return [];
      }

      var component = this.getComponent();
      var coverTypes = [].concat(component.contentType, component.coverageContentTypes);
      return _(coverTypes).chain().compact().intersection(this.statsTypes).value();
    },

    hasFeature: function (featureName, featureType) {
      return this.getComponent().hasFeature(this.getRefName(), featureName, this.getContentType(), this.getInstanceName(), featureType);
    },

    componentSet: function (key, value) {
      BVReporter.assert(key, 'componentSet must be called with at least one argument');

      if (_.isUndefined(value) || value === null) {
        BVReporter.assert(function () { return [_(key).isObject(), 'componentSet requires an object when called with only one argument']; });
      }

      var component = this.getComponent();
      var args = [].slice.call(arguments);

      args[0] = Scoped(args[0], this.getContentType());

      return component.set.apply(component, args);
    },

    componentGet: function (key) {
      BVReporter.assert(key, 'componentGet must be called with a key');

      var component = this.getComponent();
      var args = [].slice.call(arguments);
      args[0] = Scoped(args[0], this.getContentType());

      return component.get.apply(component, args);
    },

    _getOtherProps: function (parent) {
      var topModel = parent || this;

      // try to find the top model.
      try {
        while (!_(topModel.getParent()).isEmpty()) {
          topModel = topModel.getParent();
        }
      }
      catch (e) {
        BVTracker.error({
          name: str.errors.FRAMEWORK,
          detail1: 'Unable to get parent model information'
        });
      }

      return {
        topModel: topModel,
        refName: topModel === this ? 'self' : this.name
      };
    },

    _getProps: function () {
      var props = {};
      if (!this.getComponent()) {
        return props;
      }

      _([
        'componentId',
        'features',
        'subjectType',
        'contentType',
        'secondaryContentType',
        'outlets'
      ]).forEach(function (key) {
        props[key] = this.getComponent()[key];
      }, this);

      _([
        'autoload',
        'pageview',
        'preload'
      ]).forEach(function (key) {
        props[key] = this.getComponent()[key] || false;
      }, this);

      _(props).extend(this._getOtherProps());
      return props;
    },

    _getParentProps: function (parent, config) {
      if (!parent) {
        return {};
      }

      var contentType = this.isCollection ? this.contentType : this.get('contentType');
      var props = {
        contentType: config.featureType || contentType || keyFromParent('contentType')
      };

      _([
        'subjectType',
        'secondaryContentType'
      ]).forEach(function (key) {
        props[key] = (this.isCollection ? this[key] : this.get(key)) || keyFromParent(key);
      }, this);

      _([
        'component',
        'componentId',
        'coverageContentTypes',
        'submissionContentTypes',
        'clientAPIConfig'
      ]).forEach(function (key) {
        props[key] = keyFromParent(key);
      });

      function keyFromParent (key) {
        return parent.isCollection ? parent[key] : parent.get(key);
      }

      _(props).extend(this._getOtherProps(parent));
      return props;
    },

    getClosestAncestor: function (options) {
      BVReporter.assert(function () { return [!options || _(options).isObject(), 'options is object']; });

      var optionTests = {};

      if (options && options.modelType) {
        optionTests.modelType = function (model) {
          return model instanceof options.modelType;
        };
      }

      if (options && options.hasFeature) {
        optionTests.hasFeature = function (model) {
          return !model.isCollection && model.getFeatureModel(options.hasFeature);
        };
      }

      function checkOptions (model) {
        var passesOptionTests = true;  // defaults to true in case there is no options arg
        _.each(optionTests, function (optionTest) {
          if (!optionTest(model)) {
            passesOptionTests = false;
          }
        });
        return passesOptionTests;
      }

      var startModel = this.getParent();

      try {
        while (!_(startModel).isEmpty() && !(checkOptions(startModel))) {
          startModel = startModel.getParent();
        }
      }
      catch (e) {
        BVTracker.error({
          name: str.errors.FRAMEWORK,
          detail1: 'Exception caught while looking for closest ancestor model.'
        });
      }

      return startModel;
    },

    destroy: function (options) {
      BVReporter.group(BVReporter.DEBUG, 'Destroy Model/Collection', this.getScope());
      this.getComponent().unset();
      this.unsubscribe();
      this.stopListening();

      _(this.subModels).each(function (subModel) {
        if (subModel) {
          subModel.destroy();
        }
      });

      BVReporter.groupEnd(BVReporter.DEBUG, 'Destroy Model/Collection');
      if (this.isCollection) {
        return this.reset([], { silent: true });
      }

      return Backbone.Model.prototype.destroy.apply(this, arguments);
    },

    trigger: function () {
      var component;
      var args;

      // if we're a top model, trigger all events on the component as outlet: events
      if (this.getRefName() === 'self') {
        args = [].slice.call(arguments);
        args[0] = 'outlet:' + args[0];
        component = this.getComponent();
        component.trigger.apply(component, args);
      }

      Backbone.Model.prototype.trigger.apply(this, arguments);
    }

  };

  /**
   * defines the following methods:
   * - getContentType()
   * - getParent()
   * - getComponent()
   * - getTopModel()
   * - getRefName()
   * - getInstanceName()
   */
  _(['contentType', 'parent', 'component', 'topModel', 'refName', 'instanceName']).each(function (key) {
    var fnName = 'get' + key.charAt(0).toUpperCase() + key.slice(1);
    BModelBase[fnName] = function () {
      return this.isCollection ? this[key] : this.get(key);
    };
  });

  return BModelBase;
});

BV.define('dimsumFields',['underscore', 'vendor/json2'], function (_, JSON) {
  
  return {
      };
});

BV.define('dimsumFields!displayedFieldKeys',[], {"BestUsesTelecom":true,"BestUsesEntertainment":true,"BestUsesPharmacyHealth":true,"ProsTravel":true,"ProsMusic":true,"ConsB2BElectronics":true,"ProsPets":true,"ProsGames":true,"ConsTravel":true,"Clothingfit":true,"ProsSoftware":true,"TravelPurpose_89":true,"ProsSportingGoods":true,"SoftwarePrimaryUse":true,"BestUsesBooks":true,"ConsOfficeSupplies":true,"ConsCooking":true,"ProsTelecom":true,"ProsApparel":true,"ConsGames":true,"ConsTelecom":true,"ConsBeauty":true,"BestUsesApparel":true,"ProsHomeGoods":true,"blank_49":true,"ProsBooks":true,"ProsFinancialServices":true,"BestUsesPets":true,"ConsBooks":true,"BestUsesTravel":true,"BestUsesOfficeSupplies":true,"BestUsesGames":true,"IncentivizedReview":true,"BestUsesMusic":true,"Con":true,"BestUsesFood":true,"ConsSoftware":true,"ProsB2BElectronics":true,"ProsBeauty":true,"ProsPharmacyHealth":true,"ConsMusic":true,"ConsDVDs":true,"ConsFlowersGifts":true,"BestUsesBeauty":true,"BestUsesFlowersGifts":true,"ProsDVDs":true,"ConsApparel":true,"UsageFrequency_1":true,"Pro":true,"ProsEducation":true,"BestUsesEducation":true,"BestUsesCleaningSuppliesCPG":true,"ConsHomeGoods":true,"ProsEntertainment":true,"ConsToysHobbies":true,"ConsFood":true,"ConsBoringEducation":true,"ProsOfficeSupplies":true,"ProsCleaningSuppliesCPG":true,"BestUsesSoftware":true,"ConsFinancialServices":true,"BestUsesSportingGoods":true,"ConsConsumerElectronics":true,"BestUsesToysHobbies":true,"BestUsesDVDs":true,"ConsEntertainment":true,"ProsFood":true,"blank":true,"ProsCooking":true,"ConsCleaningSuppliesCPG":true,"ConsPets":true,"ConsPharmacyHealth":true,"ProsToysHobbies":true,"ProsConsumerElectronics":true,"ProsFlowersGifts":true,"BestUsesHomeGoods":true,"ConsSportingGoods":true,"BestUsesConsumerElectronics":true,"BestUsesCooking":true,"BestUsesB2BElectronics":true,"CustomerService":true,"Transportation":true,"PictureQuality":true,"EaseOfSetup":true,"EaseOfUse":true,"Design":true,"SoundQuality1":true,"Quality":true,"Features":true,"Width":true,"Cleanliness":true,"Effectiveness":true,"Appearance1":true,"SoundQuality":true,"FoodQuality":true,"TestSlider":true,"EaseOfAssembly":true,"Fit":true,"anotherTestSlider3":true,"BatteryLife":true,"Comfort":true,"Value":true,"Ambience":true,"Reliability":true,"Performance":true,"Amenities":true,"Fit_22":true,"FavoriteBookGenre":true,"TestText":true,"EducationalRole":true,"FavoriteMovieGenre":true,"BodyType":true,"HomeGoodsProfile":true,"Gender":true,"FashionStyle":true,"FavoriteMusicGenre":true,"Levelofexpertise":true,"HairType":true,"EyeColor":true,"DecorStyle":true,"TravelCompanions":true,"LineOfBusiness":true,"Skintype":true,"FavoriteComicGenre1":true,"TestDropdown":true,"Age":true,"HairCondition":true,"Trimester":true});

/**
 * messageformat.js
 *
 * ICU PluralFormat + SelectFormat for JavaScript
 *
 * @author Alex Sexton - @SlexAxton
 * @version 0.1.4
 * @license WTFPL
 * @contributor_license Dojo CLA
 */

BV.define('vendor/messageformat',['vendor/json2'], function (JSON) {
  function trim (str) {
    // no trim method on strings in IE8; we could load
    // Underscore.string, but this is all we really need.
    return String.prototype.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }


  // Create the contructor function
  function MessageFormat (locale, pluralFunc) {
    var fallbackLocale;

    if (locale && pluralFunc) {
      MessageFormat.locale[ locale ] = pluralFunc;
    }

    // Defaults
    fallbackLocale = locale = locale || "en";
    pluralFunc = pluralFunc || MessageFormat.locale[ fallbackLocale = MessageFormat.Utils.getFallbackLocale(locale) ];

    if (!pluralFunc) {
      throw new Error("Plural Function not found for locale: " + locale);
    }

    // Own Properties
    this.pluralFunc = pluralFunc;
    this.locale = locale;
    this.fallbackLocale = fallbackLocale;
  }

  // Set up the locales object. Add in english by default
  MessageFormat.locale = {
    "en" : function (n) {
      if (n === 1) {
        return "one";
      }
      return "other";
    }
  };

  // Build out our basic SafeString type
  // more or less stolen from Handlebars by @wycats
  MessageFormat.SafeString = function (string) {
    this.string = string;
  };

  MessageFormat.SafeString.prototype.toString = function () {
    return this.string.toString();
  };

  MessageFormat.Utils = {
    numSub : function (string, key, depth) {
      // make sure that it's not an escaped octothorpe
      return string.replace(/^#|[^\\]#/g, function (m) {
        var prefix = m && m.length === 2 ? m.charAt(0) : '';
        return prefix + '" + (function(){ var x = ' +
          key + ';\nif( isNaN(x) ){\nthrow new Error("MessageFormat: `"+lastkey_' + depth + '+"` isnt a number.");\n}\nreturn x;\n})() + "';
      });
    },
    escapeExpression : function (string) {
      var escape = {
          "\n" : "\\n",
          "\"" : '\\"'
        },
        badChars = /[\n"]/g,
        possible = /[\n"]/,
        escapeChar = function (chr) {
          return escape[chr] || "&amp;";
        };

      // Don't escape SafeStrings, since they're already safe
      if (string instanceof MessageFormat.SafeString) {
        return string.toString();
      }
      else if (string === null || string === false) {
        return "";
      }

      if ( !possible.test(string) ) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    },
    getFallbackLocale : function (locale) {
      var tagSeparator = locale.indexOf("-") >= 0 ? "-" : "_";

      // Lets just be friends, fallback through the language tags
      while ( !MessageFormat.locale.hasOwnProperty(locale) ) {
        locale = locale.substring( 0, locale.lastIndexOf(tagSeparator) );
        if (locale.length === 0) {
          return null;
        }
      }

      return locale;
    }
  };

    return MessageFormat;
});

/* jshint evil:true */
/* eslint-disable no-undef */
BV.define('util/pluralform',['underscore'], function (_) {
  var fs;
  var getXhr;
  var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
  var fetchText = function () {
    throw new Error('Environment unsupported.');
  };
  var buildMap = {};
  var customNameExtension = '@locale';
  var fileExtension = '.js';
  var cache = {};
  var fetchOrGetCached;

  if (typeof window !== 'undefined' && window.navigator && window.document) {
    // Browser action
    getXhr = function () {
      // Would love to dump the ActiveX crap in here. Need IE 6 to die first.
      var xhr;
      var i;
      var progId;

      if (typeof XMLHttpRequest !== 'undefined') {
        return new XMLHttpRequest();
      }
      else {
        for (i = 0; i < 3; i++) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          }
          catch (e) {}

          if (xhr) {
            progIds = [progId]; // so faster next time
            break;
          }
        }
      }

      if (!xhr) {
        throw new Error('getXhr(): XMLHttpRequest not available');
      }

      return xhr;
    };

    fetchText = function (url, callback) {
      var xhr = getXhr();
      if ( !~url.indexOf('http') ) {
        url = window.location.protocol + url;
      }
      xhr.open('GET', url, true);
      xhr.onreadystatechange = function (evt) {
        if (xhr.readyState === 4 ) {
          if ( xhr.status === 200) {
            callback(null, xhr.responseText);
          }
          else if (require.onError) {
            callback( new Error('Failure to load: ' + url) );
          }
        }
      };
      xhr.send(null);
    };
  }
  else if (typeof process !== 'undefined' && process.versions && !!process.versions.node) {
    // Using special require.nodeRequire, something added by r.js.
    fs = require.nodeRequire('fs');
    fetchText = function (path, callback) {
      var text;
      try {
        text = fs.readFileSync(path, 'utf8');
        callback(null, text);
      }
      catch (e) {
        callback(e);
      }
    };
  }

  fetchOrGetCached = function (root, locale, path, config, callback) {
    if (config.turbo) {
      BV.require(['messageLocaleMap'], function (map) {
        var language;
        var mapResult = map[root + locale];
        if (!mapResult) {
          language = locale.indexOf('-') !== -1 ? locale.split('-')[0] : 'UNKNOWN';
          mapResult = map[root + language];
        }
        callback(!mapResult, mapResult);
      });
      return;
    }

    if (cache[path]) {
      callback(null, cache[path]);
    }
    else {
      fetchText(path, function (err, data) {
        cache[path] = data;
        callback.call(this, err, data);
      });
    }
  };

  return {
    load: function (name, parentRequire, load, config) {
          },
    write: function (pluginName, moduleName, write) {
          }
  };

});

BV.define('util/pluralform!locale',['vendor/messageformat'], function (MessageFormat) {
MessageFormat.locale.en = function ( n ) {
  if ( n === 1 ) {
    return "one";
  }
  return "other";
};
   return MessageFormat;
});
/* eslint-disable */
/*global ActiveXObject:false, process:false */
BV.define('mf',[
],
function (
) {
  return {

    load: function (name, parentRequire, load, config) {
          },
    write: function (pluginName, moduleName, write) {
          }
  };
});

BV.define('mf!bv/c2013/messages/common',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"display_answertext" : function (x) { try { return (function(d){
var r = "";
r += "Answer";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_answertext`: ' + e.toString() ) ] ); return ""; } },"placeholder_answertext" : function (x) { try { return (function(d){
var r = "";
r += "Answer this question...";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_answertext`: ' + e.toString() ) ] ); return ""; } },"writeReview" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Write a review ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `writeReview`: ' + e.toString() ) ] ); return ""; } },"offscreen_writeReviewModalNotice" : function (x) { try { return (function(d){
var r = "";
r += "This action will open a modal dialog.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_writeReviewModalNotice`: ' + e.toString() ) ] ); return ""; } },"offscreen_writeReviewSiteAuthModalNotice" : function (x) { try { return (function(d){
var r = "";
r += "This action will redirect to login page";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_writeReviewSiteAuthModalNotice`: ' + e.toString() ) ] ); return ""; } },"offscreen_showMediaModalNotice" : function (x) { try { return (function(d){
var r = "";
r += "This action will open a modal dialog.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_showMediaModalNotice`: ' + e.toString() ) ] ); return ""; } },"readReviews" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Read a Review";
return r;
},
"other" : function(d){
var r = "";
r += "Read ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " Reviews";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `readReviews`: ' + e.toString() ) ] ); return ""; } },"askQuestion" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Ask a question ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `askQuestion`: ' + e.toString() ) ] ); return ""; } },"offscreen_summaryStars" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["AverageOverallRating"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["OverallRatingRange"];
r += " stars. Read reviews for";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_summaryStars`: ' + e.toString() ) ] ); return ""; } },"offscreen_summaryStarsNoValue" : function (x) { try { return (function(d){
var r = "";
r += "No rating value for";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_summaryStarsNoValue`: ' + e.toString() ) ] ); return ""; } },"offscreen_ratingSummaryText" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["AverageOverallRating"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["OverallRatingRange"];
r += " rating.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_ratingSummaryText`: ' + e.toString() ) ] ); return ""; } },"offscreen_stars_no_rating" : function (x) { try { return (function(d){
var r = "";
r += "No rating value";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_stars_no_rating`: ' + e.toString() ) ] ); return ""; } },"offscreen_ratingStars" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Rating"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingRange"];
r += " stars.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_ratingStars`: ' + e.toString() ) ] ); return ""; } },"offscreen_instructions_for_ratings" : function (x) { try { return (function(d){
var r = "";
r += "Use arrow keys to select the rating";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_instructions_for_ratings`: ' + e.toString() ) ] ); return ""; } },"offscreen_value_of_one_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of 1 means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_value_of_one_means`: ' + e.toString() ) ] ); return ""; } },"offscreen_value_max_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["sliderSize"];
r += " means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_value_max_means`: ' + e.toString() ) ] ); return ""; } },"wait_feedback" : function (x) { try { return (function(d){
var r = "";
r += "Loading";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `wait_feedback`: ' + e.toString() ) ] ); return ""; } },"autocomplete_available" : function (x) { try { return (function(d){
var r = "";
r += "Autocomplete available, press the down arrow to hear options";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `autocomplete_available`: ' + e.toString() ) ] ); return ""; } },"ProductIsRecommended" : function (x) { try { return (function(d){
var r = "";
r += "Yes";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `ProductIsRecommended`: ' + e.toString() ) ] ); return ""; } },"ProductIsNotRecommended" : function (x) { try { return (function(d){
var r = "";
r += "No";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `ProductIsNotRecommended`: ' + e.toString() ) ] ); return ""; } },"logoSource" : function (x) { try { return (function(d){
var r = "";
r += "Source:";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `logoSource`: ' + e.toString() ) ] ); return ""; } },"deeplinkModalTitle" : function (x) { try { return (function(d){
var r = "";
r += "Content Dialog";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `deeplinkModalTitle`: ' + e.toString() ) ] ); return ""; } },"close" : function (x) { try { return (function(d){
var r = "";
r += "Close";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `close`: ' + e.toString() ) ] ); return ""; } },"actionBarHeader_v2" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Type";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
r += "Reviews";
return r;
},
"question" : function(d){
var r = "";
r += "Questions";
return r;
},
"answer" : function(d){
var r = "";
r += "Answers";
return r;
},
"other" : function(d){
var r = "";
r += "Content";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `actionBarHeader_v2`: ' + e.toString() ) ] ); return ""; } },"anonymous" : function (x) { try { return (function(d){
var r = "";
r += "Anonymous";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `anonymous`: ' + e.toString() ) ] ); return ""; } },"offscreen_prsNumberOfReviews" : function (x) { try { return (function(d){
var r = "";
r += "This action will navigate to reviews.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_prsNumberOfReviews`: ' + e.toString() ) ] ); return ""; } },"appTotalContentCount" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " Review ";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " Reviews ";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `appTotalContentCount`: ' + e.toString() ) ] ); return ""; } },"stars_TotalContentCountAggregate" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span itemprop='reviewCount'>";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> Review ";
return r;
},
"other" : function(d){
var r = "";
r += "<span itemprop='reviewCount'>";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> Reviews ";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `stars_TotalContentCountAggregate`: ' + e.toString() ) ] ); return ""; } }
};
});

/**
 * @fileOverview Defines the typemap for normalizer to use.
 *
 * Basically, defines how normalizer should transform data from the api
 * into a content type agnostic, or "normalized", data format.
 *
 * This takes the form of a javascript object with the following structure:
 *
 * - The first level of properties are the different types of data handled
 *   by the map. You'll see reviewstatistics, questionstatistics, and so on.
 *
 * - The second layer of properties, within the data types, are the action
 *   definitions. Here, we have each of the actions we want to run on the
 *   data type, such as add, sum, round, merge, etc. A full list of the
 *   available actions can be found in static/dev/scripts/bv/api/normalize.js,
 *   along with documentation for each one.
 *
 * - Each action is mapped to a list of objects that define the input for
 *   the action. The action will be run once for each object in the list,
 *   with the argument object passed as the first argument and the data type,
 *   or item, as the second argument.
 *
 * Normalizer will take this map and use it to create its output.
 * The input data will be mapped to a new object and returned by #normalize.
 *
 * The actions are all executed in the order defined.
 *
 * The original input object will not be modified, so you can't rely on
 * previous actions to have been completed.
 *
 * For example, if you copied A into B, then later try to do something with
 * B, remember that you're working with the original B, not the value that was
 * copied from A.
 *
 * TODO I'd love to get this better organized and to make it more readable.
 * My main thought about how to do this is to take out each section from
 * typeMap and create a separate object. So, reviewstatics would be its own
 * object, so would questionstatistics, answerstatistics, and so on.
 * Then typeMap could just be a collection of these things.
 *
 * So something like:
 *
 * var reviewstatistics = { ... };
 * var questionstatistics = { ... };
 * ...
 *
 * var typeMap = {
 *   reviewstatistics : reviewstatistics,
 *   questionstatistics : questionstatistics,
 *   ...
 * };
 *
 * These could even be pulled out into separate files, thought I'm not 100% if
 * that's a good way to go about it. For now, we'll just have to rely on text
 * editors that can fold objects.
 */
BV.define('bv/api/normalizer/typeMap',[
  'mf!bv/c2013/messages/common'
], function (
  commonMessages
) {

  // Helper function that returns true if an item has been approved
  // by moderation and/or the client.
  function approvedByModeration (item) {
    return item.ModerationStatus === 'APPROVED';
  }

  // Helper function to return the inverse of approvedByModeration.
  function notApprovedByModeration (item) {
    return !approvedByModeration(item);
  }

  var typeMap = {
    reviewstatistics: {
      add: [
        {
          key: 'Type',
          val: 'reviewstatistics'
        }
      ],
      change: [
        {
          from: 'FeaturedReviewCount',
          to: 'FeaturedCount'
        }, {
          from: 'TotalReviewCount',
          to: 'TotalCount'
        }, {
          from: 'RatingsOnlyReviewCount',
          to: 'RatingsOnlyCount'
        }
      ],
      sum: [
        {
          add1: 'NotRecommendedCount',
          add2: 'RecommendedCount',
          sum: 'TotalRecommendedCount'
        }, {
          add1: 'HelpfulVoteCount',
          add2: 'NotHelpfulVoteCount',
          sum: 'TotalHelpfulVoteCount'
        }
      ],
      ensure: [
        {
          firstKey: 'RatingDistribution',
          secondKey: 'RatingValue',
          defaultTo: [
            {
              Count: 0,
              RatingValue: 1
            }, {
              Count: 0,
              RatingValue: 2
            }, {
              Count: 0,
              RatingValue: 3
            }, {
              Count: 0,
              RatingValue: 4
            }, {
              Count: 0,
              RatingValue: 5
            }
          ]
        }
      ],
      round: [
        {
          key: 'AverageOverallRating'
        }, {
          root: 'SecondaryRatingsAverages',
          key: 'AverageRating'
        }
      ]
    },
    questionstatistics: {
      add: [
        {
          key: 'Type',
          val: 'questionstatistics'
        }
      ],
      change: [
        {
          from: 'HelpfulVoteCount',
          to: 'DELETEME'
        }, {
          from: 'FeaturedQuestionCount',
          to: 'FeaturedCount'
        }, {
          from: 'TotalQuestionCount',
          to: 'TotalCount'
        }, {
          from: 'FirstQuestionTime',
          to: 'FirstSubmissionTime'
        }, {
          from: 'LastQuestionTime',
          to: 'LastSubmissionTime'
        }, {
          from: 'QuestionHelpfulVoteCount',
          to: 'HelpfulVoteCount'
        }, {
          from: 'QuestionNotHelpfulVoteCount',
          to: 'NotHelpfulVoteCount'
        }, {
          from: 'TotalAnswerCount',
          to: 'TotalSecondaryCount'
        }
      ],
      remove: [
        'DELETEME',
        'FirstAnswerTime',
        'LastAnswerTime'
      ]
    },
    answerstatistics: {
      add: [
        {
          key: 'Type',
          val: 'answerstatistics'
        }
      ],
      change: [
        {
          from: 'HelpfulVoteCount',
          to: 'DELETEME'
        }, {
          from: 'FeaturedAnswerCount',
          to: 'FeaturedCount'
        }, {
          from: 'TotalAnswerCount',
          to: 'TotalCount'
        }, {
          from: 'FirstAnswerTime',
          to: 'FirstSubmissionTime'
        }, {
          from: 'LastAnswerTime',
          to: 'LastSubmissionTime'
        }, {
          from: 'AnswerHelpfulVoteCount',
          to: 'HelpfulVoteCount'
        }, {
          from: 'AnswerNotHelpfulVoteCount',
          to: 'NotHelpfulVoteCount'
        }, {
          from: 'BestAnswerCount',
          to: 'BestCount'
        }
      ],
      remove: [
        'DELETEME',
        'FirstQuestionTime',
        'LastQuestionTime',
        'QuestionHelpfulVoteCount',
        'QuestionNotHelpfulVoteCount',
        'FeaturedQuestionCount',
        'TotalQuestionCount',
        'LastQuestionAnswerTime'
      ]
    },
    statistics: {
      add: [
        {
          key: 'Type',
          val: 'statistics'
        }
      ],
      copy: [
        {
          from: 'ProductStatistics.ReviewStatistics',
          to: 'Product.Reviews.Statistics'
        }, {
          from: 'ProductStatistics.FilteredReviewStatistics',
          to: 'Product.Reviews.Statistics'
        }, {
          from: 'ProductStatistics.ReviewStatistics.TotalReviewCount',
          to: 'Product.Reviews.Statistics.TotalCount'
        }, {
          from: 'ProductStatistics.FilteredReviewStatistics.TotalReviewCount',
          to: 'Product.Reviews.Statistics.TotalCount'
        }, {
          from: 'ProductStatistics.NativeReviewStatistics',
          to: 'Product.Reviews.NativeStatistics'
        }, {
          from: 'ProductStatistics.NativeReviewStatistics.TotalReviewCount',
          to: 'Product.Reviews.NativeStatistics.TotalCount'
        }, {
          from: 'ProductStatistics.ProductId',
          to: 'Product.Id'
        }
      ],
      remove: [
        'ProductStatistics',
        'ProductStatistics.ReviewStatistics',
        'ProductStatistics.FilteredReviewStatistics',
        'ProductStatistics.NativeReviewStatistics',
        'Product.Reviews.Statistics.TotalReviewCount',
        'Product.Reviews.NativeStatistics.TotalReviewCount'
      ],
      round: [
        {
          key: 'Product.Reviews.Statistics.AverageOverallRating'
        }, {
          key: 'Product.Reviews.NativeStatistics.AverageOverallRating'
        }
      ]
    },
    products: {
      add: [
        {
          key: 'Type',
          val: 'product'
        }
      ],
      change: [
        {
          from: 'ProductPageUrl',
          to: 'Url'
        }
      ],
      copy: [
        {
          from: 'ReviewStatistics',
          to: 'Content.Reviews.Statistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'ReviewStatistics',
          to: 'Content.Reviews.RawStatistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'FilteredReviewStatistics',
          to: 'Content.Reviews.Statistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'FilteredReviewStatistics',
          to: 'Content.Reviews.FilteredStatistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Questions.Statistics',
          mapTo: 'QuestionStatistics'
        }, {
          from: 'FilteredQAStatistics',
          to: 'Content.Questions.Statistics',
          mapTo: 'QuestionStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Answers.Statistics',
          mapTo: 'AnswerStatistics'
        }, {
          from: 'FilteredQAStatistics',
          to: 'Content.Answers.Statistics',
          mapTo: 'AnswerStatistics'
        }, {
          from: 'Content.Questions.Statistics.TotalQuestionCount',
          to: 'TotalQuestionCount'
        }, {
          from: 'Content.Questions.Statistics.TotalAnswerCount',
          to: 'TotalAnswerCount'
        }, {
          from: 'Content.Reviews.Statistics.TotalReviewCount',
          to: 'TotalReviewCount'
        }
      ],
      remove: [
        'ReviewIds',
        'StoryIds',
        'QuestionIds',
        'AnswerIds',
        'QAStatistics',
        'FilteredQAStatistics',
        'ReviewStatistics',
        'FilteredReviewStatistics'
      ]
    },
    authors: {
      add: [
        {
          key: 'Type',
          val: 'author'
        }
      ],
      change: [
        {
          from: 'ProductPageUrl',
          to: 'Url'
        }
      ],
      merge: [
        // Do not override DisplayName if UserNickname is not set
        {
          first: 'UserNickname',
          second: 'DisplayName',
          into: 'DisplayName'
        }
      ],
      // Anonymize DisplayName if they have not been approved by moderation.
      replace: [
        {
          key: 'DisplayName',
          val: commonMessages.anonymous(),
          condition: notApprovedByModeration
        }
      ],
      copy: [
        {
          from: 'ReviewStatistics',
          to: 'Content.Reviews.Statistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Questions.Statistics',
          mapTo: 'QuestionStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Answers.Statistics',
          mapTo: 'AnswerStatistics'
        }, {
          from: 'Content.Questions.Statistics.TotalQuestionCount',
          to: 'TotalQuestionCount'
        }, {
          from: 'Content.Questions.Statistics.TotalAnswerCount',
          to: 'TotalAnswerCount'
        }, {
          from: 'Content.Reviews.Statistics.TotalReviewCount',
          to: 'TotalReviewCount'
        }
      ],
      remove: [
        'ReviewIds',
        'StoryIds',
        'QuestionIds',
        'AnswerIds',
        'QAStatistics',
        'FilteredQAStatistics',
        'ReviewStatistics',
        'UserNickname', // We don't need this because we have merged it in
        'FilteredReviewStatistics'
      ]
    },
    categories: {
      add: [
        {
          key: 'Type',
          val: 'category'
        }
      ],
      change: [
        {
          from: 'CategoryPageUrl',
          to: 'Url'
        }
      ],
      copy: [
        {
          from: 'ReviewStatistics',
          to: 'Content.Reviews.Statistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'ReviewStatistics',
          to: 'Content.Reviews.RawStatistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'FilteredReviewStatistics',
          to: 'Content.Reviews.Statistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'FilteredReviewStatistics',
          to: 'Content.Reviews.FilteredStatistics',
          mapTo: 'ReviewStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Questions.Statistics',
          mapTo: 'QuestionStatistics'
        }, {
          from: 'FilteredQAStatistics',
          to: 'Content.Questions.Statistics',
          mapTo: 'QuestionStatistics'
        }, {
          from: 'QAStatistics',
          to: 'Content.Answers.Statistics',
          mapTo: 'AnswerStatistics'
        }, {
          from: 'FilteredQAStatistics',
          to: 'Content.Answers.Statistics',
          mapTo: 'AnswerStatistics'
        }, {
          from: 'Content.Questions.Statistics.TotalQuestionCount',
          to: 'TotalQuestionCount'
        }, {
          from: 'Content.Questions.Statistics.TotalAnswerCount',
          to: 'TotalAnswerCount'
        }, {
          from: 'Content.Reviews.Statistics.TotalReviewCount',
          to: 'TotalReviewCount'
        }
      ],
      remove: [
        'ReviewIds',
        'StoryIds',
        'QuestionIds',
        'AnswerIds',
        'QAStatistics',
        'FilteredQAStatistics',
        'ReviewStatistics',
        'FilteredReviewStatistics'
      ]
    },
    reviews: {
      add: [
        {
          key: 'Type',
          val: 'review'
        }, {
          key: 'SecondaryType',
          val: 'comment'
        }
      ],
      change: [
        {
          from: 'ReviewText',
          to: 'Text'
        }, {
          from: 'ProductId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'Product',
          to: 'Reference'
        }, {
          from: 'TotalCommentCount',
          to: 'TotalSecondaryContentCount'
        }
      ],
      copy: [],
      remove: [
        'Pros',
        'Cons'
      ]
    },
    questions: {
      add: [
        {
          key: 'Type',
          val: 'question'
        }, {
          key: 'SecondaryType',
          val: 'answer'
        }
      ],
      change: [
        {
          from: 'CategoryId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'Category',
          to: 'Reference'
        }, {
          from: 'ProductId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'Product',
          to: 'Reference'
        }, {
          from: 'QuestionSummary',
          to: 'Title'
        }, {
          from: 'TotalAnswerCount',
          to: 'TotalSecondaryContentCount'
        }
      ]
    },
    answers: {
      add: [
        {
          key: 'Type',
          val: 'answer'
        }
      ],
      change: [
        {
          from: 'QuestionId',
          to: 'ReferenceId'
        }, {
          from: 'Question',
          to: 'Reference'
        }, {
          from: 'AnswerText',
          to: 'Text'
        }
      ]
    },
    stories: {
      add: [
        {
          key: 'Type',
          val: 'story'
        }
      ],
      change: [
        {
          from: 'CategoryId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'ProductId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'StoryText',
          to: 'Text'
        }
      ]
    },
    comments: {
      add: [
        {
          key: 'Type',
          val: 'comment'
        }
      ],
      change: [
        {
          from: 'ReviewId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'StoryId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'CommentText',
          to: 'Text'
        }
      ]
    },
    reviewcomments: {
      add: [
        {
          key: 'Type',
          val: 'comment'
        }
      ],
      change: [
        {
          from: 'ReviewId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'StoryId',
          to: 'ReferenceId',
          ifValueExists: true
        }, {
          from: 'CommentText',
          to: 'Text'
        }
      ]
    },
    clientresponses: {
      add: [
        {
          key: 'Type',
          val: 'clientresponse'
        },

        // Client reponses are assumed to be moderated. We need to update our
        // data to say so.
        {
          key: 'ModerationStatus',
          val: 'APPROVED'
        }
      ],
      copy: [
        // Overwrite the Author name (which may have been anonymized) with the
        // name directly attached to our client data.
        {
          from: 'Name',
          to: 'Author.DisplayName'
        }, {
          from: 'Department',
          to: 'Author.Department'
        }, {
          from: 'ModerationStatus',
          to: 'Author.ModerationStatus'
        }, {
          from: 'Response',
          to: 'Text'
        }, {
          from: 'Date',
          to: 'SubmissionTime'
        }
      ]
    }
  };

  return typeMap;
});

/**
 * @fileOverview Defines the actions normalizer can take on the data given.
 */
BV.define('bv/api/normalizer/actions',[
  'underscore',
  'framework/util/bvreporter'
], function (
  _,
  BVReporter
) {

  /**
   * TODO figure out what this does and document it
   *
   * @param  {[type]} root   [description]
   * @param  {[type]} path   [description]
   * @param  {[type]} create [description]
   * @return {[type]}        [description]
   */
  function targetNodeParent (root, path, create) {
    var nodes = path.split('.');
    var target = root;
    nodes.pop();
    _(nodes).forEach(function (node) {
      if (create) {
        target = target[node] = target[node] || {};
      }
      else {
        target = target[node] || {};
      }
    });
    return target;
  }

  return {
    /**
     * Renames a key.
     * The value of the 'from' key will be copied into the 'to' key, then
     * the 'from' key will be deleted.
     *
     * Example :
     * {
     *   from : 'required',
     *   to : 'required',
     *   ifValueExists : 'optional'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    change: function (map, item) {
      var itemNode = targetNodeParent(item, map.from, true);
      var mapFrom = map.from.split('.').pop();

      if ((mapFrom in itemNode) && itemNode.hasOwnProperty(mapFrom)) {
        if (map.ifValueExists && !itemNode[mapFrom]) {
          return;
        }
        targetNodeParent(item, map.to, true)[map.to.split('.').pop()] = itemNode[mapFrom];
        delete itemNode[mapFrom];
      }
    },

    /**
     * Adds a new key with the specified value.
     *
     * Example:
     * {
     *   key : 'required',
     *   val : 'required'
     * }
     *
     * @param {[type]} map  [description]
     * @param {[type]} item [description]
     */
    add: function (map, item) {
      item[map.key] = map.val;
    },

    /**
     * Will add two numeric specified using the 'add1' and 'add2' keys,
     * then store the result in the 'sum' key.
     *
     * Example:
     * {
     *   add1 : 'required',
     *   add2 : 'required',
     *   sum : 'required'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    sum: function (map, item) {
      item[map.sum] = item[map.add1] + item[map.add2];
    },

    /**
     * Copies the value of the 'from' key to the 'to' key.
     * This will do a deep copy of objects.
     *
     * Example:
     * {
     *   from : 'required',
     *   to : 'required'
     * }
     *
     * @param  {[type]} map      [description]
     * @param  {[type]} item     [description]
     * @param  {[type]} todoList [description]
     */
    copy: function (map, item, todoList) {
      var itemNode = targetNodeParent(item, map.from, false);
      var mapFrom = map.from.split('.').pop();

      if (mapFrom in itemNode) {
        var value = _(itemNode[mapFrom]).clone();
        targetNodeParent(item, map.to, true)[map.to.split('.').pop()] = value;
        var mapTo = map.mapTo || map.to;
        todoList.push(value, mapTo);
      }
    },

    /**
     * Copies the value of the 'from' key to the 'to' key.
     * This will do a shallow copy of objects.
     *
     * Example:
     * {
     *  from : 'required',
     *  to : 'required'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    clone: function (map, item) {
      if (map.from in item) {
        item[map.to] = item[map.from];
      }
    },

    /**
     * TODO figure out what this does and document it
     *
     * Example:
     * {
     *   firstKey : 'required',
     *   defaultTo : 'required'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    ensure: function (map, item) {
      var targetPath = map.firstKey.split('.');
      var targetItem = item;
      var intoKey;
      // This one must create non-existing paths
      _(targetPath).forEach(function (key, i) {
        if (i < targetPath.length - 1) {
          if (targetItem[key]) {
            targetItem = targetItem[key];
          }
          else {
            targetItem[key] = {};
            targetItem = targetItem[key];
          }
        }
        else {
          intoKey = key;
        }
      });
      if (!map.secondKey) {
        if (!targetItem[intoKey]) {
          targetItem[intoKey] = map.defaultTo;
        }
      }
      else {
        var matchKey = map.secondKey;
        var current = targetItem[intoKey];
        var exists = _(current).pluck(matchKey);
        var toAdd = _(map.defaultTo).filter(function (obj) {
          return !_(exists).include(obj[matchKey]);
        });

        var result = _.union(toAdd, current);
        targetItem[intoKey] = _(result).sortBy(function (obj) { return obj[matchKey]; });
      }
    },

    /**
     * This will copy one of two values into a specified key.
     * First, this function attempts to copy the value of 'first' into the
     * 'into' key. If 'first' does not exist, then this method attempts to
     * copy the value of 'second' into the 'into' key.
     *
     * Example:
     * {
     *   into : 'required',
     *   first : 'required',
     *   second : 'optional'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    merge: function (map, item) {
      var intoParts = map.into.split('.');
      var firstParts = map.first.split('.');
      var secondParts = map.second.split('.');

      var intoItem = item;
      var intoKey;
      var firstItem = item;
      var secondItem = item;

      // This one must create non-existing paths
      _(intoParts).forEach(function (key, i) {
        if (i < intoParts.length - 1) {
          if (intoItem[key]) {
            intoItem = intoItem[key];
          }
          else {
            intoItem[key] = {};
            intoItem = intoItem[key];
          }
        }
        else {
          intoKey = key;
        }
      });

      _(firstParts).forEach(function (key) {
        if (firstItem) {
          firstItem = firstItem[key];
        }
      });

      if (firstItem) {
        intoItem[intoKey] = firstItem;
      }
      else {
        _(secondParts).forEach(function (key) {
          if (secondItem) {
            secondItem = secondItem[key];
          }
        });

        if (secondItem) {
          intoItem[intoKey] = secondItem;
        }
      }
    },

    /**
     * Removes each key in the list from the item.
     *
     * Example:
     * [
     *   'something1',
     *   'something2'
     * ]
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    remove: function (map, item) {
      delete item[map];
    },

    /**
     * Conditionally replaces a value with a given string.
     * Will also add a value if it does not already exist on item.
     *
     * Format:
     * {
     *   key : 'required',
     *   val : 'required',
     *   condition : 'optional'
     * }
     *
     * @param {Object} map An object with the properties key, val,
     *                      and condition (optional).
     *
     * @param {String} map.key The name of the key to replace.
     *
     * @param {String} map.val The value to assign to the key.
     *
     * @param {Function} map.condition (optional) A function that returns true or false.
     *  It will be passed item as an argument.
     *  If it returns false, the value will not be replaced.
     *  If it returns true, the value will be replaced.
     *
     * @param {Object} item The object to be modified.
     */
    replace: function (map, item) {
      BVReporter.assert(_(map).isObject(), 'replace requires the first argument to be an object.');
      BVReporter.assert(_(map.key).isString(), 'replaces requires a key string.');
      BVReporter.assert(_(map.val).isString() || _(map.val).isNumber(), 'replaces requires a val string or number.');
      BVReporter.assert(_(item).isObject(), 'replaces requires the second argument to be an object.');

      // If we were given a condition function and it returns false, bail.
      if (_(map.condition).isFunction() && !map.condition(item)) {
        return;
      }

      // Otherwise, go ahead and replace the value.
      item[map.key] = map.val;
    },

    /**
     * Rounds the numberic value in 'key' to the specified number of
     * decimal places.
     *
     * The number of decimal places is optional and defaults to 1.
     *
     * Example:
     * {
     *   key : 'required',
     *   root : 'optional',
     *   decimalPlaces : 'optional'
     * }
     *
     * @param  {[type]} map  [description]
     * @param  {[type]} item [description]
     */
    round: function (map, item) {
      function roundValue (innerKey, innerItem, decimalPlaces) {
        var decimal = 10 * decimalPlaces;
        if (innerItem[innerKey]) {
          innerItem[innerKey] = Math.round(innerItem[innerKey] * decimal) / decimal;
        }
      }

      var decimalPlaces = map.decimalPlaces || 1;
      var root = item;
      var from = map.key.split('.').pop();

      if (!map.root) {
        var itemNode = targetNodeParent(item, map.key, false);
        roundValue(from, itemNode, decimalPlaces);
        return;
      }

      root = targetNodeParent(item, map.root, false)[map.root];
      _(root).forEach(function (nodeItem) {
        roundValue(from, nodeItem, decimalPlaces);
      });
    }
  };
});

/**
 * @fileOverview Normalizes a raw API response into a format where the
 *   consumer doesn't have to be aware of the content type.
 */
BV.define('bv/api/normalizer',[
  'underscore',
  'bv/api',
  'dimsumFields!displayedFieldKeys',
  'bv/api/normalizer/typeMap',
  'bv/api/normalizer/actions'
], function (_, api, displayedFieldKeys, typeMap, actions) {

  var includables = [
    ['Author', 'Authors'],
    ['Comment', 'Comments'],
    ['Product', 'Products'],
    ['Category', 'Categories'],
    ['Review', 'Reviews'],
    ['Question', 'Questions'],
    ['Answer', 'Answers'],
    ['Story', 'Stories'],
    ['ClientResponse', 'ClientResponses']
  ];

  var orderables = [
    'SecondaryRatings',
    'ContextDataValues',
    'TagDimensions',
    'Badges'
  ];

  var synonyms = {
    product: 'products',
    category: 'categories',
    author: 'authors',
    filteredreviewstatistics: 'reviewstatistics',
    filteredqastatistics: 'questionstatistics'
  };


  function inlineIds (type, list, included) {
    _(list).forEach(function (item) {
      // Handle blanks once
      if (! item || ! included) {
        return list;
      }

      item.Content = item.Content || {};

      // Grab a product id
      if (item[type + 'Id']) {
        // Add that product to the item
        item[type] = included[item[type + 'Id']];
      }
      // Grab answer ids
      else if (item[type + 'Ids']) {
        var includes = {
          List: [],
          Statistics: {
            TotalCount: 0,
            TotalSecondaryCount: 0
          }
        };
        _.forEach(item[type + 'Ids'], function (item) {
          includes.List.push(included[item]);
        });
        includes.Statistics.TotalCount = item['Total' + api.Noun(type) + 'Count'];
        item[api.Nouns(type)] = includes;
        item.Content[api.Nouns(type)] = includes;
      }
    });
    // Return the list with the products now inlined.
    return list;
  }

  function inlineOrdered (list) {
    // Go through each result item
    _(list).forEach(function (base) {
      // Go through each orderable type
      _(orderables).forEach(function (name) {
        var baseOrder;
        var baseOrdered;

        // If it exists on the current item
        if (base && base[name + 'Order'] && base[name + 'Order'].length) {
          baseOrder = base[name + 'Order'];
          base[name + 'Ordered'] = baseOrdered = [];

          // For CDVs, filter out anything that isn't a known field
          // (basically anything that has been set to Hide in Display)
          if (name === 'ContextDataValues') {
            baseOrder = _(baseOrder).filter(function (item) {
              return item in displayedFieldKeys;
            });

            base[name + 'Order'] = baseOrder;
          }

          _(baseOrder).forEach(function (key) {
            // TODO : : make sure the Id is included so we don't lose it, currently
            // it usually is though.
            baseOrdered.push(base[name][key]);
          });
        }
      });
    });
    return list;
  }

  function clearEmpty (list) {
    // Go through every base property replace empty array/object values with nulls
    // TODO : : maybe just override the handlebars 'if' helper so it denies an
    // empty object.
    _(list).forEach(function (data, key) {
      if (_.isObject(data) && _.isEmpty(data)) {
        list[key] = null;
        return;
      }

      // Go two deep if it's an object
      // TODO : : figure out a way to go deeper (unlikely), without hitting an infinite
      // loop with circular refs.
      if (_.isObject(data)) {
        _(data).forEach(function (d2, k2) {
          if (_.isObject(d2) && _.isEmpty(d2)) {
            data[k2] = null;
          }
        });
      }
    });

    return list;
  }

  // TODO : figure out why it's not removing CategoryId (if that's important)
  function modDeep (list, type) {
    var todoList;

    // Bail if we don't know the type
    if (!type || !list) {
      return list;
    }

    // Convert to lowercase for ease
    type = type.toLowerCase();

    // Bail if we haven't defined any keys for this
    if (! typeMap[type]) {
      return list;
    }

    if (_.isArray(list)) {
      _(list).each(function (item) {
        if (item) {
          modDeep(item, type);
          if (item.Content) {
            _(item.Content).forEach(function (content, contentType) {
              contentType = contentType.toLowerCase();
              if (typeMap[contentType]) {
                content.List = content.List || [];
                content.Type = api.noun(contentType);
                modDeep(content.List, contentType);
              }
            });
          }
        }
      });
    }
    else {    // it's a non-array object
      // make a copy to maintain original key names
      // for content type in sub-entity normalization
      todoList = newTodoList(list);

      // normalize each key name and value in the input
      _(actions).each(function (fn, name) {
        _(typeMap[type][name]).forEach(function (map) {
          if (list.List) {
            _(list.List).forEach(function (listItem) {
              fn(map, listItem, todoList);
            });
          }
          else {
            fn(map, list, todoList);
          }
        });
      });

      // normalize each non-array object sub-entity
      todoList.each(function (entity, contentType) {
        modDeep(entity, contentType);
      });
    }

    return list;
  }

  function newTodoList (object) {
    var todoData = [],
      todoList;

    function getContentType (keyName) {
      var contentType = keyName.toLowerCase();
      contentType = synonyms[contentType] || contentType;
      return contentType;
    }

    todoList = {
      push: function (value, key) {
        if (!value || (typeof value !== 'object')) {
          return this;
        }
        var contentType = getContentType(key);
        if (!typeMap[contentType]) {
          return this;
        }
        todoData.push(
          {
            contentType: contentType,
            entity: value
          }
        );
        return this;
      },
      each: function (fn) {
        _(todoData).each(function (todoItem) {
          fn(todoItem.entity, todoItem.contentType);
        });
        return this;
      }
    };

    // push all
    _(object).each(function (value, key) {
      todoList.push(value, key);
    });
    return todoList;
  }

  function _lowerCaseIdsList (idList) {
    if (!idList || idList.length === 0) {
      return idList;
    }
    return _(idList).map(function (value) {
      if (_(value).isObject()) {
        value.Id.toLowerCase();
        return value;
      }
      return value.toLowerCase();
    });
  }

  function _lowerCaseIdAndIds (object) {
    _(object).forEach(function (value, key) {
      if (_(key).isString()) {
        if (key.search(/Id$/) > -1) {
          object[key] = _(object[key]).isString() ? object[key].toLowerCase() : object[key];
        }
        if (key.search(/Ids$/) > -1) {
          object[key] = _lowerCaseIdsList(object[key]);
        }
      }
    });
  }

  function lowerCaseIds (raw) {
    if (raw.Includes) {
      _(raw.Includes).forEach(function (contentType, contentTypeKey) {
        if (_(contentTypeKey).isString()) {
          // If this is an order array, lowercase all the IDs in it
          if (contentTypeKey.search(/Order$/) > -1) {
            raw.Includes[contentTypeKey] = _lowerCaseIdsList(contentType);
          }
          // If not, lowercase all the keys and find IDs to lowercase
          else {
            _(contentType).forEach(function (content, contentKey) {
              delete contentType[contentKey];
              contentType[contentKey.toLowerCase()] = content;
              _lowerCaseIdAndIds(content);
            });
          }
        }
      });
    }
    _(raw.Results).forEach(function (result) {
      _lowerCaseIdAndIds(result);
    });
  }

  return {

    /**
     * #normalize
     *
     * transforms entity type specific input JSON, as from the BV API, into JSON
     * that can be accessed generically instead of using keys specific to content type.
     * also performs inlining operations to make each data component more available
     * from all parts of the objects. in addition, removes all empty arrays and objects
     * from output, replacing with nulls.
     *
     * Performs inlining (on the results and the includes) :
     * - inserts entity from the includes section where an id exists
     * - changes all values that are empty objects or arrays to the value null
     * - inserts an ordered array for entities that have an order specification (such as 'SecondaryRatings', 'ContextDataValues', 'TagDimensions', 'Badges')
     *
     * Performs normalization of keys :
     * - changes entity-specific keys into generic keys that can be used in duck typing
     * - inserts ContentType attribute for each entity (review, question, answer, category, product, etc.)
     * - removes some deprecated keys
     *
     * legal options :
     * - contentType : (string) the expected content type of inRaw argument. used for transformation.
     * - disableUniversal : (boolean) if truthy, only inlining and empty removal performed, no content transforms.
     */
    normalize: function (inRaw, options, api) {
      if (! inRaw) {
        // TODO : : probably throw error in this case.
        return [];
      }

      // Options merge
      options = _.extend({}, options);

      // Don't modify the original, just in case
      // someone is relying on it.
      var raw = _.clone(inRaw),
        results = raw.Results;

      // If this is a submission, schema, just return the raw data
      // TODO - normalize submission
      if (raw.Form) {
        return raw;
      }

      // UIA - 2522 : Do not canonicalize External Ids. (product Ids)
      // Lowercase all the subject IDs
      // lowerCaseIds(raw);

      // Then inline the correct data :
      // Includes inlining
      if (raw.Includes) {
        var subjectType = api.Nouns(options.contentType);
        raw.Includes[subjectType] = raw.Includes[subjectType] || {};
        _(raw.Results).forEach(function (result) {
          raw.Includes[subjectType][result.Id] = result;
        });
        // Inline each 'Includable' type
        _(includables).forEach(function (typePair) {
          // Grab each of these out of the includes and add in their sub includes
          // Only need to do one level of these
          _(includables).forEach(function (innerTypePair) {
            if (raw.Includes[typePair[1]]) {
              // Do all the main  normalizations on the includes first
              raw.Includes[typePair[1]] = inlineIds(innerTypePair[0], raw.Includes[typePair[1]], raw.Includes[innerTypePair[1]]);
              raw.Includes[typePair[1]] = clearEmpty(raw.Includes[typePair[1]]);
              raw.Includes[typePair[1]] = inlineOrdered(raw.Includes[typePair[1]]);
            }
          });

          // Grab these out of includes and put them into the results
          results = inlineIds(typePair[0], results, raw.Includes[typePair[1]]);
        });
      }

      results = inlineOrdered(results);
      // Clear out empty keys for ease of templating
      results = clearEmpty(results);

      // Do the Universal Content Type stuff :
      if (! options.disableUniversal) {
        results = modDeep(results, (options.contentType || '').toLowerCase());
      }

      // This is ensuring we get a 'product' back when we make a products.json request
      // even if the API returns nothing. This is a bit hacky and I'm not sure what to do
      // if multiple IDs are specified. We don't care about that case for now though.
      // TODO - make this better. =)
      if (options.contentType === 'products' && results.length === 0) {
        results = [{
          Type: 'product',
          Content: {}
        }];
        _(options.api._data.subcontents).forEach(function (subcontent) {
          results[0].Content[subcontent] = {
            List: [],
            Type: api.noun(subcontent),
            Statistics: {
              TotalCount: 0,
              TotalSecondaryCount: 0
            }
          };
        });
      }

      return {
        // Send back the Includes too. We need this to make the reviews.json call for
        // pagination to work right in all cases. Can't rely on the Reference of the first
        // review to be product we made a request for (product families, etc.).
        // Maybe we can rip this out after batching is in?
        Includes: raw.Includes,
        Results: results,
        TotalResults: inRaw.TotalResults
      };
    }

    // We can't let the pragma cause an extra comma, so we'll have to sneak it
    // down here and tell jshint to ignore this part.
    /* jshint ignore:start */
        ,
    getInternalsForTestingUseOnly: function () {
      return {
        typeMap: typeMap,
        synonyms: synonyms,
        actions: actions
      };
    }
        /* jshint ignore:end */
  };
});

BV.define('util/array',['underscore'], function (_) {

  /**
   * Chunk a given array into multiple arrays based on the given chunk size.
   *
   * @param {Array} array - the array needs to be chunked.
   * @param {Int} chunkSize - chunk size.
   *
   * @returns {Array}
   */
  function chunk (array, chunkSize) {
    if (!_(array).isArray() || array.length === 0 || chunkSize <= 0) {
      return [];
    }
    var resultArray = [];
    var chunkCount = Math.floor( (array.length - 1) / chunkSize ) + 1;
    var tempArray;
    for (var i = 0; i < chunkCount; i++) {
      tempArray = _( _(array).rest(i * chunkSize) ).first(chunkSize);
      resultArray.push(tempArray);
    }
    return resultArray;
  }

  /**
   * Chunk a given array into multiple arrays based on
   *  - the given chunk size.
   *  - the size limit.
   *
   * @param {Array} array - the array needs to be chunked.
   * @param {Int} chunkSize - chunk size.
   * @param {Function} fn - the function to calculate the size of the array element.
   *                        If undefined, use array[i].toString().length as default.
   * @param {Int} limitSize - size limit.
   *
   * @returns {Array}
   */
  function chunkWithLimit (array, chunkSize, fn, limitSize) {
    var resultArray = [];
    var chunkArray = chunk(array, chunkSize);

    if (!limitSize) {
      return chunkArray;
    }

    _(chunkArray).forEach(function (subArray, index) {
      var length = 0;
      var tempArray = [];
      var extraArray = [];
      _(subArray).forEach(function (query, index) {
        fn = fn || function (array) { return array.toString().length; };
        length = length + fn(query);

        if (length < limitSize) {
          tempArray.push(query);
        }
        else {
          extraArray.push(query);
        }
      });
      resultArray.push(tempArray);

      if (extraArray.length > 0) {
        var extraResult = chunkWithLimit(extraArray, chunkSize, fn, limitSize);
        resultArray = Array.prototype.concat.call(resultArray, extraResult);
      }

    });

    return resultArray;
  }

  return {
    chunk : chunk,
    chunkWithLimit : chunkWithLimit
  };

});
/**
 * @fileOverview A module for managing the prefetch functionality. Handles
 * the response from the prefetch URL, if it exists; also queues API requests
 * to be batched while in the "prefetch" phase.
 */
BV.define('bv/prefetch',[
  'ENV',
  'underscore',
  'jquery',
  'util/url',
  'require',
  'util/array',
  'bv/strings',
  'framework/util/ie',
  'framework/util/bvtracker'
],
function (ENV, _, $, url, require, array, str, IE, BVTracker) {
  IE = IE();

  // On the first UI call, if we have a product ID, handle the prefetched data, if it exists
  ENV.on('firstUI', function (clientAPIConfig) {
    var pid = clientAPIConfig.productId;

    if (!pid) {
      return;
    }

    function subQueryKey (subQuery) {
      return url.protocol + subQuery.replace(/___PRODUCTIDTOKEN___/g, pid).toLowerCase();
    }

    var prefetchConfigs = BV.options.prefetchConfigs || [];
    var dfds = _(prefetchConfigs).some(function (c) { return !!c.promise; });

    if (!dfds) {
      return;
    }

    _(prefetchConfigs).each(function (prefetchConfig) {
      if (!prefetchConfig.promise) {
        return;
      }

      var subQueries = prefetchConfig.subQueries;

      _(subQueries).each(function (subQuery) {
        var key = subQueryKey(subQuery);
        BV._internal.apiCache[key] = $.Deferred();
      });

      prefetchConfig.promise.done(function (data) {
        if (data && data.BatchedResults) {
          _(subQueries).each(function (subQuery, index) {
            var key = subQueryKey(subQuery);
            BV._internal.apiCache[key].resolve(data.BatchedResults['q' + index]);
          });
        }
      });
    });
  });

  return {
    _isPrefetch: false,
    _batchLimit: 10,
    subQueries: {},
    subQueryDfds: {},

    setAPI: function (api) {
      this._api = api;
    },

    startPrefetch: function (cacheIndex) {
      // while this is active all fetches will be routed to prefetch
      this._isPrefetch = true;
      this.cacheIndex = cacheIndex;
      this.subQueries[cacheIndex] = [];
      this.subQueryDfds[cacheIndex] = {};
    },

    endPrefetch: function (cacheIndex) {
      if (!this._api) {
        var errorMsg = 'API is not configured correctly';
        BVTracker.error({
          name: str.errors.CONFIG,
          detail1: errorMsg
        });
        throw new Error(errorMsg);
      }

      var self = this;
      var subQueries = this.subQueries[cacheIndex];
      var subQueryDfds = this.subQueryDfds[cacheIndex];
      var urls = [];
      var batchQueries;

      if (!this.isPrefetch()) {
        return;
      }
      this._isPrefetch = false;

      // prefetch phase is over, request all the data we need and resolve all waiting fetches with the data.
      if (subQueries.length) {
        subQueries = _(subQueries).sortBy(function (subQuery) {
          return subQuery.serialize().toLowerCase();
        });

        // set the URL limit to 2000 chars for IE8 and below.
        var urlLimit = (IE && IE < 9) ? 2000 : null;
        var queryChunks = array.chunkWithLimit(subQueries, this._batchLimit, function (query) {
          return query.serialize().length;
        }, urlLimit);

        _(queryChunks).forEach(function (queryChunk) {
          var batchPrefetch = self._api.get('batch', null, queryChunk);
          var subQueryUrls = [];
          _(queryChunk).forEach(function (subQuery) {
            subQueryUrls.push(subQuery.serialize());
          });
          batchPrefetch.fetch('prefetch').done(function (dataArray) {
            _(dataArray).forEach(function (d, index) {
              /**
               *  Every result of this batch request represents the result of a unique subquery.
               *  Grab the deferred associated with the subquery and resolve it with the data.
               *  There may be any number (>=1) of outstanding fetches waiting for this resolve.
               */
              var dfdKey = queryChunk[index].serialize().toLowerCase();
              subQueryDfds[dfdKey].resolve(d);
            });
          });
          urls.push({
            url: batchPrefetch.serialize(),
            subQueries: subQueryUrls
          });
        });
        return urls;
      }
    },

    isPrefetch: function () {
      return this._isPrefetch;
    },

    prefetch: function (fetch) {
      var batch;
      var batchDfd;
      var batchQueries;
      var queryKey;
      var subQueries = this.subQueries[this.cacheIndex];
      var subQueryDfds = this.subQueryDfds[this.cacheIndex];
      if (!this.isPrefetch()) {
        throw new Error('Error: Prefetch has not been started');
      }
      // map any fetch to it's appropriate prefetch response
      if (fetch._data.contentType === 'batch') {
        batchDfd = $.Deferred();
        batch = fetch._data.apiBatch;
        batchQueries = [];
        /**
         *  For every subquery in a batch request sent to prefetch that prefetch hasn't already seen,
         *  add a deferred to the subQueryDfd map for tracking completion of that query
         *  and add the subquery to the list of subqueries we need to fetch.
         */
        _(batch).forEach(function (apiClient) {
          queryKey = apiClient.serialize().toLowerCase();
          if (!subQueryDfds[queryKey]) {
            subQueryDfds[queryKey] = $.Deferred();
            subQueries.push(apiClient);
          }
          // map the subqueries of this batch request to the deferreds associated with those queries
          batchQueries.push(subQueryDfds[queryKey]);
        });
        // when all the subqueries for this request are resolved, the batch is resolved
        $.when.apply($, batchQueries).done(function () {
          var results = _(arguments).toArray();
          batchDfd.resolve(results);
        });
        return batchDfd.promise();
      }
      else {
        // for a regular request add it to the list of queries if we haven't seen it, and promise to resolve it
        queryKey = fetch.serialize().toLowerCase();
        if (!subQueryDfds[queryKey]) {
          subQueryDfds[queryKey] = $.Deferred();
          subQueries.push(fetch);
        }
        return subQueryDfds[queryKey].promise();
      }
    }
  };
});

/**
 * Extensions Registry
 *
 * Extensions are registered in the scout file; this file
 * provides access to those extensions to the core application
 */
BV.define('framework/util/extensionsRegistry',['window'], function (window) {
  return (window && window.BV && window.BV._internal && window.BV._internal.extensionsRegistry) || {};
});

BV.define('serverFetch',{
  load: function (name, req, load, config) {
    if (config.isServerRender) {
      req(['bv/api/serverFetch'], function (serverFetch) {
        load(serverFetch);
      });
    }
    else {
      load({});
    }
  }
});

// A utility for generating namespaced jsonp callback identifiers. The intended
// usage is to call the `generate` function for each jsonp request with a
// unique id, or with no arguments to fall back to `Math.random()`

BV.define('bv/api/util/jsonpCallback',[
  'jquery'
], function ($) {

  // When building, we don't have a jquery version number
  var JQUERY_VERSION = $.fn.jquery ? $.fn.jquery.split(' ')[0] : '';

  var nonAlphanumTest = /\W+/ig;

  return {
    // Expects a unique id value for EACH request.
    generate: function (id) {
      // id falls back to a random number if nothing is provided
      id = id || Math.floor(Math.random() * 1000000);

      var identifier = 'bv_' + JQUERY_VERSION + '_' + id;
      // Remove non alphanumeric characters.
      return identifier.replace(nonAlphanumTest, '');
    }

  };

});

/**
 * Provides an API for fetching data from the BV API,
 * including the ability to deconstruct the responses
 * to a batch query and get the individual query responses
 * to the components that are interested.
 */
BV.define('bv/api/fetch',[
  'underscore',
  'jquery',
  'bv/api',
  'bv/api/normalizer',
  'bv/prefetch',
  'bv/strings',
  'framework/util/extensionsRegistry',
  'client!window',
  'vendor/json2',
  'serverFetch!',
  'framework/util/bvtracker',
  'bv/api/util/jsonpCallback'
], function (_, $, client, normalizer, prefetch, str, extensionsRegistry, window, JSON, serverFetch, BVTracker, jsonpCallback) {
  var dataExtension = extensionsRegistry['data.bvapi'];

  if (dataExtension) {
    dataExtension.sanitize = function (data) {
      return {
        contentType: data.contentType,
        results: client.normalize(data.results, data.options)
      };
    };
  }

  if (window.BV && window.BV.serverRender) {
    return serverFetch;
  }

  client.normalize = function (data, opts) {
    return normalizer.normalize(data, opts, client);
  };

  // ## `fetch`
  //
  // This function relies on jQuery's $.ajax functionality. This calls
  // into `serialize` and then actually makes the request. The function
  // returns the `jqXHR` object that jQuery returns. This is a deferred
  // based system, so calling `done` and `fail` on it will be the way
  // that you get the response.
  //
  // This tries to handle normalization turned on or off, as well as some
  // initial caching efforts.
  //
  // If you choose not to included jQuery and want to implement your own
  // fetch, just override this function and jQuery won't be referenced
  // outside of it or the normalization function.
  client.get.fn.fetch = function fetch (name, checksumKey) {
    var self = this;
    var fetchURL = self.serialize();
    var fetchCacheKey = fetchURL.toLowerCase();
    var rawData;
    var result;
    var startDate = new Date();
    var batchUrls = [];
    var rawBatchData = [];
    var batch;

    var errorLogger = function (data) {
      if (data && data.HasErrors) {
        _(data.Errors).forEach(function (error) {
          // Duplicate error is the only acceptable one
          if (error.Code !== 'ERROR_DUPLICATE_SUBMISSION') {
            BVTracker.error({
              name: str.errors.API,
              detail1: error.Code,
              detail2: fetchURL
            });
          }
        });
      }
    };

    if (!client._config.baseUrl) {
      BVTracker.error({
        name: str.errors.CONFIG,
        detail1: 'Incomplete API Config',
        detail2: JSON.stringify(client._config)
      });
      throw new Error('Incomplete API Config - ' + fetchURL);
    }

    if (prefetch.isPrefetch()) {
      return prefetch.prefetch(self);
    }

    try {
      rawData = BV._internal.apiCache[fetchCacheKey];
    } catch (e) {}

    if (self._data.contentType === 'batch') {
      batch = self._data.apiBatch;
      _(batch).forEach(function (apiClient) {
        var cacheKey = apiClient.serialize().toLowerCase();
        var cachedResponse;
        try {
          cachedResponse = BV._internal.apiCache[cacheKey];
        } catch (e) {}
        if (!cachedResponse) {
          batchUrls.push(apiClient);
          cachedResponse = BV._internal.apiCache[cacheKey] = $.Deferred();
          cachedResponse.done(errorLogger);
        }
        rawBatchData.push(cachedResponse);
      });
      if (!batchUrls.length) {
        // perfect match, nothing to do.
        rawData = $.Deferred().resolve();
      }
      else {
        self._data.apiBatch = batchUrls;
        // re-serialize the batch request sans cached responses
        fetchURL = self.serialize();
      }
    }

    // If there's no cache and/or the cached request timed out/failed, try again
    if (!rawData || rawData.state() === 'rejected') {
      // Create a jQuery request object that returns a deferred if we don't already have all the data.
      rawData = $.ajax({
        url: fetchURL,
        dataType: 'jsonp',
        cache: true,
        // 20 second timeout so that fail() will trigger for JSONP requests
        timeout: 20000,
        jsonpCallback: jsonpCallback.generate(self.checksum(name + checksumKey))
      });
      rawData.done(errorLogger);
      // If this is not a user specific API request, cache it.
      if (!self.config.user) {
        BV._internal.apiCache[fetchCacheKey] = rawData;
      }
    }

    if (client._config.normalize) {
      result = $.Deferred();
      rawData
        .done(function (data) {
          var options;
          var normalized;
          var batchReadyQueue = [];
          if (self._data.contentType === 'batch') {
            // Resolve the pieces of the batch request that weren't cached (if any)
            // This will unblock other pending fetches waiting for these pieces.
            _(batchUrls).forEach(function (apiClient, index) {
              var cacheKey = apiClient.serialize().toLowerCase();
              var batchData = data.BatchedResults['q' + index];
              if (batchData) {
                BV._internal.apiCache[cacheKey].resolve(batchData);
              }
            });
            // Once all the data is assembled from the cache and/or network request, normalize it.
            $.when.apply($, rawBatchData).done(function () {
              var results = _(arguments).toArray();
              _(results).forEach(function (result, index) {
                var api = batch[index];
                var contentType = api._data.contentType;
                var readyDfd = $.Deferred();

                options = { contentType: contentType, api: api };
                normalized = client.normalize(result, options);
                normalized.Includes = result.Includes;
                batchReadyQueue.push(readyDfd.promise());

                if (dataExtension) {
                  dataExtension.sendData({ contentType: contentType, results: result, options: options });
                }

                readyDfd.resolve({ contentType: contentType, data: normalized });
              });
              // When all the data is normalized resolve it
              $.when.apply($, batchReadyQueue).then(
                function () {
                  var dataArray = _(arguments).toArray();
                  result.resolve(dataArray);
                }
              );
            });
          }
          else {
            // for "relatedquestions", it returns a list of questions.
            // we need to set the contentType properly as "Questions"
            // instead of "relatedquestions".
            if (self._data.contentType.indexOf('related') > -1) {
              self._data.contentType = self._data.contentType.replace('related', '');
            }
            options = { contentType: self._data.contentType, api: self };
            normalized = client.normalize(data, options);
            // Send back the raw Includes too. We need this to make the reviews.json call for
            // pagination to work right in all cases. Can't rely on the Reference of the first
            // review to be product we made a request for (product families, etc.).
            normalized.Includes = data.Includes;

            if (dataExtension) {
              dataExtension.sendData({ contentType: self._data.contentType, results: data, options: options });
            }
            result.resolve({ contentType: self._data.contentType, data: normalized });
          }
        })
        .fail(function () {
          result.reject.call(result, startDate, new Date());
        });

      return result.promise();
    }
    else {
      return rawData;
    }
  };

  return client;
});

/**
 * Polyfill User Timing API
 *
 * Based on [usertiming.js].
 *
 * [usertiming.js]: https://github.com/nicjansma/usertiming.js
 */
BV.define('framework/polyfill/user-timing',[
  'window',
  'underscore',
  'framework/util/bvreporter'
],
function (window, _, BVReporter) {
  
  var BV = window.BV;

  // Even though we almost completely rely on our polyfill to avoid conflicts
  // with client code, some values we consider safe to read, such as timing
  // data. Because we still want to use this safe data when available, keep a
  // reference to the native performance.
  var nativePerformance = window.performance || {};

  var i, j;

  // PerformanceTimeline (PT) shims
  // http://www.w3.org/TR/performance-timeline/

  // performance timeline array
  BV.performance = BV.performance || {};
  var performanceTimeline = BV.performance._timeline || [];

  // whether or not the timeline will require sort on getEntries()
  var performanceTimelineRequiresSort = false;

  /**
   * Adds an object to our internal Performance Timeline array.
   *
   * @param {Object} obj PerformanceEntry
   */
  function addToPerformanceTimeline (obj) {
    performanceTimeline.push(obj);

    // If we insert a measure, its startTime may be out of order from the rest
    // of the entries because the use can use any mark as the start time.  If
    // so, note we have to sort it before returning getEntries();
    if (obj.entryType === 'measure') {
      performanceTimelineRequiresSort = true;
    }
  }

  /**
   * Ensures our PT array is in the correct sorted order (by startTime)
   */
  function ensurePerformanceTimelineOrder () {
    if (!performanceTimelineRequiresSort) {
      return;
    }

    // Measures, which may be in this list, may enter the list in an unsorted
    // order. For example:
    //
    //  1. measure('a')
    //  2. mark('start_mark')
    //  3. measure('b', 'start_mark')
    //  4. measure('c')
    //  5. getEntries()
    //
    // When calling #5, we should return [a,c,b] because technically the start
    // time of c is '0' (navigationStart), which will occur before b's start
    // time due to the mark.
    performanceTimeline.sort(function (a, b) {
      return a.startTime - b.startTime;
    });

    performanceTimelineRequiresSort = false;
  }

  /**
   * Clears the specified entry types from our timeline array.
   *
   * @param {string} entryType Entry type (eg 'mark' or 'measure')
   * @param {string} [name] Entry name (optional)
   */
  function clearEntriesFromPerformanceTimeline (entryType, name) {
    // clear all entries from the perf timeline
    var i = 0;

    while (i < performanceTimeline.length) {
      if (performanceTimeline[i].entryType !== entryType) {
        // unmatched entry type
        i++;
        continue;
      }

      if (name !== void undefined && performanceTimeline[i].name !== name) {
        // unmatched name
        i++;
        continue;
      }

      // This entry matches our criteria, remove it.
      performanceTimeline.splice(i, 1);
    }
  }

  /**
   * Gets all entries from the Performance Timeline.
   * http://www.w3.org/TR/performance-timeline/#dom-performance-getentries
   *
   * NOTE: This will only ever return marks and measures.
   *
   * @return {PerformanceEntry[]} Array of PerformanceEntrys
   */
  BV.performance.getEntries = function () {
    ensurePerformanceTimelineOrder();

    // Get a copy of all of our entries.
    return performanceTimeline.slice(0);
  };

  /**
   * Gets all entries from the Performance Timeline of the specified type.
   * http://www.w3.org/TR/performance-timeline/#dom-performance-getentriesbytype
   *
   * NOTE: This will only work for marks and measures.
   *
   * @param {string} entryType Entry type (eg 'mark' or 'measure')
   *
   * @return {PerformanceEntry[]} Array of PerformanceEntrys
   */
  BV.performance.getEntriesByType = function (entryType) {
    // We only support marks/measures.
    if (entryType !== 'mark' && entryType !== 'measure') {
      return [];
    }

    // See ensurePerformanceTimelineOrder() for why this is necessary.
    if (entryType === 'measure') {
      ensurePerformanceTimelineOrder();
    }

    // find all entries of entryType
    var entries = [];
    for (var i = 0; i < performanceTimeline.length; i++) {
      if (performanceTimeline[i].entryType === entryType) {
        entries.push(performanceTimeline[i]);
      }
    }

    return entries;
  };

  /**
   * Gets all entries from the Performance Timeline of the specified name,
   * and optionally, type.
   * http://www.w3.org/TR/performance-timeline/#dom-performance-getentriesbyname
   *
   * NOTE: This will only work for marks and measures.
   *
   * @param {string} name Entry name
   * @param {string} [entryType] Entry type (eg 'mark' or 'measure')
   *
   * @return {PerformanceEntry[]} Array of PerformanceEntrys
   */
  BV.performance.getEntriesByName = function (name, entryType) {
    if (entryType && entryType !== 'mark' && entryType !== 'measure') {
      return [];
    }

    // see note in ensurePerformanceTimelineOrder() on why this is required
    if (entryType !== 'mark') {
      ensurePerformanceTimelineOrder();
    }

    // find all entries of the name and (optionally) type
    var entries = [];
    for (var i = 0; i < performanceTimeline.length; i++) {
      if (entryType !== void undefined &&
        performanceTimeline[i].entryType !== entryType
      ) {
        continue;
      }

      if (performanceTimeline[i].name === name) {
        entries.push(performanceTimeline[i]);
      }
    }

    return entries;
  };

  // UserTiming support

  // Per http://www.w3.org/TR/user-timing/#extensions-performance-interface,
  // mark and measure names cannot be any of the attributes in the
  // PerformanceTiming interface:
  // http://www.w3.org/TR/navigation-timing/#performancetiming.
  var reservedNames = {
    'navigationStart': 1,
    'unloadEventStart': 1,
    'unloadEventEnd': 1,
    'redirectStart': 1,
    'redirectEnd': 1,
    'fetchStart': 1,
    'domainLookupStart': 1,
    'domainLookupEnd': 1,
    'connectStart': 1,
    'connectEnd': 1,
    'secureConnectionStart': 1,
    'requestStart': 1,
    'responseStart': 1,
    'responseEnd': 1,
    'domLoading': 1,
    'domInteractive': 1,
    'domContentLoadedEventStart': 1,
    'domContentLoadedEventEnd': 1,
    'domComplete': 1,
    'loadEventStart': 1,
    'loadEventEnd': 1
  };

  // Store marks internally, preserving any marks that were made by the scout
  // file.
  var marks = BV.performance._marks || {};

  // We intentionally clobber the old polyfill if it exists.

  /**
   * UserTiming mark
   * http://www.w3.org/TR/user-timing/#dom-performance-mark
   *
   * @param {string} markName Mark name
   */
  BV.performance.mark = function (markName) {
    // If the native version exists, we want to use it, but we don't want to
    // use it exclusively. Experience has taught us that we can't rely on the
    // native API being present and functioning _even if it claims to be_.
    // (Maybe the page owner is using a poorly-implemented polyfill.) So we
    // can't trust any results we get from, say,
    // `window.performance.getEntries`.
    //
    // Thus we add our own marks to our own timeline. The functions that will
    // later be defined on `BV.performance` will write to and read from that
    // timeline only.
    //
    // But we still want to register our marks with anything that claims to
    // be the native User Timing API. That way we get the benefits of tooling
    // (Chrome Dev Tools, webpagetest) on pages that we know to be
    // implementing the API properly. For more info, see UIA-7674 and its
    // associated pull request.
    if (typeof nativePerformance.mark === 'function') {
      // Call the native performance method...
      nativePerformance.mark(markName);
      // ...but don't return, because we also want to create an artificial
      // mark.
    }

    var now = BV.performance.now();

    // mark name is required
    if (markName === void undefined) {
      throw new SyntaxError('Mark name must be specified');
    }

    // mark name can't be a NT timestamp
    if (markName in reservedNames) {
      throw new SyntaxError('Mark name "' + markName + '" is not allowed');
    }

    if (!marks[markName]) {
      marks[markName] = [];
    }

    marks[markName].push(now);

    // add to perf timeline as well
    addToPerformanceTimeline({
      entryType: 'mark',
      name: markName,
      startTime: now,
      duration: 0
    });
  };

  /**
   * UserTiming clear marks
   * http://www.w3.org/TR/user-timing/#dom-performance-clearmarks
   *
   * @param {string} markName Mark name
   */
  BV.performance.clearMarks = function (markName) {
    if (!markName) {
      // clear all marks
      marks = {};
    }
    else {
      marks[markName] = [];
    }

    clearEntriesFromPerformanceTimeline('mark', markName);
  };

  /**
   * UserTiming measure
   * http://www.w3.org/TR/user-timing/#dom-performance-measure
   *
   * If startMark is a navigation timing entry name, it will be used if
   * available. If unavailable, a value of 0 will be used. The same is true
   * for endMark, but the value of startMark will be used instead of 0.
   *
   * @param {string} measureName Measure name
   * @param {string} [startMark] Start mark name
   * @param {string} [endMark] End mark name
   */
  BV.performance.measure = function (measureName, startMark, endMark) {
    var now = BV.performance.now();

    if (!measureName) {
      throw new Error('Measure must be specified');
    }

    // if there isn't a startMark, we measure from navigationStart to now
    if (!startMark) {
      // add to perf timeline as well
      addToPerformanceTimeline({
        entryType: 'measure',
        name: measureName,
        startTime: 0,
        duration: now
      });

      return;
    }

    // If there is a startMark, check for it first in the NavigationTiming
    // interface, then check our own marks.
    var startMarkTime = 0;

    // Lean on the read-only, native performance timing data if available.
    var timing = nativePerformance.timing || {};

    if (startMark in timing || startMark in reservedNames) {
      // mark cannot have a timing of 0
      if (startMark !== 'navigationStart' && timing[startMark] === 0) {
        BVReporter.warn(startMark + ' has a timing of 0');
        return;
      }

      if (startMark in timing) {
        // time is the offset of this mark to navigationStart's time
        startMarkTime = timing[startMark] - timing.navigationStart;
      }
      else {
        // use beginning of time as start mark time
        startMarkTime = 0;
      }
    }
    else {
      if (startMark in marks) {
        startMarkTime = marks[startMark][marks[startMark].length - 1];
      }
      else {
        BVReporter.warn(startMark + ' mark not found');
        return;
      }
    }

    // If there is an endMark, check for it first in the NavigationTiming
    // interface, then check our own marks.
    var endMarkTime = now;

    if (endMark) {
      endMarkTime = 0;

      if (endMark in timing || endMark in reservedNames) {
        // mark cannot have a timing of 0
        if (endMark !== 'navigationStart' && timing[endMark] === 0) {
          BVReporter.warn(endMark + ' has a timing of 0');
          return;
        }

        if (endMark in timing) {
          // time is the offset of this mark to navigationStart's time
          endMarkTime = timing[endMark] - timing.navigationStart;
        }
        else {
          // use start mark time as end mark time
          endMarkTime = startMarkTime;
        }
      }
      else {
        if (endMark in marks) {
          endMarkTime = marks[endMark][marks[endMark].length - 1];
        }
        else {
          BVReporter.warn(endMark + ' mark not found');
          return;
        }
      }
    }

    // add to our measure array
    var duration = endMarkTime - startMarkTime;

    // add to perf timeline as well
    addToPerformanceTimeline({
      entryType: 'measure',
      name: measureName,
      startTime: startMarkTime,
      duration: duration
    });
  };

  /**
   * UserTiming clear measures
   * http://www.w3.org/TR/user-timing/#dom-performance-clearmeasures
   *
   * @param {string} measureName Measure name
   */
  BV.performance.clearMeasures = function (measureName) {
    clearEntriesFromPerformanceTimeline('measure', measureName);
  };

  return BV.performance;
});

/**
 * @fileOverview Performance Logging API
 */
BV.define('framework/performance',[
  'window',
  'underscore',
  'framework/util/bvtracker',
  'framework/polyfill/user-timing'
],
function (
  window,
  _,
  BVTracker,
  userTiming
) {
  var BV = window.BV;

  function log (name, startMark, endMark, severity) {
    if (arguments.length < 1) {
      throw new SyntaxError('The "name" parameter is required');
    }

    if (arguments.length < 2 || !startMark) {
      startMark = 'scoutStart';
    }

    if (!_.isNumber(severity)) {
      severity = log.SEVERITY.WARN;
    }

    if (!endMark) {
      BV.performance.measure(name, startMark);
    }
    else {
      BV.performance.measure(name, startMark, endMark);
    }

    var event = BV.performance.getEntriesByName(name).pop();
    if (event && severity <= log.level) {
      BV.performance.track(event);
    }
  }

  log.SEVERITY = {
    DEBUG: 3,
    INFO: 2,
    WARN: 1,
    ERROR: 0
  };

  log.level = log.SEVERITY.WARN;

  log.debug = function (name, startMark, endMark) {
    BV.performance.log(name, startMark, endMark, log.SEVERITY.DEBUG);
  };

  log.info = function (name, startMark, endMark) {
    BV.performance.log(name, startMark, endMark, log.SEVERITY.INFO);
  };

  log.warn = function (name, startMark, endMark) {
    BV.performance.log(name, startMark, endMark, log.SEVERITY.WARN);
  };

  log.error = function (name, startMark, endMark) {
    BV.performance.log(name, startMark, endMark, log.SEVERITY.ERROR);
  };

  function track (event) {
    BVTracker.performance({
      name: event.name,
      elapsedMs: event.duration,
      startTime: event.startTime,
      endTime: event.startTime + event.duration
    });
  }

  BV.performance.track = track;
  BV.performance.log = log;

  return BV.performance;
});

BV.define('framework/async-queue',[
  'underscore',
  'framework/performance',
  'framework/util/bvreporter'
],
function (
  _,
  performance,
  BVReporter
) {
  var q = [];

  var queue = {
    running: false,
    delay: 5,
    debug: false,
    onError: function onTaskError (error, task) {
      BVReporter.error('Error running task', task, error);
    }
  };

  /**
   * Enqueue a task to be performed asynchronously
   *
   * @param {Object|Function} task the task to perform
   * @param {Function} task.fn the task function to run
   */
  queue.push = function pushQueue () {
    var tasks = _.toArray(arguments);

    tasks = _.map(tasks, function (task) {
      if (typeof task === 'object' && !('fn' in task)) {
        throw new Error('Task objects must implement an "fn" method');
      }

      if (typeof task !== 'object' && typeof task !== 'function') {
        throw new Error('Tasks must be functions or objects');
      }

      task = typeof task === 'function' ? { fn: task } : task;

      return task;
    });

    q.push.apply(q, tasks);

    if (!queue.running) {
      queue.running = true;
      setTimeout(tick, this.delay);
    }
  };

  var tick = _.bind(function tickQueue () {
    this.running = true;
    var task = q.shift();

    if (queue.debug &&
      performance.getEntriesByName('tick-wait-start').length > 0
    ) {
      performance.measure('tick-wait', 'tick-wait-start');
    }

    if (queue.debug) {
      performance.mark('tick-start');
    }

    try {
      task.fn();
    }
    catch (e) {
      this.onError(e, task);
    }

    if (queue.debug) {
      performance.measure('tick-run', 'tick-start');
    }

    if (q.length > 0) {
      if (queue.debug) {
        performance.mark('tick-wait-start');
      }
      setTimeout(tick, this.delay);
    }
    else {
      this.running = false;
    }
  }, queue);

  return queue;
});

BV.define('framework/bmodel',[
  'ENV',
  'backbone',
  'underscore',
  '$BV',
  'framework/bevented',
  'framework/bdata',
  'framework/bmodelbase',
  'jquery',
  'bv/api/fetch',
  'framework/async-queue',
  'framework/util/featureHelper',
  'framework/util/bvreporter',
  'framework/util/bvtracker'
], function (ENV, Backbone, _, $BV, BEvented, BData, BModelBase, $, bvApi, queue, ftHelper, BVReporter, BVTracker) {
  // BEvented provides publish, subscribe, and unsubscribe
  var BModel = Backbone.Model.extend(BEvented);
  BModel = BModel.extend(BData);
  BModel = BModel.extend(BModelBase);

  // Extends Backbone.Model to support "submodels" that
  // are derived from feature definitions in the environment
  return BModel.extend({
    initialize: function (config, options) {
      BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
      BVReporter.assert(function () { return [_(options).isObject() || _(options).isUndefined(), 'options is object or empty']; });
      BVReporter.debug('Model', this.name, 'initializing');

      var parent = this.get('parent');
      var self = this;

      this.subModels = {};

      this._initDeferreds();

      // Subscribe to global bv:initReady that fires when all models are init'ed.
      ENV.on('bv:initReady', this._initReady, this);

      if (parent) {
        this.set(this._getParentProps(parent, config));
        this.api = parent.api || bvApi;
      }
      else {
        this.set(this._getProps());
      }

      var component = this.getComponent();
      this.readOnly = !!component.readOnly;

      this._initializeAPI(config, options);
    },

    _initializeAPI: function (config, options) {
      // Set default bv api on component models.
      this.api = this.api || bvApi;
      // Pass straight through if there are no api dependencies.
      this._initialize(config, options);
    },

    _initialize: function (config, options) {
      var components = ENV.get('componentManager');
      var componentId = this.get('componentId');
      var component = components.find(componentId);

      BVReporter.assert(component, 'model ' + this.name + ' has associated component');

      if (config.name) {
        this.name = config.name;
      }

      // Passthrough to the init function now.
      if (_.isFunction(this.init)) {
        var result = this.init.apply(this, arguments);
        if (result === null) {
          return null;
        }
      }

      // After initialization set up feature models.
      this._initSubmodels(component);

      // We need submodel to be created first before we resolve the defer object.
      this.setupDataProcessing();
      this.onDataReady(this._dataReady, this);
    },

    /**
     *  Indicates whether we should process data asynchronously.
     */
    isAsyncDataProcessing: function () {
      return this.getComponent().isAsyncDataProcessing();
    },

    _initSubmodels: function (component) {
      if (!component || !component.features) {
        return;
      }

      var mappings = ENV.get('mappings');

      BVReporter.debug('Model', this.getScope(), 'initializing feature models');

      // TODO: figure out a more explicit to determine 'self'.
      var parent = this.get('parent');
      var name = !parent ? 'self' : this.name;
      var allFeatures = component.features[this.name] || component.features[name] || [];

      allFeatures = ftHelper.getFeaturesForInstance(allFeatures, this.getContentType(), this.getInstanceName());

      _(allFeatures).forEach(function (name) {
        var shortName = ftHelper.getName(name);
        var feature = mappings[shortName];
        var props = {
          parent: this,
          featureType: ftHelper.getType(name),
          instanceName: ftHelper.getInstanceName(name)
        };
        var model;

        if (!feature) {
          return;
        }

        if (feature.has || !(feature.model || feature.collection)) {
          return;
        }

        if (feature.model) {
          model = new feature.model(props);
        }
        else if (feature.collection) {
          // A model might have a collection as a feature. This is handled differently.
          model = new feature.collection(undefined, props);
          model.parent = this;
        }

        this.subModels[name] = model;
      }, this);
    },

    /**
     * This method is called as part of the initialization process. By default,
     * it either:
     *
     * - calls `processData` on the model's parent's data when it is ready, or
     * - if the model does not have a parent, immediately calls `processData`
     *
     * You should override this method if you want to run the `processData` method
     * as the result of some other event.
     */
    setupDataProcessing: function () {
      BVReporter.debug('Model', this.getScope(), 'setting up data processing');

      var parent = this.get('parent');

      // If there's a parent, wait to process whatever data the parent hands down
      // via its `.dataReady()` method.
      if (parent) {
        parent.onDataReady(this.invokeProcessData, this);
      }
      // Otherwise, just call the `.invokeProcessData()` method immediately.
      else {
        this.invokeProcessData();
      }
    },

    /**
     *  Calls `processData` either synchronously or asynchronously depending
     *  on settings.
     */
    invokeProcessData: function (data) {
      if (this.isAsyncDataProcessing()) {
        BVReporter.info('Model', this.name, 'calling processData asynchronously');
        queue.push(_(function () { this.processData(data); }).bind(this));
      }
      else {
        this.processData(data);
      }
    },

    /**
     * This method, by default, will just announce that the model's data is ready,
     * resolving its dataReadyPromise. However, most models that fetch data will
     * override this method.
     */
    processData: function (data) {
      BVReporter.debug('Model', this.getScope(), 'processing data');
      return this.dataReady(data);
    },

    _initReady: function () {
      ENV.off('bv:initReady', this._initReady, this);
      this.initReady(this);
    },

    /**
     * This method is called when all of the models for all of the components
     * associated with a UI action have been initialized. By default, this
     * method will call the `initialized` method, indicating that it is safe
     * to proceed with post-initialization activities. You should override this
     * method if there are other pre-initialization tasks you need to perform,
     * but *you should ensure that you call the `initialized` method at some point*.
     */
    initReady: function (self) {
      BVReporter.debug('Model', this.getScope(), 'initReady');
      this.initialized();
    },

    _dataReady: function (data) {
      var self = this;
      var subModels = _.values(this.subModels);

      if (subModels.length) {
        // We have submodels. Because their data is being processed
        // asynchronously, we have to wait until all our submodels have
        // resolved their `dataProcessed` promise.
        var promises = _.invoke(subModels, 'dataProcessedPromise');
        $.when.apply($, promises).done(function () {
          self.dataProcessed();
        });
      }
      else {
        // We have no submodels, so we can immediately signal to our parent
        // that we're done.
        this.dataProcessed();
      }
    },

    getFeatureModel: function (featureName) {
      var featureModel = this.getFeatureModels(featureName);
      return _(featureModel).isEmpty() ? null : featureModel[0];
    },

    getFeatureModels: function (featureName) {
      if (_(this.subModels).has(featureName)) {
        return [this.subModels[featureName]];
      }

      var allTypes = _(this.subModels).filter(function (subModel, name) {
        return ftHelper.match(featureName, name);
      });

      return _(allTypes).isEmpty() ? null : allTypes;
    }

  });
});

// These happen at compile time and make themselves obsolete
;
// These happen at compile time and make themselves obsolete
;
// These happen at compile time and make themselves obsolete
;
// These happen at compile time and make themselves obsolete
;
// These happen at compile time and make themselves obsolete
;
// These happen at compile time and make themselves obsolete
;
/**
 * @license handlebars hbs 0.1.0 - Alex Sexton, but Handlebars has it's own licensing junk
 *
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/require-cs for details on the plugin this was based off of
 */

/* Yes, deliciously evil. */
/*jshint evil: true, indent: false, strict: false, plusplus: false, regexp: false */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
define: false, process: false, window: false, console: false */
BV.define('hbs',[
], function (
) {
// NOTE :: if you want to load template in production outside of the build, either precompile
// them into modules or take out the conditional build stuff here


  return {
          };
});
/* END_hbs_PLUGIN */
;
/*

 Copyright (C) 2011 by Yehuda Katz

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 */
(function () {
// lib/handlebars/browser-prefix.js
var Handlebars = {};

(function(Handlebars, undefined) {
  ;
// lib/handlebars/base.js

  Handlebars.VERSION = "1.0.0-rc.3";
  Handlebars.COMPILER_REVISION = 2;

  Handlebars.REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '>= 1.0.0-rc.3'
  };

  Handlebars.helpers  = {};
  Handlebars.partials = {};

  Handlebars.registerHelper = function(name, fn, inverse) {
    if(inverse) { fn.not = inverse; }
    this.helpers[name] = fn;
  };

  Handlebars.registerPartial = function(name, str) {
    this.partials[name] = str;
  };

  Handlebars.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Error("Could not find property '" + arg + "'");
    }
  });

  var toString = Object.prototype.toString, functionType = "[object Function]";

  Handlebars.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    var type = toString.call(context);

    if(type === functionType) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if(type === "[object Array]") {
      if(context.length > 0) {
        return Handlebars.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  Handlebars.K = function() {};

  Handlebars.createFrame = Object.create || function(object) {
    Handlebars.K.prototype = object;
    var obj = new Handlebars.K();
    Handlebars.K.prototype = null;
    return obj;
  };

  Handlebars.logger = {
    DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,

    methodMap: {0: 'debug', 1: 'info', 2: 'warn', 3: 'error'},

    // can be overridden in the host environment
    log: function(level, obj) {
      if (Handlebars.logger.level <= level) {
        var method = Handlebars.logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, obj);
        }
      }
    }
  };

  Handlebars.log = function(level, obj) { Handlebars.logger.log(level, obj); };

  Handlebars.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (options.data) {
      data = Handlebars.createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if(context instanceof Array){
        for(var j = context.length; i<j; i++) {
          if (data) { data.index = i; }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { data.key = key; }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  Handlebars.registerHelper('if', function(context, options) {
    var type = toString.call(context);
    if(type === functionType) { context = context.call(this); }

    if(!context || Handlebars.Utils.isEmpty(context)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  Handlebars.registerHelper('unless', function(context, options) {
    return Handlebars.helpers['if'].call(this, context, {fn: options.inverse, inverse: options.fn});
  });

  Handlebars.registerHelper('with', function(context, options) {
    if (!Handlebars.Utils.isEmpty(context)) return options.fn(context);
  });

  Handlebars.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    Handlebars.log(level, context);
  });
  ;

// lib/handlebars/utils.js

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  Handlebars.Exception = function(message) {
    var tmp = Error.prototype.constructor.apply(this, arguments);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }
  };
  Handlebars.Exception.prototype = new Error();

// Build out our basic SafeString type
  Handlebars.SafeString = function(string) {
    this.string = string;
  };
  Handlebars.SafeString.prototype.toString = function() {
    return this.string.toString();
  };

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  var escapeChar = function(chr) {
    return escape[chr] || "&amp;";
  };

  Handlebars.Utils = {
    escapeExpression: function(string) {
      // don't escape SafeStrings, since they're already safe
      if (string instanceof Handlebars.SafeString) {
        return string.toString();
      } else if (string == null || string === false) {
        return "";
      }

      if(!possible.test(string)) { return string; }
      return string.replace(badChars, escapeChar);
    },

    isEmpty: function(value) {
      if (!value && value !== 0) {
        return true;
      } else if(toString.call(value) === "[object Array]" && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
  };
  ;
// lib/handlebars/runtime.js

  Handlebars.VM = {
    template: function(templateSpec) {
      // Just add water
      var container = {
        escapeExpression: Handlebars.Utils.escapeExpression,
        invokePartial: Handlebars.VM.invokePartial,
        programs: [],
        program: function(i, fn, data) {
          var programWrapper = this.programs[i];
          if(data) {
            return Handlebars.VM.program(fn, data);
          } else if(programWrapper) {
            return programWrapper;
          } else {
            programWrapper = this.programs[i] = Handlebars.VM.program(fn);
            return programWrapper;
          }
        },
        programWithDepth: Handlebars.VM.programWithDepth,
        noop: Handlebars.VM.noop,
        compilerInfo: null
      };

      return function(context, options) {
        options = options || {};
        var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);

        var compilerInfo = container.compilerInfo || [],
          compilerRevision = compilerInfo[0] || 1,
          currentRevision = Handlebars.COMPILER_REVISION;

        if (compilerRevision !== currentRevision) {
          if (compilerRevision < currentRevision) {
            var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision],
              compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
            throw "Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").";
          } else {
            // Use the embedded version info since the runtime doesn't know about this revision yet
            throw "Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").";
          }
        }

        return result;
      };
    },

    programWithDepth: function(fn, data, $depth) {
      var args = Array.prototype.slice.call(arguments, 2);

      return function(context, options) {
        options = options || {};

        return fn.apply(this, [context, options.data || data].concat(args));
      };
    },
    program: function(fn, data) {
      return function(context, options) {
        options = options || {};

        return fn(context, options.data || data);
      };
    },
    noop: function() { return ""; },
    invokePartial: function(partial, name, context, helpers, partials, data) {
      var options = { helpers: helpers, partials: partials, data: data };

      if(partial === undefined) {
        throw new Handlebars.Exception("The partial " + name + " could not be found");
      } else if(partial instanceof Function) {
        return partial(context, options);
      } else if (!Handlebars.compile) {
        throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      } else {
        partials[name] = Handlebars.compile(partial, {data: data !== undefined});
        return partials[name](context, options);
      }
    }
  };

  Handlebars.template = Handlebars.VM.template;
  ;

// lib/handlebars/browser-suffix.js
})(Handlebars, undefined);
// AMD Define
if (typeof BV.define === 'function' && BV.define.amd) {
  BV.define('vendor/handlebars/runtime',[],function(){
    return Handlebars;
  });
}
else {
  module.exports = Handlebars;
}
})();

/* START_TEMPLATE */
BV.define('hbs!modestboxLoader',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  


  return "<div id=\"bv-mbox-loading\"> <div class=\"bv-mbox-spinner\"></div> </div> ";
  });
Handlebars.registerPartial('modestboxLoader', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!ariaStatus',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"bv-cleanslate bv-cv2-cleanslate bv-aria-status\" role=\"region\"> <div role=\"status\" aria-live=\"polite\" aria-relevant=\"additions\" class=\"";
  if (stack1 = helpers.containerClass) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.containerClass; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " bv-aria-polite\"> <div class=\"bv-off-screen\"></div> </div> <div role=\"status\" aria-live=\"assertive\" aria-atomic=\"true\" aria-relevant=\"additions\" class=\"";
  if (stack1 = helpers.containerClass) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.containerClass; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " bv-aria-assertive\"> <div class=\"bv-off-screen\"></div> </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('ariaStatus', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('body',['document'], function (document) {
  var cachedBody;
  // Thanks Dojo
  return function() {
    cachedBody = cachedBody || document.body || document.getElementsByTagName('body')[0];
    return cachedBody;
  };
});

/**
 * Creates a container to which we can add polite and assertive
 * ARIA status messages, and returns an object with methods for
 * adding messages.
 */
BV.define('bv/util/ariaStatus',[
  'jquery',
  'underscore',
  'hbs!ariaStatus',
  'ENV',
  'window',
  'body'
], function ($, _, ariaStatus, ENV, window, body) {
  if (window.BV && window.BV.serverRender) {
    return;
  }

  var $aria;
  var $ariaStatus;
  var $ariaStatusPolite;

  function createContainer () {
    $aria = $(ariaStatus({
      containerClass: 'bv-core-container-' + ENV.get('config').version
    })).appendTo(body());

    $ariaStatus = $aria.find('.bv-aria-assertive .bv-off-screen');
    $ariaStatusPolite = $aria.find('.bv-aria-polite .bv-off-screen');
  }

  return {
    /**
     * Add a message to the status area. Returns a jQuery object representing the
     * added message. It is up to the caller of the `add` method to remove the
     * message when appropriate. For example, if this is used to add a "Loading"
     * message, then the message should be removed when the loading is complete.
     *
     * @param {String or DOM} msg  The message to add; can be a string or a DOM node
     * @param {string} type Optional, the type of message. Defaults to assertive.
     * @returns {jQuery} a jQuery object representing the added message.
     */
    add: function (msg, type) {
      if (!$aria) {
        createContainer();
      }

      var $el = $('<div class="bv-aria-status-message" />');
      $el[_(msg).isString() ? 'html' : 'append'](msg);

      return $el.appendTo(type === 'polite' ? $ariaStatusPolite : $ariaStatus);
    }
  };

});

BV.define('bv/util/loadingOverlay',[
  'underscore',
  'jquery',
  'hbs!modestboxLoader',
  'bv/util/ariaStatus',
  'mf!bv/c2013/messages/common',
  'body'
], function (_, $, mboxLoader, ariaStatus, msgPack, body) {

  var $loading;
  var $ariaStatus;
  var hideLoadingDelay;
  var waitFeedback = msgPack.wait_feedback();

  function createContainer () {
    if ($loading) {
      return;
    }

    $loading = $(mboxLoader());
  }

  var LoadingOverlay = {
    show: function (sticky) {
      createContainer();

      this._clear();

      $loading.appendTo(body());

      if (!this._showing) {
        $ariaStatus = ariaStatus.add(waitFeedback);
      }

      if (!sticky) {
        // Hide the loading if it's not hidden in 20s
        hideLoadingDelay = _(this.hide).chain().bind(this).delay(20000);
      }

      this._showing = true;
    },

    hide: function () {
      createContainer();

      this._clear();

      $loading.remove();

      if ($ariaStatus) {
        $ariaStatus.remove();
      }

      this._showing = false;
    },

    _clear: function () {
      if (hideLoadingDelay) {
        window.clearTimeout(hideLoadingDelay);
      }
    }
  };

  return LoadingOverlay;
});

BV.define('bv/c2013/model/fullProfile',[
  'framework/bmodel',
  'underscore',
  'bv/util/loadingOverlay',
  'jquery'
], function (BModel, _, LoadingOverlay, $) {
  return BModel.extend({

    name: 'fullProfile',

    init: function (config, options) {
      if (config.dimsumConfig) {
        this.set('coverageContentTypes', config.dimsumConfig.coverageContentTypes);
      }

      // listen for launch profile event in r&r via component outlet
      this.subscribe('launchprofile', this.launchProfile);

      // listen for pageto event from init.js.
      // This is necessary for being as a standalone component.
      this.subscribe('pageto', this.fetchPage);
    },

    setupDataProcessing: function () {
      this.subscribe('authorresponse', this.processData);
    },

    /**
     * fetchPage shall only be triggered via BV.ui('cp', 'show_profile', { profileId : 'XXXXX' });
     */
    fetchPage: function (pageNum, force) {
      var clientAPIConfig = this.get('clientAPIConfig');
      if (!clientAPIConfig.profileId) {
        return;
      }
      this.set({
        autoload: true,
        renderSidebar: true
      });
      this.launchProfile({ Id: clientAPIConfig.profileId });
    },

    launchProfile: function (authorData) {
      // inheriting Author data object when full profile is triggered from r&r outlet
      // we need this to get the Author.Id for api call and also to render initial data in popup
      if (!authorData || !authorData.Id) {
        return;
      }

      var clientAPIConfig = this.get('clientAPIConfig');
      if (clientAPIConfig && !clientAPIConfig.silentMode) {
        LoadingOverlay.show();
      }

      this.set('Author', authorData);

      var tabs = this.getFeatureModel('tabs');
      if (tabs) {
        tabs.fetchPage(1, authorData);
      }

    },

    processData: function (authorData) {
      this.set('Author', authorData);
      var sidebarModel = this.getFeatureModel('sidebar');
      if (sidebarModel) {
        sidebarModel.set('Author', authorData);
      }

      this.dataReady(authorData);
      LoadingOverlay.hide();

      // if model autoload != true, we don't need to render sidebar.
      // the sidebar will be rendered by modest box automatically.
      if (!this.get('autoload')) {
        this.set('renderSidebar', false);
        this.trigger('showfullprofile');
      }
    },

    getSubject: function () {
      // Eventually need to make this handle other types?
      return {
        type: 'author',
        id: this.get('clientAPIConfig').profileId,
        contentType: this.get('contentType')
      };
    }

  });
});

BV.define('util/highContrast',[
  'jquery',
  'body',
  'util/has'
], function (
  $,
  body,
  has
) {

  function checkHighContrast () {
    // While `has` does support providing a generic element, it's the same for
    // all tests. Given that I don't want to muck up an element that may be
    // used in other tests, I'm just making one here. Also using jQuery for
    // consistent results.
    var $div;
    var color;

    $div = $('<div></div>');
    $div.appendTo(body());
    $div.css('background-color', 'blue', 'important');
    color = $div.css('background-color');
    $div.remove();

    // jQuery's result for color will usually return a normalized string in the
    // form of "rgb(R, G, B)" where R, G, and B are values between 0-255
    // respectively.  In high-contrast mode, this value takes on several
    // variations, none of which actually represent our baseline blue:
    //
    // - rgb(0, 0, 0)
    // - rgb(255, 255, 255)
    // - transparent
    //
    // As such, if we get back "rgb(0, 0, 255)", that indicates that we're not
    // in a high-contrast mode.
    if (color === 'rgb(0, 0, 255)') {
      return false;
    }

    // Of course, IE8 tells a different story. Instead of returning the RGB
    // color, it simply returns "blue" in this case, in normal contrast modes.
    // All other supported browsers are returning the RGB code, but in the
    // event that any of them (like IE8) return the directly assigned value,
    // this conditional will catch it.
    if (color === 'blue') {
      return false;
    }

    // At this point, the color isn't one of the two possible valid results for
    // blue, so we're assuming that high-contrast mode is altering our visual.
    return true;
  }

  has.add('high-contrast', checkHighContrast);

  return has;

});

BV.define('util/specialKeys',[],function () {
  return {
    DOWN : 40,
    END : 35,
    ENTER : 13,
    ESCAPE : 27,
    HOME : 36,
    LEFT : 37,
    PAGE_DOWN : 34,
    PAGE_UP : 33,
    RIGHT : 39,
    SPACE : 32,
    TAB : 9,
    UP : 38
  };
});
BV.define('framework/beventmanager',[
  'underscore',
  'jquery',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'bv/strings'
], function (_, $, BVReporter, BVTracker, str) {

  // This is a runtime mixin for bview. It contains methods that are useful
  // _only_ to a view that acts as an "event manager" of a particular
  // component. It manages event delegation for itself and all of its
  // subviews.
  //
  // == HOW IT WORKS ==
  //
  // 1. When a component initializes its top view, the view is augmented with
  //    the methods in this file. Any subsequent views that need to act as
  //    their own event managers (for reasons specified below) can also gain
  //    these methods by setting `isEventManager` to `true` in their class
  //    definitions.
  //
  // 2. When any views in this component (including the event manager view
  //    itself) want to register their events, they tell their event manager
  //    to handle it by calling the `delegateSubviewEvents` method. (This
  //    happens in bview.js; if you extend from BView, you probably won't
  //    need to worry about this.)
  //
  // 3. `delegateSubviewEvents` is careful to register only one copy of a
  //     given event for each combination of view name and contentType.
  //
  // 4. The responder attached by `delegateSubviewEvents` starts at the
  //    event's target element, looks at its ancestor chain to see if any
  //    views will be interested in this particular event, then calls the
  //    original method on all such interested views, starting with the view
  //    nearest to the event target. The `stopPropagation` method works as
  //    expected.
  //
  // 5. When a subview detaches, it calls `undelegateSubviewEvents`. (Again,
  //    this happens in bview.js, so it will happen automatically unless you
  //    tell it not to.) The method checks to see if this was the last
  //    subview of the given type (name + contentType); if so, it knows it
  //    can stop listening for that view type's events.
  //
  //
  // == WHY WE DO THIS ==
  //
  // Previously, each view would attach its events to the node represented by
  // its `$el` property, which is usually its parent's DOM node. But now
  // we're attaching all events to a common ancestor. This is usually the
  // component's top view, but can be another view in certain circumstances.
  // This allows us to streamline event delegation.
  //
  // After all, if a contentList has 10 contentItems as subviews, they're all
  // gonna have the same events, so we need only register each event once.
  //
  // This means that the event manager has to do a bit of housekeeping —
  // keeping track of (e.g.) how many contentItems it has, so that if they
  // all get removed it'll know to unregister the relevant events. But it
  // also means that we attach far fewer handlers than a naive event
  // delegation strategy.
  //
  // This is entirely a plumbing change, and the standard Backbone approach
  // of specifying an `events` property has not changed. The only caveat is
  // this: all views of a certain name and contentType are expected to
  // register the same events. If you need to violate this constraint, you
  // may have to register your non-conformant events manually.
  //
  //
  // == SPECIAL CASES ==
  //
  // Some views may need to act as their own event managers rather than rely
  // on their component's top view to do it for them. You might need this if
  // your view is rendering elsewhere in the DOM — for example, in a pop-up
  // view — or if your view is a one-off that doesn't belong to a component.
  //
  // If you want to force your view to be an event manager, give it an
  // `isEventManager` property set to `true`. All of its subviews (and
  // sub-subviews, and so on) will know to register its events with your
  // view.
  //
  // (`BPopupView` already has this property set, so if you inherit from it,
  // you needn't worry about this.)
  //
  // Regardless of the presence of the `isEventManager` flag, if a view can't
  // find an event manager in its view hierarchy, it will make itself one.
  //
  // Finally: if you override the base `attach` or `detach` method without
  // making a super-call to the original `BView` version, you'll have to
  // register and unregister with your event manager manually, like so:
  //
  //     // in your "attach" method:
  //     this.getEventManager().delegateSubviewEvents(this);
  //
  //     // in your "detach" method:
  //     this.getEventManager().undelegateSubviewEvents(this);
  //

  // Pass a view into this function to mixin the BEventManager methods.
  function BEventManager (view) {

    // Cached regex to split keys for `delegate`. Borrowed from Backbone.
    var eventSplitter = /^(\S+)\s*(.*)$/;

    // Subviews of this top view are stored here, indexed by unique ID.
    //
    // NOTE: We need this flat list so that we can easily obtain a view using
    // nothing but its unique ID. When we've got a DOM node and want to
    // obtain its corresponding BView, we can't go through the
    // SUBVIEWS_BY_VIEW_NAME collection because the DOM node doesn't have
    // any contentType information.
    var SUBVIEWS;

    // Subviews are also stored here, but in arrays indexed by view name.
    // This way, we know how many of a given kind of subview we're managing
    // at once. It also means that when the last subview of a certain type
    // detaches, we know to undelegate its events.
    var SUBVIEWS_BY_VIEW_NAME;

    // Keys are view names. Values are objects with signatures ("click
    // .bv-tile") as keys and boolean `true` as values.
    var EVENT_REGISTRY;

    // We create a deferred so that we can register events without caring
    // about where the view is in its lifecycle.
    var ATTACH_DEFERRED;

    // Once we detach the element, all of the delegation we did can be
    // undone, and we should prepare for the possibility that the element
    // could get re-attached by clearing the registry and creating another
    // deferred.
    function onDetach () {
      EVENT_REGISTRY = {};
      SUBVIEWS = {};
      SUBVIEWS_BY_VIEW_NAME = {};
      ATTACH_DEFERRED = $.Deferred();

      // Make sure the top view itself is in here.
      SUBVIEWS[view.uniq] = view;
    }

    onDetach();


    // Throughout this file, "view name" refers to the combination of view
    // name and contentType. Two otherwise-identical views with different
    // contentTypes should be treated differently.
    function getViewName (instance) {
      return instance.name + '<' + instance.contentType + '>';
    }

    function addInstanceByViewName (instance) {
      var name = getViewName(instance);
      if (!(name in SUBVIEWS_BY_VIEW_NAME)) {
        SUBVIEWS_BY_VIEW_NAME[name] = [];
      }
      SUBVIEWS_BY_VIEW_NAME[name].push(instance);
    }

    function removeInstanceByViewName (instance) {
      var name = getViewName(instance);
      var entry = SUBVIEWS_BY_VIEW_NAME[name];
      if (!entry) {
        return 0;
      }

      SUBVIEWS_BY_VIEW_NAME[name] = _(entry).without(instance);

      // For convenience, returns the number of remaining instances of this
      // view type.
      return SUBVIEWS_BY_VIEW_NAME[name].length;
    }

    function getRegistryForViewName (viewName) {
      if (!EVENT_REGISTRY[viewName]) { EVENT_REGISTRY[viewName] = {}; }
      return EVENT_REGISTRY[viewName];
    }

    function clearRegistryForViewName (viewName) {
      delete EVENT_REGISTRY[viewName];
    }

    // Given a DOM element (which we know already has a `data-bv-v`
    // attribute), return its corresponding BView instance.
    function lookupViewByNameAndViewId ($elem) {
      var viewId = $elem.attr('data-bv-v');
      var targetView = SUBVIEWS[viewId];
      return targetView || null;
    }

    // Test whether a view is interested in a particular signature (i.e., has
    // a matching key in its `events` hash).
    function viewIsInterested (instance, signature) {
      if (!instance) { return false; }
      var registry = getRegistryForViewName(getViewName(instance));
      return (signature in registry);
    }

    // We add two different namespaces to the event name: one for the top
    // view (so that we can unregister all events on the top view at once),
    // and one for the specific view name interested in the event (so we can
    // unregister all events for a particular view name at once).
    function getEventName (eventName, instance) {
      var general = '.delegateSubviewEvents' + view.cid;
      var specific = general + getViewName(instance);

      return eventName + general + specific;
    }

    function getInstanceKeyForView (view) {
      return view.name + ':' + view.uniq;
    }

    view.on('attach', function () {
      ATTACH_DEFERRED.resolve();
    });

    view.on('detach', function () {
      view.$el.undelegate('.delegateSubviewEvents' + view.cid);
      onDetach();
    });

    function makeResponder (signature, method, viewName, methodName) {
      return function (event) {
        BVReporter.group(BVReporter.DEBUG, 'Responding to event:', signature);
        BVReporter.debug('(event manager:', getViewName(view), ')');

        // We need to ensure that this responder calls methods on only the
        // kind of view for which it was created. Why?
        //
        // Let's say we've got views A, B, and C (of different types) such
        // that A encloses B and B encloses C, and that all of them subscribe
        // to "click button". Because they're of different types, this
        // creates three different responders.
        //
        // Thereafter, if we click on a button inside view C, all three
        // responders will be triggered, all three responders will look up
        // their ancestor chain and find three interested views, and all
        // three responders will call a particular method in the scope of
        // three different view types. This would be wrong.
        //
        // Instead, we look for all interested views, then ignore views that
        // don't have our expected view name. That's OK; the views of other
        // types will have their own responders.
        //
        // (In the future, we could refactor such that A, B, and C would
        // share a responder.)
        BVReporter.debug('(responder for view name:', viewName, ')');

        // Starting at the target of the event, traverse upward, collecting
        // any element with a `data-bv-v` attribute.
        var $targetView = $(event.currentTarget);
        var interestedViews = [], parents = $targetView.parents('[data-bv-v]').toArray();

        // Don't forget the target view itself. Unshifted because this array
        // starts with the most specific element and ends with the least
        // specific one.
        if ($targetView.is('[data-bv-v]')) {
          parents.unshift($targetView[0]);
        }

        // Figure out which of these elements is interested in this event.
        //
        // TODO: Right now, because we delegate once per (event name + view
        // name), it'd be impossible (or nearly so) for this responder to
        // discover more than one interested view. But in the future we might
        // change to delegating once per event name, so we do it this way to
        // make that potential change easier.
        _.each(parents, function (elem, j) {
          // Map the element to its view instance.
          var instance = lookupViewByNameAndViewId($(elem));
          if (viewIsInterested(instance, signature)) {
            interestedViews.push(instance);
          }
        });

        BVReporter.debug('Views interested in this event:', _(interestedViews).map(getViewName));

        // Trigger the responder on each interested view instance, keeping
        // track of calls to `stopPropagation`.
        for (var i = 0, length = interestedViews.length, instance; i < length; i++) {
          instance = interestedViews[i];
          if (getViewName(instance) !== viewName) {
            // Ignore views of other types, for the reasons explained above.
            BVReporter.debug('Skipping', getViewName(instance), "because it's of the wrong type.");
            continue;
          }
          try {
            BVReporter.debug('Calling method', methodName, 'on view', getViewName(instance));
            method.call(instance, event);
          } catch (err) {
            BVTracker.error({
              name: str.errors.FRAMEWORK,
              detail1: err
            });
          }
          if (event.isPropagationStopped()) { break; }
        }
        BVReporter.groupEnd(BVReporter.DEBUG, 'Responding to event:', signature);
      };
    }

    return {
      // Register a view's `events` collection with its top view, which is in
      // charge of event delegation.
      //
      // When a subview wants to register its events, it retrieves its event
      // manager and calls this method.
      delegateSubviewEvents: function (instance) {
        var events = instance.events;
        if (!events) { return; }

        var self = this;
        var key = getInstanceKeyForView(instance);

        // Add this view to both the flat table and the grouped-by-view-name
        // table.
        SUBVIEWS[key] = instance;
        addInstanceByViewName(instance);

        var registry = getRegistryForViewName(getViewName(instance));
        _(events).each(function (methodName, signature) {
          BVReporter.debug('Handling signature:', signature);
          if (signature in registry) {
            BVReporter.debug('Signature already exists:', signature);
            return;
          }

          if (!(methodName in instance)) {
            // Should not happen.
            // TODO: Report this with the BV reporter thing, when it's ready?
            // console.error('no method', methodName, 'in', instance);
          }

          // Borrow Backbone's code for splitting a signature into event name
          // and selector.
          var match = signature.match(eventSplitter);
          var eventName = match[1];
          var selector = match[2];

          // Append a couple of namespaces to the event name so we can easily
          // unregister stuff.
          eventName = getEventName(eventName, instance);

          var method = instance[methodName];

          ATTACH_DEFERRED.done(function () {
            var responder = makeResponder(signature, method, getViewName(instance), methodName);
            self.$el.delegate(selector, eventName, responder);
          });
          registry[signature] = true;
        });
      },

      undelegateSubviewEvents: function (instance) {
        var key = getInstanceKeyForView(instance);
        delete SUBVIEWS[key];
        var remaining = removeInstanceByViewName(instance);
        if (remaining === 0) {
          // That was the last one to detach, so we can undelegate this view's events.
          var eventName = '.delegateSubviewEvents' + this.cid + getViewName(instance);
          this.$el.undelegate(eventName);
          clearRegistryForViewName(getViewName(instance));
        }
      },

      detachEvents: function (instance) {
        instance.off('attach');
        instance.off('detach');
      }
    };

  }

  return BEventManager;

});

/* START_TEMPLATE */
BV.define('hbs!ariaAlert',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<p class=\"bv-off-screen\" role=\"alert\">";
  if (stack1 = helpers.message) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.message; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</p>";
  return buffer;
  });
Handlebars.registerPartial('ariaAlert', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview  Base view class for Firebird features. Extends Backbone.View.
 */

BV.define('framework/bview',[
  'ENV',
  'backbone',
  'underscore',
  'jquery',
  'window',
  'util/highContrast',
  'util/specialKeys',
  'framework/util/featureHelper',
  'framework/bevented',
  'framework/util/bvreporter',
  'framework/beventmanager',
  'framework/async-queue',
  'hbs!ariaAlert'
], function (
  ENV,
  Backbone,
  _,
  $,
  window,
  has,
  specialKeys,
  ftHelper,
  BEvented,
  BVReporter,
  BEventManager,
  queue,
  ariaAlertTmpl
) {

  var UNDEFINED;

  // TODO: There was some dumb stuff in here that was only used in submission
  // views. Rewrite it so that BView doesn't need to know about those special
  // cases:
  //
  // viewready event
  // formSetup method
  // cleanup method
  // ieCompat method
  // _registerFocusables

  // TODO: Haven't decided what to do about FocusManager integration.

  // BVIEW
  // =====
  //
  // (Fun fact: originally the elision of "BView" (instead of BVView) was a
  // silly stylistic thing done by Alex Sexton in the months before initial
  // Firebird launch. Then someone wrote BModel and BCollection and the
  // convention stuck. Whoops.)
  //
  // BView is our base view for features. It extends from Backbone.View but
  // behaves quite differently from a standard Backbone view.
  //
  // # CREATING A BVIEW
  //
  // Most BViews will be created programmatically by feature definitions. If
  // you need to instantiate one manually, you must pass in a `parent` option
  // that points to the view's parent in the tree. (The only exception is the
  // top view in the tree, but that should never be created manually.)
  //
  // You also must allow the BView to discover its component and model. Hence
  // you should pass EITHER a `model` option pointing to the view's model (in
  // which case it can infer its component from the model's metadata) OR a
  // `componentId` pointing to the component's unique identifier (in which
  // case it can look up its model instance through the component).
  //
  // # RENDERING A BVIEW
  //
  // By default, BViews will expect a template to reside on the `template`
  // property; specify one at subclass definition time. Typically this will
  // be a Handlebars template, but it can be any function that accepts a data
  // object and returns an HTML string.
  //
  // BView's default `toHTML` implementation is what assumes the presence of
  // a template. If you don't need a template, you can override `toHTML` to
  // return whatever you like, but it's usually easier to simply define your
  // template as a function that returns that same HTML.
  //
  // # DOING DOM THINGS
  //
  // BViews are rendered hierarchically. Hence a view's element won't exist
  // on the page until after its parent view has rendered. Unlike a standard
  // Backbone view, then, you won't be able to do DOM-related things until
  // after a view has rendered and "attached" to a DOM node.
  //
  // If you want to do something jQuery-ish to your view at the earliest
  // possible opportunity, you can listen for your view's own `attach` event
  // as described below.
  //
  // # USE `viewEl`, NOT `el`
  //
  // By Backbone convention, a view's `el` property is the container that a
  // view is rendered _into_. This means, counterintuitively, that in a view
  // hierarchy, a view and its siblings will all have their `el` properties
  // pointing to the same node.
  //
  // This is likely not what you had in mind. Instead, we define a `viewEl`
  // property which points (typically) to the root element in a view's
  // template (see the Handlebars `view` helper for specifics).
  //
  // Naturally, this property is available only after `attach` has fired. You
  // can refer to `viewEl` for the raw DOM node or `$viewEl` for the
  // jQuery-wrapped version. Or you can use Backbone's built-in `$` method,
  // which has been redefined to search within the context of `viewEl`
  // instead of `el`.
  //
  // (You can also use the presence of `viewEl` to figure out what state your
  // view is in; `if (!!this.viewEl)` is the same as saying "if this view has
  // attached...")
  //
  // Of course, `el` is still there in case you need it. Just keep in mind
  // that `this.el` is usually equal to `this.parent.viewEl` and is thus not
  // of much value.
  //
  // # RENDER vs. ATTACH
  //
  // In Backbone, a view's `render` method is typically called when a view
  // needs to change its markup. But since we have a view tree, re-rendering
  // a view also involves re-rendering all of its descendant views, and we
  // don't want each one to render itself atomically.
  //
  // Instead, we have a two-stage process. The `render` stage is how a view
  // tree (or arbitrary subtree) turns itself into HTML and inserts itself
  // into the document. The `attach` stage is how the views in that tree (or
  // subtree) find their corresponding DOM nodes within the content that was
  // inserted in the `render` stage.
  //
  // This approach means that we insert HTML into the DOM only once per
  // render, which is crucial for performance. It also allows for decoupling.
  // For instance, imagine the R&R HTML being generated server-side; we could
  // then _skip_ the render phase on the client side and go straight to the
  // attach phase without much complication.
  //
  // If your view needs to do something clever in the render phase, please
  // have it override `_render` instead of `render` or `renderAsync`. The
  // latter two methods are facades that invoke `_render` with synchronous or
  // asynchronous behavior, respectively.
  //
  // You can override `attach` if you like, though it's preferred that you
  // hook into the `attach` event instead if it's possible.


  // So that we get subscribe/unsubscribe and publish.
  var BaseView = Backbone.View.extend(BEvented);
  BaseView.config = ENV.get('config');

  var BView = BaseView.extend({

    /// PROPERTIES

    // Events that should get attached to every view. Don't put something
    // here unless you know exactly what you're doing.
    events: {
      'click button, input[type="submit"]': '_preventSubmit',
      'keydown .bv-focusable': '_keyboardNavigate'
    },

    // All BViews should define a name that corresponds to the feature they
    // represent.
    name: null,

    // Optionally include an array of i18n message packs at definition time.
    // Any such packs will be made available within the view's template.
    msgpacks: null,

    // Should be a function that takes an object of data as an argument and
    // returns a string of HTML. Used in `toHTML`.
    template: function () {
      BVReporter.assert(false, 'No template defined for view ' + this.name + '!');
    },

    // Whether this view is acting as an event manager.
    //
    // This boolean can be specified at definition time and will be considered
    // when initializing the view. After initialization, if `isEventManager`
    // is true, then this view has mixed in the methods defined in
    // BEventManager. See beventmanager.js for more information.
    isEventManager: false,

    /// PUBLIC

    constructor: function (opts) {
      // If there is an `el` property defined in the class, ignore the `el`
      // option. This allows a subview to specify a strict injection point in
      // its class definition.
      //
      // TODO: Investigate whether this is a useful feature.
      //
      // This won't plausibly be pointing to a DOM node at definition time.
      // It can point to a CSS selector, but given our architecture, that
      // selector (a) is unlikely to match anything; (b) is likely to match
      // the _wrong_ thing, should a match somehow be found.
      //
      // There are a few views that seem to specify non-standard injection
      // points in the form of CSS selector strings, but apparently without
      // the desired effect.
      if (this.el && opts.el) {
        delete opts.el;
      }
      return Backbone.View.prototype.constructor.call(this, opts);
    },

    initialize: function (opts) {
      BVReporter.assert(function () { return [_.isObject(opts), 'opts is object']; });
      BVReporter.debug('View', this.name, 'initializing');

      var self = this;
      var modelName = ftHelper.getFullName(this.name, opts.featureType, opts.instanceName);

      this.parent = opts.parent || {};

      // TODO: I hate this. It's only used in `ratingItem`, but if I remove
      // it I've got to figure out how to pass that information to
      // `ratingItem` other than through a parent chain.
      this.containerPrefix = this.parent.containerPrefix;

      // TODO: I hate this, too. We don't seem to use it anywhere. We should
      // either remove it OR ensure that it gets read by the `view`
      // Handlebars helper, which currently hardcodes "bv-" in a few places.
      this.classPrefix = ENV.get('classPrefix');

      // If the componentId wasn't specified in the options, we can still
      // grab it from the model below.
      this.componentId = opts.componentId;

      // This allows us to define members of these collections both at
      // definition time and at creation time.
      this.classList = (this.classList || []).concat(opts.classList || []);
      this.seoTagList = (this.seoTagList || []).concat(opts.seoTagList || []);

      // The `viewAlias` option lets a view use a different name for itself
      // in a template than it does in an instance. Thus a view that has two
      // subviews of the same type can nonetheless distinguish them by name
      // -- e.g., if they should be mounted in different places.
      this.viewAlias = opts.viewAlias;

      // The `instanceName` option lets two copies of the same type of
      // feature coexist without confusion.
      this.instanceName = opts.instanceName;

      // Base HTML tag will probably be specified by the template, but retain
      // the ability to specify at view definition time.
      this.tag = opts.tag;

      // Find our model if it wasn't given to us in the options.
      this._assignModel(modelName);

      // Copy some properties over from the model for convenience.
      this._loadPropertiesFromModel();

      // We can't proceed if we don't know which component this view belongs to.
      BVReporter.assert(this.componentId, 'View ' + this.name + ' must have componentId');

      // Are we the top view in the tree?
      this.isTopView = opts.isTopView;

      var featureName;
      if (this.model) {
        // Figure out which name refers to our view in the feature definition.
        if (this.isTopView || this.model === this.getTopModel()) {
          // This means we're the top view of a particular component. (The
          // second half of this conditional is a workaround for contentSort
          // views, which technically are the top views of their own
          // components but are duct-taped onto contentList views.)
          featureName = 'self';
        }
        else if (this.model.get('parent') || this.model.isCollection) {
          featureName = ftHelper.getName(modelName);
        }
        else {
          BVReporter.assert(false, 'can\'t derive model name for view:', this.name);
        }
      }

      if (this.model) {
        this.readOnly = !!this.getComponent().readOnly;
      }

      // If we defined this view as an event manager, force it to be one.
      //
      // The `force` flag is needed because hereafter `isEventManager` means
      // "has been made an event manager," not "has been defined to be an
      // event manager." Hence `_actAsEventManager` will typically return
      // early if `isEventManager` is true. Here, though, we know that the
      // mixin hasn't happened yet, so we should force it to happen.
      if (this.isEventManager) {
        this._actAsEventManager(true);
      }

      // If it's the top view, it _must_ be the event manager.
      if (this.isTopView) {
        this._actAsEventManager();
        this.getComponent().setTopView(this);

        // Special case for high-contrast mode.
        // TODO: Can this be moved to a template?
        if (has('high-contrast')) {
          // Schedule this to run as soon as we have a DOM node.
          this.on('attach', function (self) {
            self.$viewEl.closest('.bv-cv2-cleanslate').addClass('bv-highcontrast');
          });
        }
      }

      // Initialize our subviews, should we have any.
      this._setupSubviews(opts, featureName);

      this.getComponent().registerView(this);

      // We tell subclasses to define an `init` method instead of
      // `initialize` so that this `initialize` method isn't overridden by
      // accident.
      if (_.isFunction(this.init)) {
        this.init.apply(this, arguments);
      }
    },

    /**
     *  Creates this view's subviews based on the feature definition.
     *
     *  Override this method if you need to change the way that feature views
     *  get created, or if you need to do something immediately before or
     *  after subview creation.
     *
     *  @param {Object} features An object representing the component's
     *    feature definition.
     *  @param {String} featureName The name used in the feature definition for
     *    this feature.
     *  @param {Object} mappings An object that maps feature names to their
     *    model/view class references.
     *  @returns {Array} An array of the subviews that were created.
     */
    createFeatureViews: function (features, featureName, mappings) {
      BVReporter.assert(function () { return [_(features).isObject(), 'features is object']; });
      BVReporter.assert(function () { return [_(featureName).isString(), 'featureName is string']; });
      BVReporter.assert(function () { return [_(mappings).isObject(), 'mappings is object']; });
      BVReporter.debug('View', this.name, 'creating feature views');

      // Derive our subviews from the environment feature definitions.
      var views = [];
      var allFeatures = ftHelper.getFeaturesForInstance(features[featureName], this.contentType, this.instanceName);

      _(allFeatures).each(function (name) {
        var type = ftHelper.getType(name);
        var instanceName = ftHelper.getInstanceName(name);

        var feature = mappings[ftHelper.getName(name)];
        var FeatureView;
        if (feature.view) {
          FeatureView = feature.view;
          views.push(new FeatureView({
            parent: this,
            featureType: type,
            instanceName: instanceName,
            componentId: this.componentId
          }));
        }
      }, this);
      return views;
    },

    // TODO: Figure out how to replace this.
    //
    // I hate `formSetup` because (a) it's only called in certain views, and
    // not as a standard part of the view life cycle; (b) I can't easily
    // remove it from `BView` because we appear to take advantage of its
    // existence on all views.
    //
    // It gets called after a view attaches, so one solution would be to move
    // the stuff in `formSetup` methods into handlers on the `attach` event.
    // But this is non-trivial.
    formSetup: function (dataMixin) {
      // By default, all this does is call `formSetup` on its children.
      _(this.views).invoke('formSetup', dataMixin);
    },

    /**
     *  A callback that executes when a view's model is done processing its
     *  data. Empty by default.
     *
     *  Collection views use this callback to initialize their items' views.
     */
    modelDataReady: $.noop,

    /**
     *  Tests whether this view has a feature with the given name and type.
     *
     *  @param {String} featureName The name of the feature to test.
     *  @param {String} featureType The type of the feature to test; optional.
     *  @returns {Boolean} Whether the feature is defined on this view.
     */
    hasFeature: function (featureName, featureType) {
      var component = this.getComponent();
      return component.hasFeature(this.getRefName(), featureName, this.contentType, this.instanceName, featureType);
    },

    /**
     *  Finds the first subview (or descendant view) with the given name,
     *  starting with this view.
     *
     *  @param {String} featureName The name of the feature to find.
     *  @return {BView} The BView instance for the given feature.
     */
    getFeatureView: function (featureName) {
      if (this.name === featureName) {
        return this;
      }
      if (_.isEmpty(this.views)) {
        return null;
      }

      var i;

      // First check only this view's subviews.
      for (i = 0; i < this.views.length; i++) {
        if (this.views[i].name === featureName) {
          return this.views[i];
        }
      }

      // We didn't find it, so we'll have to check all our subviews'
      // descendant views.
      for (i = 0; i < this.views.length; i++) {
        var childFeature = this.views[i].getFeatureView(featureName);
        if (childFeature) {
          return childFeature;
        }
      }

      return null;
    },

    // We make this a no-op because Backbone tries to call it in its own
    // constructor, and we've chosen to handle event delegation manually.
    delegateEvents: $.noop,

    /**
     *  Get this view's component.
     *  @returns {BComponent}
     */
    getComponent: function () {
      if (this.model) {
        // Easy; we delegate to the model.
        return this.model.getComponent();
      }
      else if (this.componentId) {
        // We don't have a model (or don't have one yet), but we have the
        // information we need to look up our component.
        if (!this._component) {
          this._component = ENV.get('componentManager').find(this.componentId);
        }
        return this._component;
      }

      // Otherwise we don't have a component.
      BVReporter.assert(false, 'cannot get component; no model or componentId');
    },

    /**
     *  Get the model at the top of the tree for this view's component.
     *  @returns {BModel}
     */
    getTopModel: function () {
      BVReporter.assert(this.model, 'model property is required to get top model');
      return this.model.getTopModel();
    },

    /**
     *  Get the ref name (the name used for this view in a feature
     *  definition).
     *  @returns {String}
     */
    getRefName: function () {
      BVReporter.assert(this.model, 'model property is required to get ref name');
      return this.model.getRefName();
    },

    /**
     *  Ask this view to serialize its subviews to HTML.
     *
     *  @param {Object} dataMixin An optional object of data to pass to each
     *    subview's template.
     *  @param {Boolean} isAsync Whether serialization should be done
     *    asynchronously.
     *  @returns {$.Deferred.promise} A promise that will resolve with the
     *    data this view will need to do its own serialization.
     */
    serializeSubviews: function (dataMixin, isAsync) {
      BVReporter.debug('View', this.name, 'serializing subviews');
      if (!_.isObject(dataMixin)) {
        dataMixin = {};
      }

      var viewList = dataMixin.viewList || [];
      var subviews = dataMixin._subview || {};
      var self = this;

      var data = {};

      if (this.collection) {
        data = this.collection.toJSON();
      }
      else if (this.model) {
        data = this.model.toJSON();
      }
      else {
        BVReporter.log('no collection or model found', this);
      }

      // User-specified data should be able to trump model data (but not the
      // view metadata specified below).
      _(data).extend(dataMixin);

      // Add some metadata about this view that will be needed by certain
      // Handlebars helpers.
      data._bview = this._getViewMetadata();

      // Collect all the promises returned by our subviews.
      var subviewPromises = _(this.views).map(function (v) {
        viewList.push({
          viewIndex: v.cid,
          viewName: v.viewAlias || v.name,
          viewInstanceName: v.instanceName,
          component: v.componentId,
          contentType: v.contentType
        });

        var subviewDfd = $.Deferred();
        var viewToHTML = v.toHTML(null, isAsync);

        $.when(viewToHTML).done(function (html) {
          subviews[v.cid] = html;
          subviewDfd.resolve();
        });

        return subviewDfd.promise();
      });

      var dfd = $.Deferred();

      // When all subviews are done serializing themselves...
      $.when.apply($, subviewPromises).done(function () {
        // (special case for deep merging of subviews)
        _.extend(subviews, dataMixin._subview || {});

        // add their assembled data to ours...
        data._subview = subviews;
        data.viewList = viewList;
        data.viewName = self.templateName || self.name;

        self.subviewsInitialized = true;

        // ...and resolve.
        dfd.resolve(data);
      });

      return dfd.promise();
    },

    /**
     *  Behaves like jQuery's `$` function, but is scoped to this view's
     *  element (`viewEl`). Shorthand for `this.$viewEl.find`.
     *
     *  This overrides Backbone's default `$` method on views, which is
     *  scoped to the view's `$el` property. This is the wrong behavior for
     *  our purposes and runs the risk of matching elements outside of our
     *  view.
     *
     *  Will throw an error if called before this view is attached (or after
     *  it has been detached).
     *
     *  @param {String} selector The CSS selector to search for.
     *  @returns {$} A jQuery object.
     */
    $: function (selector) {
      BVReporter.assert(this.viewEl, 'View must be attached to use $ method!');
      return this.$viewEl.find(selector);
    },

    /**
     *  Serialize this view to HTML.
     *
     *  @param {Object} dataMixin An optional object of data to pass to this
     *    subview's template.
     *  @param {Boolean} isAsync Whether serialization should be done
     *    asynchronously.
     *  @returns {String|$.Deferred.promise} An HTML string when called with
     *    one argument; a promise that will resolve with an HTML string when
     *    called with two arguments.
     */
    toHTML: function (dataMixin, isAsync) {
      BVReporter.debug('View', this.name, 'doing toHTML', isAsync ? '(async)' : '');

      if (isAsync) {
        BVReporter.info('View', this.name, 'rendering asynchronously');
      }

      var self = this;
      dataMixin = dataMixin || {};

      // Collect all the i18n message packs for this view and flatten them
      // into one object.
      var msgpacks = {};

      if (this.msgpacks) {
        for (var i = 0, len = this.msgpacks.length; i < len; i++) {
          _.extend(msgpacks, this.msgpacks[i]);
        }
      }

      if (!_.isEmpty(msgpacks)) {
        dataMixin.msgpack = msgpacks;
      }

      dataMixin.viewTag = this.tag;

      var subviewPromise = this.serializeSubviews(dataMixin, isAsync);
      var dfd = $.Deferred();

      // The bulk of the cost of serialization is paid when we actually
      // render the handlebars template. If we're supposed to be async, let's
      // put our rendering task in a queue that can manage the rate at which
      // we pay down that cost.
      $.when(subviewPromise).done(function (data) {
        var serialize = function () {
          var html = self.template(data);
          dfd.resolve(html);
        };

        // In case we're debugging in Safari or Chrome, this is nice to have.
        serialize.displayName = 'Template for ' + this.name + ' ' + this.uniq;

        if (isAsync) {
          queue.push(serialize);
        }
        else {
          // If we're not async, just call the function and the promise will
          // resolve immediately.
          serialize();
        }
      });

      if (arguments.length < 2) {
        // Preserve the original contract of `toHTML` and return the actual
        // HTML rather than a promise. In this scenario we're guaranteed to
        // be synchronous, so this is safe to do.
        var returnValue;
        dfd.done(function (html) {
          returnValue = html;
        });
        return returnValue;
      }
      else {
        return dfd.promise();
      }
    },

    /**
     *  Returns a CSS selector that uniquely identifies this view's
     *  corresponding DOM node.
     *  (Example: '[data-bv-v="contentList:10"]')
     *  @returns {String}
     */
    selector: function () {
      var attr = 'data-' + this.classPrefix + 'v';
      var val = this.name + ':' + this.uniq;
      return '[' + attr + '="' + val + '"]';
    },

    /**
     *  Serializes this view to HTML and inserts that HTML in the view's
     *  proper place on the page. Asynchronous.
     *
     *  This view SHOULD NOT be overridden in subviews; override `_render`
     *  instead.
     *
     *  @param {Element} elToAttach An element to render this view into.
     *    Optional.
     *  @returns {$.Deferred.promise} A promise that resolves when the view
     *    is done rendering.
     */
    renderAsync: function () {
      return this._render(true);
    },

    /**
     *  Serializes this view to HTML and inserts that HTML in the view's
     *  proper place on the page. Synchronous.
     *
     *  This view SHOULD NOT be overridden in subviews; override `_render`
     *  instead.
     *
     *  @param {Element} elToAttach An element to render this view into.
     *    Optional.
     *  @returns {BView} Itself.
     */
    render: function () {
      var returnValue;
      this._render(false).done(function (value) {
        returnValue = value;
      });
      return returnValue;
    },


    /**
     *  Associates a view with its current DOM node and attaches its events.
     *
     *  Fires an "attach" event. If you need to run some code when a view
     *  attaches, hook into this event instead of overriding the `attach`
     *  method.
     *
     *  @param {Element} element The element that should be the view's new
     *    `el` property. Optional.
     *  @returns {BView} Itself.
     */
    attach: function (element) {
      if (!ENV.get('cssIsLoaded')) {
        BVReporter.warn('View', this.name, 'tried to attach before CSS loaded!');
        return;
      }

      if (element) {
        BVReporter.assert(_.isElement(element), 'element must be a DOM element');
      }

      BVReporter.group(BVReporter.LOG, 'View', this.name, 'attaching');

      // This is the only place in this entire file that we explicitly set a
      // view's element.
      //
      // The `el` property, in Backbone, is the element that a view is
      // _rendered into_; hence it can't be generated by the view's `render`
      // method. Thus all views in a tree implicitly have their `el`
      // properties set to their parent's view element.
      //
      // We only actually use the `el` property in two places:
      //
      // 1. If we tell a view to re-render, and we can't find its existing
      //    view element, we'll just append to `el` instead of doing a swap.
      //    But we could just as easily append to `this.parent.viewEl`.
      // 2. We find a view's `viewEl` property through a jQuery `find` scoped
      //    to `el`. (Since the selector should be unique on the page, we
      //    don't have to do this. TODO: Write code such that we can
      //    gracefully recover when we don't find our `viewEl` where we think
      //    it should be.)
      //
      // We don't use it for delegation; BEventManager handles that. And we don't
      // use it for `this.$`; that's redefined above.
      //
      // Therefore, it's _theoretically_ possible to eliminate the `el` property
      // entirely -- or, rather, to redefine it to mean `viewEl`.
      //
      // TODO: Pull this off.
      if (element) {
        this.setElement(element);
      }

      // Use the selector to find the correct element for this view.
      var $viewEl = this.$el.find(this.selector());

      if (!$viewEl.length) {
        // If we can't find one, then something weird is happening. Let the
        // developer know.
        //
        // TODO: There are legitimate reasons why this could happen, which is
        // why we don't throw an error here. Find a way to weed out the
        // legitimate reasons so that this warning cries wolf less often.
        BVReporter.warn(
          'View',
          this.name,
          'could not find a content element. A view might be rendering before its parents are ready.'
        );
      }

      this.$viewEl = $viewEl;
      this.viewEl = $viewEl[0];

      // We want the events specified above to propagate to subclasses
      // without the subclasses having to do anything special.
      var defaultEvents = _.clone(BView.prototype.events);
      this.events = _(defaultEvents).extend(this.events);

      // Backbone's event delegation would find our `$el` property (which
      // points to our parent's $viewEl) and delegate events from there.
      // Instead, we find our most distant ancestor in the view tree whose
      // element is also a DOM ancestor of our element and we delegate from
      // there.
      //
      // This lets us more efficiently screen for redundant handlers, like
      // when there are 8 review contentItems and they all try to attach the
      // same handlers. See the BEventManager documentation for more info.
      var eventManager = this.getEventManager();
      eventManager.delegateSubviewEvents(this);

      // Call `attach` on our subviews.
      _(this.views).each(function (subview) {
        // If a subview is acting as its own event manager, it's probably
        // being rendered elsewhere. Don't attach it again and potentially
        // mess it up.
        if (!subview.isEventManager) {
          subview.attach(this.viewEl);
        }
      }, this);

      // IMPORTANT NOTE: See the long comment in #render() relating to why
      // this is called here for event managers only.
      if (this.isEventManager) {
        this._setButtonOnclickReturnFalse();
      }

      // Trigger an event to let everyone know that this view now has a DOM
      // node.
      //
      // If your view needs to do something as soon as it has a DOM node, add
      // a handler for the "attach" event instead of overriding the `attach`
      // method in your subclass.
      this.trigger('attach', this);

      BVReporter.groupEnd(BVReporter.LOG, 'View', this.name, 'attaching');

      return this;
    },

    /**
     *  Remove DOM event handlers from this view and its subviews. Happens
     *  before a view is moved or removed.
     *
     *  Fires a "detach" event. If you need to run some code when a view
     *  detaches, hook into this event instead of overriding the `detach`
     *  method.
     *
     *  @returns {BView} Itself.
     */
    detach: function () {
      BVReporter.debug('View', this.name, 'detaching');

      var eventManager = this.getEventManager();
      eventManager.undelegateSubviewEvents(this);

      this.$viewEl = this.viewEl = null;

      _.invoke(this.views, 'detach');
      this.trigger('detach', this);

      return this;
    },

    /**
     *  Removes a view's element from the DOM and stops listening to any
     *  Backbone events that the view has attached.
     *
     *  Also calls `remove` on all its subviews.
     *
     *  Fires a "remove" event.
     *
     *  @returns {BView} Itself.
     */
    remove: function () {
      if (this.isTopView) {
        BVReporter.group(BVReporter.DEBUG, 'Removing top view' + this.getScope());
      }

      if (this.$viewEl) {
        this.$viewEl.remove();
      }

      this.detach();
      this.stopListening();

      this.off('attach');
      this.off('detach');

      _(this.views).invoke('remove');

      if (this.isTopView) {
        BVReporter.groupEnd(BVReporter.DEBUG);
      }
      return this;
    },

    /**
     *  Finds a view's "event manager" -- the view that its event handlers
     *  will attach to.
     *
     *  As opposed to the Backbone default (a view's `$el` property), this
     *  will be the view's most distant ancestor in the view tree whose DOM
     *  node is also an ancestor of this view's DOM node.
     *
     *  If no view meets those criteria, this view will become an event
     *  manager (thus managing its own events), and will be the implicit
     *  event manager for all its descendant views.
     *
     *  A view acting as an event manager is augmented with special methods
     *  for event delegation.
     *
     *  @returns {BView} The event manager view (either this view or one of
     *    its ancestors).
     */
    getEventManager: function () {
      if (this.isEventManager) {
        BVReporter.log('View', this.name, 'is acting as its own event manager.');
        return this;
      }

      // Look up the view tree until we find an ancestor that is an event
      // manager.
      var view = this;
      while (view) {
        view = view.parent;
        if (view && view.isEventManager) {
          BVReporter.log('View', this.name, 'found an event manager:', view.getScope());
          return view;
        }
      }

      // If we get this far, there's no event manager in our hierarchy. We
      // should act as an event manager for any of our subviews.
      BVReporter.log('View', this.name, 'found no event manager, so it is becoming an event manager.');
      this._actAsEventManager();
      return this;
    },

    /**
     *  Get the scope of the view's component.
     *
     *  (Example: "BVRRContainer[reviewContentList1<Reviews>]")
     *
     *  @returns {String}
     */
    getScope: function () {
      return this.getComponent().getScope(this.contentType);
    },

    /**
     *  "Display" a message that should be read aloud by a screen reader. We
     *  do this by appending an off-screen element as an ARIA live region.
     *
     *  @param {String} alertText The text that should be read aloud.
     *  @returns {$} The jQuery wrapper for the element that was injected.
     */
    showAriaAlert: function (alertText) {
      var $alert = $(ariaAlertTmpl({ message: alertText }));
      this.$viewEl.append($alert);
      return $alert;
    },

    /// PROTECTED

    /**
     *  Renders a view.
     *
     *  This method should not be called directly, but it's documented
     *  because it is the defined override point for the render process. Your
     *  view should try very hard not to override this method, but if it
     *  can't be helped, you should be overriding this method instead of
     *  `render` or `renderAsync`.
     *
     *  If you override this method, you are not necessarily obligated to
     *  respect the `isAsync` argument. But if you render asynchronously in
     *  all cases, even when `isAsync` is `false`, you'll be violating the
     *  contract of the `render` method, which assumes that the view will
     *  have been rendered before the next line of code executes.
     *
     *  On the other hand, if you choose to render synchronously in all
     *  cases, even when `isAsync` is `true`, then you won't be breaking any
     *  contracts.
     *
     *  Either way, however, note that your `_render` method MUST return a
     *  promise.
     *
     *  @param {Boolean} isAsync Whether this view should render
     *    asynchronously.
     *  @returns {$.Deferred.promise} A promise that will resolve when the
     *    rendering is done.
     */
    _render: function (isAsync) {
      var dfd = $.Deferred();
      var self = this;

      if (!ENV.get('cssIsLoaded')) {
        // This shouldn't happen. Bail early.
        BVReporter.warn('View', this.name, 'tried to render before CSS loaded!');
        // All paths taken through this method _must_ return a promise.
        //
        // TODO: Investigate whether it's ideal behavior to return early here
        // without scheduling a retry.
        dfd.resolve();
        return dfd.promise();
      }

      if (this.isTopView) {
        BVReporter.group(BVReporter.INFO, 'Rendering top view', this.getScope());
      }

      // TODO: Account for serverRender?

      this.toHTML(null, isAsync).done(function (html) {
        // If we don't have a $viewEl, or our $viewEl is no longer on
        // the page, see if we can find a new one.
        if (!self.$viewEl || !self.$viewEl.closest('html').length) {
          self.$viewEl = self.$el.find(self.selector());
        }

        // Either way, replace the existing $viewEl with our
        // newly-rendered one.
        if (self.$viewEl.length > 0) {
          self.$viewEl.replaceWith(html);
        }
        else {
          // Or, if we didn't find a $viewEl, just append to the parent.
          self.$el.append(html);
        }

        var returnValue = self.attach();

        // This is something we do here for convenience, but it quickly became a pain.
        //
        // Here we ensure that buttons are set with onclick="return false;".
        //
        // But this can get expensive if done once at every level of a view tree
        // for all descendants. So we're trying to be a little smarter about
        // this and not call it more than is needed. Only call it at the top
        // level of a view after it has created its DOM elements, or for the
        // rerender of a section of a view.
        //
        // We call this here and in #attach(). Note that #render() always calls
        // #attach() as above, but #attach can be called on its own in some
        // circumstances. Most top level views are (and should be) event
        // managers.
        //
        // Scenarios:
        //
        // 1) #isEventManager = true, #render() is invoked.
        //
        // Typical behavior that happens at the top of a view tree.
        // #_setButtonOnclickReturnFalse() called in #attach().
        //
        // 2) #isEventManager = false, #render() is invoked.
        //
        // Rerender of a subview somewhere down in the depths of a view tree.
        // #_setButtonOnclickReturnFalse() called in #render().
        //
        // 3) #isEventManager = true, #attach() is invoked without #render().
        //
        // Odd behavior that nonetheless can happen for disjoint views, and we
        // do need to handle correctly.
        // #_setButtonOnclickReturnFalse() called in #attach().
        //
        // 4) #isEventManager = false, #attach() is invoked without #render().
        //
        // All subviews have #attach() called when #attach() is called for a
        // parent view, so this happens all the time. This is the scenario
        // under which we don't want to make lots of attempts to set the button
        // onclick attributes.
        // #_setButtonOnclickReturnFalse() is not called.
        //
        if (!self.isEventManager) {
          self._setButtonOnclickReturnFalse();
        }

        if (self.isTopView) {
          BVReporter.groupEnd(BVReporter.INFO, 'Rendering top view');
        }

        dfd.resolve(returnValue);
      });

      return dfd.promise();
    },

    /// PRIVATE

    // We override this Backbone method because we don't want to mandate that
    // an element exist this early in the view's lifecycle.
    //
    // Instead, this will set the element to `undefined` except in the rare
    // case (well, rare for _us_) that the user has specified an `el` at
    // definition time.
    _ensureElement: function () {
      this.setElement(this.el);
    },

    // Needed for iOS, where `return false` apparently doesn't work on
    // buttons.
    _preventSubmit: function (event) {
      if (!$(event.target).is('.bv-submit')) {
        event.preventDefault();
      }
    },

    // Listen for keypresses so we can guess at whether the user is using
    // their keyboard as their primary means of navigation.
    _keyboardNavigate: function (event) {
      if (event.keyCode === specialKeys.ENTER || event.keyCode === specialKeys.TAB) {
        ENV.set('keyboardMode', true);
      }
    },

    // Mixin the methods needed for this view to act as an event delegation
    // target.
    _actAsEventManager: function (force) {
      if (this.isEventManager && !force) { return; }
      this.isEventManager = true;
      _.extend(this, BEventManager(this));
    },

    // Tries to figure out what this view's model should be if it wasn't
    // specified in the options.
    _assignModel: function (modelName) {
      if (this.model) {
        // Already have one.
        return;
      }
      if (!this.parent.model || !this.parent.model.subModels) {
        // We can't look it up through our parent.
        return;
      }

      var m = this.parent.model.subModels[modelName];
      if (!m) {
        // We couldn't find our model on our parent.
        return;
      }
      this.model = m;
    },

    // Copy some properties from the model to the view for convenience. This
    // also saves us from redundancy on view creation; we won't have to
    // specify any of these things as long as we pass in the model.
    _loadPropertiesFromModel: function () {
      if (!this.model) { return; }
      var isCollection = this.model.isCollection;
      _([
        'subjectType',
        'componentId',
        'contentType',
        'secondaryContentType',
        'coverageContentTypes',
        'submissionContentTypes',
        'clientAPIConfig',
        'component',
        'outlets',
        'dimsumConfig'
      ]).each(function (key) {
        this[key] = isCollection ? this.model[key] : this.model.get(key);
      }, this);

      this.model.onDataProcessed(this.modelDataReady, this);
    },

    // Figures out whether we're using a passed-in set of views or creating
    // our own subviews based on the feature definition.
    _setupSubviews: function (opts, featureName) {
      var component = this.getComponent();
      var mappings = ENV.get('mappings');
      var views;

      this.uniq = ++component.viewUniq;

      if (opts.views) {
        // Use the subviews that were passed in at initialization.
        this.views = opts.views;
      }
      else if (component && component.features && component.features[featureName]) {
        // Create subviews based on the feature definition.
        this.views = [];
        views = this.createFeatureViews(component.features, featureName, mappings);
        if (views.length > 0) {
          this.views = this.views.concat(views);
        }
        else {
          this.views = UNDEFINED;
        }
      }
    },

    // Generates some metadata that is useful within templates.
    _getViewMetadata: function () {
      var data = {
        viewId: this.uniq,
        classList: this.classList,
        name: this.name,
        component: this.getComponent(),
        contentType: this.contentType,
        refName: this.getRefName(),
        seoTagList: this.seoTagList,
        instanceName: this.instanceName
      };

      if (this.parent && this.parent.uniq) {
        data.parentViewId = this.parent.uniq;
      }
      return data;
    },

    _setButtonOnclickReturnFalse: function () {
      // Deferring seems to improve render time slightly.
      // replace attr() with click() method to fix CSP issue (see UIA-9272, CCS-34125)
      _.defer(function ($el) {
        $el.find('button, input[type="submit"]').
          not('.bv-submit').
          click(
            function(e) {
              e.preventDefault();
            }
          );
      }, this.$el);
    }

  });

  return BView;
});

/* START GENERATED MESSAGE */
BV.define('_i18n_anonymousContentAuthorPreview', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function anonymousContentAuthorPreview( data ) {
try { return (function(d){
var r = "";
r += "you";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `anonymousContentAuthorPreview`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_anonymousContentAuthorPreview', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return anonymousContentAuthorPreview(data);
});
return anonymousContentAuthorPreview;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_anonymousContentAuthor', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function anonymousContentAuthor( data ) {
try { return (function(d){
var r = "";
r += "Anonymous";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `anonymousContentAuthor`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_anonymousContentAuthor', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return anonymousContentAuthor(data);
});
return anonymousContentAuthor;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorInner',['hbs','vendor/handlebars/runtime','hbs!contentAuthorNameLink', 'hbs!contentAuthorNameNormal', 'hbs!contentAuthorNameSpan', 'template/helpers/notEqual', 'template/helpers/schemaType', 'template/helpers/ifHasFeature', 'template/helpers/mountView', 'template/helpers/equals', '_i18n_anonymousContentAuthorPreview', '_i18n_anonymousContentAuthor'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName), {hash:{},inverse:self.program(16, program16, data),fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Department), {hash:{},inverse:self.noop,fn:self.program(21, program21, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.Type, "clientresponse", options) : helperMissing.call(depth0, "notEqual", depth0.Type, "clientresponse", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "avatar", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "avatar", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "avatar", depth0, options) : helperMissing.call(depth0, "mountView", "avatar", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.program(12, program12, data),fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "fullProfileLink", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "fullProfileLink", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(14, program14, data),fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.viewName, "avatarPopup", options) : helperMissing.call(depth0, "notEqual", depth0.viewName, "avatarPopup", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.isSyndicated, {hash:{},inverse:self.program(12, program12, data),fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.showProfileLink), {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorNameLink, 'contentAuthorNameLink', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorNameNormal, 'contentAuthorNameNormal', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  stack1 = self.invokePartial(partials.contentAuthorNameSpan, 'contentAuthorNameSpan', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-author bv-content-author-name-anonymous\" itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> ";
  stack2 = helpers['if'].call(depth0, depth0._isPreview, {hash:{},inverse:self.program(19, program19, data),fn:self.program(17, program17, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }
function program17(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  if (stack1 = helpers._i18n_anonymousContentAuthorPreview) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_anonymousContentAuthorPreview; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program19(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  if (stack1 = helpers._i18n_anonymousContentAuthor) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_anonymousContentAuthor; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program21(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.Type, "clientresponse", options) : helperMissing.call(depth0, "equals", depth0.Type, "clientresponse", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program22(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span class=\"bv-author bv-content-author-department\">"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Department)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span class=\"bv-author bv-content-author-department\">&nbsp;<span>&middot;</span> "
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Department)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.ResponseSource, "Review Response", options) : helperMissing.call(depth0, "notEqual", depth0.ResponseSource, "Review Response", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorInner', t);
t.deps = ["contentAuthorNameLink","contentAuthorNameNormal","contentAuthorNameSpan"];
t.tplMountedViews = ['avatar'];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/notEqual',['vendor/handlebars/runtime'], function (Handlebars) {

  // The opposite of `#equals`.
  //

  function notEqual (a, b, options) {
    if (a !== b) {
      return options.fn(this);
    }
    else {
      return options.inverse(this);
    }
  }

  Handlebars.registerHelper('notEqual', notEqual);
  return notEqual;
});

BV.define('template/helpers/schemaType',['vendor/handlebars/runtime'], function (Handlebars) {
  function schemaType (key, options) {
    // Usage: {{schemaType Type comment="creator" def="author"}}
    // pass in key and possible values via options, accepts a default of def.
    // no default and no match will return blank
    return options.hash[key] ? options.hash[key] : (options.hash.def ? options.hash.def : '');
  }

  Handlebars.registerHelper('schemaType', schemaType);
  return schemaType;
});

/* START_TEMPLATE */
BV.define('hbs!contentAuthorNameLink',['hbs','vendor/handlebars/runtime', 'template/helpers/notEqual', 'template/helpers/schemaType'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"";
  return buffer;
  }

  buffer += "<button type=\"button\" class=\"bv-author bv-fullprofile-popup-target bv-focusable\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.viewName, "contentAuthorProfileInline", options) : helperMissing.call(depth0, "notEqual", depth0.viewName, "contentAuthorProfileInline", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "> <h3>"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h3> </button> ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorNameLink', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
(function () {
  // Checks if two arguments are identical, with `===` semantics.
  //
  // EXAMPLES:
  //
  // (given data: { foo: '1', bar: 1, baz: null, thud: 1 })
  //
  // {{#equals bar thud}}  evaluates true.
  // {{#equals foo bar}}   evaluates false.
  // {{#equals baz blerg}} evaluates false (because null !== undefined).
  //
  function equals (a, b, options) {
    if (a === b) {
      return options.fn(this);
    }
    else {
      return options.inverse(this);
    }
  }

      BV.define('template/helpers/equals',['vendor/handlebars/runtime'], function (hbs) {
      hbs.registerHelper('equals', equals);
      return equals;
    });
    })();

/* START_TEMPLATE */
BV.define('hbs!contentAuthorNameNormal',['hbs','vendor/handlebars/runtime', 'template/helpers/equals', 'template/helpers/notEqual', 'template/helpers/schemaType'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  
  return "<h2 ";
  }

function program3(depth0,data) {
  
  
  return "<div class=\"bv-author\"><span ";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"";
  return buffer;
  }

function program7(depth0,data) {
  
  
  return "</h2>";
  }

function program9(depth0,data) {
  
  
  return "</div></span>";
  }

  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.viewName, "fullProfile", options) : helperMissing.call(depth0, "equals", depth0.viewName, "fullProfile", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " class=\"bv-author\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.viewName, "contentAuthorProfileInline", options) : helperMissing.call(depth0, "notEqual", depth0.viewName, "contentAuthorProfileInline", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += ">"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  options = {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.viewName, "fullProfile", options) : helperMissing.call(depth0, "equals", depth0.viewName, "fullProfile", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorNameNormal', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorNameSpan',['hbs','vendor/handlebars/runtime', 'template/helpers/schemaType'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";


  buffer += "<span class=\"bv-author bv-fullprofile-popup-target\" itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> <h3>"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h3> </span> ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorNameSpan', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/ifHasFeature',[
  'underscore',
  'vendor/handlebars/runtime'
], function (_, Handlebars) {

  // Evaluates the content within the block _if_ the component has the given
  // feature. Useful for small things (like `has:` features) that don't
  // warrant having their own feature logic.
  //
  function ifHasFeature () {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];

    var featureName = args[0];
    var data = args.length === 2 ? this : args[1];

    if (!_(options.hash).isEmpty()) {
      _(data).extend(options.hash);
    }

    var result = !Handlebars.Utils.isEmpty(featureName) &&
                  data._bview.component.hasFeature(data._bview.refName, featureName, data._bview.contentType, data._bview.instanceName);

    if (result) {
      return options.fn(data);
    }
    else {
      return options.inverse(data);
    }
  }

  Handlebars.registerHelper('ifHasFeature', ifHasFeature);
  return ifHasFeature;
});

BV.define('template/helpers/mountView',['vendor/handlebars/runtime'], function (Handlebars) {

  // Reach into a view's subviews, grab the first view found with a given
  // name, and render that view in this spot instead of rendering it as a
  // generic subview.
  //
  // (If a view appears in a `mountView` helper anywhere in a template, the
  // `subviews` helper will know to exclude it when it outputs its HTML.)
  //
  function mountView () {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];
    var viewNameData = args[0].split(':');
    var viewInstanceName = viewNameData[1];
    var viewName = viewNameData[0];
    var data = args.length === 2 ? this : args[1];
    var outputString = '';
    var i;
    var subView;
    if (data.viewList && data._subview) {
      for (i = 0; i < data.viewList.length; i++) {
        subView = data.viewList[i];
        if ((subView.viewName === viewName) &&
           ((viewInstanceName && viewInstanceName === subView.viewInstanceName) || (!viewInstanceName && !subView.viewInstanceName))
           ) {
          outputString = data._subview[subView.viewIndex];
          break;
        }
      }
      return new Handlebars.SafeString(outputString);
    }
    return '';
  }

  Handlebars.registerHelper('mountView', mountView);
  return mountView;
});

/* START_TEMPLATE */
BV.define('hbs!contentAuthor',['hbs','vendor/handlebars/runtime','hbs!contentAuthorInner'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"bv-content-author-name\" role=\"presentation\"> ";
  stack1 = self.invokePartial(partials.contentAuthorInner, 'contentAuthorInner', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthor', t);
t.deps = ["contentAuthorInner"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/withIf',['vendor/handlebars/runtime'], function (Handlebars) {

  // Combines the built-in `#with` and `#if` block helpers. If the given
  // property exists, evaluates the content within the block _within the
  // context_ of that property.
  //
  function withIf (context, block) {
    var ifResult = !Handlebars.Utils.isEmpty(context);

    if (ifResult) {
      return block.fn(context);
    }
    else {
      return block.inverse(this);
    }
  }

  Handlebars.registerHelper('withIf', withIf);
  return withIf;
});

/* START_TEMPLATE */
BV.define('hbs!contentAuthorLocation',['hbs','vendor/handlebars/runtime', 'template/helpers/withIf'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-author-location\"> ";
  stack1 = helpers['if'].call(depth0, depth0.Location, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span> ";
  if (stack1 = helpers.Location) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Location; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " </span> ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Author, options) : helperMissing.call(depth0, "withIf", depth0.Author, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorLocation', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/view',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {

  // Wraps a block inside a `div` with a special `data-bv-v` attribute. If a file
  // is the main template for a `BView` subclass, then it should absolutely use
  // this helper, because that attribute will be used to associate the
  // instance with a DOM node.
  //
  // By default, if the contents of the view are empty (only whitespace),
  // `#view` won't render the container after all.
  //
  function view (ctx, options) {
    var attrs;
    var classStr = '';
    var classList = this._bview.classList;
    var tmplClassList = options.hash.classList ? options.hash.classList.split(/\s+/) : null;

    var o = options.hash;

    var seoTagStr = '';
    var seoTagList = this._bview.seoTagList;
    var tmplSeoTagList = options.hash.seoTagList ? options.hash.seoTagList.split(/\s+/) : null;
    var viewId = this._bview.viewId;
    var tag = (ctx.viewTag || options.hash.tag || 'div');

    // Optional attributes for the view tag.
    //
    // Sadly, we can't just allow this helper to accept arbitrary
    // attribute-value pairs because Handlebars syntax won't allow for it. So
    // we have to map options to attributes.
    //
    // If you add to this list, be sure to make the key the exact name of the
    // attribute. If the value is null or undefined, the attribute won't be
    // included.
    var attributes = {
      id: o.id,
      role: o.role,
      type: o.elemType,
      tabindex: o.tabindex,
      'aria-labelledby': o.ariaLabelledBy,
      'aria-label': o.ariaLabel,

      // If the `dataContentId` option is true, this is a contentItem with an
      // ID. We'll build a special `data-` attribute for the sake of easier
      // QA automation.
      'data-content-id': (o.dataContentId && ctx.Id && ctx.contentType) ? ctx.contentType + '-' + ctx.Id : null,

      // If the `dataProductId` option is true, this is a container view for
      // which we've decided it's useful (for QA automation) to include the
      // product ID as a `data-` attribute.
      'data-product-id': (o.dataProductId && ctx.Product && ctx.Product.Id) ? _.escape(ctx.Product.Id) : null
    };

    var innerString = options.fn(ctx);

    // Typically, we'll skip rendering this element altogether if it has no
    // content. But if `alwaysRender` is true, we'll render it even if it's
    // empty.
    if (options.hash.alwaysRender !== true && _.string.trim(innerString) === '') {
      return '';
    }

    if (tmplClassList) {
      classList = _.union(tmplClassList, classList || []);
    }

    // If tabindex is not explicitly set, set it to 0 anyway if we're marking
    // this view as focusable.
    if (!attributes.tabindex && _(classList).contains('focusable')) {
      attributes.tabindex = '0';
    }

    if (classList) {
      classStr = ' class="' +
      (classList && classList.length ?
        'bv-' + classList.join(' bv-') : ''
      ) + '"';
    }

    if (tmplSeoTagList) {
      seoTagList = _.union(tmplSeoTagList, seoTagList || []);
    }

    if (seoTagList) {
      seoTagStr = ' ' + seoTagList.join(' ');
    }

    // Collect the attributes defined above into a single string. We check
    // for the presence of the option; if it's not there, the attribute
    // doesn't get included.
    attrs = [];
    _(attributes).each(function (value, name) {
      var pair;
      if (value === null || _.isUndefined(value)) { return; }
      pair = name + '="' + value + '"';
      attrs.push(pair);
    });

    return '' +
      // opening tag
      '<' + tag + ' data-bv-v="' + this._bview.name + ':' + viewId + '"' +
      classStr +
      seoTagStr +
      attrs.join(' ') + '>' + '\n' +

      // content
      innerString + '\n' +

      // closing tag
      '</' + tag + '>';
  }

  Handlebars.registerHelper('view', view);
  return view;
});

/* START_TEMPLATE */
BV.define('hbs!fullProfile',['hbs','vendor/handlebars/runtime','hbs!contentAuthor', 'hbs!contentAuthorLocation', 'template/helpers/view', 'template/helpers/mountView'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <tr> ";
  stack1 = helpers['if'].call(depth0, depth0.renderSidebar, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <td class=\"bv-popup-profull bv-author-profile\"> <div class=\"bv-author-profile-content\"> ";
  stack1 = self.invokePartial(partials.contentAuthor, 'contentAuthor', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorLocation, 'contentAuthorLocation', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "tabs", options) : helperMissing.call(depth0, "mountView", "tabs", options)))
    + " </div> </td> </tr> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <td class=\"bv-profull-sidebar\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "sidebar", options) : helperMissing.call(depth0, "mountView", "sidebar", options)))
    + " </td> ";
  return buffer;
  }

  buffer += " <div class=\"bv-cleanslate bv-cv2-cleanslate\"> <div class=\"bv-shared\"> ";
  options = {hash:{
    'tag': ("table"),
    'classList': ("shared table-full-width"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('fullProfile', t);
t.deps = ["contentAuthor","contentAuthorLocation"];
t.tplMountedViews = ['sidebar','tabs'];
return t;
});
/* END_TEMPLATE */
;
/*global jQuery */
/*!
* FitText.js 1.1
*
* Copyright 2011, Dave Rupert http://daverupert.com
* Released under the WTFPL license
* http://sam.zoy.org/wtfpl/
*
* Date: Thu May 05 14:23:00 2011 -0600
*/
BV.define('vendor/jquery/fittext',['jquery'], function ($) {

  $.fn.fitText = function( kompressor, options ) {

    // Setup options
    var compressor = kompressor || 1,
        settings = $.extend({
          'minFontSize' : Number.NEGATIVE_INFINITY,
          'maxFontSize' : Number.POSITIVE_INFINITY
        }, options);

    return this.each(function(){

      // Store the object
      var $this = $(this);

      // Resizer() resizes items based on the object width divided by the compressor * 10
      var resizer = function () {
        $this.css('font-size', Math.max(Math.min($this.width() / (compressor*10), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)));
      };

      // Call once to set.
      resizer();

      // Call on resize. Opera debounces their resize by default.
      $(window).on('resize', resizer);

    });

  };

  return $;
});

/**
 * @fileOverview A module to extract productInfo from a Product Model
 */
BV.define('bv/util/productInfo',[], function () {
  return {
    RATINGSANDREVIEWS: 'RatingsAndReviews',
    ASKANDANSWER: 'AskAndAnswer',
    PROFILES: 'Profiles',
    STORIES: 'Stories',
    SEARCH: 'UniversalSearch',
    PRODUCT: null,

    /**
     * Get the category id from the passed in ref's model.
     * Assume that any ref will have a categoryId if we can get
     * its top model and that top model is a product.
     *
     * @param {bmodel/bview} ref
     * @returns {string|null} categoryId
     */
    getCategoryId: function (ref) {
      var product;
      var subject;
      var model;
      var categoryId = null;
      // Make sure that the ref has a model is a bview or bmodel
      if (ref.model && typeof ref.model.getTopModel === 'function') {
        model = ref.model.getTopModel();
      }

      // Make sure that the top model has a subject
      if (model && typeof model.getSubject === 'function') {
        subject = model.getSubject();
      }

      // If the subject is product, we are on a product page
      // So get the categoryId from the model
      if (subject && subject.type === 'product') {
        product = model.toJSON().Product;
        categoryId = product.CategoryId;
      }

      // Never return undefined.
      return typeof categoryId === 'undefined' ? null : categoryId;
    },

    getId: function (ref) {
      var clientAPIConfig = ref.clientAPIConfig || (ref.model && ref.model.get('clientAPIConfig')) || null;

      if (!clientAPIConfig) {
        return null;
      }

      var productId = clientAPIConfig.productId;

      return productId;
    },

    getType: function (ref) {
      var type = (ref.model) ? ref.model.getContentType() : null;

      return this.getTypeByContentType(type);
    },

    getTypeByContentType: function (type) {
      if (type) {
        type = type.toLowerCase();

        var contentTypeMap = {
          'reviews': this.RATINGSANDREVIEWS,
          'review': this.RATINGSANDREVIEWS,
          'comments': this.RATINGSANDREVIEWS,
          'comment': this.RATINGSANDREVIEWS,
          'reviewcomment': this.RATINGSANDREVIEWS,
          'reviewcomments': this.RATINGSANDREVIEWS,
          'question': this.ASKANDANSWER,
          'questions': this.ASKANDANSWER,
          'answers': this.ASKANDANSWER,
          'story': this.STORIES,
          'stories': this.STORIES,
          'author': this.PROFILES,
          'authors': this.PROFILES
        }[type];

        return (contentTypeMap) || null;
      }

      return null;
    }
  };
});

/* eslint-disable no-unused-vars */

/**
 * This controls keyboard navigation (tab, shift tab, up arrow, down
 * arrow, esc, enter) in Firebird. It allows us to do things like:
 *   -registerFocusableLayer() - which moves tabbing priority onto a
 *    new set of elements (for example, a modestbox).
 *   -rescanFocusLayer() - which will rescan the current layer of
 *    focusable elements in order to take into account any new
 *    elements or any change in the order of elements.
 *
 * Mix this into a view using the focusableview.js class.
 */

BV.define('bv/util/focusManager',[
  'ENV',
  'underscore',
  'jquery',
  'document',
  'body',
  'util/specialKeys',
  'framework/util/bvreporter'
], function (ENV, _, $, document, body, specialKeys, BVReporter) {

  // We increment _before_ assigning the UID so that we don't accidently
  // return a falsy value.
  var UID = 0;

  var focusManager = {

    focus: [],
    layer: -1,
    keyboardNavigationSetup: false,

    init: function () {
      // When the base page has loaded, set up keyboard navigation.
      ENV.on('init:viewsRendered', function () {
        this.registerBaseFocusableLayer($(document), '.bv-focusable');
      }, this);
    },

    /**
     * rescan the current layer of focusable elements in order to take into account
     * any new elements or any change in the order of elements.
     */
    rescanFocusLayer: function () {
      var layer;
      var focusedNode;
      var index;
      var newIndex;

      if (this.focus.length) {
        layer = this._getLayer();
        if (!layer) {
          BVReporter.error('FocusManager: rescanFocusLayer: Invalid layer returned');
          return;
        }

        index = layer.index;

        // Any old index on the layer will no longer be valid
        delete layer.oldIndex;

        // If we've been visited, get a reference to our focused node before we rescan,
        // then actually do the rescan.
        if (index > -1) {
          focusedNode = layer.$els[index];
        }
        layer.$els = layer.$layerRoot.find(layer.focusSelector);

        // Assume that we couldn't find the original previouslyly focused node,
        // treating the layer like it was unvisited.
        layer.index = -1;

        if (focusedNode) {
          newIndex = layer.$els.index(focusedNode);
          // If we have a non-negative newIndex, we know where we were and it's still in this layer,
          // so use the newly found index as our layer's index.
          // Otherwise, we couldn't find the element we used to know, and we can't safely infer
          // where we should be, so we want our index to be -1.
          // In either case, we basically just want to use the newIndex we've found.
          layer.index = newIndex;
        }
      }
    },

    setupKeyboardNavigation: function () {
      var self;
      var $body;
      var keydownQuery = [];
      var underDropdownKeys = {};
      var radioNavKeys = {};
      var clickQuery = [];

      // Don't re-run this function if we've already done it once
      if (this.keyboardNavigationSetup) {
        return;
      }
      this.keyboardNavigationSetup = true;
      self = this;
      $body = $(body());

      // Construct a query element of all bv containers.
      ENV.get('componentManager').forEach(function (comp) {
        if (comp.inject) {
          keydownQuery.push('#' + comp.container);
        }
      });

      // Listen for tabs in all lightboxes.
      keydownQuery.push('.bv-mboxzone');

      // Listen for tabs in all pop ups.
      keydownQuery.push('.bv-popup-container');
      keydownQuery.push('.bv-dropdown');
      keydownQuery = _(keydownQuery).unique().join(',');

      // Which keycodes to listen to for which types of handling
      _(['ENTER', 'UP', 'DOWN']).each(function (k) {
        underDropdownKeys[specialKeys[k]] = 1;
      });

      _(['LEFT', 'UP', 'RIGHT', 'DOWN']).each(function (k) {
        radioNavKeys[specialKeys[k]] = 1;
      });

      // Listen for keydowns globally.
      $body.off('keydown.bvkb').on('keydown.bvkb', keydownQuery, function (e) {
        var $source = $(e.target);
        var keyCode = e.keyCode;
        var doFocus;
        var doClick;
        var layer;
        var preFocusEvent;
        var index;
        var oldIndex;
        var $focusables;
        var focusEl;
        var blurEl;
        var $focusEl;
        var $blurEl;

        // Don't process events that have already been managed by this callback
        if (e._bvkbFocusManaged) { return; }

        // Prevent duplicate handlers from certain popups.
        if ($source.is('.bv-dropdown button') && !$(e.currentTarget).is('.bv-dropdown')) {
          return;
        }

        // Before focus is moved, trigger an event on the source to see if it wants/needs
        // to manage focus itself.
        // Note that we're using triggerHandler instead of trigger, in order to avoid
        // any DOM bubbling.
        preFocusEvent = $.Event('focusManagerBlur', {
          originalEvent: e
        });
        $source.triggerHandler(preFocusEvent);

        // If the FM Blur event has been prevented,
        // assume that the handler that prevented the default has managed focus,
        // therefore we'll prevent the original event and stop subsequent processing
        if (preFocusEvent.isDefaultPrevented()) {
          e.preventDefault();
          e._bvkbFocusManaged = true;
          return;
        }

        // Tab key pressed.
        if (keyCode === specialKeys.TAB) {
          if (!e.shiftKey) {
            // Handle tabbing off the page.
            layer = self._getLayer();
            if (self.layer === 0 && !layer) {
              BVReporter.error('FocusManager: tab on bottom layer: Invalid layer returned');
              return;
            }
            // We need to change last condition from layer.index >= layer.$els.length -1 to have
            // possibility to move focus from submission to close button on client container page
            if (self.layer === 0 && layer.index >= layer.$els.length) {
              return;
            }
            // this check is needed to prevent tabbing off the lightobx when
            // duplicatePage or submissionUnavailablePage is displayed
            if (layer.$els.length > 1) {
              self.nextFocusable();
            }
          }
          else if (e.shiftKey) {
            // Handle shift tabbing off the page.
            layer = self._getLayer();
            if (self.layer === 0 && !layer) {
              BVReporter.error('FocusManager: shift-tab on bottom layer: Invalid layer returned');
              return;
            }
            if (self.layer === 0 && layer.index <= 0) {
              return;
            }
            // this check is needed to prevent tabbing off the lightobx when
            // duplicatePage or submissionUnavailablePage is displayed
            if (layer.$els.length > 1) {
              self.prevFocusable();
            }
          }
          doFocus = true;
        }
        else if ((keyCode in underDropdownKeys) && $source.is('.bv-dropdown-target button, .bv-dropdown li')) {
          // Enter key pressed.
          if (keyCode === specialKeys.ENTER) {
            $source.click();
            e.preventDefault();
          }
          // Up arrow key pressed.
          else if (keyCode === specialKeys.UP) {
            self.prevFocusable();
            doFocus = true;
          }
          // Down arrow key pressed.
          else {
            self.nextFocusable();
            doFocus = true;
          }
        }
        else if ((keyCode in radioNavKeys) && $source.is('[role=radiogroup] [role=radio]')) {
          if (keyCode === 37 || keyCode === 38) {
            // Left or Up
            doFocus = self.prevFocusableRadio();
          }
          else {
            // Right or Down
            doFocus = self.nextFocusableRadio();
          }

          // Radio navigation is special: If we are focusing an item, we need to
          // activate it.
          if (doFocus) { doClick = true; }
        }

        if (doFocus) {
          layer = self._getLayer();
          if (!layer) {
            BVReporter.error('FocusManager: keydown handler: Invalid layer returned');
            return;
          }
          index = layer.index;
          oldIndex = layer.oldIndex;
          $focusables = layer.$els;
          focusEl = $focusables[index];
          blurEl = $focusables[oldIndex];
          $focusEl = $(focusEl);
          $blurEl = $(blurEl);

          // If we're saying we should be moving focus, we should actually
          // have an element that is going to receive focus.
          if (!focusEl) {
            BVReporter.error('FocusManager: Focus element does not exist');
            return;
          }

          // If we had a prior non-negative index,
          // but can't find the element at that prior index,
          // something has gone really, really wrong.
          if (typeof oldIndex !== 'undefined' && oldIndex > -1 && !blurEl) {
            BVReporter.error('FocusManager: Prior focus element does not exist');
            return;
          }

          // If both the focus and blur element are the same, we couldn't find a valid focus
          // to move to, so we shouldn't handle the event.
          // This can happen if we're the only visible container on a page with multiple containers.
          if (focusEl === blurEl) {
            BVReporter.debug('FocusManager: Cannot find valid next focusable, not handling event');
            return;
          }

          // If we have an element that we're blurring, and the highest bv-cv2-cleanslate parent isn't shared,
          // we should not be handling this event. This handles the scenario when a user is tabbing out
          // of a BV container and into a non BV container.
          if (blurEl && ($focusEl.parents('.bv-cv2-cleanslate').last()[0] !== $blurEl.parents('.bv-cv2-cleanslate').last()[0])) {
            BVReporter.debug('FocusManager: Moving out of one container, not handling event');
            layer.index = oldIndex;
            return;
          }

          // If we're here, start handling like usual.
          e._bvkbFocusManaged = true;
          e.preventDefault();

          if (!$.contains(layer.$layerRoot[0], focusEl)) {
            self.rescanFocusLayer();
          }

          // Focus the element, triggering an event to indicate that the element has received
          // focus due to automatic focus manager movement.
          // Note that we're using triggerHandler to avoid DOM bubbling of the event.
          $focusEl.focus();
          $focusEl.triggerHandler(new $.Event('focusManagerFocus', {
            target: focusEl,
            relatedTarget: e.target,
            keyEvent: e
          }));

          if (doClick) {
            $focusEl.click();
          }
        }

      });
      // Construct a query element of places to listen for clicks.
      // Listen for clicks in all form text fields.
      clickQuery.push('.bv-fieldset');

      // Also anything focusable
      clickQuery.push('.bv-focusable');

      clickQuery = _(clickQuery).unique().join(',');

      // Listen for clicks and adjust the tabbing index.
      $body.off('click.bvkb').on('click.bvkb', clickQuery, function (e) {
        var layer;
        var $els;
        var newIndex;

        if (e.metaKey) {
          return;
        }

        layer = self._getLayer();
        if (!layer) {
          BVReporter.error('FocusManager: click to move focus: Invalid layer returned');
          return;
        }
        $els = layer.$els;
        newIndex = $els.index(e.target || document.activeElement);

        // If the clicked element is in the list of $focusables,
        // move the tab index to this spot.
        if (newIndex > -1) {
          layer.index = newIndex;
          delete layer.oldIndex;
        }
      });

      // Listen for focus changes and attempt to keep focus manager aware
      // of its location. This feels computationally heavy, since we're
      // now creating a new jQuery object every time anything is focused,
      // but in practice, the impact isn't observable in IE8 and it results
      // in much more stable code, since we're now actively monitoring focus
      // movements. Anywhere that people call stray `.focus()` on a node,
      // we'll detect it, and issue a warning if something seems problematic.
      $body.off('focusin.bvkb').on('focusin.bvkb', function (e) {
        var layer = self._getLayer();
        var reporterGroup;
        var focusSelector;
        var $el;
        var index;

        if (!layer) {
          BVReporter.error('FocusManager: Element focused: Invalid layer returned');
          return;
        }

        reporterGroup = 'FocusManager: Element focused';
        BVReporter.group(BVReporter.DEBUG, reporterGroup);

        focusSelector = layer.focusSelector;
        $el = $(e.target || document.activeElement);

        // If the element doesn't match the current layer's selector, ignore it
        if (!$el.is(focusSelector)) {
          BVReporter.debug('Focused element does not match current focus selector, ignoring event');
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return;
        }

        // Since it *does* match our focus selector, let's try to find it
        index = layer.$els.index($el);
        BVReporter.debug('Index of focused element: ' + index);

        // If we didn't find the element, we won't completely die, but we need to
        // throw up some notices. In theory, it shouldn't ever happen. Hopefully.
        if (index === -1) {
          BVReporter.warn('FocusManager: An element received focus that was not in the current focus layer - potential for odd focus behavior upon next user navigation');
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return;
        }

        // If we're found, but focus manager is out of sync, update the layer
        // and get rid of the oldIndex. The oldIndex is necessary in other areas of code,
        // but when this event fires from usual FocusManager movement (which it will),
        // the layers will be in sync and so we'll keep oldIndex intact.
        if (index !== layer.index) {
          BVReporter.debug('FocusManager layer index out of sync, adjusting');
          layer.index = index;
          delete layer.oldIndex;
        }

        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
      });
    },

    registerBaseFocusableLayer: function ($layerRoot, focusSelector) {
      var self = this;
      var reporterGroup = 'FocusManager: registerBaseFocusableLayer';
      var currentBaseLayer;
      var currentLayerRoot;
      var $focusLayer;

      BVReporter.group(BVReporter.DEBUG, reporterGroup);

      // Special case: We may already have a base focusable layer
      if (this.focus && this.focus.length) {
        // Check to see if our new base is different, and make sure we abort
        currentBaseLayer = this.focus[0];
        currentLayerRoot = currentBaseLayer.$layerRoot[0];
        if (currentLayerRoot !== $layerRoot[0]) {
          BVReporter.error('Trying to register a new base focusable layer when one is already in effect, refusing to do so.');
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return;
        }

        // Since it's the same, just rescan, ensuring we update our focus selector
        BVReporter.debug('FocusManager: registerBaseFocusableLayer invoked on the same layer again, rescanning');
        currentBaseLayer.focusSelector = focusSelector;
        this.rescanFocusLayer();

        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return;
      }

      this.setupKeyboardNavigation();
      $focusLayer = $layerRoot.find(focusSelector);

      // Add the base focusables.
      this.focus = [{
        $layerRoot: $layerRoot,
        focusSelector: focusSelector,
        $els: $focusLayer,
        index: -1,
        cycleTabs: false,
        id: ++UID
      }];
      this.layer = 0;
    },

    /**
     *  Registers a new focusable layer.
     *  @return {Number} A unique ID representing this layer. (Can later be
     *    given to `deregisterFocusableLayerById` to remove this specific layer
     *    no matter where it is in the stack.)
     */
    registerFocusableLayer: function ($layerRoot, focusSelector, autoFocus, cycleTabs) {
      var reporterGroup = 'FocusManager: registerFocusableLayer';
      var $focusLayer = $layerRoot.find(focusSelector);
      var startIndex;

      BVReporter.group(BVReporter.DEBUG, reporterGroup);
      this.setupKeyboardNavigation();

      if (!$focusLayer.length) {
        BVReporter.error('No focusable elements found in new registered layer');
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return;
      }

      if (autoFocus) {
        startIndex = 0;
        // Focus on the first element.
        $focusLayer[startIndex].focus();
      }
      else {
        startIndex = -1;
      }

      // Default to not cycling tabs.
      cycleTabs = !!cycleTabs;

      this.focus.push({
        $layerRoot: $layerRoot,
        focusSelector: focusSelector,
        $els: $focusLayer,
        index: startIndex,
        cycleTabs: cycleTabs,
        id: ++UID
      });
      this.layer++;

      BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
      return UID;
    },

    deregisterFocusableLayer: function (moveNext, preserveFocus) {
      var layer = this._getLayer();
      var $focusables;
      var index;
      var focusEl;

      this._backupFocusables();

      if (!layer) {
        BVReporter.error('FocusManager: deregisterFocusableLayer: Invalid layer returned');
        return;
      }
      if (this.focus[0].index === -1) {
        return;
      }
      if (preserveFocus) {
        // Return early so focus is not changed
        return;
      }
      if (moveNext) {
        this.nextFocusable();
      }

      $focusables = layer.$els;
      index = layer.index;

      // If our index is negative, that means we haven't visited anything
      // on the prior layer, so our work is done.
      if (index < 0) { return; }

      // Find and focus the element at our index.
      focusEl = $focusables[index];
      if (focusEl) {
        focusEl.focus();
      }
    },

    /**
     *  Deregisters a focusable layer by its unique ID.
     *
     *  There is an obscure need to deregister a layer when it is not
     *  guaranteed to be the top layer. For this to be possible, one must keep
     *  a reference to the unique layer ID returned by
     *  `registerFocusableLayer`.
     */
    deregisterFocusableLayerById: function (id, moveNext, preserveFocus) {
      var layer = this._findLayerById(id);
      var currentLayer;

      if (!layer) {
        BVReporter.error('Couldn\'t find layer with ID: ' + id);
        return;
      }

      BVReporter.debug('Removing focusable layer with ID:', id, layer);

      if (_(this.focus).last() === layer) {
        // This is identical to a `deregisterFocusableLayer` scenario.
        return this.deregisterFocusableLayer(moveNext, preserveFocus);
      }

      currentLayer = this._getLayer();
      if (!currentLayer) {
        BVReporter.error('FocusManager: deregisterFocusableLayerById: Invalid layer returned');
        return;
      }

      // Otherwise, we're removing a layer that isn't on top, so we can be
      // extra stealthy about it.
      this.focus = _.without(this.focus, layer);

      // The top layer's index may have changed.
      this.layer = _.indexOf(this.focus, currentLayer);
    },

    _findLayerById: function (id) {
      return _.detect(this.focus, function (l) {
        return l.id === id;
      });
    },

    addFocusables: function ($newFocusables, $elToAddAfter) {
      var layer;
      var $focusables;
      var after;

      if ($newFocusables.length === 0) {
        return;
      }

      $elToAddAfter = $elToAddAfter.first();

      layer = this._getLayer();
      if (!layer) {
        BVReporter.error('FocusManager: addFocusables: Invalid layer returned');
        return;
      }

      $focusables = layer.$els;
      after = $focusables.index($elToAddAfter[0]) + 1;

      if (after !== 0) {
        $newFocusables.each(function (i, newEl) {
          $focusables.splice(after + i, 0, newEl);
        });
      }
    },

    addFocusablesInline: function ($newFocusables) {
      var layer = this._getLayer();
      var $focusables;
      var after;
      var second;

      if (!layer) {
        BVReporter.error('FocusManager: addFocusablesInline: Invalid layer returned');
        return;
      }

      $focusables = layer.$els;
      after = layer.index + 1;

      second = $focusables.splice(after);
      layer.$els = $($focusables.toArray().concat($newFocusables.toArray()).concat(second));

      layer.index = after;
      layer.$els[after].focus();
    },

    removeFocusables: function ($newFocusables) {
      var layer;
      var $focusables;
      var from;

      if ($newFocusables.length === 0) {
        return;
      }

      layer = this._getLayer();

      if (!layer) {
        BVReporter.error('FocusManager: removeFocusables: Invalid layer returned');
        return;
      }

      $focusables = layer.$els;
      from = $focusables.index($newFocusables[0]);

      if (from !== -1) {
        $focusables.splice(from, $newFocusables.length);
      }
    },

    moveFocus: function ($elToFocusOn) {
      var layer = this._getLayer();
      var $focusables;
      var newIndex;

      $elToFocusOn = $elToFocusOn.first();

      if (!layer) {
        BVReporter.error('FocusManager: moveFocus: Invalid layer returned');
        return;
      }

      $focusables = layer.$els;
      newIndex = $focusables.index($elToFocusOn[0]);

      // Only move the focus index if the $elToFocusOn exists in the list of focusables.
      if (newIndex !== -1) {
        layer.index = newIndex;
      }

      // Focus on the element
      $elToFocusOn.focus();
    },

    refocusLayer: function () {
      var $focusables;
      var layer = this._getLayer();
      var index;

      if (!layer) {
        BVReporter.error('FocusManager: refocusLayer: Invalid layer returned');
        return;
      }

      index = layer.index;

      if (index === -1) {
        return;
      }

      $focusables = layer.$els;
      $focusables[index].focus();
    },

    _backupFocusables: function () {
      var layer;
      var focusLayerRemoved;
      var reporterGroup = 'FocusManager: _backupFocusables';

      BVReporter.group(BVReporter.DEBUG, reporterGroup);

      if (this.layer > 0) {
        layer = this.focus.pop();
        this.layer--;
        focusLayerRemoved = $.Event('focusLayerRemoved', {
          focusLayer: layer
        });
        ENV.trigger('focusLayerRemoved', focusLayerRemoved);
        BVReporter.debug('Focus layer moved from ' + (this.layer + 1) + ' to ' + this.layer);
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return true;
      }

      BVReporter.debug('Trying to _backupFocusables on the base layer, no action taken');
      BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
      return false;
    },

    // A method to forcefully move focus in a direction
    _focus: function (dir) {
      var layer = this._getLayer();
      var method;
      var $nextEl;

      if (!layer) {
        BVReporter.error('FocusManager: _focus: Invalid layer returned');
        return;
      }

      // If we've not been focused, do nothing
      if (layer.index === -1) { return; }

      // Determine which method to invoke for now.
      // We'll improve on this in a subsequent rewrite.
      switch (dir) {
        case 1:
          method = 'nextFocusable';
          break;
        case -1:
          method = 'prevFocusable';
          break;
        default:
        // Silently fail for now on bad input
          return;
      }

      // Find the next visible node while moving in a direction
      do {
        this[method]();
        $nextEl = layer.$els.eq(layer.index);
      } while ($nextEl.is(':hidden'));
      $nextEl.focus();
    },

    // Exposed API to move focus explicitly
    focusNext: function () {
      this._focus(1);
    },

    focusPrev: function () {
      this._focus(-1);
    },

    nextFocusable: function () {
      var layer = this._getLayer();
      var reporterGroup = 'FocusManager: nextFocusable';
      var layerIndex;
      var $els;
      var numEls;
      var index;
      var $currentEl;
      var $newEl;

      if (!layer) {
        BVReporter.error('FocusManager: nextFocusable: Invalid layer returned');
        return;
      }

      BVReporter.group(BVReporter.DEBUG, reporterGroup);
      layerIndex = this.layer;
      $els = layer.$els;
      numEls = $els ? $els.length : 0;
      index = layer.index;
      $currentEl = $els.eq(index);

      // Remember where we last were
      layer.oldIndex = index;

      // Move to the next element.
      do {
        index++;
        $newEl = $els.eq(index);
        if (!$newEl.length) { $newEl = null; }
      } while ($newEl && !this._validFocusable($currentEl, $newEl));

      // Edge condition: tab off the page.
      if (index === $els.length) {
        BVReporter.debug('index hit array length, ran out of elements to check');
        // If we're not cycling tabs and can move to the next layer down,
        // move to the next element.
        if (!layer.cycleTabs) {
          if (this._backupFocusables()) {
            this.nextFocusable();
          }
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return;
        }

        // Cycling tabs, just reset index
        index = 0;
      }

      BVReporter.debug('Layer ' + layerIndex + ' focus index moving from ' + layer.oldIndex + ' to ' + index);
      layer.index = index;
      BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
    },

    prevFocusable: function () {
      var self = this;
      var layer = this._getLayer();
      var layerIndex;
      var $els;
      var numEls;
      var index;
      var $currentEl;
      var $newEl;
      var prevLayer;
      var $prevFocusEl;
      var reporterGroup = 'FocusManager: prevFocusable';

      if (!layer) {
        BVReporter.error('FocusManager: prevFocusable: Invalid layer returned');
        return;
      }

      BVReporter.group(BVReporter.DEBUG, reporterGroup);
      layerIndex = this.layer;
      $els = layer.$els;
      numEls = $els ? $els.length : 0;
      index = layer.index;
      $currentEl = $els.eq(index);

      // Remember where we last were
      layer.oldIndex = index;

      // Move to the previous element.
      do {
        // First we check for some special cases. We have to do this each
        // time through the loop because we can hit these cases even if we
        // start out with a positive index. (Example: we're on index 1, but 0
        // is hidden, so we end up at -1. This actually happened with
        // UIA-4558.)

        // Index is -1 if shift + tab is first keypress.
        if (index === -1) {
          // Special scenario:
          // If all of the criteria are true:
          // 1. We haven't been keyboard navigated (true by virtue of being here, listing to be thorough)
          // 2. We are not on the bottommost layer
          // 3. cycleTabs is false (no looping around in a container)
          // 4. Current focus is on the previous layer's focused element
          // We can safely assume that the current layer should not be visited.
          if (this.layer > 0 && !layer.cycleTabs) { // Satisfies points 2 & 3
            prevLayer = this.focus[this.layer - 1];
            $prevFocusEl = prevLayer.$els.eq(prevLayer.index);
            if ($prevFocusEl[0] === document.activeElement) { // Satisfies point 4
              // Back out to the prior layer, and then go to the previous
              // focusable element in that layer.
              // Note that unlike some places, we're not checking the return value
              // of _backupFocusables, as we know that it'll successfully complete
              // from this layer.
              this._backupFocusables();
              this.prevFocusable();
            }
          }

          // Wrap around to the last element.
          index = $els.length - 1;
          if (this._validFocusable($currentEl, $els.eq(index))) {
            BVReporter.debug('Layer ' + layerIndex + ' focus index moving from ' + layer.oldIndex + ' to ' + index);
            layer.index = index;
            BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
            return;
          }
        }

        if (index === 0) {
          if (!layer.cycleTabs) {
            // If we're not cycling tabs, we want to move to the last focusable
            // in the previous layer.
            if (this._backupFocusables()) {
              // We've switched focus layers, so it's safe to call ourselves
              // again.
              this.prevFocusable();
            }
            // If we successfully moved to the previous layer, we're done. If
            // not, we don't want to take any action here. So we should return
            // early either way.
            return;
          }
          else {
            // Wrap around to the last element.
            index = $els.length - 1;
            if (this._validFocusable($currentEl, $els.eq(index))) {
              BVReporter.debug('Layer ' + layerIndex + ' focus index moving from ' + layer.oldIndex + ' to ' + index);
              layer.index = index;
              BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
              return;
            }
          }
        }

        index--;
        $newEl = index >= 0 ? $els.eq(index) : null;
        if (!$newEl || !$newEl.length) { $newEl = null; }
      } while ($newEl && !this._validFocusable($currentEl, $newEl));


      BVReporter.debug('Layer ' + layerIndex + ' focus index moving from ' + layer.oldIndex + ' to ' + index);
      layer.index = index;
      BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
    },

    nextFocusableRadio: function () {
      var layerIndex = this.layer;
      var layer = this._getLayer();
      var $els;
      var index;
      var $currentEl;
      var currentEl;
      var $parent;
      var owns;
      var currentRadioIndex;
      var $nextRadio;
      var nextIndex;

      if (!layer) {
        BVReporter.error('FocusManager: nextFocusableRadio: Invalid layer returned');
        return;
      }

      $els = layer.$els;
      index = layer.index;
      $currentEl = $els.eq(index);
      currentEl = $currentEl[0];
      $parent = $currentEl.closest('[role=radiogroup]');
      // If there's no explicit ownership,
      // just let the key event be handled naturally
      owns = $parent.attr('aria-owns');
      if (!owns) { return false; }

      // Remember where we last were
      layer.oldIndex = index;

      owns = owns.split(' ');
      currentRadioIndex = _(owns).indexOf(currentEl.id);

      // Special case: If we're the last item, do nothing
      if (currentRadioIndex === owns.length - 1) { return; }

      $nextRadio = $('#' + owns[currentRadioIndex + 1]);
      nextIndex = $els.index($nextRadio[0]);

      if (nextIndex !== -1) {
        layer.index = nextIndex;
        return true;
      }

      // In theory, we shouldn't ever hit this point,
      // but if we do, we need to ignore this call
      return false;
    },

    prevFocusableRadio: function () {
      var layerIndex = this.layer;
      var layer = this._getLayer();
      var $els;
      var index;
      var $currentEl;
      var currentEl;
      var $parent;
      var owns;
      var currentRadioIndex;
      var $prevRadio;
      var prevIndex;

      if (!layer) {
        BVReporter.error('FocusManager: prevFocusableRadio: Invalid layer returned');
        return;
      }

      $els = layer.$els;
      index = layer.index;
      $currentEl = $els.eq(index);
      currentEl = $currentEl[0];
      $parent = $currentEl.closest('[role=radiogroup]');

      // If there's no explicit ownership, the right thing happens by default in the browser
      owns = $parent.attr('aria-owns');
      if (!owns) { return false; }

      // Remember where we last were
      layer.oldIndex = index;

      owns = owns.split(' ');
      currentRadioIndex = _(owns).indexOf(currentEl.id);

      // Special case: If we're the first item, do nothing
      if (currentRadioIndex === 0) { return; }

      $prevRadio = $('#' + owns[currentRadioIndex - 1]);
      prevIndex = $els.index($prevRadio[0]);

      if (prevIndex !== -1) {
        layer.index = prevIndex;
        return true;
      }

      // In theory, we shouldn't ever hit this point,
      // but if we do, we need to ignore this call
      return false;
    },

    _getLayer: function () {
      var layer = this.focus[this.layer];

      // If we didn't get a layer, this is a serious problem.
      // Issue an error, and explicitly return null.
      // Any users of _getLayer need to be aware of this,
      // and respond appropriately (likely just erroring and returning)
      if (!layer) {
        BVReporter.error('FocusManager: Layer index returned invalid layer. Index: ' + this.layer + ', layer count: ' + this.focus.length);
        return null;
      }
      return layer;
    },

    _validFocusable: function ($currentEl, $newEl) {
      var $currentParentGroup;
      var $newParentGroup;
      var $newParentFirstRadio;
      var $newParentChecked;
      var $tablist;
      var $activeTab;
      var reporterGroup = 'FocusManager: _validFocusable';

      BVReporter.group(BVReporter.DEBUG, reporterGroup);
      BVReporter.debug('Current element: ', $currentEl && $currentEl[0]);
      BVReporter.debug('New element: ', $newEl && $newEl[0]);

      if (!$newEl || !$newEl.length) {
        BVReporter.warn('No element received, invalid use of _validFocusable');
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return false;
      }
      if ($newEl.is(':hidden')) {
        BVReporter.debug('New element is hidden, not valid');
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return false;
      }
      if ($newEl.is('[disabled]')) {
        BVReporter.debug('New element is disabled, not valid');
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return false;
      }
      // Remove elements with `tabindex = -1` from focus order
      if ($newEl.attr('tabindex') === '-1') {
        BVReporter.debug('New element is disabled, not valid');
        BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
        return false;
      }

      // Special checks for radios
      if ($newEl.is('[role=radio]')) {
        $currentParentGroup = $currentEl.closest('[role=radiogroup]');
        $newParentGroup = $newEl.closest('[role=radiogroup]');
        $newParentChecked = $newParentGroup.find('[aria-checked=true], :checked');

        // If we're both radios, make sure the parent group isn't the same
        if ($currentEl.is('[role=radio]') &&
            $currentParentGroup[0] === $newParentGroup[0]) {
          BVReporter.debug('Current and new elements are both radio buttons in the same radio group, not valid');
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return false;
        }

        if ($newParentChecked.length) {
          // If there is a selection but it's not us, skip on by
          if ($newParentChecked[0] !== $newEl[0]) {
            BVReporter.debug('New element is a radio and is in a different group, but is not the selected radio in its group, not valid');
            BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
            return false;
          }
        }
        else {
          // Since nothing is selected, if we're not the first item, skip by
          $newParentFirstRadio = $newParentGroup.find('[role=radio]').first();
          if ($newParentFirstRadio[0] !== $newEl[0]) {
            BVReporter.debug('New element is a radio in a new group with no selection, and is not the first item, not valid');
            BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
            return false;
          }
        }
      }

      // Special checks for tabs
      if ($newEl.is('[role=tab]')) {
        $tablist = $newEl.closest('[role=tablist]');
        $activeTab = $tablist.find('[aria-selected=true]');

        if ($newEl[0] !== $activeTab[0]) {
          // If there is an active tab and it is NOT the new element, skip by
          BVReporter.debug('New element is a tab, but is not the active tab, not valid');
          BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
          return false;
        }
      }

      BVReporter.debug('Found a valid focusable: ', $newEl);
      BVReporter.groupEnd(BVReporter.DEBUG, reporterGroup);
      return true;
    }

  };

  return focusManager;

});

BV.define('mf!bv/c2013/messages/profile',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"displaytext_review" : function (x) { try { return (function(d){
var r = "";
r += "Reviews Tab Panel";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `displaytext_review`: ' + e.toString() ) ] ); return ""; } },"displaytext_question" : function (x) { try { return (function(d){
var r = "";
r += "Questions Tab Panel";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `displaytext_question`: ' + e.toString() ) ] ); return ""; } },"displaytext_answer" : function (x) { try { return (function(d){
var r = "";
r += "Answers Tab Panel";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `displaytext_answer`: ' + e.toString() ) ] ); return ""; } },"aria_label_for_author_name" : function (x) { try { return (function(d){
var r = "";
r += "All content by user";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `aria_label_for_author_name`: ' + e.toString() ) ] ); return ""; } }
};
});

/**
 * @fileOverview
 *
 * View for fullProfile.
 */

BV.define('bv/c2013/view/fullProfile',[
  'ENV',
  'underscore',
  'framework/bview',
  'hbs!fullProfile',
  'vendor/jquery/fittext',
  'framework/util/bvtracker',
  'bv/util/productInfo',
  'bv/util/focusManager',
  'mf!bv/c2013/messages/profile'
], function (ENV, _, BView, template, $, BVTracker, ProductInfo, FocusManager, msgPack) {

  return BView.extend({

    name: 'fullProfile',

    events: {
      'click .bv-content-btn-pages-first, .bv-content-btn-pages-last': 'moveInitialFocus'
    },

    template: template,

    msgpacks: [msgPack],

    classList: ['core-container-' + BView.config.version],

    init: function () {
      this.listenTo(this.model, 'showfullprofile', this.showFullProfile);
    },

    /**
     * Shows a user profile in a modest box.
     */
    showFullProfile: function () {
      var self = this;
      BV.require(['secondary'], function (app) {
        var mb = app.ModestBox.get('lightbox');
        var sidebarView = self.getFeatureView('sidebar') || null;
        var authorName = self.model.get('Author').DisplayName;
        var ariaTitle = msgPack.aria_label_for_author_name ? msgPack.aria_label_for_author_name() + ' ' + authorName : '';

        mb.pushOrOpen({
          view: self,
          autoFocus: true,
          sidebar: sidebarView,
          ariaTitle: ariaTitle,
          ariaDialog: true,
          classList: ['fullprofile'],
          beforeShow: function () {
            // Scale the avatar to fit nicely.
            if (sidebarView.subViewContainer) {
              sidebarView.subViewContainer.find('.bv-author-no-avatar').fitText(0.1);
            }
          },
          afterShow: function () {
            self.moveInitialFocus();
          },
          afterDetach: function (layer) {
            // When the layer is detached, grab the components involved in
            // those views. We'll restore them when the box is closed. (We
            // need to do it like this because the layer won't exist anymore
            // when the `afterClose` callback runs.)
            var toBeRestored = _(layer.views).pluck('component');
            ENV.get('componentManager').restore(toBeRestored);
          }
        });
      });
    },

    /**
     * Function to move to the first focusable tab.
     */
    moveInitialFocus: function () {
      var $viewEl = $(this.viewEl);

      // Focus on the close button
      var $firstFocusable = $viewEl.find('button.bv-mbox-close.bv-focusable').eq(0);

      if ($firstFocusable.length) {
        // We cannot guarantee that this function is running after all elements have attached.
        // Once https://bits.bazaarvoice.com/jira/browse/UIA-7362 is resolved we can remove the delay.
        setTimeout(function () {
          FocusManager.moveFocus($firstFocusable);
        }, 0);
      }
    },

    render: function () {
      if (this.model.get('pageview')) {
        this.triggerPageView();
      }

      BView.prototype.render.apply(this, arguments);
    },

    triggerPageView: function () {
      var pageview = this.model.get('pageview');
      var productId;

      if (!pageview) {
        return;
      }

      productId = ProductInfo.getId(this);
      if (productId) {
        BVTracker.pageview({
          type: 'Product',
          label: 'Default',
          bvProduct: pageview.bvProduct,
          productId: productId
        }, this.model);
      }
      else {
        BVTracker.pageview({
          type: 'Misc',
          pageName: pageview.bvProduct
        }, this.model);
      }
    }

  });
});

BV.define('bv/util/contentType',[
  'bv/util/grammr',
  'underscore',
  'bv/api/fetch'
], function (grammr, _, bvApi) {
  var typePairs = _.flatten(_.union([bvApi.typePairs]), true);
  var methods = grammr(typePairs);
  return methods;
});

BV.define('bv/c2013/model/sidebar',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/util/contentType'
], function (ENV, BModel, _, ContentType) {
  return BModel.extend({
    name: 'sidebar',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
    },

    processData: function (authorData) {
      this.set(ContentType.Noun(this.get('subjectType')), authorData);
      this.dataReady(authorData);
    }

  });
});

/* START GENERATED MESSAGE */
BV.define('_i18n_avatarIconContentAuthor', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarIconContentAuthor( data ) {
try { return (function(d){
var r = "";
r += "Avatar image";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarIconContentAuthor`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarIconContentAuthor', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarIconContentAuthor(data);
});
return avatarIconContentAuthor;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarIconMale', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarIconMale( data ) {
try { return (function(d){
var r = "";
r += "Avatar image";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarIconMale`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarIconMale', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarIconMale(data);
});
return avatarIconMale;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarIconFemale', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarIconFemale( data ) {
try { return (function(d){
var r = "";
r += "Avatar image";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarIconFemale`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarIconFemale', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarIconFemale(data);
});
return avatarIconFemale;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarIconGeneric', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarIconGeneric( data ) {
try { return (function(d){
var r = "";
r += "Avatar image";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarIconGeneric`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarIconGeneric', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarIconGeneric(data);
});
return avatarIconGeneric;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorIcon',['hbs','vendor/handlebars/runtime', 'template/helpers/exists', 'template/helpers/renderIcon', 'template/helpers/equals', '_i18n_avatarIconContentAuthor', '_i18n_avatarIconMale', '_i18n_avatarIconFemale', '_i18n_avatarIconGeneric'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <img ";
  stack1 = helpers['if'].call(depth0, depth0.lazyLoad, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "src=\"";
  if (stack1 = helpers._avatarImage) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._avatarImage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\"";
  if (stack1 = helpers._i18n_avatarIconContentAuthor) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_avatarIconContentAuthor; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-author-thumb\"/> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "data-";
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(8, program8, data),fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.ContextDataValues),stack1 == null || stack1 === false ? stack1 : stack1.Gender)),stack1 == null || stack1 === false ? stack1 : stack1.Value), "Male", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.ContextDataValues),stack1 == null || stack1 === false ? stack1 : stack1.Gender)),stack1 == null || stack1 === false ? stack1 : stack1.Value), "Male", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span title=\"";
  if (stack1 = helpers._i18n_avatarIconMale) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_avatarIconMale; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-author-no-avatar bv-author-gender-Male\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-author-gender-Male", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-author-gender-Male", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }
function program6(depth0,data) {
  
  
  return "&#x2642;";
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span title=\"";
  if (stack1 = helpers._i18n_avatarIconFemale) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_avatarIconFemale; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-author-no-avatar bv-author-gender-Female\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-author-gender-Female", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-author-gender-Female", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }
function program9(depth0,data) {
  
  
  return "&#x2640;";
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span title=\"";
  if (stack1 = helpers._i18n_avatarIconGeneric) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_avatarIconGeneric; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-author-no-avatar bv-author-gender-Male\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-author-gender-Male", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-author-gender-Male", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0._avatarImage, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{},inverse:self.program(11, program11, data),fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, ((stack1 = depth0.ContextDataValues),stack1 == null || stack1 === false ? stack1 : stack1.Gender), options) : helperMissing.call(depth0, "exists", ((stack1 = depth0.ContextDataValues),stack1 == null || stack1 === false ? stack1 : stack1.Gender), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorIcon', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/exists',['vendor/handlebars/runtime'], function (Handlebars) {

  // Evaluates to true if the property in question is not `null` or
  // `undefined`. Much stricter than the builtin `#if`, which will evaluate
  // to false with `""`, `0`, or another "falsy" value.
  //
  //
  // EXAMPLES:
  //
  // (given data: { foo: 1, bar: 0, baz: null })
  //
  // {{#exists foo}}   evaluates true.
  // {{#exists bar}}   evaluates true.
  // {{#exists baz}}   evaluates false.
  // {{#exists blerg}} evaluates false.
  //
  function exists (context, block) {
    var ifResult = !(context === null || context === undefined);

    if (ifResult) {
      return block.fn(this);
    }
    else {
      return block.inverse(this);
    }
  }

  Handlebars.registerHelper('exists', exists);
  return exists;
});

/*
 * This file lets us avoid having to load ENV to get basic config values.
 * It should only be used in circumstances where we don't want to incur
 * the overhead of ENV (which includes Backbone, jQuery, underscore, etc.)
 */
BV.define('bv/util/envConfig',['window'], function (window) {
  return window.BV && window.BV.options;
});

BV.define('template/helpers/renderIcon',['vendor/handlebars/runtime', 'bv/util/envConfig'], function (Handlebars, envConfig) {

  function renderIcon (cls, options) {
    var classList = options.hash.classList || '';
    var ariaHidden = options.hash.ariaHidden ? 'aria-hidden="true"' : '';
    var role = options.hash.role ? 'role="' + options.hash.role + '"' : '';
    var style = options.hash.style ? 'style="' + options.hash.style + '"' : '';
    var classes = [];

    if (options.hash.classList) {
      classes.push(options.hash.classList);
    }

    if (envConfig && envConfig.display && envConfig.display.sprite) {
      classes.push(Handlebars.Utils.escapeExpression(cls));
      classes = 'class="' + classes.join(' ') + '"';
      return '<!--[if !IE]> -->' +
                options.fn(this) +
             '<!-- <![endif]-->' +
             '<!--[if lte IE 9]>' +
               '<div ' + classes + '></div>' +
             '<!-- <![endif]-->';
    }
    else {
      classes = classes.length ? 'class="' + classes.join(' ') + '"' : '';

      if ((classes && classes.length) || ariaHidden || role || style) {
        return '<span ' + classes + ' ' + ariaHidden + ' ' + role + '  ' + style + '>' + options.fn(this) + '</span>';
      }

      return options.fn(this);
    }
  }

  Handlebars.registerHelper('renderIcon', renderIcon);
  return renderIcon;
});

/* START GENERATED MESSAGE */
BV.define('_i18n_avatarStatsReviewCount_v2', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarStatsReviewCount_v2( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalReviewCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\">Review</span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalReviewCount"];
r += "</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\">Reviews</span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalReviewCount"];
r += "</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarStatsReviewCount_v2`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarStatsReviewCount_v2', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarStatsReviewCount_v2(data);
});
return avatarStatsReviewCount_v2;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarStatsQuestionCount_v2', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarStatsQuestionCount_v2( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalQuestionCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Question </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalQuestionCount"];
r += "</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Questions </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalQuestionCount"];
r += "</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarStatsQuestionCount_v2`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarStatsQuestionCount_v2', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarStatsQuestionCount_v2(data);
});
return avatarStatsQuestionCount_v2;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarStatsAnswerCount_v2', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarStatsAnswerCount_v2( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalAnswerCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Answer </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalAnswerCount"];
r += "</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Answers </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalAnswerCount"];
r += "</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarStatsAnswerCount_v2`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarStatsAnswerCount_v2', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarStatsAnswerCount_v2(data);
});
return avatarStatsAnswerCount_v2;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_avatarStatsHelpfulCount_v2', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function avatarStatsHelpfulCount_v2( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "HelpfulVoteCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Vote </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["HelpfulVoteCount"];
r += "</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-author-userstats-data\"> Votes </span> <span class=\"bv-author-userstats-value\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["HelpfulVoteCount"];
r += "</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `avatarStatsHelpfulCount_v2`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_avatarStatsHelpfulCount_v2', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return avatarStatsHelpfulCount_v2(data);
});
return avatarStatsHelpfulCount_v2;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorStats',['hbs','vendor/handlebars/runtime', 'template/helpers/withIf', 'template/helpers/conditionalContainer', 'template/helpers/exists', '_i18n_avatarStatsReviewCount_v2', '_i18n_avatarStatsQuestionCount_v2', '_i18n_avatarStatsAnswerCount_v2', '_i18n_avatarStatsHelpfulCount_v2'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("author-userstats")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("ul"),
    'classList': ("author-userstats-list"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.TotalReviewCount, options) : helperMissing.call(depth0, "exists", depth0.TotalReviewCount, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.TotalQuestionCount, options) : helperMissing.call(depth0, "exists", depth0.TotalQuestionCount, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.TotalAnswerCount, options) : helperMissing.call(depth0, "exists", depth0.TotalAnswerCount, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.TotalStatistics, options) : helperMissing.call(depth0, "withIf", depth0.TotalStatistics, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-author-userstats-reviews\" role=\"presentation\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_avatarStatsReviewCount_v2),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_avatarStatsReviewCount_v2", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-author-userstats-questions\" role=\"presentation\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_avatarStatsQuestionCount_v2),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_avatarStatsQuestionCount_v2", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-author-userstats-answers\" role=\"presentation\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_avatarStatsAnswerCount_v2),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_avatarStatsAnswerCount_v2", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.HelpfulVoteCount, options) : helperMissing.call(depth0, "exists", depth0.HelpfulVoteCount, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-author-userstats-votes\" role=\"presentation\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_avatarStatsHelpfulCount_v2),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_avatarStatsHelpfulCount_v2", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Author, options) : helperMissing.call(depth0, "withIf", depth0.Author, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorStats', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
(function () {

  // Wraps a content block inside of an element, but only if that block
  // produces non-whitespace content.
  //
  // This is useful because we end up having a lot of divs that should only
  // exist on the page if there's content to render inside of them. This
  // saves us from constructing some gnarly conditionals.
  //
  // EXAMPLE:
  //
  // {{#conditionalContainer . tag='div' id='some-container'}}
  //   {{#if foo}}
  //     Bar
  //   {{/if}}
  // {{/conditionalContainer}}
  //
  // Here, `div#some-container` will only exist when `foo` is true.
  //
  var _;
  var trim = String.prototype.trim;
  var trimLeft = /^\s+/;
  var trimRight = /\s+$/;

  // copy of trim from jquery
  var trimString = trim ?
    function (text) {
      return text === null ?
        '' :
        trim.call(text);
    } :

    function (text) {
      return text === null ?
        '' :
        text.toString().replace(trimLeft, '').replace(trimRight, '');
    };

  function conditionalContainer (context, options) {
    var tag = (options.hash.tag || 'div');
    var classes = options.hash.classList ? options.hash.classList.split(/\s+/) : [];
    var idStr = options.hash.id ? ' id="' + options.hash.id + '"' : '';
    var roleString = options.hash.role ? ' role="' + options.hash.role + '"' : '';
    var classStr = '';
    var innerString = options.fn(context);

    // Trim the string and remove all &nbsp; to check for emptiness.
    var trimmed = trimString(innerString.replace(/&nbsp;/gi, ''));
    var isEmpty = trimmed === '' || trimmed === '&nbsp;';
    if (isEmpty) {
      return '';
    }
    if (classes.length) {
      classStr = ' class="bv-' + classes.join(' bv-') + '"';
    }
    return '<' + tag + idStr + classStr + roleString + '>' + innerString + '</' + tag + '>';
  }
      BV.define('template/helpers/conditionalContainer',['vendor/handlebars/runtime', 'underscore'], function (hbs, underscore) {
      _ = underscore;
      hbs.registerHelper('conditionalContainer', conditionalContainer);
      return conditionalContainer;
    });
  })();

/**
 * This plugin code should only be invoked in development.
 *
 * In development, using unbuilt clients, it constructs a map containing all the
 * badges that have custom images and the url to the image that is based on the
 * config hub API.
 *
 * For built clients, whether or not in development, a different image map is
 * built with URLs that point to badge images that were deployed to S3 by our
 * build process. The build image map is written as a hard-coded require define
 * (see the "write" function below). Because the map will already be defined for
 * built clients mode, none of the code below will run in production.
 */
BV.define('badges',['underscore', 'vendor/json2'], function (_, JSON) {
  var buildText = '';

  return {
    load: function (name, parentRequire, load, config) {
      // When not in build mode, use the config api to load badge images
      var badges = config.badges;
      var configBadgeApiBaseUrl = config.configBadgeApiBaseUrl;
      var badgeExtensionMap = config.badgeExtensionMap || {};
      var buildBaseUrl = '{{baseUrl}}/images/badgeImages';
      var devBadgeMap = {};
      var buildBadgeMap = {};
      _(badges).forEach(function (badge) {
        var devUrl;
        var buildUrl;
        if (badge.customImage) {
          devUrl = configBadgeApiBaseUrl.replace('{{imageName}}', badge.badgeImageName);
          buildUrl = buildBaseUrl + '/' + badge.id + badgeExtensionMap[badge.id];
        }
        devBadgeMap[badge.id] = {
          badgeImageUrl: devUrl,
          badgeDescription: badge.description,
          badgeTitle: badge.title,
          badgeDisplayLabel: badge.displayLabel
        };
        buildBadgeMap[badge.id] = {
          badgeImageUrl: buildUrl,
          badgeDescription: badge.description,
          badgeTitle: badge.title,
          badgeDisplayLabel: badge.displayLabel
        };
      });

      // For production use the S3/Cloudfront image urls
      buildText = 'BV.define(' + JSON.stringify(buildBadgeMap) + ');\n';

      parentRequire([], function () {
        load(devBadgeMap);
      });

    },
    write: function (pluginName, moduleName, write) {
      write.asModule(pluginName + '!' + moduleName, buildText);
    }
  };
});

BV.define('badges!',{"expert":{"badgeDescription":"This person has a high level of expertise or experience with the product or service.","badgeTitle":"Expert"},"verifiedpurchaser":{"badgeDescription":"This reviewer owns this product.","badgeTitle":"Verified Purchaser"},"featured":{"badgeDescription":"The company that provides the product or service considers this review helpful.","badgeTitle":"Featured"},"top500":{"badgeDescription":"This person is one of the top 500 contributors of useful reviews.","badgeTitle":"Top 500 Contributor"},"top10":{"badgeDescription":"This person is one of the top 10 contributors of useful reviews.","badgeTitle":"Top 10 Contributor"},"top50":{"badgeDescription":"This person is one of the top 50 contributors of useful reviews.","badgeTitle":"Top 50 Contributor"},"top1000":{"badgeDescription":"This person is one of the top 1000 contributors of useful reviews.","badgeTitle":"Top 1000 Contributor"},"top1":{"badgeDescription":"This person is the top contributor of useful reviews.","badgeTitle":"Top Contributor"},"staff":{"badgeDescription":"When enabled, you can configure these badges to indicate that the contributor has an affiliation with the product or retail organization.","badgeTitle":"Staff"},"top25":{"badgeDescription":"This person is one of the top 25 contributors of useful reviews.","badgeTitle":"Top 25 Contributor"},"incentivizedreview":{"badgeImageUrl":"{{baseUrl}}/images/badgeImages/incentivizedreview.png","badgeDescription":"This reviewer received an incentive to write this review. An incentive can be a coupon, sample product, sweepstakes entry, loyalty points, or other token of value in exchange for writing a review for this product.","badgeTitle":"Incentivized Review","badgeDisplayLabel":"Incentivised Review"},"top250":{"badgeDescription":"This person is one of the top 250 contributors of useful reviews.","badgeTitle":"Top 250 Contributor"},"top100":{"badgeDescription":"This person is one of the top 100 contributors of useful reviews.","badgeTitle":"Top 100 Contributor"}});

/**
 * @fileOverview Helper that checks if badge image exists but also sets description and title.
 */
BV.define('template/helpers/ifBadgeImage',[
  'vendor/handlebars/runtime',
  'badges!',
  'BV',
  'underscore'
], function (Handlebars, enabledBadges, BV, _) {

  /**
   * The API field for "ContributorRank" doesn't match the badgeId of the contributor badge.
   * We need to detect contributor ranks and convert them to their corresponding badgeId.
   */
  var contributorBadgeRegex = /TOP_\d+/;

  function ifBadgeImage (badges, badgeId, context) {
    var badgeData;
    var configBadgeId;

    if (badgeId.match(contributorBadgeRegex)) {
      var contributorNumber = badgeId.split('_')[1];
      badgeId = 'top' + contributorNumber;
    }

    if (!badges || !badges[badgeId]) {
      return;
    }

    var badge = badges[badgeId];
    // Normalize all IDs to lowercase just to be safe.
    configBadgeId = badge.Id.toLowerCase();
    var enabledBadge = enabledBadges[configBadgeId];
    if (enabledBadge) {
      badgeData = _({}).extend(badge);
      badgeData.description = enabledBadge.badgeDescription;
      badgeData.title = enabledBadge.badgeTitle;
      badgeData.displayLabel = enabledBadge.badgeDisplayLabel;

      if (enabledBadge.badgeImageUrl) {
        badgeData.imageUrl = enabledBadge.badgeImageUrl.replace('{{baseUrl}}', BV._internal.baseUrl);
        return context.fn(badgeData);
      }
      else {
        return context.inverse(badgeData);
      }
    }
    // The badge is not enabled, do nothing
    return;
  }

  Handlebars.registerHelper('ifBadgeImage', ifBadgeImage);
  return ifBadgeImage;
});

BV.define('dimsumFields!localeMapping',[], {"anonymousContentAuthorPreview":"you","featuredQuestionsFirst":"Featured questions first","totalAAStats":"{TotalCount, plural, one { {TotalSecondaryCount, plural, one {<a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\"> {TotalCount} question </a> and <a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\"> {TotalSecondaryCount} answer </a> for this product} other {<a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\"> {TotalCount} question </a> and <a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\"> {TotalSecondaryCount} answers </a> for this product} } } other { {TotalSecondaryCount, plural, one {<a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\"> {TotalCount} questions </a> and <a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\"> {TotalSecondaryCount} answer </a> for this product} other {<a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\"> {TotalCount} questions </a> and <a href=\"\\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\"> {TotalSecondaryCount} answers </a> for this product} } } }","submit_answer":"Post Answer","contentReportedBtn":"Reported","ProductIsRecommended":"Yes","display_commenttext":"Comment","contentReportBtn":"Report","display_usernickname":"Nickname","submit_comment":"Post Comment","display_hostedauthentication_authenticationemail":"Email","categoryGalleryReviewCount":"{TotalCount, plural, one { {TotalCount} review } other { {TotalCount} reviews } }","content_sort_link":"Sort","reviewPhotoMaxCount":"{maxPhotos, plural, one {Add up to {maxPhotos} photo} other {Add up to {maxPhotos} photos} }","remove_confirm_photo":"{Gender, select, other {Are you sure you want to remove this photo?} }","error_ERROR_FORM_INVALID_OPTION":"invalid value","display_title":"Review Title","error_ERROR_FORM_SUBMITTED_NICKNAME":"nickname already used","error_ERROR_FORM_IMAGE_PARSE":"invalid image","featured":"Featured","content_filter_show_all_label":"Show All","avatar_rank_TOP_25":"Top 25 Contributor","error_ERROR_FORM_DUPLICATE_NICKNAME":"nickname already used","searchStatsTotalQuestionCount":"{TotalCount, plural, one {<span class=\"bv-content-title\">{TotalCount}</span> <span class=\"bv-content-data-label\">Question</span>} other {<span class=\"bv-content-title\">{TotalCount}</span> <span class=\"bv-content-data-label\">Questions</span>} }","reviewPhotoRemainingCount":"({remainingPhotos, plural, one { {remainingPhotos} remaining } other { {remainingPhotos} remaining } })","firstToAskQuestion":"{ Gender, select, other {Be the first to ask a question} }","recentQuestionsLast":"Oldest questions","searchStatsTotalReviewCount":"{TotalCount, plural, one {<span class=\"bv-content-title\">{TotalCount}</span> <span class=\"bv-content-data-label\">Review</span>} other {<span class=\"bv-content-title\">{TotalCount}</span> <span class=\"bv-content-data-label\">Reviews</span>} }","recommendationCount":"{RecommendedCount} out of {TotalRecommendedCount} ({percentage}%) reviewers recommend this product","contentPreview_Questions":"Thank you for submitting a question! Your question is being moderated and may take up to a few days to appear.","helpfulnessAnswersFirst":"Most helpful answers","avatar_rank_NONE":"","error_ERROR_FORM_IMAGE_WIDTH_TOO_SMALL":"image too narrow","header_review":"{productNameAvailable, select, true {My Review for {productName}} false {My Review} }","writeReview":"{ Gender, select, other { Write a review } }","actionBarHeader_v2":"{ Type, select, review {Reviews} question {Questions} answer {Answers} other {Content} }","avatar_badge_brand":"Brand","content_secondary_btn_Reviews":"Comment","avatar_badge_staff":"Staff","socialConnectThankYou":"Thanks! You've posted your content on Facebook.","error_ERROR_FORM_REQUIRED_NICKNAME":"required","display_questionsummary":"Question","placeholder_hostedauthentication_authenticationemail":"Example: youremail@example.com","ratingSnapshotHeader":"Rating Snapshot","avatar_rank_TOP_100":"Top 100 Contributor","add_photo":"Add Photo","content_type_display":"{ type, select, review { { total, plural, one {Review} other {Reviews} } } question { { total, plural, one {Question} other {Questions} } } answer { { total, plural, one {Answer} other {Answers} } } product { { total, plural, one {Product} other {Products} } } other { { total, plural, one {Content} other {Content} } } }","show_full_Review":"Show Full Review","content_filter_locale":"Locale","contentConsLabel":"Cons:","display_userlocation":"Location","contentIsHelpful":"Yes","error_ERROR_FORM_REQUIRED_EITHER":"required","recommendsProduct":"{Gender, select, other {I recommend this product.} }","error_ERROR_FORM_TOO_LOW":"too low","socialConnectFieldLabel":"Post your review on Facebook","oldest":"Oldest","placeholder_usernickname":"Example: jackie27","paginationLoadMore":"Load More","error_ERROR_FORM_DUPLICATE":"nickname already used","display_rememberemail":"Remember me","add_video":"Add Video","title_rating_3":"Average","placeholder_photocaption_1":"Example: My new shirt","avatarStatsReviewCount_v2":"{TotalReviewCount, plural, one {<span class=\"bv-author-userstats-data\">Review</span> <span class=\"bv-author-userstats-value\"> {TotalReviewCount} </span>} other {<span class=\"bv-author-userstats-data\">Reviews</span> <span class=\"bv-author-userstats-value\"> {TotalReviewCount} </span>} }","helper_netpromoterscore_1":"Never","contentSubmitted_comment":"Your comment was submitted!","display_rating":"Overall Rating","searchStatsTotalAnswerCount":"{TotalSecondaryCount, plural, one {<span class=\"bv-content-title\">{TotalSecondaryCount}</span> <span class=\"bv-content-data-label\">Answer</span>} other {<span class=\"bv-content-title\">{TotalSecondaryCount}</span> <span class=\"bv-content-data-label\">Answers</span>} }","contentListPageInfoSimple":"{orphanEnd, select, true {{total, plural, one {{lastPageSize} of {total}} other {{lastPageSize} of {total}} }} other {{total, plural, one {{pageSize} of {total}} other {{pageSize} of {total}} }} }","negative":"Lowest to Highest Rating","facebookAvatarButton":"Add Profile Photo","contentPreview_Reviews":"Thank you for submitting a review! Your review is being moderated and may take up to a few days to appear.","error_ERROR_FORM_TOO_SHORT":"too short","submit_review":"Post Review","placeholder_questionsummary":"Ask a question...","mostAnsweredQuestionsLast":"Answers needed","recentAnswersFirst":"Newest answers","firstToWriteReview":"{ Gender, select, other {Be the first to review this product} }","display_isrecommended":"{Gender, select, other {Would you recommend this product to a friend?} }","janrain_error_try_again":"We're sorry, something went wrong. Please try again.","close":"Close","header_question":"Ask a Question","anonymousContentAuthor":"Anonymous","mostRecent":"Most Recent","error_ERROR_FORM_FILE_TOO_LARGE":"file too large","askQuestion":"{ Gender, select, other { Ask a question } }","mostUnhelpful":"Least Helpful","responseFrom":"Response from {clientName}:","error_ERROR_FORM_REQUIRED_FAKE":"required","display_videourl_1":"Link to YouTube Video","appTotalContentCount":"{TotalCount, plural, one { {TotalCount} Review } other { {TotalCount} Reviews }}","content_filter_ratings":"Rating","contentPreview_Comments":"Thank you for submitting a comment! Your comment is being moderated and may take up to a few days to appear.","answerRequestActionBarHeader":"Can you answer the following questions?","content_search_button":"Search","error_ERROR_FORM_PATTERN_MISMATCH":"only use letters and numbers","title_rating_1":"Poor","helpfulnessAnswersLast":"Least helpful answers","avatar_rank_TOP_50":"Top 50 Contributor","helpfulStats":"{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} of {TotalFeedbackCount} people found this helpful} other {{TotalPositiveFeedbackCount} of {TotalFeedbackCount} people found this helpful} }","error_unknown":"error","error_ERROR_FORM_TOO_FEW":"too few","notRecommendProduct":"{Gender, select, other {I do not recommend this product.} }","content_share_button":"Share","recentQuestionsFirst":"Newest questions","placeholder_videocaption_1":"Example: How to Install","error_ERROR_FORM_TOO_LONG":"too long","error_ERROR_FORM_REQUIRES_TRUE":"required","placeholder_userlocation":"Example: New York, NY","error_ERROR_FORM_INVALID_IPADDRESS":"invalid IP","avatar_rank_TOP_250":"Top 250 Contributor","contentIsNotHelpful":"No","cancel":"Cancel","display_photocaption_1":"Caption","header_comment":"My Comment","error_ERROR_FORM_REQUIRED":"required","display_photourl_1":"Choose File","helper_netpromoterscore_2":"Definitely","userAlreadyVerified":"This email address has already been verified.","error_ERROR_FORM_IMAGE_TOO_LARGE":"image too large","selectOne":"Select","error_message_invalid_url_video":"Invalid YouTube URL","questionCloseForAnswers":"This question is closed for new answers!","error_ERROR_FORM_FILE_PARSE":"error","error_message_require_url_video":"YouTube URL is required","mostHelpful":"Most Helpful","placeholder_answertext":"Answer this question...","content_search_placeholder":"Search topics and reviews","authorProfileArchiveTabReviews":"Reviews","remove_confirm_video":"Are you sure you want to remove this video?","productFamilyText":"Originally posted on <a href=\"{Url}\" class=\"bv-focusable\">{Name}</a>","error_ERROR_FORM_TOO_HIGH":"too high","avatar_rank_TOP_1000":"Top 1000 Contributor","error_ERROR_FORM_PROFANITY":"profanity","title_rating_4":"Good","placeholder_reviewtext":"Example: I bought this a month ago and am so happy that I did...","avatarFieldLabel":"Complete your profile","avatarStatsHelpfulCount_v2":"{HelpfulVoteCount, plural, one {<span class=\"bv-author-userstats-data\"> Vote </span> <span class=\"bv-author-userstats-value\"> {HelpfulVoteCount} </span>} other {<span class=\"bv-author-userstats-data\"> Votes </span> <span class=\"bv-author-userstats-value\"> {HelpfulVoteCount} </span>} }","content_search_no_results":"Your search returned no results.","contentProsLabel":"Pros:","error_ERROR_FORM_REJECTED":"Does not meet moderation guidelines","relevancyPopup":"<strong>Relevancy sort</strong> puts the best reviews at the top. We look at things like helpfulness votes, latest reviews, pictures and other traits that readers look for in their reviews.","error_ERROR_FORM_IMAGE_HEIGHT_TOO_SMALL":"image too short","placeholder_title":"Example: Great features!","unavailableSubmission":"We're sorry, submission is currently unavailable.","avatarStatsQuestionCount_v2":"{TotalQuestionCount, plural, one {<span class=\"bv-author-userstats-data\"> Question </span> <span class=\"bv-author-userstats-value\"> {TotalQuestionCount} </span>} other {<span class=\"bv-author-userstats-data\"> Questions </span> <span class=\"bv-author-userstats-value\"> {TotalQuestionCount} </span>} }","mostAnsweredQuestionsFirst":"Most answered","avatarFieldDescription":"Display your Facebook or Gravatar profile photo with your submission.","error_ERROR_FORM_INVALID_EMAILADDRESS":"invalid email","helper_rating_1":"Clique para classificar!","recentAnswersLast":"Oldest answers","content_secondary_btn_Questions":"Answer this Question","avatar_rank_TOP_1":"Top Contributor","avatar_rank_TOP_500":"Top 500 Contributor","avatarThankYou":"Thanks! You've added your avatar to your content.","error_ERROR_FORM_RESTRICTED":"too young","placeholder_useremail":"Example: yourname@example.com","content_follow_button":"Follow","fullProfileLink":"See My Profile","acceptTCButton":"Accept","content_filter_clear_label":"Clear All","contentSubmitted_answer":"Your answer was submitted!","duplicateContent":"{Gender, select, other {You already submitted a review. Thanks!} }","contentHelpfulQuestion":"Helpful?","error_ERROR_FORM_STORAGE_PROVIDER_FAILED":"upload failed","mediaViewerCollectionSummary":"{currentItem} of {totalItems}","title_rating_5":"Excellent","remove_photo":"Remove Photo","authorProfileArchiveTabQuestions":"Questions","add_facebookphoto":"Add Photo","mostHelpfulFavorable_Reviews":"Most Helpful Favorable Review","authorProfileArchiveTabAnswers":"Answers","display_reviewtext":"Review","relevancy":"Most Relevant","display_videocaption_1":"Caption","syndicationText":"Originally posted on <a href=\"{ContentLink}\" class=\"bv-focusable\">{Name}</a>","error_ERROR_FORM_UPLOAD_IO":"upload failed","display_useremail":"Email","answersWithAffiliationStaffFirst":"Staff answers","socialConnectFieldDescription":"Share your opinion with friends on Facebook.","placeholder_commenttext":"Write a comment...","mostHelpfulCritical_Reviews":"Most Helpful Critical Review","avatar_rank_TOP_10":"Top 10 Contributor","avatar_badge_expert":"Expert","positive":"Highest to Lowest Rating","title_rating_2":"Fair","avatarStatsAnswerCount_v2":"{TotalAnswerCount, plural, one {<span class=\"bv-author-userstats-data\"> Answer </span> <span class=\"bv-author-userstats-value\"> {TotalAnswerCount} </span>} other {<span class=\"bv-author-userstats-data\"> Answers </span> <span class=\"bv-author-userstats-value\"> {TotalAnswerCount} </span>} }","secondaryContentCommentLink":"comments","facebookShareButton":"Share on Facebook","searchActionBarHeader":"Search Results","submit_question":"Post Question","secondaryContentAnswerLink":"{TotalSecondaryContentCount, plural, one {answer} other {answers} }","ProductIsNotRecommended":"No","header_answer":"My Answer","display_netpromotercomment":"Please tell us why <em>(will not appear on our site)</em>","userVerified":"{Gender, select, other {Thanks! You have successfully authenticated your content.} }","contentListPageInfo":"{orphanEnd, select, true {{total, plural, one {{start} of {total}} other {{start} of {total}} }} other {{total, plural, one {{start} of {total}} other {{start}&ndash;{end} of {total}} }} }","display_netpromoterscore":"{Gender, select, other {Would you recommend {clientName} to a friend?} }","contentFeaturedBadge":"Featured","avatar_badge_verified_purchaser":"Verified Purchaser","display_answertext":"Answer","secondaryRatingSummaryHeader":"Average Customer Ratings","contentSubmitted_question":"Your question was submitted!","contentSubmitted_review":"Your review was submitted!","remove_video":"Remove Video","content_filter_expand_label":"Filter {contentType}","offscreen_summaryStars":"{AverageOverallRating} out of {OverallRatingRange} stars. Read reviews for ","moreCriticalLink_Reviews":"See more 1, 2, and 3 star reviews","avatarIconFemale":"Avatar image","offscreen_sort_label":"Sort by","offscreen_histogram_stars":"stars","submission_yes":"Yes","autocomplete_available":"Autocomplete available, press the down arrow to hear options","helpertext_photourl_1":"<div>  Photo guidelines</div> <div>  When submitting images, please follow these guidelines:</div> <ul>  <li>   Images must be in BMP, PNG, GIF or JPEG format.</li>  <li>   File size must be 5 MB or less.</li>  <li>   Image must be at least 60 pixels tall.</li>  <li>   Image must be at least 60 pixels wide.</li>  <li>   If you are not the copyright holder, you may not submit copyrighted images.</li>  <li>   Objectionable images will be rejected.</li>  <li>   Uploaded images become the property of the Company.</li> </ul> ","error_message_required":"Required","placeholder_netpromoterscore":"Rate from 0 to 10 where 0 is never and 10 is definitely.","histogram_readReviews":"{Gender, select, other {{TotalCount, plural, one {Read a Review} other {Read {TotalCount} Reviews}}}}","offscreen_ugc_arrow":"Menu, press enter to show options","paginationPrevious":"Previous","offscreen_ratingStars":"{Rating} out of {RatingRange} stars.","aria_alert_voted_positive":"Your vote was successful. The number of positive helpfulness votes is now {Count}.","offscreen_secondary_rating":"{Value} out of {ValueRange}","secondaryRatingSummaryOverallRatingLabel":"Overall","avatarIconMale":"Avatar image","helpertext_reviewtext":"<h2>  Writing guidelines</h2> <p>  We want to publish your review, so please:</p> <ul>  <li>   Keep your review focused on the product.</li>  <li>   Avoid writing about customer service, contact us instead if you have issues requiring immediate attention.</li>  <li>   Refrain from mentioning competitors or the specific price you paid for the product.</li>  <li>   Do not include any personally identifiable information, such as full names.</li> </ul> ","morePositiveLink_Reviews":"See more 4 and 5 star reviews","offscreen_histogram_count":"reviews","error_message_minlength":"{difference, plural, one { {difference} character too short } other { {difference} characters too short }}","paginationNext":"Next","submission_no":"No","offscreen_play_media":"Play Video","wait_feedback":"Loading","aria_alert_voted_negative":"Your vote was successful. The number of negative votes is now {Count}.","helpertext_videourl_1":"<h2>  Video guidelines</h2> <p>  When submitting videos, please follow these guidelines:</p> <ul>  <li>   Make sure your video is related to the product.</li>  <li>   Try to submit videos of you using the product.</li>  <li>   Inappropriate videos will be rejected along with your review.</li>  <li>   If you are not the copyright holder, you may not submit copyrighted videos.</li> </ul> ","placeholder_rating":"Rate from 1 to 5 where 1 is poor and 5 is excellent.","aria_alert_voted_inappropriate":"You have successfully reported this content as inappropriate.","offscreen_sort_arrow":"Menu","avatarIconGeneric":"Avatar image","categoryTotalReviewCount":"{TotalCount, plural, one {({TotalCount})} other {({TotalCount})} }","offscreen_secondary_rating_summary":"average rating value is {AverageRating} of {RatingRange}.","offscreen_filter_label":"Filter by","responseFrom_reviewresponse":"Response from {Department}:","content_filter_star_ratings":"{rating, plural, one {{rating} star} other {{rating} stars} }","add_photo_dialog":"Add Photo. dialog.","content_filter_button_clear":"Clear All","error_message_maxlength":"{difference, plural, one { {difference} character too long } other { {difference} characters too long } }","contentItem_defaultPhotoCaption":"{ContentType, select, review { Review photo {ItemNumber} } comment { Comment photo {ItemNumber} } clientresponse { Comment photo {ItemNumber} } question { Question photo {ItemNumber} } answer { Answer photo {ItemNumber} } other { Content photo {ItemNumber} } }","markAsHelpful":"Yes, {contentSelectType} by {authorDisplayName} is helpful.","content_filter_list_title":"Active Filters","product_item_collection_other_categories":"in all categories","message_characters_used_minlength":"{count} out of a minimum {minlength} characters used","markAsInappropriate":"{hasTitle, select, true { Mark {Title} by {authorDisplayName} as inappropriate. } other { {contentSelectType, select, review { Mark this review by {authorDisplayName} as inappropriate. } comment { Mark this comment by {authorDisplayName} as inappropriate. } clientresponse { Mark this response by {authorDisplayName} as inappropriate. } question { Mark this question by {authorDisplayName} as inappropriate. } answer { Mark this answer by {authorDisplayName} as inappropriate. } other { Mark this content by {authorDisplayName} as inappropriate. } } } }","product_item_collection_no_results":"No products found","contentItem_defaultVideoCaption":"{ContentType, select, review { Review video {ItemNumber} } comment { Comment video {ItemNumber} } clientresponse { Comment video {ItemNumber} } question { Question video {ItemNumber} } answer { Answer video {ItemNumber} } other { Content video {ItemNumber} } }","error_message_maxlength_aria":"{difference, plural, one { Error: Value is {difference} character too long } other { Error: Value is {difference} characters too long } }","deeplinkModalTitle":"Content Dialog","error_message_required_aria":"Error: Required.","offscreen_content_secondary_btn_Questions":"Answer this question by {authorDisplayName}.","field_required":"Required field","offscreen_secondary_rating_summary_stars":"{AverageRating} out of {RatingRange} stars.","product_item_collection_in_category":"in","show_full_offscreen_Review":"This action will open a modal dialog.","selectCategory":"More Categories","goBackCategory":"Back to {lastCategoryName}","product_picker_title":"Select a Product to Review","message_characters_used_maxlength":"{count} of a possible {maxlength} characters used","markAsNotHelpful":"No, {contentSelectType} by {authorDisplayName} is not helpful.","logoSource":"Source:","readReviews":"{Gender, select, other {{TotalCount, plural, one {Read a Review} other {Read {TotalCount} Reviews}}}}","negativeFeedback":"{ Type, select, review {{ TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this review helpful.} other {{TotalNegativeFeedbackCount} people did not find this review helpful.}}} answer {{ TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this answer helpful.} other {{TotalNegativeFeedbackCount} people did not find this answer helpful.}}} comment {{ TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this comment helpful.} other {{TotalNegativeFeedbackCount} people did not find this comment helpful.}}}}","offscreen_content_secondary_btn_Reviews":"Comment on review by {authorDisplayName}.","product_sharing":"Share","positiveFeedback":"{ Type, select, review {{ TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this review helpful.} other {{TotalPositiveFeedbackCount} people found this review helpful.}}} answer {{ TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this answer helpful.} other {{TotalPositiveFeedbackCount} people found this answer helpful.}}} comment {{ TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this comment helpful.} other {{TotalPositiveFeedbackCount} people found this comment helpful.}}}}","content_search_placeholder_reviewGenericSubmission1":"Search {categoryName}","offscreen_writeReviewModalNotice":"This action will open a modal dialog.","add_video_dialog":"Add Video. dialog.","offscreen_category_select_arrow":"Menu, press enter to show options","error_message_minlength_aria":"{difference, plural, one { Error: Value is {difference} character too short } other { Error: Value is {difference} characters too short } }","next_media":"Next","media_dialog_label":"Media Viewer","offscreen_ratingSummaryText":"{AverageOverallRating} out of {OverallRatingRange} rating.","offscreen_showMediaModalNotice":"This action will open a modal dialog.","offscreen_photo":"Photo","previous_media":"Previous","noReviewsYet":"No reviews have been submitted yet.","userUnsubscribed":"You have successfully unsubscribed from these emails.","contentVerifiedPurchaserBadge":"Verified Purchaser","contentHelpfulStatement":"helpful","offscreen_value_max_means":"Rating of {sliderSize} means ","offscreenHelpful":"{Gender, select, other {{contentSelectType, select, review {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this review helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this review helpful. Click to agree.} }} comment {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this comment helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this comment helpful. Click to agree.} }} clientresponse {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this response helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this response helpful. Click to agree.} }} question {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this question helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this question helpful. Click to agree.} }} answer {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this answer helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this answer helpful. Click to agree.} }} other {{TotalPositiveFeedbackCount, plural, one {{TotalPositiveFeedbackCount} person found this content helpful. Click to agree.} other {{TotalPositiveFeedbackCount} people found this content helpful. Click to agree.} }} }} }","allCategories":"All Categories","offscreen_remove_filter":"Remove Filter","offscreen_value_of_one_means":"Rating of 1 means ","offscreen_histogram_ratingDistribution":"{Count, plural, one {{RatingValue, plural, one {{Count} review with {RatingValue} star.} other {{Count} review with {RatingValue} stars.} } } other { {RatingValue, plural, one {{Count} reviews with {RatingValue} star.} other {{Count} reviews with {RatingValue} stars.} } } }","error_AN_ERROR_OCCURRED":"An error occurred. Please try again.","syndicationTextNoLink":"Originally posted on {Name}","max_length_message":"Maximum of {maxlength} characters.","ariaTitle_answer":"Answer this Question","contentFeaturedBadgeAltText":"Featured review","offscreen_clear_all_filters":"Clear All Filters","contentVerifiedPurchaserBadgeAltText":"Verified purchaser","offscreenNotHelpful":"{Gender, select, other {{contentSelectType, select, review {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this review helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this review helpful. Click to agree.} }} comment {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this comment helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this comment helpful. Click to agree.} }} clientresponse {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this response helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this response helpful. Click to agree.} }} question {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this question helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this question helpful. Click to agree.} }} answer {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this answer helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this answer helpful. Click to agree.} }} other {{TotalNegativeFeedbackCount, plural, one {{TotalNegativeFeedbackCount} person did not find this content helpful. Click to agree.} other {{TotalNegativeFeedbackCount} people did not find this content helpful. Click to agree.} }} }} }","headToHeadSummary":"Review by {authorDisplayName}. Written {submissionTimeAgo}. {Rating} out of {RatingRange} stars.","video_upload_success":"The video was successfully linked.","avatarIconSocialConnect":"Avatar image","offscreen_secondary_rating_summary_value_max_means":"Rating of {RatingRange} means ","offscreen_content_secondary_value_of_one_means":"Rating of 1 means ","postSubmission_unknownError":"Something went wrong. Please try again later.","avatarIconSubmissionForm":"Avatar image","avatarIconContentAuthor":"Avatar image","submission_video_added":"The video was successfully added.","offscreen_content_secondary_value_max_means":"Rating of {ValueRange} means ","productFamilyTextNoLink":"Originally posted on {Name}","offscreen_secondary_rating_summary_value_of_one_means":"Rating of 1 means ","photo_upload_success":"The photo was uploaded successfully.","photo_upload_preview_placeholder":"Uploading photo.","photo_upload_preview":"This is a preview of the photo that was uploaded.","video_upload_preview_placeholder":"Loading video.","video_upload_preview":"This is a preview of the video that was linked.","submission_photo_added":"The photo was successfully added.","unsubscribe_unknownError":"Something went wrong. Please try again later.","error_ERROR_PRIVATE_BROWSING_MODE":"Sorry, writing reviews is disabled in private browsing mode. Please disable private browsing mode and try again.","display_casltext":"You may receive emails regarding this submission. Any emails will include the ability to opt-out of future communications.","authorDetailsOffscreenHeader":"User Details for {DisplayName}","postSubmission_errorOffScreenText":"Press Escape to return to the form.","postSubmission_unrecoverableErrorOffScreenText":"Press Escape to close this message","add_file":"Add File","add_facebookphoto_1":"Facebook","contentIncentivizedReviewBadge":"Received Free Product","error_ERROR_DUPLICATE_SUBMISSION":"{Gender, select, other {You already submitted a review. Thanks!} }","trustmarkPopupText":"These reviews are managed by Bazaarvoice and comply with the Bazaarvoice Authenticity Policy, which is supported by anti-fraud technology and human analysis.<br />Details at {url}","valid_field_input":"Field input is valid.","authentic_reviews":"Authentic Reviews","error_invalid_email":"Invalid email","error_invalid_email_aria":"Error: The email address is invalid.","ratingsOnly_contentListCount":"{count, plural, one {{count} Ratings-Only Review} other {{count} Ratings-Only Reviews}}","otherLocales_contentListCount":"{count, plural, one {{count} Review in Another Language} other {{count} Reviews in Other Languages}}","offscreen_relevancy_link_description":"Display a popup with information about Relevancy Sort.","histogram_filter":"{RatingValue, plural, one {Select to filter reviews with {RatingValue} star.} other {Select to filter reviews with {RatingValue} stars.} }","histogram_select_to_filter":"Select a row below to filter reviews.","max_length_reached_message":"Reached maximum of {maxlength} characters.","anonymous":"Anonymous","displaytext_review":"Reviews Tab Panel","displaytext_question":"Questions Tab Panel","displaytext_answer":"Answers Tab Panel","spotlights_readMoreAboutProduct":"Read more about this product","spotlights_reviewReadMore":"read more","spotlights_anonymousContentAuthor":"Anonymous","spotlights_productReviewsCount":"{ProductReviewCount, plural, one {{ReviewCount}&nbsp;<span class=\"bv-rating-count-label\">Review</span>} other {{ReviewCount}&nbsp;<span class=\"bv-rating-count-label\">Reviews</span>} }","error_ERROR_FORM_REJECTED_HEADER":"Your review cannot be approved at this time because it:","error_ERROR_FORM_REJECTED_CR":"mentions a competitor","error_ERROR_FORM_REJECTED_DBA":"directs business away","error_ERROR_FORM_REJECTED_PII":"includes personally identifiable information","error_ERROR_FORM_REJECTED_SI":"shipping or fulfillment focused","error_ERROR_FORM_REJECTED_IMG":"includes inappropriate media","error_ERROR_FORM_REJECTED_URL":"contains a URL","error_ERROR_FORM_REJECTED_VAC":"is vague or needs more detail","error_ERROR_FORM_REJECTED_PRF":"includes profanity","spotlights_incentivized":"This person received an incentive to write a review.","error_ERROR_FORM_REJECTED_SENTENCE":"This field {errorCodeMessage}","error_ERROR_FORM_REJECTED_VID":"includes inappropriate media","error_ERROR_FORM_REJECTED_PRI":"mentions the specific price","error_ERROR_FORM_REJECTED_CS":"customer service focused","error_ERROR_FORM_REJECTED_LI":"contains legally sensitive content","error_ERROR_FORM_REJECTED_FL":"does not match the site's language","error_ERROR_FORM_REJECTED_SPM":"looks like duplicate content","error_ERROR_FORM_REJECTED_GIU":"contains inappropriate content","error_ERROR_FORM_REJECTED_WP":"applies to a different product","error_ERROR_FORM_REJECTED_UA":"was written by a reviewer younger than 13","error_ERROR_FORM_REJECTED_PUX":"was written lacking personal experience","contentListPageInfoSearch":"Showing {orphanEnd, select, true {{end} of {end}} other {{total, plural, one {{total} of {total}} other {{start}&ndash;{end}} }}}","spotlights_reviewTruncatedSymbol":"...","spotlights_ay_reviewReadMore":"Click to read full text of review titled \"{ReviewTitle}\".","spotlights_ay_chevronBack":"Click here for the previous set of products.","spotlights_ay_chevronNext":"Click here for the next set of products.","spotlights_syndicated":"This review was originally posted to {Name}.","spotlights_ay_productAvgRating":"{ProductRating} out of {RatingRange} stars.","spotlights_ay_reviewRating":"This reviewer rated product {Rating} out of {RatingRange} stars.","spotlights_ay_productImgAltText":"Display product reviews for {ProductName}","sellerRatings_viewAll":"{TotalReviewCount, plural, one {View {TotalReviewCount} review} other {View all {TotalReviewCount} reviews}}","sellerRatings_postedBy":"Posted by {Author} {SubmissionTimeAgo}","sellerRatings_customersRated":"Customers rate us","sellerRatings_poweredBy":"Powered by {BazaarvoiceLabel}","sellerRatings_logoTitle":"Bazaarvoice","sellerRatings_ratingFraction":"{Rating} / {MaxRating}","sellerRatings_offscreenRating":"{Rating} out of {MaxRating} stars.","error_emoji":"Emoji not allowed","error_emoji_aria":"Error: This field cannot contain special characters like emoji.","sellerRatings_anonymous":"Anonymous","offscreen_prsNumberOfReviews":"This action will navigate to reviews.","spotlights_spotlightHeader":"","error_FAILED_TO_LOAD_FINGERPRINT_BEFORE":"Please disable any ad blockers, which can prevent successful review submission.","error_FAILED_TO_LOAD_FINGERPRINT_AFTER":"Ad blockers prevented your review submission. Please disable ad blockers from this page, then resubmit your review.","review_highlights_title":"Review Highlights","review_highlights_count":"{Count, plural, one { {Count} review } other { {Count} reviews } }","review_highlights_expand":"Full review","review_highlights_empty":"Suitable {Subject} could not be generated at this time.","review_highlights_author_name":"By {Name}","review_highlights_author_anonymous":"anonymous","restricted_age":"Sorry, we cannot collect your review at this time.","appTotalContentCountAggregate":"{TotalCount, plural, one { <span itemprop=\"reviewCount\">{TotalCount}</span> Review } other { <span itemprop=\"reviewCount\">{TotalCount}</span> Reviews } }","offscreen_stars_no_rating":"No rating value","stars_TotalContentCountAggregate":"{TotalCount, plural, one { <span itemprop='reviewCount'>{TotalCount}</span> Review } other { <span itemprop='reviewCount'>{TotalCount}</span> Reviews }}","offscreen_filter_button_update":"Clicking on the following button will update the content below","mprs_off_screen_before_product_name":"Review for {productName}","mprs_click_to_rate":"Click to rate","mprs_rating_success":"Thanks!","mprs_rating_already_rated":"You rated this","mprs_button_add_review":"Add text to your rating","mprs_heading_review_text_form":"Write your review","mprs_optional":"Optional","mprs_review_text_form_label_text":"Review text","mprs_review_text_form_placeholder_text":"Share feedback with other shoppers…","mprs_review_text_form_guidance_text":"Quality insights are 2-3 sentences long","mprs_off_screen_review_text_form_text":"Add text to your review. This is optional.","mprs_review_text_form_label_nickname":"Your public name","mprs_review_text_form_placeholder_nickname":"Displayed with your review…","mprs_button_submit":"Submit","mprs_review_text_success":"Thanks for your review","mprs_button_read_comment":"Read your comment","mprs_button_close_comment":"Close comment","mprs_error_generic":"An error occurred. Please try again later.","mprs_error_products":"There was a problem loading your products.","mprs_heading_terms_and_conditions":"Terms and Conditions","mprs_off_screen_product_rating":"{rating, plural, one {1 star out of 5.} other {{rating} stars out of 5.}}","mprs_off_screen_heading_review_text_form_collapsed":"Optional. Click this button to expand this form.","mprs_off_screen_heading_review_text_form_expanded":"Optional. Click this button to collapse this form.","mprs_review_text_form_text_length":"{typed}/{minimum} minimum","mprs_off_screen_review_text_form_text_length":"{typed, plural, one {1 character typed out of a minimum {minimum}} other {{typed} characters typed out of a minimum {minimum}}}","mprs_terms_and_conditions_disclaimer":"By clicking Submit you agree to <a href=\"#\">Terms & Conditions</a>","__n1Q7n4ubnR__":"too short","mprs_button_submit_as_nickname":"Submit as {nickname}","mprs_rating_already_rated_and_reviewed":"You rated and reviewed","mprs_posted_as_nickname":"Review submitted as {nickname}","mprs_loading":"Loading…","trustmarkIcon":"The trustmark icon that reveals a popup describing BV authenticity","display_crowdSourcedAnswerText":"Information button","spotlights_ay_selectedProduct":"This product is currently selected","spotlights_ay_reviewsForProduct":"The following reviews are for product \"{ProductName}\"","mprs_button_finish_review":"Finish editing","mprs_review_text_form_label_title":"Review title","mprs_review_text_form_placeholder_title":"Help your review stand out with a title…","mprs_button_collapse_product":"Hide review form","mprs_error_product_already_reviewed":"You have already reviewed this product.","mprs_error_product_already_rated":"You have already rated this product.","mprs_error_product_needs_rating_before_review":"To submit your review, tap a rating.","mprs_validation_blank_nickname":"Please enter a nickname.","mprs_validation_short_nickname":"Your nickname must be at least {minimum} characters long.","mprs_validation_blank_review_text":"Please enter review text.","mprs_validation_short_review_text":"Please type at least {minimum} characters.","mprs_validation_blank_review_title":"Please enter a review title.","mprs_one_time_verification_title":"One-time permission","mprs_one_time_verification_description":"To submit a rating or review, please agree to the following:","mprs_one_time_verification_heading_required":"Required","mprs_one_time_verification_heading_optional":"Optional","mprs_one_time_verification_button_ok":"Okay","mprs_one_time_verification_button_cancel":"Cancel","mprs_button_homepage":"Visit our Website","mprs_progress_ratings":"{ratedCount} of {productCount, plural, one {{productCount} product rated} other {{productCount} products rated}}","mprs_progress_reviews":"{reviewedCount} of {productCount, plural, one {{productCount} product reviewed} other {{productCount} products reviewed}}","mprs_progress_guidance":"Tap the stars above to rate and review your purchases.","mprs_progress_thank_you":"Thank you for reviewing your purchases.","content_sort_label":"Sort by","mprs_instructions":"Tap to rate and review your recent purchases.","mprs_further_communication":"You may receive emails regarding review submissions. Any emails will include the ability to opt-out of future communications.","mprs_copyright":"© {Year} {CompanyDisplayName}. All Rights Reserved.","mprs_nickname_form_text_length":"{typed}/{minimum} minimum","mprs_review_title_form_text_length":"{typed}/{remaining} maximum","offscreen_writeReviewSiteAuthModalNotice":"This action will redirect to login page","error_message_required_agreements_aria":"Error: Required. You must agree to Agreements","mprs_rating_pending":"Submitting…","mprs_form_placeholder_text":"Type your answer here…","mprs_button_finish":"Finish","mprs_nps_question_text":"Would you recommend {CompanyDisplayName} to a friend?","mprs_nps_minimumLabel":"Never","mprs_nps_maximumLabel":"Definitely","mprs_step_label_submitted":"Submitted","display_required_text":"Required fields are marked with *","mprs_slider_default_label":"Drag to Rate","offscreen_instructions_for_ratings":"Use arrow keys to select the rating","offscreen_videourl_1":"Enter the URL of the video to add","error_ERROR_FORM_REJECTED_MSR":"has star rating that does not match review text","aria_label_for_author_name":"All content by user","mprs_recommend_question_text":"Would you recommend this product to a friend?","mprs_product_missing_label":"Product {productId}","mprs_button_yes":"Yes","mprs_button_no":"No","mprs_button_skip_finish":"Skip & Finish","mprs_button_skip":"Skip","mprs_step_label_skipped":"Resume","mprs_video_caption_label":"Video caption","mprs_video_upload_label":"Add YouTube video","mprs_video_upload_caption_placeholder_text":"Add a caption to your video…","mprs_video_upload_url_placeholder_text":"https://","mprs_youtube_embed_title":"YouTube preview","mprs_youtube_field_label":"YouTube link","mprs_youtube_invalid_link_error_text":"Please enter a valid YouTube link.","mprs_generic_field_error_text":"Invalid entry.","mprs_photo_upload_label_text":"Add photos","mprs_count_and_max_photo_limit_text":"{uploadedPhotos}/6 maximum","mprs_undo_photo_delete":"undo","mprs_photo_upload_button_text":"Photo","mprs_photo_upload_add_caption_text":"Select a photo to add a caption.","mprs_photo_caption_label":"Photo caption","mprs_photo_current_caption_count":"({currentPhoto} of {uploadedPhotoCount})","mprs_photo_caption_placeholder_text":"Type here…","mprs_photo_guidelines_button_text":"Photo guidelines","mprs_video_guidelines_button_text":"Video guidelines","mprs_over_max_photos_error_label":"{maxPhotoCount} image maximum.","mprs_over_max_photos_error_content":"{overLimitAmount} of your images could not be added.","mprs_error_modal_acknowledgment_text":"okay","mprs_photo_error_modal_default_label":"Error uploading your image","mprs_photo_upload_default_error":"There was an unknown problem uploading your image. Please try another image.","review_highlights_pros":"Pros","review_highlights_cons":"Cons","mprs_validation_blank_text_field":"Please complete this field.","mprs_validation_blank_rating_field":"Please select a rating.","mprs_validation_blank_slider_field":"Please select a value.","mprs_heading_required_step_text_form":"Share your thoughts","mprs_complete_required_step_helper_text":"Complete all fields to finish step 1","mprs_inmail_helper_text":"Complete all fields to finish step 1","mprs_step_1_inmail_helper_text":"Complete all fields to finish step 1","mprs_review_guidelines_button_text":"Guidelines","contentItem_translateContent":"Translate with Google","contentItem_translateContentPending":"Loading translation…","contentItem_untranslateContent":"Show original review","contentItem_translateContentFailure":"Translation failed.","contentItem_translateContentRetry":"Try again","contentItem_translateContentAttribution":"Translated by Google","contentItem_translationTermsButtonLabel":"About this translation","contentItem_translationTermsTitle":"About this translation","mprs_rating_should_be_rated":"Finish step 1 to submit rating","mprs_instructions_empty_list_top_heading":"Oh no!","mprs_instructions_empty_list_bottom_heading":"Something went wrong on our end.","mprs_instructions_empty_list_tip_message":"We'll be back up shortly, so try again later or visit","mprs_error_token_expired":"Review period has expired.","mprs_location_label":"Where are you located?","mprs_location_placeholder_text":"Example: New York, NY","mprs_off_screen_star_rating":"Rating is {rating} (out of {range} stars)","mprs_aria_star_rating":"Rating is {rating} (out of {range} stars)","mprs_aria_close_agreements_modal":"Close agreements modal","mprs_aria_close_guidelines_modal":"Close guidelines modal","flex:common:anonymous":"Anonymous","flex:questions:staffAffiliationDescending":"Staff answers","flex:questions:lastAnswerTimeDescending":"Recently Answered","flex:questions:lastAnswerTimeAscending":"Old Answers","flex:questions:answerQuestionScreenReaderLabel":"Click this button to open the submission form and answer the question: \"{questionText}\".","flex:questions:askQuestionScreenReaderLabel":"Ask a question. Click this button to open the submission form.","flex:common:cancel":"Cancel","flex:common:closeDialog":"Click to close this dialog.","flex:common:countParenthesized":"{count, plural, one {({count, number})} other {({count, number})}}","flex:common:labelValuePair":"{label}: {value}","flex:common:helpful:prompt":"Helpful?","flex:common:commonListPageInfo":"{orphanEnd, select, true {{start, number} of {total, number}} other {{total, plural, one {{start, number} of {total, number}} other {{start, number}&ndash;{end, number} of {total, number}}}}}","flex:common:report":"Report","flex:common:reported":"Reported","flex:common:collation:ratingTitle":"Rating","flex:common:collation:starCount":"{rating, plural, one {{rating, number} star} other {{rating, number} stars}}","flex:common:collation:sortBy":"Sort by","flex:common:photo":"Photo","flex:common:collation:featuredDescending":"Featured","flex:reviews:firstToWriteReview":"Be the first to review this product","flex:questions:askQuestion":"Ask a Question","flex:common:reportInappropriate":"{hasTitle, select, true {Mark {title} by {authorDisplayName} as inappropriate.} other {Mark this content by {authorDisplayName} as inappropriate.}}","flex:questions:answerCountDescending":"Most answered","flex:questions:answerCountAscending":"Answers needed","flex:common:collation:helpfulnessDescending":"Most Helpful","flex:common:collation:dateDescending":"Most Recent","flex:common:collation:ratingAscending":"Lowest to Highest Rating","flex:reviews:notRecommendProduct":"I do not recommend this product.","flex:common:collation:filterBy":"Filter by","flex:ratings:reviewsWithRatingCountScreenReaderLabel":"{reviewCount, plural, one {{rating, plural, one {{reviewCount, number} review with {rating, number} star.} other {{reviewCount, number} review with {rating, number} stars.}}} other {{rating, plural, one {{reviewCount, number} reviews with {rating, number} star.} other {{reviewCount, number} reviews with {rating, number} stars.}}}}","flex:ratings:ratingsCountLinkScreenReaderLabel":"{count, plural, one {This product has {count, number} review. Click to view it.} other {This product has {count, number} reviews. Click to view them.}}","flex:ratings:ratingsCountScreenReaderLabel":"{count, plural, one {This product has {count, number} review.} other {This product has {count, number} reviews.}}","flex:ratings:starsLowercase":"stars","flex:ratings:ratingScreenReaderLabel":"Rated {rating, number} out of {range, number} stars.","flex:common:collation:dateAscending":"Oldest","flex:common:collation:loadMore":"Load More","flex:common:collation:loadMoreScreenReaderLabel":"Click this button to load more {contentTypeLabel}","flex:questions:answerQuestion":"Answer this Question","flex:common:collation:ratingDescending":"Highest to Lowest Rating","flex:ratings:ratingSnapshotHeader":"Rating Snapshot","flex:questions:answerDateDescending":"Newest answers","flex:questions:answerDateAscending":"Oldest answers","flex:ratings:recommendationCount":"{percentage, number, percent} of reviewers recommend this product","flex:reviews:recommendsProduct":"I recommend this product.","flex:common:collation:relevanceDescending":"Most Relevant","flex:common:authorAttributionLabel":"by {Name}","flex:review_highlights:cons":"Cons","flex:review_highlights:mentionCount":"{count, plural, one {{topic} mentioned in {count, number} review} other {{topic} mentioned in {count, number} reviews}}","flex:review_highlights:empty":"Suitable {Subject} could not be generated at this time.","flex:review_highlights:pros":"Pros","flex:ratings:secondaryRatingSummaryHeader":"Average Customer Ratings","flex:common:select":"Select","flex:reviews:showFullReview":"Show Full Review","flex:reviews:showFullReviewScreenReaderLabel":"Show Full Review. Click this button to expand the review.","flex:common:no":"No","flex:common:yes":"Yes","flex:common:syndicatedFrom":"Originally posted on {Name}","flex:reviews:writeReview":"Write a Review","flex:reviews:writeReviewScreenReaderLabel":"Write a Review. Click this button to open the submission form.","flex:common:collation:clearAll":"Clear All ({filtersCount, number})","flex:common:collation:clearAllScreenReaderLabel":"Clear All Filters button. Click to remove all applied content filters.","flex:common:media:viewAllImages":"{countIsTotal, select, true {View All Images ({count, number})} other {View All Images ({count, number}+)}}","flex:common:media:defaultImageLabel":"Customer Review Photo","flex:common:media:summaryPhotosTitle":"Customer Images","flex:common:media:galleryHeader":"Customer Images Media Gallery","flex:review_highlights:title":"Review Highlights","flex:reviews:titleRatings":"Ratings and Reviews","flex:reviews:title":"Reviews","flex:reviews:titleCustomer":"Customer Reviews","flex:questions:title":"Questions and Answers","flex:reviews:showDetails":"View more review details","flex:reviews:hideDetails":"Hide review details","flex:common:authorAttributionLabelDated":"{name} on {date, date, long}","flex:common:thanksForFeedback":"Thank you for your feedback.","flex:common:noDetails":"No additional details available.","flex:questions:noResults":"No questions to display.","flex:common:collation:filterDescription":"Dropdown menu to filter content by {filter}.","flex:common:collation:removeFilterScreenReaderLabel":"Applied filter \"{label}: {value}\". Click to remove applied filter.","flex:common:helpful:promptYes":"Yes, this message was helpful. Click to agree.","flex:common:helpful:promptNo":"No, this message was not helpful. Click to agree.","flex:common:helpful:counts":"{yesHelpfulCount, number} found this helpful. {notHelpfulCount, number} found this not helpful.","flex:common:helpful:feedbackGiven":"Thank you for your feedback.","flex:questions:collapseAnswers":"Collapse Answers","flex:ratings:secondaryRatingLabel":"{type} is rated {rating, number} out of {range, number}","flex:common:previousPageScreenReaderLabel":"Previous Page. Click this button to display the previous page of results.","flex:common:nextPageScreenReaderLabel":"Next Page. Click this button to display the next page of results.","flex:reviews:noResults":"No reviews to display.","flex:common:pageNumberScreenReaderLabel":"Page {pageNumber, number} of {contentTypeLabel} content. Click this button to display this set of results.","offscreen_summaryStarsNoValue":"No rating value for ","flex:ratings:submitComment":"Comment","flex:ratings:submitCommentScreenReaderLabel":"Click this button to open the submission form and comment on review: \"{reviewText}\".","flex:ratings:collapseComments":"Collapse Comments","flex:ratings:ratingsCount":"{count, plural, one {{count, number} Review} other {{count, number} Reviews}}","flex:ratings:recommendationCountDetailed":"{recommendedVotes, number} out of {totalVotes, number} ({percentage, number, percent}) reviewers recommend this product","contentHelpfulAriaLabel":"Content helpfulness","mprs_title_text":"Rate Your Purchases","flex:common:authenticityIconAltText":"Bazaarvoice Authenticity Icon","flex:common:authenticityIconDescription":"These reviews are managed by Bazaarvoice and comply with the Bazaarvoice Authenticity Policy, which is supported by anti-fraud technology and human analysis.<br />Details at {url}","mprs_review_text_form_label_email":"Your email address","mprs_review_text_form_placeholder_email":"Only used for notifications about this purchase...","mprs_validation_blank_email":"Please enter an email.","mprs_validation_invalid_email":"Your email is incorrect, try again.","mprs_validation_short_email":"Your email must be at least {minimum} characters long.","rating_CustomerService":"Customer Service","display_rating_CustomerService":"Customer Service","rating_TestSlider":"Test Slider","display_rating_TestSlider":"Test Slider","rating_TestSlider_valueLabel1":"Test Slider1","rating_TestSlider_valueLabel2":"Test Slider2","rating_TestSlider_valueLabel3":"Test Slider3","rating_TestSlider_valueLabel4":"Test Slider4","rating_TestSlider_valueLabel5":"Test Slider5","slider_dimension_1_rating_TestSlider":"Test Slider Left","slider_dimension_2_rating_TestSlider":"Test Slider Right","rating_Slider7":"Slider 7","display_rating_Slider7":"Slider 7","rating_Slider7_valueLabel1":"1","rating_Slider7_valueLabel2":"2","rating_Slider7_valueLabel3":"3","rating_Slider7_valueLabel4":"4","rating_Slider7_valueLabel5":"5","rating_Slider7_valueLabel6":"6","rating_Slider7_valueLabel7":"7","slider_dimension_1_rating_Slider7":"Cool","slider_dimension_2_rating_Slider7":"test","rating_anotherTestSlider3":"another test slider 3","display_rating_anotherTestSlider3":"another test slider 3","rating_anotherTestSlider3_valueLabel1":"1","rating_anotherTestSlider3_valueLabel2":"2","rating_anotherTestSlider3_valueLabel3":"3","slider_dimension_1_rating_anotherTestSlider3":"one","slider_dimension_2_rating_anotherTestSlider3":"three","contextdatavalue_TestDropdown":"Test Dropdown","display_contextdatavalue_TestDropdown":"Test Dropdown","contextdatavalue_TestDropdown_TestDropdown":"Test Dropdown","contextdatavalue_TestDropdown_TestDropdown2":"Test Dropdown 2","additionalfield_TestText":"Test Text","display_additionalfield_TestText":"Test Text","tag_BestUsesTelecom":"Best Uses - Telecom","display_tag_BestUsesTelecom":"Best Uses","tag_BestUsesTelecom_EverydayUse":"Everyday Use","tag_BestUsesTelecom_HomeUse":"Home Use","tag_BestUsesTelecom_OfficeUse":"Office Use","tag_BestUsesTelecom_Outdoors":"Outdoors"});

BV.define('template/helpers/extmsg',['vendor/handlebars/runtime', 'underscore', 'dimsumFields!localeMapping'], function (Handlebars, _, localeMapping) {

  var unsafeSymbols = {
    '"': '&quot;',
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;'
  };

  var symbolsPattern = (function () {
    var pattern = '';

    for (var s in unsafeSymbols) {
      pattern += s;
    }

    return '[' + pattern + ']';
  })();

  /**
   * Replaces some unsafe symbols to HTML names
   * @param str
   * @returns {String}
   */
  function protectString (str) {
    if (_(str).isEmpty()) {
      return str;
    }

    return str.replace(new RegExp(symbolsPattern, 'g'), function (match) {
      return unsafeSymbols[match];
    });
  }

  function extmsg (key, msgpack, data, options) {
    options = options || {};
    options.hash = options.hash || {};
    var prefix = options.hash.prefix;
    if (options.hash.prefixNum) {
      var i;
      for (i = 1; i < options.hash.prefixNum; i ++) {
        var index = 'prefix' + i;
        prefix = prefix + options.hash[index];
      }
    }

    var matchKey = (!prefix) ? key : prefix + key;
    var matchKeyAndComponent;

    if (options.hash.includeComponentId) {
      matchKeyAndComponent = (!prefix) ? key + '_' + data.componentId : prefix + key + '_' + data.componentId;
    }

    var defaultString = options.hash.defaultDisplay || '';
    var value;

    if ((!matchKey && !matchKeyAndComponent) || (!msgpack && _(localeMapping).isEmpty())) {
      return new Handlebars.SafeString(defaultString);
    }

    var temp;
    if (msgpack && options.hash.includeComponentId) {
      temp = msgpack[matchKeyAndComponent];
    }
    if (!temp && msgpack) {
      temp = msgpack[matchKey];
    }
    if (!temp && localeMapping) {
      temp = localeMapping[matchKey];
    }
    if (!temp) {
      return new Handlebars.SafeString(defaultString);
    }

    value = _(temp).isFunction() ? temp(data) : temp;
    return _(value).isEmpty() ? new Handlebars.SafeString(defaultString) : new Handlebars.SafeString(options.hash.protectString ? protectString(value) : value);
  }

  Handlebars.registerHelper('extmsg', extmsg);
  return extmsg;
});

/* START_TEMPLATE */
BV.define('hbs!userBadge',['hbs','vendor/handlebars/runtime', 'template/helpers/ifBadgeImage', 'template/helpers/renderIcon', 'template/helpers/extmsg', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-badge-image";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.badgeType, depth0.user, options) : helperMissing.call(depth0, "equals", depth0.badgeType, depth0.user, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + escapeExpression(((stack1 = depth1.badgeClassName),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> <img ";
  stack2 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " src=\"";
  if (stack2 = helpers.imageUrl) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.imageUrl; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"/> </li> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return " bv-badge-user";
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "title=\"";
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\"";
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program6(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li ";
  stack1 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.noop,fn:self.program(7, program7, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " class=\"bv-badge bv-badge-user "
    + escapeExpression(((stack1 = depth1.badgeClassName),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> ";
  options = {hash:{
    'classList': ("bv-badge-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.programWithDepth(program9, data, depth1)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, depth1.badgeClassName, options) : helperMissing.call(depth0, "renderIcon", depth1.badgeClassName, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-badge-label\">";
  options = {hash:{
    'prefix': (depth1.msgPrefix)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth1.msgKey, depth1.msgPack, depth1, options) : helperMissing.call(depth0, "extmsg", depth1.msgKey, depth1.msgPack, depth1, options)))
    + "</span> </li> ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "title=\"";
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program9(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = ((stack1 = depth2.iconChar),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{},inverse:self.programWithDepth(program6, data, depth0),fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.ifBadgeImage),stack1 ? stack1.call(depth0, depth0.badges, depth0.badgeId, options) : helperMissing.call(depth0, "ifBadgeImage", depth0.badges, depth0.badgeId, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('userBadge', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!badge',['hbs','vendor/handlebars/runtime', 'template/helpers/ifBadgeImage', 'template/helpers/renderIcon', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2;
  buffer += " <dd title=\"";
  stack1 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-badge-image "
    + escapeExpression(((stack1 = depth1.badgeClassName),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" role=\"presentation\"> <img src=\"";
  if (stack2 = helpers.imageUrl) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.imageUrl; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" alt=\"";
  stack2 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> </dd> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program4(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.displayLabel) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.displayLabel; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program6(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.displayLabel, {hash:{},inverse:self.programWithDepth(program10, data, depth1),fn:self.programWithDepth(program7, data, depth1)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dd title=\"";
  stack1 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-badge bv-badge-"
    + escapeExpression(((stack1 = depth2.badgeType),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = depth2.badgeClassName),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" role=\"presentation\"> ";
  options = {hash:{
    'classList': ("bv-badge-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.programWithDepth(program8, data, depth2)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, depth0.badgeClassName, options) : helperMissing.call(depth0, "renderIcon", depth0.badgeClassName, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-badge-label\">";
  if (stack2 = helpers.displayLabel) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.displayLabel; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> </dd> ";
  return buffer;
  }
function program8(depth0,data,depth3) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = ((stack1 = depth3.iconChar),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program10(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <dd ";
  stack1 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.noop,fn:self.program(11, program11, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " class=\"bv-badge bv-badge-"
    + escapeExpression(((stack1 = depth2.badgeType),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = depth2.badgeClassName),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" role=\"presentation\"> ";
  options = {hash:{
    'classList': ("bv-badge-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.programWithDepth(program8, data, depth2)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, depth0.badgeClassName, options) : helperMissing.call(depth0, "renderIcon", depth0.badgeClassName, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-badge-label\"> ";
  options = {hash:{
    'prefix': (depth2.msgPrefix)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth2.msgKey, depth2.msgpack, depth2, options) : helperMissing.call(depth0, "extmsg", depth2.msgKey, depth2.msgpack, depth2, options)))
    + " </span> </dd> ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "title=\"";
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<dl class=\"bv-badge-summary\" role=\"presentation\"> ";
  options = {hash:{},inverse:self.programWithDepth(program6, data, depth0),fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.ifBadgeImage),stack1 ? stack1.call(depth0, depth0.badges, depth0.badgeId, options) : helperMissing.call(depth0, "ifBadgeImage", depth0.badges, depth0.badgeId, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl>";
  return buffer;
  });
Handlebars.registerPartial('badge', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('ratingIconCharMap',['underscore', 'vendor/json2'], function (_, JSON) {
  var buildText = '';

  return {
      };
});

BV.define('ratingIconCharMap!',{"rating-stars-on":9734,"rating-stars-off":9734,"prs-rating-stars-on":9734,"prs-rating-stars-off":9734,"rating-stars":9733,"prs-rating-stars":9734,"category-rating":9733,"category-rating-on":9733,"category-rating-off":9733});

BV.define('template/helpers/renderBadge',['jquery', 'vendor/handlebars/runtime', 'hbs!userBadge', 'hbs!badge', 'ratingIconCharMap!'], function ($, Handlebars, userBadgeTemplate, badgeTemplate, charMap) {

  function renderBadge (badges, context) {
    var badgeData = context.hash;
    var badgeType = badgeData.badgeType;
    var badgeId = badgeData.badgeId;
    var isContributor = badgeType === 'contributor';
    var template;
    var outputString;
    var isEmpty;

    // By default, we'll render this badge as though it goes in the content
    // badge area (as even user badges can). The `asUserBadge` option, when
    // true, renders the badge as a standard user badge, like when we put it
    // in someone's profile, inline or otherwise.
    var asUserBadge = badgeData.asUserBadge;

    var classNameSuffix = isContributor ? 'rank' : badgeData.badgeId.toLowerCase();
    var iconChar;

    badgeData.badges = badges;
    badgeData.badgeClassName = 'bv-badge-' + badgeType + '-' + classNameSuffix;

    if (!badgeData.msgKey) {
      badgeData.msgKey = isContributor ? badgeId : classNameSuffix;
    }

    // For contributor badges use the rating star icon
    if (isContributor) {
      iconChar = charMap['rating-stars-on'] || '9733';
      iconChar = '&#' + iconChar + ';';
      badgeData.iconChar = iconChar;
    }

    if (!badgeData.iconChar) {
      badgeData.iconChar = '*';
    }

    template = asUserBadge ? userBadgeTemplate : badgeTemplate;
    outputString = template(badgeData);

    // Convert outputString to jquery object
    isEmpty = $($.parseHTML(outputString)).children();
    // If outputString doesn't have children skip render
    if (isEmpty.length === 0) {
      return;
    }

    return new Handlebars.SafeString(outputString);
  }

  Handlebars.registerHelper('renderBadge', renderBadge);
  return renderBadge;
});

/* START_TEMPLATE */
BV.define('hbs!userBadges',['hbs','vendor/handlebars/runtime', 'template/helpers/equals', 'template/helpers/notEqual', 'template/helpers/withIf', 'template/helpers/renderBadge', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " <div class=\"bv-content-author-badges\" role=\"presentation\"> <ul class=\"bv-content-author-badges-list\" role=\"presentation\"> ";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-author-profile-crowdSourcedAnswerBadge-outter\"> <div class=\"bv-crowdSourcedAnswerBadge-icon bv-author-profile-crowdSourcedAnswerBadge-icon\" aria-hidden=\"true\">&#x2139;</div> <div class=\"bv-author-profile-crowdSourcedAnswerBadge-text bv-focusable\" tabindex=\"-1\"> ";
  options = {hash:{
    'prefix': ("display_"),
    'defaultDisplay': ("Answer provided by third party; accuracy not guaranteed.")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "crowdSourcedAnswerText", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "crowdSourcedAnswerText", depth0.msgpack, depth0, options)))
    + " </div> </div> ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.viewName, "contentAuthorProfileInline", options) : helperMissing.call(depth0, "notEqual", depth0.viewName, "contentAuthorProfileInline", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), {hash:{},inverse:self.noop,fn:self.program(11, program11, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program15, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options) : helperMissing.call(depth0, "withIf", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program9, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options) : helperMissing.call(depth0, "withIf", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'asUserBadge': (true),
    'badgeId': ("Brand"),
    'badgeType': ("user"),
    'iconChar': ("&#x2642"),
    'msgPack': (depth1.msgpack),
    'msgPrefix': ("avatar_badge_")
  }};
  buffer += escapeExpression(((stack1 = helpers.renderBadge),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "renderBadge", depth0, options)))
    + " ";
  options = {hash:{
    'asUserBadge': (true),
    'badgeId': ("Staff"),
    'badgeType': ("user"),
    'iconChar': ("&#x2642;"),
    'msgPack': (depth1.msgpack),
    'msgPrefix': ("avatar_badge_")
  }};
  buffer += escapeExpression(((stack1 = helpers.renderBadge),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "renderBadge", depth0, options)))
    + " ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(12, program12, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.viewName, "contentAuthorProfileInline", options) : helperMissing.call(depth0, "notEqual", depth0.viewName, "contentAuthorProfileInline", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program13, data, depth0)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program13(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'asUserBadge': (true),
    'badgeId': (((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank)),
    'badgeType': ("contributor"),
    'msgPack': (depth1.msgpack),
    'msgPrefix': ("avatar_rank_")
  }};
  buffer += escapeExpression(((stack1 = helpers.renderBadge),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options) : helperMissing.call(depth0, "renderBadge", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), options)))
    + " ";
  return buffer;
  }

function program15(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'asUserBadge': (true),
    'badgeId': ("Expert"),
    'badgeType': ("user"),
    'iconChar': ("&infin;"),
    'msgPack': (depth1.msgpack),
    'msgPrefix': ("avatar_badge_")
  }};
  buffer += escapeExpression(((stack1 = helpers.renderBadge),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "renderBadge", depth0, options)))
    + " "
    + " ";
  return buffer;
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(19, program19, data),fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), "NONE", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Badges), {hash:{},inverse:self.noop,fn:self.program(19, program19, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  
  return " </ul> </div> ";
  }

  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), {hash:{},inverse:self.program(2, program2, data),fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.communityAnswer), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContributorRank), {hash:{},inverse:self.program(18, program18, data),fn:self.program(17, program17, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('userBadges', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/foreach',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {
  function foreach (context, options) {
    var empty = true;
    var ret = '';
    var data = Handlebars.createFrame(options.data || null);

    if (_(context).isArray()) {
      _(context).forEach(function (item, index) {
        if (data) {
          data.index = index;
          data.first = index === 0;
          data.last = index === context.length - 1;
          data.length = context.length;
        }
        ret = ret + options.fn(item, { data: data });
        empty = false;
      });
    }
    else if (_(context).isObject()) {
      var length = _(context).size();
      var index = 0;
      _(context).forEach(function (item, key) {
        if (data) {
          data.key = key;
          data.first = index === 0;
          data.last = index === length - 1;
          data.length = length;
        }
        ret = ret + options.fn(item, { data: data });
        empty = false;
        index++;
      });
    }

    if (empty) {
      ret = options.inverse(this);
    }

    return ret;
  }

  Handlebars.registerHelper('foreach', foreach);
  return foreach;
});

/* START_TEMPLATE */
BV.define('hbs!contentAuthorCDVs',['hbs','vendor/handlebars/runtime', 'template/helpers/renderIcon', 'template/helpers/foreach', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; data = data || {};
  var buffer = "", stack1, stack2, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <ul role=\"presentation\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data};
  stack2 = ((stack1 = helpers.foreach),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContextDataValuesOrdered), options) : helperMissing.call(depth0, "foreach", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContextDataValuesOrdered), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <li class=\"bv-author-cdv ";
  stack1 = helpers['if'].call(depth0, data.first, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, data.last, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" role=\"presentation\"> <!-- UIA-7763 - removed default display so only translated strings matched by FB will display; can't remove defaultDisplay field entirely due to compilation errors, so used a value of '' --> <span class=\"bv-author-userinfo-data\">";
  options = {hash:{
    'prefix': ("contextdatavalue_"),
    'defaultDisplay': ("")
  },data:data};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth0.msgpack, depth0, options)))
    + "</span> <span class=\"bv-author-userinfo-value\">";
  options = {hash:{
    'prefixNum': (3),
    'prefix': ("contextdatavalue_"),
    'prefix1': (depth0.Id),
    'prefix2': ("_"),
    'defaultDisplay': ("")
  },data:data};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Value, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Value, depth0.msgpack, depth0, options)))
    + "</span> </li> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return "bv-first";
  }

function program5(depth0,data) {
  
  
  return "bv-last";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'classList': ("bv-no-userinfo"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(8, program8, data),data:data};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-no-userinfo-icon", options) : helperMissing.call(depth0, "renderIcon", "bv-no-userinfo-icon", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  
  return "&#8230;";
  }

  buffer += "<div class=\"bv-author-userinfo\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContextDataValuesOrdered), {hash:{},inverse:self.program(7, program7, data),fn:self.program(1, program1, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorCDVs', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!sidebar',['hbs','vendor/handlebars/runtime','hbs!contentAuthorIcon', 'hbs!contentAuthorStats', 'hbs!userBadges', 'hbs!contentAuthorCDVs', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Author, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-off-screen\"> <h4>";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "authorDetailsOffscreenHeader", depth0.msgpack, depth0.Author, options) : helperMissing.call(depth0, "extmsg", "authorDetailsOffscreenHeader", depth0.msgpack, depth0.Author, options)))
    + "</h4> </div> ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "socialAvatar", options) : helperMissing.call(depth0, "ifHasFeature", "socialAvatar", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <dl class=\"bv-author-profile-userinfo\" role=\"presentation\"> ";
  stack2 = self.invokePartial(partials.contentAuthorStats, 'contentAuthorStats', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.userBadges, 'userBadges', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentAuthorCDVs, 'contentAuthorCDVs', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-author-avatar\"> ";
  stack1 = self.invokePartial(partials.contentAuthorIcon, 'contentAuthorIcon', depth0.Author, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("sidebar")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('sidebar', t);
t.deps = ["contentAuthorIcon","contentAuthorStats","userBadges","contentAuthorCDVs"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/avatar',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"avatar_rank_TOP_1" : function (x) { try { return (function(d){
var r = "";
r += "Top Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_1`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_10" : function (x) { try { return (function(d){
var r = "";
r += "Top 10 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_10`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_25" : function (x) { try { return (function(d){
var r = "";
r += "Top 25 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_25`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_50" : function (x) { try { return (function(d){
var r = "";
r += "Top 50 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_50`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_100" : function (x) { try { return (function(d){
var r = "";
r += "Top 100 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_100`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_250" : function (x) { try { return (function(d){
var r = "";
r += "Top 250 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_250`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_500" : function (x) { try { return (function(d){
var r = "";
r += "Top 500 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_500`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_TOP_1000" : function (x) { try { return (function(d){
var r = "";
r += "Top 1000 Contributor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_TOP_1000`: ' + e.toString() ) ] ); return ""; } },"avatar_rank_NONE" : function (x) { try { return (function(d){
var r = "";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_rank_NONE`: ' + e.toString() ) ] ); return ""; } },"avatar_badge_verified_purchaser" : function (x) { try { return (function(d){
var r = "";
r += "Verified Purchaser";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_badge_verified_purchaser`: ' + e.toString() ) ] ); return ""; } },"avatar_badge_brand" : function (x) { try { return (function(d){
var r = "";
r += "Brand";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_badge_brand`: ' + e.toString() ) ] ); return ""; } },"avatar_badge_staff" : function (x) { try { return (function(d){
var r = "";
r += "Staff";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_badge_staff`: ' + e.toString() ) ] ); return ""; } },"avatar_badge_expert" : function (x) { try { return (function(d){
var r = "";
r += "Expert";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `avatar_badge_expert`: ' + e.toString() ) ] ); return ""; } },"authorDetailsOffscreenHeader" : function (x) { try { return (function(d){
var r = "";
r += "User Details for ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["DisplayName"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `authorDetailsOffscreenHeader`: ' + e.toString() ) ] ); return ""; } },"authorProfileArchiveTabReviews" : function (x) { try { return (function(d){
var r = "";
r += "Reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `authorProfileArchiveTabReviews`: ' + e.toString() ) ] ); return ""; } },"authorProfileArchiveTabQuestions" : function (x) { try { return (function(d){
var r = "";
r += "Questions";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `authorProfileArchiveTabQuestions`: ' + e.toString() ) ] ); return ""; } },"authorProfileArchiveTabAnswers" : function (x) { try { return (function(d){
var r = "";
r += "Answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `authorProfileArchiveTabAnswers`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/view/sidebar',[
  'framework/bview',
  'underscore',
  'hbs!sidebar',
  'mf!bv/c2013/messages/avatar'
], function (BView, _, template, msgPack) {
  return BView.extend({
    name: 'sidebar',

    events: {
    },

    template: template,

    msgpacks: [msgPack]

  });
});

BV.define('bv/util/socialAvatar',['underscore', 'util/url'], function (_, Url) {

  var imageTransform = {
    gravatar: function (id) {
      var base = (Url.protocol === 'https:') ? 'https://secure.gravatar.com/avatar/' : 'http://www.gravatar.com/avatar/';
      return base + id + '?s=100&d=blank';
    },
    facebook: function (id) {
      return Url.protocol + '//graph.facebook.com/' + id + '/picture?width=100&height=100';
    }
  };

  function author2Image (Author) {
    var images = {};
    if (Author && Author.ThirdPartyIds && Author.ThirdPartyIds.length) {
      _(Author.ThirdPartyIds).forEach(function (thirdPartyId) {
        var network = thirdPartyId.Name.toLowerCase();
        images[network] = networkId2Image(network, thirdPartyId.Id);
      });
    }
    // Use FB first, fallback to Gravatar
    return images.facebook || images.gravatar || null;
  }

  function networkId2Image (network, id) {
    network = network.toLowerCase();
    return imageTransform[network] ? imageTransform[network](id) : null;
  }

  return {
    // image(Author) or image(network, id)
    image: function () {
      if (arguments.length < 2) {
        return author2Image.apply(this, arguments);
      } else {
        return networkId2Image.apply(this, arguments);
      }
    }
  };

});

BV.define('bv/c2013/model/tabs',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/api/fetch',
  'bv/util/socialAvatar'
], function (ENV, BModel, _, api, SocialAvatar) {

  return BModel.extend({
    options: {},
    name: 'tabs',
    collectionFeatureName: 'profileContentList',

    init: function (config, options) {
      _.extend(this.options, options);
    },

    setupDataProcessing: function () {
      var allContent = this.getContent();
      if (!allContent) {
        return;
      }
      BModel.prototype.setupDataProcessing.apply(this, arguments);
    },

    processData: function (data) {
      this.set({ Author: data });
      BModel.prototype.processData.apply(this, arguments);
    },

    toJSON: function () {
      return BModel.prototype.toJSON.apply(this, arguments);
    },

    _initContent: function () {
      var content = {};
      var allContent = this.getFeatureModels(this.collectionFeatureName);

      if (allContent) {
        _(allContent).forEach(function (aContent) {
          if (aContent.isCollection) {
            content[aContent.contentType] = aContent;
          }
          else {
            content[aContent.get('contentType')] = aContent;
          }
        });
        this.set({ content: content }, { silent: true });
        return content;
      }

      return null;
    },

    _getContent: function () {
      return this.get('content') || this._initContent();
    },

    getContent: function () {
      return this._getContent();
    },

    fetchPage: function (page, author) {
      var self = this;
      var config = ENV.get('config');
      var subjectType = api.nouns(this.get('subjectType'));
      var includeRequestTypes = {
        Reviews: 'Comments',
        Questions: 'Answers',
        Answers: 'Questions'
      };
      var allContent = this.getContent();
      var requestTypes = _(allContent).keys();
      var authorId = author.Id;

      var profileRequest = api.get(subjectType, authorId)
                              .withStatsOn(_(allContent).keys())
                              .withoutContentLocaleFilter();

      // for each covered type, create an api request
      var contentRequests = _(requestTypes).map(function (requestType) {
        var pageConfig = config.page.details[api.noun(requestType)] || config.page;
        var pageSize = pageConfig.size;
        var pageSize2n = pageConfig.size2n;

        var limit = page > 1 ? pageSize2n : pageSize;
        var offset = page > 1 ? pageSize + (pageSize2n * (page - 2)) : 0;

        var contentRequest = api.get(api.nouns(requestType))
                .include(['Authors', 'Products'])
                .limit(limit)
                .offset(offset);

        var includeType = includeRequestTypes[api.Nouns(requestType)];
        if (!_(includeType).isEmpty()) {
          var secondaryPageConfig = config.page.details[api.noun(includeType)] || config.page;
          var secondaryPageSize = secondaryPageConfig.size;
          contentRequest = contentRequest.include([includeType])
                            .limitIncluded(includeType)
                            .to(secondaryPageSize);
        }

        contentRequest = contentRequest.filterBy('AuthorId', authorId);
        contentRequest.withoutContentLocaleFilter();
        return contentRequest;
      });

      contentRequests.unshift(profileRequest);
      var batchContent = api.get('batch', null, contentRequests);

      var authorData = author;

      try {
        batchContent.fetch('author').done(function (dataArray) {
          var subjectData = _(dataArray).find(function (d) {
            return d.contentType === 'authors';
          });

          if (subjectData) {
            authorData = subjectData.data.Results[0];
          }

          if (!authorData) {
            return;
          }

          authorData.Content = authorData.Content || {};

          var validContentCount = 0;

          _(allContent).forEach(function (aContent) {
            var aType = aContent.get('contentType');
            var contentData = _(dataArray).find(function (d) {
              return d.contentType === api.nouns(aType);
            });

            _(authorData.Content[aType]).extend(contentData.data);
            authorData.Content[aType].List = contentData.data.Results;

            aContent.processData(subjectData.data);
            aContent.getContent().reset(contentData.data.Results);

            if (contentData.data.Results.length > 0) {
              validContentCount ++;
            }
          });

          authorData.ContentLength = validContentCount;
          authorData._avatarImage = SocialAvatar.image(authorData);

          self.set('Author', authorData);
          self.publish('authorresponse', authorData);
        });
      }
      catch (e) {
        self.set('Author', authorData);
        self.publish('authorresponse', authorData);
      }
    }

  });

});

BV.define('template/helpers/subviews',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {

  // Use this helper when you want a view to render the HTML for its subviews.
  //
  // Note that this helper will skip any subviews that have been "mounted"
  // (by `mountView`) in the same template.
  //
  // If the given subview doesn't exist, `mountView` returns an empty string,
  // so there's no need to wrap it inside an `#ifHasFeature` block.
  //

  var mountedViews;

  function subviews (context) {
    var outputStringBuilder = [];
    var contextPartial;


    if (context.viewList && context._subview) {
      // calculate the views that are mounted in this template
      contextPartial = Handlebars.partials[context.viewName];
      mountedViews = [];

      if (contextPartial) {
        buildMountedViews(contextPartial);
      }

      _(context.viewList).forEach(function (subView) {
        var viewKey = subView.viewName;
        viewKey = subView.viewInstanceName ? viewKey + ':' + subView.viewInstanceName : viewKey;
        if (_(mountedViews).indexOf(viewKey) === -1) {
          outputStringBuilder.push(context._subview[subView.viewIndex]);
        }
      });

      return new Handlebars.SafeString(outputStringBuilder.join(''));
    }
    return '';
  }

  function buildMountedViews (contextPartial) {
    mountedViews = mountedViews.concat(contextPartial.tplMountedViews);
    _(contextPartial.deps).forEach(function (partialDep) {
      buildMountedViews(Handlebars.partials[partialDep]);
    });
  }

  Handlebars.registerHelper('subviews', subviews);
  return subviews;
});

/* START_TEMPLATE */
BV.define('hbs!tabs',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/conditionalContainer', 'template/helpers/foreach', 'template/helpers/notEqual', 'template/helpers/extmsg', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; data = data || {};
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-fullpro-archive-container\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("fullpro-tab-container")
  },inverse:self.noop,fn:self.program(2, program2, data),data:data};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContentLength), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.ContentLength), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("ul"),
    'classList': ("fullpro-tabs"),
    'role': ("tablist")
  },inverse:self.noop,fn:self.programWithDepth(program3, data, depth0),data:data};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program4, data, depth1),data:data};
  stack2 = ((stack1 = helpers.foreach),stack1 ? stack1.call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Content), options) : helperMissing.call(depth0, "foreach", ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.Content), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program5, data, depth2),data:data};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.Statistics),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.Statistics),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data,depth3) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li role=\"presentation\"> <a href=\"#\" class=\"bv-fullpro-tab-link bv-fullpro-tab-"
    + escapeExpression(((stack1 = data.key),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-focusable ";
  stack2 = helpers['if'].call(depth0, data.first, {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" tab=\""
    + escapeExpression(((stack1 = data.key),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"0\" aria-selected=";
  stack2 = helpers['if'].call(depth0, data.first, {hash:{},inverse:self.program(10, program10, data),fn:self.program(8, program8, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " role=\"tab\"> ";
  options = {hash:{
    'prefix': ("authorProfileArchiveTab")
  },data:data};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, data.key, depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", data.key, depth3.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth0.Statistics),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </a> </li> ";
  return buffer;
  }
function program6(depth0,data) {
  
  
  return "bv-active";
  }

function program8(depth0,data) {
  
  
  return "\"true\"";
  }

function program10(depth0,data) {
  
  
  return "\"false\"";
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-fullpro-archive-content\"> ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("collection-tab fullpro-archive")
  },inverse:self.noop,fn:self.program(1, program1, data),data:data};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('tabs', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview The view for tabs
 */
BV.define('bv/c2013/view/tabs',[
  'framework/bview',
  'jquery',
  'underscore',
  'hbs!tabs',
  'mf!bv/c2013/messages/avatar',
  'framework/util/bvtracker',
  'util/specialKeys',
  'bv/util/contentType',
  'bv/util/focusManager',
  'bv/util/productInfo'
], function (BView, $, _, template, msgPack, BVTracker, specialKeys, ContentType, focusManager, ProductInfo) {

  return BView.extend({

    name: 'tabs',
    classList: ['tabs'],

    events: {
      'click a.bv-fullpro-tab-link': 'switchTab',
      'keydown a.bv-fullpro-tab-link': 'switchTab'
    },

    template: template,

    msgpacks: [msgPack],

    /**
     * Attach the view.
     *
     * @param {DOMElement} elToAttach - Element to attach this view to.
     */
    attach: function (elToAttach) {
      BView.prototype.attach.apply(this, arguments);

      var collectionModels = _(this.model.getFeatureModels(this.model.collectionFeatureName))
        .filter(function (collection) {
          return collection.get('TotalResults') > 0;
        });

      if (collectionModels && collectionModels.length > 0) {
        var collectionModel = collectionModels[0];
        var contentType = collectionModel.isCollection ? collectionModel.contentType : collectionModel.get('contentType');
        this.setActiveArchiveTab(contentType);
      }

      // Setup relationships between tabs and content.
      // TODO: This would be better done in the templates, but I can't
      // figure out a way to connect the two there.
      this.$viewEl.find('.bv-fullpro-tab-link').each(function (index) {
        $(this)
          .attr('id', 'bv-fullpro-tab-' + index);
      });

      _(this.views).forEach(function (subview, index) {
        subview.$viewEl
          .attr('id', 'bv-fullpro-content-' + index);
      });
    },

    switchTab: function (e) {
      var tab;
      if (e.keyCode) {
        // Keyboard navigation
        tab = this.switchTabByKey(e);
      }
      else {
        // Clicked on a tab
        e.preventDefault();  // preventDefault right away
        tab = e.target.attributes.tab.value;
      }

      // Tab to show.
      if (tab) {
        var tabView = this.setActiveArchiveTab(tab);

        // the new tab itself
        var $focusableContent = tabView.$el.find('.bv-fullpro-tab-' + tab);

        if ($focusableContent.length) {
          focusManager.moveFocus($focusableContent);
        }

        BVTracker.feature({
          type: 'Used',
          name: 'TabClick',
          detail1: tab,
          bvProduct: ProductInfo.PROFILES,
          categoryId: ProductInfo.getCategoryId(this)
        });
      }
    },

    switchTabByKey: function (e) {
      var arrowKeys = [
        specialKeys.LEFT,
        specialKeys.RIGHT,
        specialKeys.UP,
        specialKeys.DOWN
      ];

      if (!_.contains(arrowKeys, e.keyCode)) {
        return;
      }

      e.preventDefault();  // preventDefault as soon as we know its an arrow key

      // identify the appropriate tab to switch to
      var $toTab;
      if (e.keyCode === specialKeys.RIGHT || e.keyCode === specialKeys.DOWN) {
        $toTab = $(e.target).parent().next().find('.bv-fullpro-tab-link');

        if (!$toTab[0]) {
          // we're at the end, so cycle to the first tab
          $toTab = this.$viewEl.find('.bv-fullpro-tab-link').first();
        }
      }

      if (e.keyCode === specialKeys.LEFT || e.keyCode === specialKeys.UP) {
        $toTab = $(e.target).parent().prev().find('.bv-fullpro-tab-link');

        if (!$toTab[0]) {
          // we're at the end, so cycle to the last tab
          $toTab = this.$viewEl.find('.bv-fullpro-tab-link').last();
        }
      }

      return $toTab[0].attributes.tab.value;
    },

    /**
     * @param tab {string} "reviews", "questions", or "answers"
     */
    setActiveArchiveTab: function (tab) {
      tab = ContentType.Nouns(tab);
      var tabs = this.$viewEl.find('.bv-fullpro-tab-link');

      // Set active tab.
      var activeTab = tabs
        .removeClass('bv-active')
        .attr('aria-selected', 'false')
        .filter('.bv-fullpro-tab-' + tab)
        .attr('aria-selected', 'true')
        .addClass('bv-active');

      var displayedView;

      // Display active tab content.
      _(this.views).forEach(function (subview) {
        if (ContentType.Nouns(subview.contentType) === tab) {
          displayedView = subview;
          subview.$viewEl
            .css('display', 'block')
            .attr('aria-hidden', 'false')
            .attr('aria-expanded', 'true');
        }
        else {
          subview.$viewEl
            .css('display', 'none')
            .attr('aria-hidden', 'true')
            .attr('aria-expanded', 'false');
        }
      });

      return displayedView;
    }

  });

});

// moment.js
// version : 1.7.2
// author : Tim Wood
// license : MIT
// momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "1.7.2",
        round = Math.round, i,
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // Parameters to check for on the lang config.  This list of properties
        // will be inherited from English if not provided in a language
        // definition.  monthsParse is also a lang config property, but it
        // cannot be inherited and as such cannot be enumerated here.
        langConfigProperties = 'months|monthsShort|weekdays|weekdaysShort|weekdaysMin|longDateFormat|calendar|relativeTime|ordinal|meridiem'.split('|'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?)/g,

        // parsing tokens
        parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenWord = /[0-9a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/i, // any word characters or numbers
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)

        // preliminary iso regex
        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
        isoRegex = /^\s*\d{4}-\d\d-\d\d(T(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.S', /T\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /T\d\d:\d\d:\d\d/],
            ['HH:mm', /T\d\d:\d\d/],
            ['HH', /T\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w M D d'.split(' '),
        paddedTokens = 'M D H h m s w'.split(' '),

        /*
         * moment.fn.format uses new Function() to create an inlined formatting function.
         * Results are a 3x speed boost
         * http://jsperf.com/momentjs-cached-format-functions
         *
         * These strings are appended into a function using replaceFormatTokens and makeFormatFunction
         */
        formatTokenFunctions = {
            // a = placeholder
            // b = placeholder
            // t = the current moment being formatted
            // v = getValueAtKey function
            // o = language.ordinal function
            // p = leftZeroFill function
            // m = language.meridiem value or function
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return getValueFromArray("monthsShort", this.month(), this, format);
            },
            MMMM : function (format) {
                return getValueFromArray("months", this.month(), this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                var a = new Date(this.year(), this.month(), this.date()),
                    b = new Date(this.year(), 0, 1);
                return ~~(((a - b) / 864e5) + 1.5);
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return getValueFromArray("weekdaysMin", this.day(), this, format);
            },
            ddd  : function (format) {
                return getValueFromArray("weekdaysShort", this.day(), this, format);
            },
            dddd : function (format) {
                return getValueFromArray("weekdays", this.day(), this, format);
            },
            w    : function () {
                var a = new Date(this.year(), this.month(), this.date() - this.day() + 5),
                    b = new Date(a.getFullYear(), 0, 4);
                return ~~((a - b) / 864e5 / 7 + 1.5);
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return ~~(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(~~(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(~~(10 * a / 6), 4);
            }
        };

    function getValueFromArray(key, index, m, format) {
        var lang = m.lang();
        return lang[key].call ? lang[key](m, format) : lang[key][index];
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func) {
        return function (a) {
            var b = func.call(this, a);
            return b + this.lang().ordinal(b);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i]);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/


    // Moment prototype object
    function Moment(date, isUTC, lang) {
        this._d = date;
        this._isUTC = !!isUTC;
        this._a = date._a || null;
        this._lang = lang || false;
    }

    // Duration Constructor
    function Duration(duration) {
        var data = this._data = {},
            years = duration.years || duration.y || 0,
            months = duration.months || duration.M || 0,
            weeks = duration.weeks || duration.w || 0,
            days = duration.days || duration.d || 0,
            hours = duration.hours || duration.h || 0,
            minutes = duration.minutes || duration.m || 0,
            seconds = duration.seconds || duration.s || 0,
            milliseconds = duration.milliseconds || duration.ms || 0;

        // representation for dateAddRemove
        this._milliseconds = milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = months +
            years * 12;

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
        seconds += absRound(milliseconds / 1000);

        data.seconds = seconds % 60;
        minutes += absRound(seconds / 60);

        data.minutes = minutes % 60;
        hours += absRound(minutes / 60);

        data.hours = hours % 24;
        days += absRound(hours / 24);

        days += weeks * 7;
        data.days = days % 30;

        months += absRound(days / 30);

        data.months = months % 12;
        years += absRound(months / 12);

        data.years = years;

        this._lang = false;
    }


    /************************************
        Helpers
    ************************************/


    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
        var ms = duration._milliseconds,
            d = duration._days,
            M = duration._months,
            currentDate;

        if (ms) {
            mom._d.setTime(+mom + ms * isAdding);
        }
        if (d) {
            mom.date(mom.date() + d * isAdding);
        }
        if (M) {
            currentDate = mom.date();
            mom.date(1)
                .month(mom.month() + M * isAdding)
                .date(Math.min(currentDate, mom.daysInMonth()));
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (~~array1[i] !== ~~array2[i]) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromArray(input, asUTC, hoursOffset, minutesOffset) {
        var i, date, forValid = [];
        for (i = 0; i < 7; i++) {
            forValid[i] = input[i] = (input[i] == null) ? (i === 2 ? 1 : 0) : input[i];
        }
        // we store whether we used utc or not in the input array
        input[7] = forValid[7] = asUTC;
        // if the parser flagged the input as invalid, we pass the value along
        if (input[8] != null) {
            forValid[8] = input[8];
        }
        // add the offsets to the time to be parsed so that we can have a clean array
        // for checking isValid
        input[3] += hoursOffset || 0;
        input[4] += minutesOffset || 0;
        date = new Date(0);
        if (asUTC) {
            date.setUTCFullYear(input[0], input[1], input[2]);
            date.setUTCHours(input[3], input[4], input[5], input[6]);
        } else {
            date.setFullYear(input[0], input[1], input[2]);
            date.setHours(input[3], input[4], input[5], input[6]);
        }
        date._a = forValid;
        return date;
    }

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        var i, m,
            parse = [];

        if (!values && hasModule) {
            values = BV.require('./lang/' + key);
        }

        for (i = 0; i < langConfigProperties.length; i++) {
            // If a language definition does not provide a value, inherit
            // from English
            values[langConfigProperties[i]] = values[langConfigProperties[i]] ||
              languages.en[langConfigProperties[i]];
        }

        for (i = 0; i < 12; i++) {
            m = moment([2000, i]);
            parse[i] = new RegExp('^' + (values.months[i] || values.months(m, '')) +
                '|^' + (values.monthsShort[i] || values.monthsShort(m, '')).replace('.', ''), 'i');
        }
        values.monthsParse = values.monthsParse || parse;

        languages[key] = values;

        return values;
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.  If you pass in a moment or duration instance, it
    // will decide the language based on that, or default to the global
    // language.
    function getLangDefinition(m) {
        var langKey = (typeof m === 'string') && m ||
                      m && m._lang ||
                      null;

        return langKey ? (languages[langKey] || loadLang(langKey)) : moment;
    }


    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[.*\]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += typeof array[i].call === 'function' ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return m.lang().longDateFormat[input] || input;
        }

        while (i-- && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        }

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token) {
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
            return parseTokenFourDigits;
        case 'S':
        case 'SS':
        case 'SSS':
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'a':
        case 'A':
            return parseTokenWord;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
            return parseTokenOneOrTwoDigits;
        default :
            return new RegExp(token.replace('\\', ''));
        }
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, datePartArray, config) {
        var a, b;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            datePartArray[1] = (input == null) ? 0 : ~~input - 1;
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            for (a = 0; a < 12; a++) {
                if (getLangDefinition().monthsParse[a].test(input)) {
                    datePartArray[1] = a;
                    b = true;
                    break;
                }
            }
            // if we didn't find a month name, mark the date as invalid.
            if (!b) {
                datePartArray[8] = false;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DDDD
        case 'DD' : // fall through to DDDD
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                datePartArray[2] = ~~input;
            }
            break;
        // YEAR
        case 'YY' :
            datePartArray[0] = ~~input + (~~input > 70 ? 1900 : 2000);
            break;
        case 'YYYY' :
            datePartArray[0] = ~~Math.abs(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config.isPm = ((input + '').toLowerCase() === 'pm');
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[3] = ~~input;
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[4] = ~~input;
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[5] = ~~input;
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
            datePartArray[6] = ~~ (('0.' + input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config.isUTC = true;
            a = (input + '').match(parseTimezoneChunker);
            if (a && a[1]) {
                config.tzh = ~~a[1];
            }
            if (a && a[2]) {
                config.tzm = ~~a[2];
            }
            // reverse offsets
            if (a && a[0] === '+') {
                config.tzh = -config.tzh;
                config.tzm = -config.tzm;
            }
            break;
        }

        // if the input is null, the date is not valid
        if (input == null) {
            datePartArray[8] = false;
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(string, format) {
        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        // We store some additional data on the array for validation
        // datePartArray[7] is true if the Date was created with `Date.UTC` and false if created with `new Date`
        // datePartArray[8] is false if the Date is invalid, and undefined if the validity is unknown.
        var datePartArray = [0, 0, 1, 0, 0, 0, 0],
            config = {
                tzh : 0, // timezone hour offset
                tzm : 0  // timezone minute offset
            },
            tokens = format.match(formattingTokens),
            i, parsedInput;

        for (i = 0; i < tokens.length; i++) {
            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
            if (parsedInput) {
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            }
            // don't parse if its not a known token
            if (formatTokenFunctions[tokens[i]]) {
                addTimeToArrayFromToken(tokens[i], parsedInput, datePartArray, config);
            }
        }
        // handle am pm
        if (config.isPm && datePartArray[3] < 12) {
            datePartArray[3] += 12;
        }
        // if is 12 am, change hours to 0
        if (config.isPm === false && datePartArray[3] === 12) {
            datePartArray[3] = 0;
        }
        // return
        return dateFromArray(datePartArray, config.isUTC, config.tzh, config.tzm);
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(string, formats) {
        var output,
            inputParts = string.match(parseMultipleFormatChunker) || [],
            formattedInputParts,
            scoreToBeat = 99,
            i,
            currentDate,
            currentScore;
        for (i = 0; i < formats.length; i++) {
            currentDate = makeDateFromStringAndFormat(string, formats[i]);
            formattedInputParts = formatMoment(new Moment(currentDate), formats[i]).match(parseMultipleFormatChunker) || [];
            currentScore = compareArrays(inputParts, formattedInputParts);
            if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                output = currentDate;
            }
        }
        return output;
    }

    // date from iso format
    function makeDateFromString(string) {
        var format = 'YYYY-MM-DDT',
            i;
        if (isoRegex.exec(string)) {
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    format += isoTimes[i][0];
                    break;
                }
            }
            return parseTokenTimezone.exec(string) ?
                makeDateFromStringAndFormat(string, format + ' Z') :
                makeDateFromStringAndFormat(string, format);
        }
        return new Date(string);
    }


    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        var rt = lang.relativeTime[string];
        return (typeof rt === 'function') ?
            rt(number || 1, !!withoutSuffix, string, isFuture) :
            rt.replace(/%d/i, number || 1);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Top Level Functions
    ************************************/


    moment = function (input, format) {
        if (input === null || input === '') {
            return null;
        }
        var date,
            matched;
        // parse Moment object
        if (moment.isMoment(input)) {
            return new Moment(new Date(+input._d), input._isUTC, input._lang);
        // parse string and format
        } else if (format) {
            if (isArray(format)) {
                date = makeDateFromStringAndArray(input, format);
            } else {
                date = makeDateFromStringAndFormat(input, format);
            }
        // evaluate it as a JSON-encoded date
        } else {
            matched = aspNetJsonRegex.exec(input);
            date = input === undefined ? new Date() :
                matched ? new Date(+matched[1]) :
                input instanceof Date ? input :
                isArray(input) ? dateFromArray(input) :
                typeof input === 'string' ? makeDateFromString(input) :
                new Date(input);
        }

        return new Moment(date);
    };

    // creating with utc
    moment.utc = function (input, format) {
        if (isArray(input)) {
            return new Moment(dateFromArray(input, true), true);
        }
        // if we don't have a timezone, we need to add one to trigger parsing into utc
        if (typeof input === 'string' && !parseTokenTimezone.exec(input)) {
            input += ' +0000';
            if (format) {
                format += ' Z';
            }
        }
        return moment(input, format).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._data : (isNumber ? {} : input)),
            ret;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        }

        ret = new Duration(duration);

        if (isDuration) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // humanizeDuration
    // This method is deprecated in favor of the new Duration object.  Please
    // see the moment.duration method.
    moment.humanizeDuration = function (num, type, withSuffix) {
        return moment.duration(num, type === true ? null : type).humanize(type === true ? true : withSuffix);
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var i;

        if (!key) {
            return currentLanguage;
        }
        if (values || !languages[key]) {
            loadLang(key, values);
        }
        if (languages[key]) {
            // deprecated, to get the language definition variables, use the
            // moment.fn.lang method or the getLangDefinition function.
            for (i = 0; i < langConfigProperties.length; i++) {
                moment[langConfigProperties[i]] = languages[key][langConfigProperties[i]];
            }
            moment.monthsParse = languages[key].monthsParse;
            currentLanguage = key;
        }
    };

    // returns language data
    moment.langData = getLangDefinition;

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        }
    });


    /************************************
        Moment Prototype
    ************************************/


    moment.fn = Moment.prototype = {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d;
        },

        unix : function () {
            return Math.floor(+this._d / 1000);
        },

        toString : function () {
            return this._d.toString();
        },

        toDate : function () {
            return this._d;
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds(),
                !!this._isUTC
            ];
        },

        isValid : function () {
            if (this._a) {
                // if the parser finds that the input is invalid, it sets
                // the eighth item in the input array to false.
                if (this._a[8] != null) {
                    return !!this._a[8];
                }
                return !compareArrays(this._a, (this._a[7] ? moment.utc(this._a) : moment(this._a)).toArray());
            }
            return !isNaN(this._d.getTime());
        },

        utc : function () {
            this._isUTC = true;
            return this;
        },

        local : function () {
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            return formatMoment(this, inputString ? inputString : moment.defaultFormat);
        },

        add : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, val, asFloat) {
            var inputMoment = this._isUTC ? moment(input).utc() : moment(input).local(),
                zoneDiff = (this.zone() - inputMoment.zone()) * 6e4,
                diff = this._d - inputMoment._d - zoneDiff,
                year = this.year() - inputMoment.year(),
                month = this.month() - inputMoment.month(),
                date = this.date() - inputMoment.date(),
                output;
            if (val === 'months') {
                output = year * 12 + month + date / 30;
            } else if (val === 'years') {
                output = year + (month + date / 30) / 12;
            } else {
                output = val === 'seconds' ? diff / 1e3 : // 1000
                    val === 'minutes' ? diff / 6e4 : // 1000 * 60
                    val === 'hours' ? diff / 36e5 : // 1000 * 60 * 60
                    val === 'days' ? diff / 864e5 : // 1000 * 60 * 60 * 24
                    val === 'weeks' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7
                    diff;
            }
            return asFloat ? output : round(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this._lang).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            var diff = this.diff(moment().sod(), 'days', true),
                calendar = this.lang().calendar,
                allElse = calendar.sameElse,
                format = diff < -6 ? allElse :
                diff < -1 ? calendar.lastWeek :
                diff < 0 ? calendar.lastDay :
                diff < 1 ? calendar.sameDay :
                diff < 2 ? calendar.nextDay :
                diff < 7 ? calendar.nextWeek : allElse;
            return this.format(typeof format === 'function' ? format.apply(this) : format);
        },

        isLeapYear : function () {
            var year = this.year();
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        },

        isDST : function () {
            return (this.zone() < moment([this.year()]).zone() ||
                this.zone() < moment([this.year(), 5]).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return input == null ? day :
                this.add({ d : input - day });
        },

        startOf: function (val) {
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (val.replace(/s$/, '')) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }
            return this;
        },

        endOf: function (val) {
            return this.startOf(val).add(val.replace(/s?$/, 's'), 1).subtract('ms', 1);
        },

        sod: function () {
            return this.clone().startOf('day');
        },

        eod: function () {
            // end of day = start of day plus 1 day, minus 1 millisecond
            return this.clone().endOf('day');
        },

        zone : function () {
            return this._isUTC ? 0 : this._d.getTimezoneOffset();
        },

        daysInMonth : function () {
            return moment.utc([this.year(), this.month() + 1, 0]).date();
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (lang) {
            if (lang === undefined) {
                return getLangDefinition(this);
            } else {
                this._lang = lang;
                return this;
            }
        }
    };

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase(), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');


    /************************************
        Duration Prototype
    ************************************/


    moment.duration.fn = Duration.prototype = {
        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              this._months * 2592e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                rel = this.lang().relativeTime,
                output = relativeTime(difference, !withSuffix, this.lang()),
                fromNow = difference <= 0 ? rel.past : rel.future;

            if (withSuffix) {
                if (typeof fromNow === 'function') {
                    output = fromNow(output);
                } else {
                    output = fromNow.replace(/%s/i, output);
                }
            }

            return output;
        },

        lang : moment.fn.lang
    };

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);

    BV.define('vendor/moment',[],function () {
        return moment;
    });
}).call(this);

BV.define('framework/bcollection',[
  'backbone',
  'underscore',
  'framework/bevented',
  'framework/bdata',
  'framework/bmodelbase',
  'jquery',
  'framework/util/bvreporter'
], function (Backbone, _, BEvented, BData, BModelBase, $, BVReporter) {
  // BEvented provides publish, subscribe, and unsubscribe
  var BCollection = Backbone.Collection.extend(BEvented);
  BCollection = BCollection.extend(BData);
  BCollection = BCollection.extend(BModelBase);

  return BCollection.extend({
    isCollection: true,

    initialize: function (models, options) {
      BVReporter.debug('Initializing collection', this.name);

      this._initDeferreds();

      // Mixin options
      this.options = _.extend({}, this.options, options);

      var parent = this.options.parent;

      if (parent) {
        _(this).extend(this._getParentProps(parent, options));
        this.parent = parent;
      }
      else {
        _(this).extend(this._getProps());
      }

      this.parent = parent;

      // Passthrough to the init function now
      if (_.isFunction(this.init)) {
        this.init.apply(this, arguments);
      }

      this.attachDataReady(parent);
      this.onDataReady(this._dataReady, this);
    },

    attachDataReady: function (parent) {
      BVReporter.debug('Collection', this.getScope(), 'attaching data ready');

      if (parent) {
        parent.onDataReady(this._processData, this);
      }
      else {
        this.dataReady();
      }
    },

    _dataReady: function () {
      var self = this;
      var subModels = this.models;

      if (subModels.length) {
        // This collection has models. Because their data is being processed
        // asynchronously, we have to wait until all our models have
        // resolved their `dataProcessed` promise.
        var promises = _.invoke(subModels, 'dataProcessedPromise');
        $.when.apply($, promises).done(function () {
          self.dataProcessed();
        });
      }
      else {
        // We have no models, so we can immediately signal to our parent that
        // we're done.
        this.dataProcessed();
      }
    },

    _processData: function (data) {
      this.dataReady(data);
    },

    _setParent: function (item) {
      item.parent = this;
    },

    reset: function (models, options) {
      BVReporter.debug('Resetting collection', this.name);

      if (models) {
        _(models).each(this._setParent, this);
      }
      return Backbone.Collection.prototype.reset.call(this, models, options);
    },

    add: function (models, options) {
      if (models) {
        models = _.isArray(models) ? models.slice() : [models];

        BVReporter.debug('Adding models to collection', this.name, models);

        _(models).each(this._setParent, this);
      }
      return Backbone.Collection.prototype.add.call(this, models, options);
    },

    loadMore: function (models) {
      BVReporter.debug('Loading more for collection', this.name);

      var fromIndex = this.size();
      this.add(models, { silent: true });
      this.trigger('loadmore', this, _(this.models).rest(fromIndex), fromIndex);
    },

    toJSON: function () {
      return this.invoke('toJSON');
    }
  });
});

/* global console:false */

/**
 * @fileOverview This file defines utility functions for working with the
 * Translated Reviews API.  */
BV.define('bv/translationapi/index',[
  'ENV',
  'jquery',
  'window',
  'underscore',
  'BV'
],
// eslint-disable-next-line func-names
function (
  ENV,
  $,
  window,
  _,
  BV
) {

  var DEFAULT_TIMEOUT = 10000;

  var options = ENV.get('config');
  var targetLanguage = options.locale.substring(0, 2);
  var translationAPI;

  // TODO: Define endpoint parts in server-config.json?
  function generateApiUrl (productId, contentIds) {
    var ids = contentIds.join(',');
    var passkey = BV.options.apiconfig.passkey;
    var baseUrl = BV.options.apiconfig.baseUrl;

    return 'https:' + baseUrl + 'v0.1alpha/translations' +
      '?passkey=' + passkey +
      '&productId=' + productId +
      '&ids=' + ids +
      '&targetLanguage=' + targetLanguage;

  }

  translationAPI = {
    fetch: function fetch (productId, contentIds, _opts) {
      var dfd = $.Deferred();
      var req;
      var result;
      var opts = $.extend({
        dataType: 'json',
        timeout: DEFAULT_TIMEOUT
      }, _opts || {});
      var url = generateApiUrl(productId, contentIds);
      opts.url = url;

      // There are six ways that the returned promise can fail:
      // 1. Timeout value exceeded. (Handled automatically by $.ajax.)
      // 2. HTTP request results in an actual HTTP error.
      // 3. 2xx HTTP response but a non-JSON response body.
      // 4. 2xx HTTP response but a JSON response body whose signature isn't
      //    what we're expecting.
      // 5. 2xx HTTP response but a "HasErrors" value of `true` in the response
      //    JSON.
      // 6. Valid HTTP response, "HasErrors" = `false`, but the `ReviewText`
      //    field is `null`. This should be treated as an error because we don't
      //    want to show the user blank content here.
      req = $.ajax(opts);
      req.done(function done (json) {
        var results;
        var i;

        // Handle failure scenario #4.
        if (!('HasErrors' in json)) {
          dfd.reject(json);
          return;
        }

        // Handle failure scenario #5.
        if (json.HasErrors) {
          dfd.reject(json);
          return;
        }

        results = json.Results;
        // Handle failure scenario #6: if any of the pieces of content we ask
        // for has an empty review text field, reject the deferred. (Currently
        // we ask for only one at a time; if we end up asking for multiple
        // translations at once, we should revisit this behavior.)
        for (i = 0; i < contentIds.length; i++) {
          result = results[contentIds[i]];
          // Empty field here means translation failed.
          if (!result || !('ReviewText' in result) || result.ReviewText === null) {
            dfd.reject(json);
            return;
          }
        }
        dfd.resolve(json);
      });

      // Handle failure scenarios #2 and #3: both an HTTP error code and a
      // failed attempt to parse the response body as JSON will trigger a
      // rejected promise.
      req.fail(function fail (_req, textStatus, errorThrown) {
        dfd.reject(_req, textStatus, errorThrown);
      });

      return dfd.promise();
    }
  };

  return translationAPI;
});

BV.define('util/lookup',['underscore'], function (_) {

  return function (root, path, opts) {
    var options = opts || {};
    if ( _(path).isEmpty() ) {
      return root;
    }
    var nodes = path.split('.');
    var target = root || {};
    var currentNode = target[nodes.shift()];
    while (currentNode && nodes.length) {
      currentNode = currentNode[nodes.shift()];
    }
    return _(currentNode).isUndefined() ? options.undefinedDefault : currentNode;
  };

});
BV.define('dimsumFields!',[], {"rating":{"CustomerService":{"displayLabel":"Customer Service","submissionFormLabel":"Customer Service","filterable":false,"possibleValues":[],"autoPopulate":false,"type":"RATING","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Customer Service"},"id":"CustomerService","subjectIDRequired":false,"hideOnSubmission":false},"TestSlider":{"displayLabel":"Test Slider","sliderDimension2Label":"Test Slider Right","submissionFormLabel":"Test Slider","filterable":false,"possibleValues":[{"displayLabel":"Test Slider1","id":"valueLabel1"},{"displayLabel":"Test Slider2","id":"valueLabel2"},{"displayLabel":"Test Slider3","id":"valueLabel3"},{"displayLabel":"Test Slider4","id":"valueLabel4"},{"displayLabel":"Test Slider5","id":"valueLabel5"}],"autoPopulate":false,"sliderSize":5,"type":"SLIDER","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Slider"},"sliderDimension1Label":"Test Slider Left","id":"TestSlider","subjectIDRequired":false,"hideOnSubmission":false},"Slider7":{"displayLabel":"Slider 7","sliderDimension2Label":"test","submissionFormLabel":"Slider 7","filterable":false,"possibleValues":[{"displayLabel":"1","id":"valueLabel1"},{"displayLabel":"2","id":"valueLabel2"},{"displayLabel":"3","id":"valueLabel3"},{"displayLabel":"4","id":"valueLabel4"},{"displayLabel":"5","id":"valueLabel5"},{"displayLabel":"6","id":"valueLabel6"},{"displayLabel":"7","id":"valueLabel7"}],"autoPopulate":false,"sliderSize":7,"type":"SLIDER","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":true,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Slider 7"},"sliderDimension1Label":"Cool","id":"Slider7","subjectIDRequired":false,"hideOnSubmission":false},"anotherTestSlider3":{"displayLabel":"another test slider 3","sliderDimension2Label":"three","submissionFormLabel":"another test slider 3","filterable":false,"possibleValues":[{"displayLabel":"1","id":"valueLabel1"},{"displayLabel":"2","id":"valueLabel2"},{"displayLabel":"3","id":"valueLabel3"}],"autoPopulate":false,"sliderSize":3,"type":"SLIDER","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"another test slider 3"},"sliderDimension1Label":"one","id":"anotherTestSlider3","subjectIDRequired":false,"hideOnSubmission":false}},"contextdatavalue":{"TestDropdown":{"displayLabel":"Test Dropdown","submissionFormLabel":"Test Dropdown","filterable":false,"possibleValues":[{"displayLabel":"Test Dropdown","id":"TestDropdown"},{"displayLabel":"Test Dropdown 2","id":"TestDropdown2"}],"autoPopulate":false,"type":"CHOICE","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Dropdown"},"id":"TestDropdown","subjectIDRequired":false,"hideOnSubmission":false}},"additionalfield":{"TestText":{"displayLabel":"Test Text","submissionFormLabel":"Test Text","filterable":false,"possibleValues":[],"autoPopulate":false,"type":"TEXT","required":false,"allowUserCreated":false,"answerLength":"SHORT_LINE","disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Text"},"id":"TestText","subjectIDRequired":false,"hideOnSubmission":false}},"tag":{"BestUsesTelecom":{"displayLabel":"Best Uses - Telecom","submissionFormLabel":"Best Uses","filterable":false,"possibleValues":[{"displayLabel":"Everyday Use","id":"EverydayUse"},{"displayLabel":"Home Use","id":"HomeUse"},{"displayLabel":"Office Use","id":"OfficeUse"},{"displayLabel":"Outdoors","id":"Outdoors"}],"autoPopulate":false,"type":"MULTICHOICE_TAGGROUP","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Best Uses - Telecom"},"id":"BestUsesTelecom","subjectIDRequired":false,"hideOnSubmission":false}}});

/**
 * Provides a simple lookup of Firebird config field information
 */
BV.define('bv/util/configFieldReader',[
  'underscore',
  'framework/util/bvreporter'
], function (_, BVReporter) {
  // Several known strings can be used to describe type,
  // so we'll create a nice little map to make life a bit easier.
  // The four types we'll map to:
  var CDV = 'contextdatavalue';
  var AF = 'additionalfield';
  var RATING = 'rating';
  var TAG = 'tag';

  var typeMap = {
    'contextdatavalues': CDV,
    'cdv': CDV,
    'additionalfields': AF,
    'ratings': RATING,
    'tags': TAG
  };

  function ConfigFieldReader (config) {
    this._config = config;
  }

  var cfrProto = ConfigFieldReader.prototype;

  cfrProto.getField = function (type, id) {
    if (_.isObject(type)) {
      // Assume that we got a field as input, simply hand it back
      return type;
    }

    // Normalize our type a bit
    type = typeMap[type.toLowerCase()] || type.toLowerCase();

    var fields = this._config[type];
    if (!fields) {
      // Given that field types are a fairly known and stable thing,
      // we'll issue a warning here.
      BVReporter.warn('Unable to get details for config field type ' + type + ', not found');
      return false;
    }

    var field = fields[id];
    if (!field) {
      // It seems more common to possibly be looking for a field that may
      // or may not exist, but it may be unexpected, so we'll issue a warning
      BVReporter.warn('Unable to find config field ' + id);
      return false;
    }

    return field;
  };

  cfrProto.getLabel = function (type, id) {
    var field = this.getField(type, id);
    if (!field) {
      BVReporter.warn('Unable to retrieve label for field ' + id);
      return false;
    }

    return field.displayLabel;
  };

  cfrProto.getValueLabels = function (type, id) {
    var field = this.getField(type, id);
    if (!field) {
      BVReporter.warn('Unable to retrieve possible value labels for field ' + id);
      return false;
    }

    var labels = {};

    _(field.possibleValues).forEach(function (value) {
      labels[value.id] = value.displayLabel;
    });

    return labels;
  };

  cfrProto.getFieldType = function (type, id) {
    var field = this.getField(type, id);
    if (!field) {
      BVReporter.warn('Unable to retrieve type for field' + id);
      return false;
    }
    return field.type;
  };

  // Extracts the labels from the field
  // opts = { value : int, foo : 'bar' }
  cfrProto.getLabelsObject = function (type, id, opts) {
    var field = this.getField(type, id);

    if (!field) {
      BVReporter.warn('Unable to retrieve label for field ' + id);
      return false;
    }

    var labels = {};

    labels.Label = field.displayLabel;

    if (field.type === 'SLIDER') {
      labels.MinLabel = field.sliderDimension1Label;
      labels.MaxLabel = field.sliderDimension2Label;
      labels.ValueRange = field.sliderSize;
      // We can only get the ValueLabel if we were passed the value of the rating
      if (opts && opts.value) {
        labels.ValueLabel = field.possibleValues[opts.value - 1].displayLabel;
      }
    }

    return labels;
  };

  return ConfigFieldReader;
});

/**
 * Provides a simple lookup of dimsum field information
 */
BV.define('bv/util/configFieldInfo',[
  'dimsumFields!',
  './configFieldReader'
], function (dimsumFields, ConfigFieldReader) {
  return new ConfigFieldReader(dimsumFields);
});

BV.define('dimsumFields!fields',[], {"rating":{"CustomerService":{"displayLabel":"Customer Service","submissionFormLabel":"Customer Service","filterable":false,"possibleValues":[],"autoPopulate":false,"type":"RATING","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Customer Service"},"id":"CustomerService","subjectIDRequired":false,"hideOnSubmission":false},"TestSlider":{"displayLabel":"Test Slider","sliderDimension2Label":"Test Slider Right","submissionFormLabel":"Test Slider","filterable":false,"possibleValues":[{"displayLabel":"Test Slider1","id":"valueLabel1"},{"displayLabel":"Test Slider2","id":"valueLabel2"},{"displayLabel":"Test Slider3","id":"valueLabel3"},{"displayLabel":"Test Slider4","id":"valueLabel4"},{"displayLabel":"Test Slider5","id":"valueLabel5"}],"autoPopulate":false,"sliderSize":5,"type":"SLIDER","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Slider"},"sliderDimension1Label":"Test Slider Left","id":"TestSlider","subjectIDRequired":false,"hideOnSubmission":false},"Slider7":{"displayLabel":"Slider 7","sliderDimension2Label":"test","submissionFormLabel":"Slider 7","filterable":false,"possibleValues":[{"displayLabel":"1","id":"valueLabel1"},{"displayLabel":"2","id":"valueLabel2"},{"displayLabel":"3","id":"valueLabel3"},{"displayLabel":"4","id":"valueLabel4"},{"displayLabel":"5","id":"valueLabel5"},{"displayLabel":"6","id":"valueLabel6"},{"displayLabel":"7","id":"valueLabel7"}],"autoPopulate":false,"sliderSize":7,"type":"SLIDER","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":true,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Slider 7"},"sliderDimension1Label":"Cool","id":"Slider7","subjectIDRequired":false,"hideOnSubmission":false},"anotherTestSlider3":{"displayLabel":"another test slider 3","sliderDimension2Label":"three","submissionFormLabel":"another test slider 3","filterable":false,"possibleValues":[{"displayLabel":"1","id":"valueLabel1"},{"displayLabel":"2","id":"valueLabel2"},{"displayLabel":"3","id":"valueLabel3"}],"autoPopulate":false,"sliderSize":3,"type":"SLIDER","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"another test slider 3"},"sliderDimension1Label":"one","id":"anotherTestSlider3","subjectIDRequired":false,"hideOnSubmission":false}},"contextdatavalue":{"TestDropdown":{"displayLabel":"Test Dropdown","submissionFormLabel":"Test Dropdown","filterable":false,"possibleValues":[{"displayLabel":"Test Dropdown","id":"TestDropdown"},{"displayLabel":"Test Dropdown 2","id":"TestDropdown2"}],"autoPopulate":false,"type":"CHOICE","required":true,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Dropdown"},"id":"TestDropdown","subjectIDRequired":false,"hideOnSubmission":false}},"additionalfield":{"TestText":{"displayLabel":"Test Text","submissionFormLabel":"Test Text","filterable":false,"possibleValues":[],"autoPopulate":false,"type":"TEXT","required":false,"allowUserCreated":false,"answerLength":"SHORT_LINE","disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Test Text"},"id":"TestText","subjectIDRequired":false,"hideOnSubmission":false}},"tag":{"BestUsesTelecom":{"displayLabel":"Best Uses - Telecom","submissionFormLabel":"Best Uses","filterable":false,"possibleValues":[{"displayLabel":"Everyday Use","id":"EverydayUse"},{"displayLabel":"Home Use","id":"HomeUse"},{"displayLabel":"Office Use","id":"OfficeUse"},{"displayLabel":"Outdoors","id":"Outdoors"}],"autoPopulate":false,"type":"MULTICHOICE_TAGGROUP","required":false,"allowUserCreated":false,"disabledPossibleValues":[],"hideDisplay":false,"name":{"$schema":"http://config.bazaarvoice.com/api/schemas/Configuration/LocalizedText/1.0.1","defaultValue":"Best Uses - Telecom"},"id":"BestUsesTelecom","subjectIDRequired":false,"hideOnSubmission":false}}});

BV.define('dimsumFields!fieldCategories',[], {"fieldCategoryMap":{"tag_BestUsesTelecom":"product","tag_BestUsesEntertainment":"product","tag_BestUsesPharmacyHealth":"product","tag_ProsTravel":"product","additionalfield_OrderNumber":"product","tag_ProsMusic":"product","tag_ConsB2BElectronics":"product","tag_ProsPets":"product","tag_ProsGames":"product","tag_ConsTravel":"product","contextdatavalue_Clothingfit":"product","contextdatavalue_LengthOfOwnership":"product","tag_ProsSoftware":"product","contextdatavalue_TravelPurpose_89":"product","tag_ProsSportingGoods":"product","contextdatavalue_TravelPurpose":"product","contextdatavalue_SoftwarePrimaryUse":"product","tag_BestUsesBooks":"product","tag_ConsOfficeSupplies":"product","tag_ConsCooking":"product","tag_ProsTelecom":"product","tag_ProsApparel":"product","tag_ConsGames":"product","tag_ConsTelecom":"product","tag_ConsBeauty":"product","tag_BestUsesApparel":"product","tag_ProsHomeGoods":"product","tag_blank_49":"product","tag_ProsBooks":"product","tag_ProsFinancialServices":"product","tag_BestUsesPets":"product","tag_ConsBooks":"product","tag_BestUsesTravel":"product","tag_BestUsesOfficeSupplies":"product","tag_BestUsesGames":"product","contextdatavalue_IncentivizedReview":"product","tag_BestUsesMusic":"product","contextdatavalue_ReadReviews":"product","tag_Con":"product","contextdatavalue_RunningSurface":"product","tag_BestUsesFood":"product","tag_ConsSoftware":"product","contextdatavalue_Appearance":"product","tag_ProsB2BElectronics":"product","tag_ProsBeauty":"product","tag_ProsPharmacyHealth":"product","tag_ConsMusic":"product","tag_ConsDVDs":"product","tag_ConsFlowersGifts":"product","contextdatavalue_Numberofpets":"product","tag_BestUsesBeauty":"product","tag_BestUsesFlowersGifts":"product","tag_ProsDVDs":"product","tag_ConsApparel":"product","contextdatavalue_UsageFrequency_1":"product","tag_Pro":"product","tag_ProsEducation":"product","tag_BestUsesEducation":"product","tag_BestUsesCleaningSuppliesCPG":"product","tag_ConsHomeGoods":"product","tag_ProsEntertainment":"product","tag_ConsToysHobbies":"product","tag_ConsFood":"product","tag_ConsBoringEducation":"product","tag_ProsOfficeSupplies":"product","tag_ProsCleaningSuppliesCPG":"product","tag_BestUsesSoftware":"product","contextdatavalue_ComputerPrimaryUse":"product","tag_ConsFinancialServices":"product","tag_BestUsesSportingGoods":"product","tag_ConsConsumerElectronics":"product","tag_BestUsesToysHobbies":"product","tag_BestUsesDVDs":"product","contextdatavalue_UsageFrequency_19":"product","tag_ConsEntertainment":"product","tag_ProsFood":"product","tag_blank":"product","contextdatavalue_HouseholdSize":"product","contextdatavalue_UsageFrequency":"product","contextdatavalue_WhereDidYouPurchase":"product","tag_ProsCooking":"product","contextdatavalue_NumberOfChildren":"product","tag_ConsCleaningSuppliesCPG":"product","contextdatavalue_FavoriteComicGenre":"product","tag_ConsPets":"product","tag_ConsPharmacyHealth":"product","tag_ProsToysHobbies":"product","tag_ProsConsumerElectronics":"product","tag_ProsFlowersGifts":"product","tag_BestUsesHomeGoods":"product","tag_ConsSportingGoods":"product","contextdatavalue_TvPrimaryUse":"product","tag_BestUsesConsumerElectronics":"product","tag_BestUsesCooking":"product","tag_BestUsesB2BElectronics":"product","contextdatavalue_UsageFrequency1":"product","contextdatavalue_DomainExpertise":"product","contextdatavalue_blank_1":"product","rating_CustomerService":"ratings","rating_Transportation":"ratings","rating_PictureQuality":"ratings","rating_EaseOfSetup":"ratings","rating_EaseOfUse":"ratings","rating_Design":"ratings","rating_SoundQuality1":"ratings","rating_Quality":"ratings","rating_Features":"ratings","rating_Width":"ratings","rating_Cleanliness":"ratings","rating_Effectiveness":"ratings","rating_Appearance1":"ratings","rating_SoundQuality":"ratings","rating_FoodQuality":"ratings","rating_TestSlider":"ratings","rating_EaseOfAssembly":"ratings","rating_Fit":"ratings","rating_Slider7":"ratings","rating_anotherTestSlider3":"ratings","rating_BatteryLife":"ratings","rating_Comfort":"ratings","rating_Value":"ratings","rating_Ambience":"ratings","rating_Reliability":"ratings","rating_Performance":"ratings","rating_Amenities":"ratings","rating_Fit_22":"ratings","contextdatavalue_FavoriteBookGenre":"people","additionalfield_TestText":"people","contextdatavalue_EducationalRole":"people","contextdatavalue_FavoriteMovieGenre":"people","contextdatavalue_BodyType":"people","contextdatavalue_HomeGoodsProfile":"people","contextdatavalue_Gender":"people","contextdatavalue_FashionStyle":"people","contextdatavalue_FavoriteMusicGenre":"people","contextdatavalue_Levelofexpertise":"people","contextdatavalue_HairType":"people","contextdatavalue_EyeColor":"people","contextdatavalue_DecorStyle":"people","contextdatavalue_TravelCompanions":"people","contextdatavalue_LineOfBusiness":"people","contextdatavalue_Skintype":"people","contextdatavalue_FavoriteComicGenre1":"people","contextdatavalue_TestDropdown":"people","contextdatavalue_Age":"people","contextdatavalue_HairCondition":"people","contextdatavalue_Trimester":"people"},"fieldCategoryOrder":["baseReviewQuestions","basicUserInfo","people","ratings","product","netPromoterScore","hiddenPeopleQuestions","hiddenProductQuestions"]});

BV.define('dimsumFields!hiddenFieldKeys',[], {"OrderNumber":true,"LengthOfOwnership":true,"TravelPurpose":true,"ReadReviews":true,"RunningSurface":true,"Appearance":true,"Numberofpets":true,"ComputerPrimaryUse":true,"UsageFrequency_19":true,"HouseholdSize":true,"UsageFrequency":true,"WhereDidYouPurchase":true,"NumberOfChildren":true,"FavoriteComicGenre":true,"TvPrimaryUse":true,"UsageFrequency1":true,"DomainExpertise":true,"blank_1":true,"Slider7":true});

BV.define('mf!bv/c2013/messages/contentItem',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"syndicationText" : function (x) { try { return (function(d){
var r = "";
r += "Originally posted on <a href=\"";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ContentLink"];
r += "\" class=\"bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Name"];
r += "</a>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `syndicationText`: ' + e.toString() ) ] ); return ""; } },"syndicationTextNoLink" : function (x) { try { return (function(d){
var r = "";
r += "Originally posted on ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Name"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `syndicationTextNoLink`: ' + e.toString() ) ] ); return ""; } },"productFamilyText" : function (x) { try { return (function(d){
var r = "";
r += "Originally posted on <a href=\"";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Url"];
r += "\" class=\"bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Name"];
r += "</a>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `productFamilyText`: ' + e.toString() ) ] ); return ""; } },"productFamilyTextNoLink" : function (x) { try { return (function(d){
var r = "";
r += "Originally posted on ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Name"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `productFamilyTextNoLink`: ' + e.toString() ) ] ); return ""; } },"questionCloseForAnswers" : function (x) { try { return (function(d){
var r = "";
r += "This question is closed for new answers!";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `questionCloseForAnswers`: ' + e.toString() ) ] ); return ""; } },"contentPreview_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "Thank you for submitting a review! Your review is being moderated and may take up to a few days to appear.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentPreview_Reviews`: ' + e.toString() ) ] ); return ""; } },"contentPreview_Comments" : function (x) { try { return (function(d){
var r = "";
r += "Thank you for submitting a comment! Your comment is being moderated and may take up to a few days to appear.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentPreview_Comments`: ' + e.toString() ) ] ); return ""; } },"contentPreview_Questions" : function (x) { try { return (function(d){
var r = "";
r += "Thank you for submitting a question! Your question is being moderated and may take up to a few days to appear.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentPreview_Questions`: ' + e.toString() ) ] ); return ""; } },"content_secondary_btn_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "Comment";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_secondary_btn_Reviews`: ' + e.toString() ) ] ); return ""; } },"offscreen_content_secondary_btn_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "Comment on review by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += ".";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_content_secondary_btn_Reviews`: ' + e.toString() ) ] ); return ""; } },"content_secondary_btn_Questions" : function (x) { try { return (function(d){
var r = "";
r += "Answer this Question";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_secondary_btn_Questions`: ' + e.toString() ) ] ); return ""; } },"offscreen_content_secondary_btn_Questions" : function (x) { try { return (function(d){
var r = "";
r += "Answer this question by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += ".";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_content_secondary_btn_Questions`: ' + e.toString() ) ] ); return ""; } },"offscreen_play_media" : function (x) { try { return (function(d){
var r = "";
r += "Play Video";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_play_media`: ' + e.toString() ) ] ); return ""; } },"offscreen_photo" : function (x) { try { return (function(d){
var r = "";
r += "Photo";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_photo`: ' + e.toString() ) ] ); return ""; } },"offscreen_content_secondary_value_of_one_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of 1 means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_content_secondary_value_of_one_means`: ' + e.toString() ) ] ); return ""; } },"offscreen_content_secondary_value_max_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ValueRange"];
r += " means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_content_secondary_value_max_means`: ' + e.toString() ) ] ); return ""; } },"offscreen_secondary_rating" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Value"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ValueRange"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_secondary_rating`: ' + e.toString() ) ] ); return ""; } },"responseFrom" : function (x) { try { return (function(d){
var r = "";
r += "Response from ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["clientName"];
r += ":";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `responseFrom`: ' + e.toString() ) ] ); return ""; } },"responseFrom_reviewresponse" : function (x) { try { return (function(d){
var r = "";
r += "Response from ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Department"];
r += ":";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `responseFrom_reviewresponse`: ' + e.toString() ) ] ); return ""; } },"contentItem_defaultPhotoCaption" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "ContentType";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
r += "Review photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"comment" : function(d){
var r = "";
r += "Comment photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"clientresponse" : function(d){
var r = "";
r += "Comment photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"question" : function(d){
var r = "";
r += "Question photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"answer" : function(d){
var r = "";
r += "Answer photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"other" : function(d){
var r = "";
r += "Content photo ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_defaultPhotoCaption`: ' + e.toString() ) ] ); return ""; } },"contentItem_defaultVideoCaption" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "ContentType";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
r += "Review video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"comment" : function(d){
var r = "";
r += "Comment video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"clientresponse" : function(d){
var r = "";
r += "Comment video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"question" : function(d){
var r = "";
r += "Question video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"answer" : function(d){
var r = "";
r += "Answer video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
},
"other" : function(d){
var r = "";
r += "Content video ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["ItemNumber"];
r += " ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_defaultVideoCaption`: ' + e.toString() ) ] ); return ""; } },"contentFeaturedBadge" : function (x) { try { return (function(d){
var r = "";
r += "Featured";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentFeaturedBadge`: ' + e.toString() ) ] ); return ""; } },"contentFeaturedBadgeAltText" : function (x) { try { return (function(d){
var r = "";
r += "Featured review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentFeaturedBadgeAltText`: ' + e.toString() ) ] ); return ""; } },"contentVerifiedPurchaserBadge" : function (x) { try { return (function(d){
var r = "";
r += "Verified Purchaser";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentVerifiedPurchaserBadge`: ' + e.toString() ) ] ); return ""; } },"contentVerifiedPurchaserBadgeAltText" : function (x) { try { return (function(d){
var r = "";
r += "Verified purchaser";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentVerifiedPurchaserBadgeAltText`: ' + e.toString() ) ] ); return ""; } },"contentIncentivizedReviewBadge" : function (x) { try { return (function(d){
var r = "";
r += "Received Free Product";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentIncentivizedReviewBadge`: ' + e.toString() ) ] ); return ""; } },"headToHeadSummary" : function (x) { try { return (function(d){
var r = "";
r += "Review by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += ". Written ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["submissionTimeAgo"];
r += ". ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Rating"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingRange"];
r += " stars.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `headToHeadSummary`: ' + e.toString() ) ] ); return ""; } },"display_crowdSourcedAnswerText" : function (x) { try { return (function(d){
var r = "";
r += "Information button";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_crowdSourcedAnswerText`: ' + e.toString() ) ] ); return ""; } },"contentItem_translateContent" : function (x) { try { return (function(d){
var r = "";
r += "Translate with Google";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translateContent`: ' + e.toString() ) ] ); return ""; } },"contentItem_translateContentPending" : function (x) { try { return (function(d){
var r = "";
r += "Loading translation…";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translateContentPending`: ' + e.toString() ) ] ); return ""; } },"contentItem_untranslateContent" : function (x) { try { return (function(d){
var r = "";
r += "Show original review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_untranslateContent`: ' + e.toString() ) ] ); return ""; } },"contentItem_translateContentFailure" : function (x) { try { return (function(d){
var r = "";
r += "Translation failed.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translateContentFailure`: ' + e.toString() ) ] ); return ""; } },"contentItem_translateContentRetry" : function (x) { try { return (function(d){
var r = "";
r += "Try again";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translateContentRetry`: ' + e.toString() ) ] ); return ""; } },"contentItem_translateContentAttribution" : function (x) { try { return (function(d){
var r = "";
r += "Translated by Google";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translateContentAttribution`: ' + e.toString() ) ] ); return ""; } },"contentItem_translationTermsButtonLabel" : function (x) { try { return (function(d){
var r = "";
r += "About this translation";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translationTermsButtonLabel`: ' + e.toString() ) ] ); return ""; } },"contentItem_translationTermsTitle" : function (x) { try { return (function(d){
var r = "";
r += "About this translation";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentItem_translationTermsTitle`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('util/datelocale',[
],
function (
) {
  return {
    load : function (name, parentRequire, load, config) {
          },
    write : function (pluginName, moduleName, write) {
          }
  };
});


BV.define('util/datelocale!ago',['vendor/moment'], function (moment) {
var lang = {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        meridiem : {
            AM : 'AM',
            am : 'am',
            PM : 'PM',
            pm : 'pm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        }
    };
  return function () { return moment.lang('en-us', lang); };
});
/**
 * @fileOverview Helper to get past times in relation to "now"
 *
 * Formats dates and times.
 *
 * Pass in a date (assumed to be ISO 8601 format) as the first argument. If
 * a `format` keyword argument is present, it'll output the date in that
 * format; consult the Moment.js docs for specifics on the format syntax.
 * If there is no such argument, it'll output the date relative to the
 * current time.
 *
 * EXAMPLES:
 *
 * {{ago SubmissionTime format='MMMM D, YYYY'}}
 * {{! outputs (e.g.) "December 1, 2012" }}
 *
 * {{ago SubmissionTime}}
 * {{! outputs (e.g.) "2 months ago" }}
 *
 */
BV.define('template/helpers/ago',[
  'vendor/handlebars/runtime',
  'vendor/moment',
  'util/datelocale!ago',
  'framework/util/bvreporter'
], function (Handlebars, moment, setdatelocale, BVReporter) {

  function ago (date, options) {
    if (!date) {
      BVReporter.warn('The ago helper was called without a date.');
      return;
    }

    // Make sure options.hash exists
    options = options || {};
    options.hash = options.hash || {};

    // This runs the moment.lang function for us to make sure
    // we're in the right language.
    setdatelocale();

    // Remove microseconds - moment can't parse it
    date = date.replace('.000', '');

    // format of timestamp
    var internalFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    var formattedDate = moment(date, internalFormat);

    // check for optional arguments for setting format
    var externalFormat = options.hash.format || '';

    return externalFormat ? formattedDate.format(externalFormat) : formattedDate.fromNow();
  }

  Handlebars.registerHelper('ago', ago);
  return ago;
});

/**
 * @fileOverview This helper returns an ordered list of badges.
 * To order the badges, this function uses a priority list defined inside the
 * function and the BadgesOrder array. The order in the priority list trumps
 * the order in BadgesOrder.
 *
 * @param {Object} Badges The list of badges.
 * @param {Object} Author The list of author badges.
 * @param {Array} BadgesOrder The order for the list of badges.
 * @returns {Array} Returns an array of ordered badges.
 *
 * This is an amalgam of content badges and user badges.
 *
 * The badges are in a specific order based on how important we think they are.
 * The order interleaves content badges with user badges. We have an order
 * because in some circumstances we're forced to show fewer badges than the
 * theoretical maximum, and in those cases we want to make sure the most
 * important badge(s) are shown.
 *
 * This is an order that we've hard-coded because the order we get from Config
 * Hub is arbitrary.
 *
 * Reviews:
 * 0) Incentivized (aka, "sampling badge" or"compensated contributor")
 * 1) Verified Purchaser
 * 2) Featured
 * 3) Staff badge
 * 4) Merit ('ContibutorRank' / Top N)
 * 5) Expert
 * 6....n) Future CDV Badges
 *
 * Q&A:
 * 1) Crowdsourced Answer badge // currently located in the hbs template.
 * 2) Brand Answer badge
 * 3) Featured
 * 4) Staff
 * 5) Merit
 * 6) Expert
 * 7...n) Future CDV Badges
 */

BV.define('bv/c2013/model/contentItem/getOrderedBadges',[
  'underscore',
  'util/lookup'
], function (_, lookup) {

  function getOrderedBadges (Badges, Author, BadgesOrder) {

    Author = Author || {};

    var addedBadges = {};
    var badgeDefinitions = {};
    var badgePriority = [];
    var result = [];
    var AuthorBadges = lookup(Author, 'Badges');
    var ContributorRank = lookup(Author, 'ContributorRank') || getInferredRank() || 'NONE';
    var isContributor = ContributorRank !== 'NONE';
    var contributorKey = '';

    // No reason to continue processing if we received no badges
    // and the author is not a contributor.
    if (_.isEmpty(Badges) && _.isEmpty(Author.Badges) && !isContributor) {
      return [];
    }

    // Helper function to add a badge to result and also
    // keeps track of all added badges.
    function addBadge (badgeName) {
      if (badgeDefinitions[badgeName]) {
        result.push(badgeDefinitions[badgeName]);
      }
      else {
        result.push({
          id: badgeName,
          badgeType: 'content',
          iconChar: '',
          msgKey: '',
          Badges: Badges
        });
      }

      // Create a map to quickly check which badges have been added.
      addedBadges[badgeName] = true;
    }

    // Creates the badge name from ContributorRank.
    // The value for ContributorRank shows up in the Badges object in a different format.
    // I.E. ContributorRank value "Top_10" shows up as "top10" in the Badges object.
    // If the rank isn't found in the Badges object, then default to
    // the "ContributorRank".
    function getContributorKey () {
      var defaultKey = 'ContributorRank';
      var key = '';

      if (isContributor) {
        key = ContributorRank.replace('_', '').toLowerCase();

        if (!(Badges && Badges[key])) {
          key = defaultKey;
        }
      }

      return key;
    }

    /**
     * With the addition of anonymous reviewers, we cannot always rely on the Author
     * data for determining the contributor rank of the reviewer.
     *
     * Instead of hiding top contributor badges for anonymous reviewers, determine the
     * rank of a reviewer from the badges themselves.
     */
    function getInferredRank () {
      var rankPattern = /^top(\d+)$/;

      var contributorBadge = _.find(_(Badges).keys(), function (name) {
        return name.match(rankPattern);
      });

      if (contributorBadge) {
        var parsedRank = contributorBadge.match(rankPattern);
        return 'TOP_' + parsedRank[1];
      }
    }

    contributorKey = getContributorKey();

    // These badges should appear first in the list.
    badgePriority = [
      'incentivizedReview',
      'verifiedPurchaser',
      'featured',
      'Staff',
      contributorKey,
      'Expert'
    ];

    // Use badgePriority and BadgesOrder to make a new prioritized list.
    // The order in the original badgePriority trumps the order in BadgesOrder.
    badgePriority = _.union(badgePriority, BadgesOrder);

    // Badge information that is used to overwrite data from the API.
    badgeDefinitions = {
      incentivizedReview: {
        id: 'incentivizedReview',
        badgeType: 'content',
        iconChar: '&#8862;',
        msgKey: 'contentIncentivizedReviewBadge',
        Badges: Badges
      },
      verifiedPurchaser: {
        id: 'verifiedPurchaser',
        badgeType: 'content',
        iconChar: '',
        msgKey: 'contentVerifiedPurchaserBadge',
        Badges: Badges
      },
      featured: {
        id: 'featured',
        badgeType: 'content',
        iconChar: '',
        msgKey: '',
        Badges: Badges
      },
      Staff: {
        id: 'Staff',
        badgeType: 'user',
        iconChar: '&#x2642;',
        msgKey: '',
        msgPrefix: 'avatar_badge_',
        Badges: Badges
      },
      Expert: {
        id: 'Expert',
        badgeType: 'user',
        iconChar: '&infin;',
        msgKey: '',
        msgPrefix: 'avatar_badge_',
        // Expert badge can be in Author.Badges or in Badges.
        // If it appears in one, then it usually appears in the other.
        // Do the check below just to be safe.
        Badges: AuthorBadges && AuthorBadges.Expert ? AuthorBadges : Badges
      }
    };

    badgeDefinitions[contributorKey] = {
      id: ContributorRank,
      badgeType: 'contributor',
      iconChar: '',
      msgKey: '',
      msgPrefix: 'avatar_rank_',
      // Contributor badge can be in Author.Badges or in Badges.
      // If it appears in one, then it usually appears in the other.
      // Do the check below just to be safe.
      Badges: AuthorBadges && AuthorBadges[contributorKey] ? AuthorBadges : Badges
    };

    // Add badges to the result using the priority we define.
    _.each(badgePriority, function (badgeName) {
      var isValidBadge = Badges && Badges[badgeName];

      // Adds for contributor in case the contributor badge
      // isn't in the Badges object.
      var isContributorBadge = badgeName === contributorKey && isContributor;

      // Only add the Author badges defined in badgeDefinition.
      var isAuthorBadge = AuthorBadges && AuthorBadges[badgeName] && badgeDefinitions[badgeName];

      if (isValidBadge || isContributorBadge || isAuthorBadge) {
        addBadge(badgeName);
      }
    });

    // Add the rest of the badges that do not have a defined order.
    _.each(Badges, function (badge) {
      var badgeName = badge.Id;

      // Check to see that the badge isn't already added when creating
      // the priority badges.
      if (!addedBadges[badgeName]) {
        addBadge(badgeName);
      }
    });

    return result;
  }

  return getOrderedBadges;
});

/**
 * @fileOverview Implementation for contentItem model
 */
BV.define('bv/c2013/model/contentItem',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/translationapi/index',
  'bv/util/contentType',
  'util/lookup',
  'bv/util/configFieldInfo',
  'dimsumFields!fields',
  'dimsumFields!fieldCategories',
  'dimsumFields!hiddenFieldKeys',
  'mf!bv/c2013/messages/common',
  'mf!bv/c2013/messages/contentItem',
  'template/helpers/ago',
  'bv/c2013/model/contentItem/getOrderedBadges',
  'framework/util/bvreporter'
], function module (
  ENV,
  BModel,
  _,
  TranslationApi,
  ContentType,
  lookup,
  configFieldInfo,
  dimsumFields,
  dimsumFieldCategoryMap,
  dimsumHiddenFieldKeys,
  commonMessages,
  msgPack,
  ago,
  getOrderedBadges,
  BVReporter
) {
  return BModel.extend({
    options: {},
    name: 'contentItem',

    init: function init (config, options) {
      var ENVConfig = ENV.get('config');
      var parent = this.get('parent');
      var productFamiliesAttribution = this.hasFeature('productFamiliesAttribution');
      var contentType;
      var secondaryContentType;
      var mainLang;
      var contentLang;
      var canTranslate;

      if (parent && parent.subjectId && this.get('ReferenceId')) {
        // added toLowerCase() to exclude double attribution statement appearing. See CCS-32666.
        if ((this.get('ReferenceId').toLowerCase() !== parent.subjectId.toLowerCase()) && productFamiliesAttribution) {
          this.set('IsFromProductFamily', true);
        }
      }
      // Mixin options
      _.extend(this.options, options);

      // set content type and secondary content type based on each content item
      // this is useful when the collection reset its models
      contentType = this.get('contentType') ||
        (config.Type ? ContentType.Nouns(config.Type) : undefined);
      secondaryContentType = this.get('secondaryContentType') ||
        (config.SecondaryType ? ContentType.Nouns(config.SecondaryType) : undefined);
      this.set({
        contentType: contentType,
        secondaryContentType: secondaryContentType
      });

      // Trigger for lazyloading in contentMediaList template
      if (parent && parent.lazyLoad) {
        this.set('lazyLoad', parent.lazyLoad && !this.get('_isPreview'));
      }

      if (this.hasFeature('secondaryContentList')) {
        this.subscribe('previewsecondarycontent', this.previewSecondaryContent);
      }

      // additional check for ContentLocale was added to solve post-submission issue (see UIA-9338)
      canTranslate = ENVConfig.translatedReviews &&
        this.get('contentType') === 'Reviews' &&
        this.get('Text') !== null && !!this.get('ContentLocale');

      if (canTranslate) {
        // Reviews whose content are in a foreign language should get marked so
        // we can show the translation UI.
        mainLang = ENVConfig.locale.substring(0, 2);
        contentLang = this.get('ContentLocale').substring(0, 2);
        this.set('translatable', mainLang !== contentLang);

        // The language code to use when showing machine-translated text.
        // (see: https://cloud.google.com/translate/markup)
        this.set('translationLanguageCode', mainLang + '-x-mtfrom-' + contentLang);
      }
      else {
        this.set('translatable', false);
      }

      this._cleanAuthorData();
    },

    /**
     * Cleans up the author data a little bit.
     * - Warn if there's no author data already.
     * - If there's no author or the author profile is not approved by moderation,
     *   use the review nickname as this is moderated content.
     * - If the there is no author profile or review nickname, anonymize the user.
     * - Determine if we should show the profile link for this author.
     * - Set the updated author data to the model.
     */
    _cleanAuthorData: function _cleanAuthorData () {
      var author = this.get('Author');

      if (!author) {
        BVReporter.warn(
          'Content Item was initialized without Author data.',
          'Type:', this.get('Type'),
          'Id:', this.get('Id')
        );

        // We have to create a blank, anonymous author because other methods
        // don't protect against Author being undefined.
        author = {
          DisplayName: commonMessages.anonymous()
        };
      }

      // Default to NOT showing the profile link
      author.showProfileLink = false;

      // If there isn't a valid profile, use the UserNickname
      if (author.ModerationStatus !== 'APPROVED') {
        author.DisplayName = this.get('UserNickname') || commonMessages.anonymous();
      }

      // If the client has specifically removed this profile, anonymize it
      if (author.ModerationStatus === 'REMOVEDBYCLIENT') {
        author.DisplayName = commonMessages.anonymous();
      }

      // If the author is approved and the content isn't syndicated,
      // show the profile link.
      if (author.ModerationStatus === 'APPROVED' && !this.get('IsSyndicated')) {
        author.showProfileLink = true;
      }

      this.set('Author', author);
    },

    processData: function processData () {
      // PRR allows for two differnent video types.  Youtube videos and hosted
      // Videos (Brightcove hosted).  We only support youtube videoes at this
      // point so for upgrade clients who have data that contains Brightcove
      // hosted vidoes (VideoHost === "BAZAARVOICE") we need to filter
      // the data to only return youtube videoes.
      var youtubeVideos = _(this.get('Videos')).where({
        VideoHost: 'www.youtube.com'
      });
      this.set('Videos', youtubeVideos);
      return BModel.prototype.processData.call(this, this.toJSON());
    },

    index: function index () {
      var parent = this.get('parent');
      // if the parent is a collection return the index, else index is 0
      if (parent.indexOf) {
        return parent.indexOf(this);
      }
      return 0;
    },

    remove: function remove (options) {
      this.get('parent').remove(this, options);
    },

    findMediaById: function findMediaById (id, mediaType) {
      var media = this.get(mediaType);
      var currentMedia = _(media).find(function needle (m) {
        return (m.Id === id || m.VideoId === id);
      });
      return currentMedia;
    },

    toJSON: function toJSON () {
      var self = this;
      var json = BModel.prototype.toJSON.call(this);
      var syndicationBlacklist;
      var secondaryRatings = this.get('SecondaryRatings') || {};
      var contentTypeLower = ContentType.noun(this.get('contentType'));
      var referenceRatingsOrder;
      var allBadges;
      var parentItem;
      var isSyndicated;
      var syndicationSource;
      json.feedbackEnabled = ENV.get('config').feedbackEnabled;
      json.SecondaryRatingList = [];
      json.secondaryContentNotification = self.secondaryContentNotification;

      if (json.translationActive && json.translatedFields) {
        // When this flag is enabled, the user wants to see a machine
        // translation of the content instead of the original text, so we'll
        // swap that into the JSON.
        json.Text = json.translatedFields.ReviewText;
        json.Title = json.translatedFields.Title;
      }

      function getFeatureFor (badgeType) {
        switch (badgeType) {
          case 'user':
          case 'contributor':
            return 'userBadges';
          case 'content':
            return 'contentBadges';
          // otherwise, an undefined return value is as good a default as we have
        }
      }

      // For reviews, determine if the reference/subject has secondary ratings
      if (contentTypeLower === 'review') {
        referenceRatingsOrder = lookup(
          json,
          'Reference.Content.Reviews.Statistics.SecondaryRatingsAveragesOrder'
        ) || [];
        json._ReferenceHasSecondaryRatings = !!referenceRatingsOrder.length;
      }

      // Reviews and comments should display badges
      if (contentTypeLower === 'review' || contentTypeLower === 'comment') {
        // get the badges in display order
        allBadges = getOrderedBadges(
          this.get('Badges'),
          this.get('Author'),
          this.get('BadgesOrder')
        );

        // Only use badges that have corresponding features enabled Important:
        // only the badge types that are whitelisted here will ever be
        // displayed for content items
        json.OrderedBadges = _(allBadges).filter(function f (badge) {
          var feature = getFeatureFor(badge.badgeType);
          return !_.isUndefined(feature) && self.hasFeature(feature);
        });
      }
      else {
        json.OrderedBadges = [];
      }

      // UIA-5800: Populate SecondaryRatingsList items with data from config
      _(secondaryRatings).each(function forEachRating (rating) {
        var labels = configFieldInfo.getLabelsObject('rating', rating.Id, { value: rating.Value });
        var type = configFieldInfo.getFieldType('rating', rating.Id);

        _.extend(secondaryRatings[rating.Id], labels, type);
      });

      _(this.get('SecondaryRatingsOrder')).forEach(function forEachRating (key) {
        var dimsumRating;

        if (_(referenceRatingsOrder).indexOf(key) === -1) {
          // only include secondary ratings that are active; only active ones will be in the stats
          return;
        }

        dimsumRating = dimsumFields && dimsumFields.rating && dimsumFields.rating[key];
        if (dimsumRating) {
          _(secondaryRatings[key]).extend({
            HideDisplay: dimsumRating.hideDisplay
          });
        }
        json.SecondaryRatingList.push(secondaryRatings[key]);
      });

      json.Pros =
        (json.TagDimensions && json.TagDimensions.Pro && !dimsumHiddenFieldKeys.Pro) ?
          json.TagDimensions.Pro.Values :
          null;
      json.Cons =
        (json.TagDimensions && json.TagDimensions.Con && !dimsumHiddenFieldKeys.Con) ?
          json.TagDimensions.Con.Values :
          null;

      json.TagDimensionsList = _(this.get('TagDimensions'))
        .chain()
        .filter(function f (dimension) {
          var id = dimension.Id;
          var tag;
          var fieldIsHidden;

          if (id === 'Pro' || id === 'Con') {
            return false;
          }

          tag = dimsumFields.tag[id];
          if (tag) { return !tag.hideDisplay; }

          fieldIsHidden = dimsumHiddenFieldKeys[id];
          if (fieldIsHidden) {
            return false;
          }

          return true;
        })
        .map(function m (tag) {
          var tagId = tag.Id;
          var label;

          if (!tagId) {
            return tag;
          }

          label = configFieldInfo.getLabel('tag', tagId);
          if (label) {
            tag.Label = label;
          }

          return tag;
        })
        .value();

      // Build a list of Ordered Product Questions made of of ContextDataValues
      // and AdditionalFields. We always display ContextDataValues before
      // AdditionalFields and the order of the fields within the lists of CDVs
      // and AdditionalQuestions is determined by the API
      // (ContextDataValuesOrder / AdditionalFieldsOrder)
      if (json.AdditionalFields) {
        json.AdditionalFieldsOrdered = _(json.AdditionalFieldsOrder).map(function m (fieldId) {
          return json.AdditionalFields[fieldId];
        });
      }
      // Remove any "People" questions from the Review CDV data, so we don't
      // display people questions in the review and in the Profile.
      if (json.ContextDataValuesOrdered && dimsumFieldCategoryMap.fieldCategoryMap) {
        json.ContextDataValuesOrdered = _(json.ContextDataValuesOrdered).filter(function f (cdv) {
          return (
            dimsumFieldCategoryMap.fieldCategoryMap['contextdatavalue_' + cdv.Id] === 'product'
          );
        });
      }
      _(['ContextDataValues', 'AdditionalFields']).forEach(function f (productQuestionsKey) {
        var productQuestions = json[productQuestionsKey + 'Ordered'];
        var questionsOrdered;

        if (!productQuestions) {
          return;
        }
        questionsOrdered = _(productQuestions)
          .chain()
          .map(function m (question) {
            var field;
            var label;
            var value;
            // Look up the each field individually. If we couldn't find our
            // field, return false so that we can recover in the filter later.
            // No need to explicitly report error, as configFieldInfo will do
            // so.
            field = configFieldInfo.getField(productQuestionsKey, question.Id);
            if (!field) { return false; }

            // Get our label, again returning false if not found for recovery later.
            label = configFieldInfo.getLabel(field);
            if (!label) { return false; }

            // Unlike field and label, since some fields may be free-form text,
            // `getValueLabels` may not find a value,
            // so we'll just fall back to the value, as is appropriate.
            value = configFieldInfo.getValueLabels(field)[question.Value] || question.Value;

            return {
              Id: question.Id,
              Label: label,
              Value: value
            };
          })
          .filter(function ff (field) {
            // As we used `false` above, simply returning the field is a
            // sufficient filter condition.
            return field;
          })
          .value();

        json[productQuestionsKey + 'Ordered'] = questionsOrdered;
      });
      json.ProductQuestionsList =
        (json.ContextDataValuesOrdered || [])
          .concat(json.AdditionalFieldsOrdered || []);
      json.currentSort = this.componentGet('currentSort') || null;
      json.clientName = ENV.get('config').clientDisplayName || ENV.get('config').clientname;

      if (
        json.IsSyndicated &&
        json.SyndicationSource &&
        json.SyndicationSource.Name
      ) {
        syndicationBlacklist = ENV.get('config').display.syndicationFilter;
        if (_(syndicationBlacklist).contains(json.SyndicationSource.Name)) {
          json.IsSyndicated = false;
        }
      }
      else if (json.parentContentItem && json.Type === 'clientresponse') {
        // If this content has a parent and this content is a client response
        // then check if this content is syndicated.  If so, use the correct client
        // name for syndicated client responses
        parentItem = json.parentContentItem;
        isSyndicated = parentItem.get('IsSyndicated');
        syndicationSource = parentItem.get('SyndicationSource');
        if (isSyndicated && syndicationSource && syndicationSource.Name) {
          json.clientName = syndicationSource.Name;
        }
      }

      // Our message pack needs to know the authorDisplayName but can't look
      // it up using Author.DisplayName.
      json.authorDisplayName = json.Author.DisplayName;

      // Likewise for submission time. We need to use the "ago" helper here
      // in code to capture it in a property.
      json.submissionTimeAgo = ago(json.SubmissionTime);

      // Add default captions for photos and videos to make screen readers more informative.
      _(['Photo', 'Video']).each(function fe (contentType) {
        _(json[contentType + 's']).each(function fet (item, index) {
          item.Caption = item.Caption || msgPack['contentItem_default' + contentType + 'Caption']({
            ContentType: contentTypeLower,
            ItemNumber: index + 1
          });
        });
      });

      return json;
    },

    previewSecondaryContent: function previewSecondaryContent (id, response) {
      if (this.get('Id') === id) {
        this.getFeatureModel('secondaryContentList').previewContent(response);
      }
    },

    /**
     * Return true if this content item has photos.
     * @return {Boolean}
     */
    hasPhoto: function hasPhoto () {
      return (this.get('Photos') && this.get('Photos').length) ||
        (this.get('Author') && this.get('Author')._avatarImage);
    },

    hasMedia: function hasMedia () {
      if (this.hasPhoto()) { return true; }
      return (this.get('Videos') && this.get('Videos').length);
    },

    translateContent: function translateContent () {
      var translationActive = this.get('translationActive');
      var translationPending = this.get('translationPending');
      var translatedFields = this.get('translatedFields');
      var contentId = this.get('Id');
      var dfd;

      if (translationPending) { return; }

      if (translationActive) {
        // Translation was already being shown; restore the original text.
        this.set({ translationActive: false });
      }
      else if (translatedFields) {
        // We need to show the translation, but we don't need to ask the API
        // because we have the result of previous attempt.
        this.set({ translationActive: true });
      }
      else {
        // We need to show the translation and we don't yet know what it is, so
        // we need to set the "pending" flag and ask the API.
        this.set({
          translationPending: true,
          translationFailed: false
        });

        dfd = TranslationApi.fetch(this.get('ReferenceId'), [contentId]);
        dfd.done(function done (json) {
          var translated = json.Results[contentId];
          this.set({
            translationActive: true,
            translationPending: false,
            translatedFields: translated
          });
        }.bind(this));

        // There are only a few ways that the translation request can fail;
        // we'll treat them all identically.
        dfd.fail(function fail () {
          this.set({
            translationPending: false,
            translationFailed: true
          });
        }.bind(this));
      }
    }

  });
});

BV.define('bv/api/util/statsRequest',[
  'ENV',
  'underscore',
  'bv/api/fetch',
  'framework/util/bvreporter'
], function (ENV, _, api, BVReporter) {

  return function (config, requestingComponent) {
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(function () { return [!_(config.subjectId).isUndefined(), 'config.subjectId is defined']; });

    var productsRequest = api.get(config.subjectType || 'products').limit(null).filterBy('id', config.subjectId);

    if (requestingComponent) {
      productsRequest._label(requestingComponent);
    }

    var statsTypes = config.statsTypes || ENV.get('config').statsTypes;

    BVReporter.assert(statsTypes && statsTypes.length, 'statsTypes is defined');

    _(statsTypes).forEach(function (coverType) {
      productsRequest = productsRequest.withStatsOn(api.Nouns(coverType));
    });

    return productsRequest;
  };

});

BV.define('bv/c2013/collection/contentItemCollection',[
  'framework/bcollection',
  'underscore',
  'bv/c2013/model/contentItem',
  'bv/api/fetch',
  'util/url',
  'ENV',
  'bv/api/util/statsRequest'
],
function (BCollection, _, ContentItem, api, url, ENV, statsRequest) {
  return BCollection.extend({
    model: ContentItem,
    name: 'contentItemCollection',
    statsTypes: ['Reviews', 'Questions'],

    init: function () {
      this._isReviews = api.nouns(this.contentType) === 'reviews';
    },

    /**
     * This is a temporary function to call content specific API calls (reviews.json) until
     * API team implements offset_<type> on products.json.
     * https://bits.bazaarvoice.com/jira/browse/DEVAPI-1231
     */
    createContentRequest: function (page, clientAPIConfig, filters) {
      var requestType = api.nouns(this.contentType);
      var config = ENV.get('config');
      var pageConfig = config.page.details[api.noun(requestType)] || config.page;
      var pageSize = pageConfig.size;
      var pageSize2n = pageConfig.size2n;

      var limit = page > 1 ? pageSize2n : pageSize;
      var offset = page > 1 ? pageSize + (pageSize2n * (page - 2)) : 0;

      var content = api.get(requestType)
        .include(['Authors', 'Products'])
        .withStatsOn(this.getStatsTypes())
        .limit(limit)
        .offset(offset);

      // Use the sort option if it has been set, otherwise use the default.
      if (_(this.parent.subModels).has('contentSort')) {
        var sort = this.parent.subModels.contentSort.lookup(this.parent.componentGet('currentSort'));
        sort = sort || this.parent.componentGet('defaultSort');

        if (sort) {
          // Set the primary sort.
          _(sort.primary).forEach(function (primarySort) {
            content.sortBy(primarySort[1], primarySort[0]);
          });

          // Set any secondary sorts.
          _(sort.secondary).chain().keys().forEach(function (contentType) {
            _(sort.secondary[contentType]).forEach(function (secondarySort) {
              content.get(contentType).sortBy(secondarySort[1], secondarySort[0]).end();
            });
          });
        }
      }

      // Add filters if present
      _(filters).forEach(function (filter) {
        _(filter.options).forEach(function (option) {
          if (option.get('enabled')) {
            content.filterBy(filter.get('id'), '=', option.get('id'));
          }
        });
      });

      if (requestType === 'reviews') {
        content.filterBy('IsRatingsOnly', '=', false);
      }

      // Secondary ContentType
      if (!_.isEmpty(this.secondaryContentType)) {
        var secondaryPageConfig = config.page.details[api.noun(this.secondaryContentType)] || config.page;
        var secondaryPageSize = secondaryPageConfig.size;
        content.include(this.secondaryContentType)
          .limitIncluded(this.secondaryContentType)
          .to(secondaryPageSize);
      }

      if (!_(clientAPIConfig.productId).isUndefined()) {
        this.subjectId = clientAPIConfig.productId;
        content = content.forProduct(clientAPIConfig.productId);
      }

      return content;
    },

    /**
     * Normalize the submission response (for preview)
     *
     * @param response : the API submission response object.
     */
    _normalizeSubmissionResponse: function (response) {
      var result;
      var contentData = api.normalize(
        { Results: [response] },
        { contentType: api.Nouns(response._contentType) }
      );
      if (contentData && contentData.Results && !_(contentData.Results).isEmpty()) {
        result = contentData.Results[0];
      }
      return result;
    },

    /**
     * Create a (review) ContentItem by adding needed properties.
     *
     * @param modelConfig : content item model attributes. (mostly from submission API response)
     */
    createContentItem: function (modelConfig) {
      var subject = this.parent.getSubject();
      var ratingRange;
      var model;

      modelConfig = this._normalizeSubmissionResponse(modelConfig);

      ratingRange = modelConfig.RatingRange;
      modelConfig.RatingRange = ratingRange.length === 1 ? (ratingRange[0] + 1) : (ratingRange[1] - ratingRange[0] + 1);
      modelConfig.parent = this;
      modelConfig._isPreview = true;

      return modelConfig;
    },

    _getChecksum: function () {
      var checksumKey = this.contentType;
      var parent = this.getParent();
      if (parent) {
        checksumKey += parent.get('TotalResults') || 0;
      }
      return checksumKey;
    },

    /**
     * Request page content from the dev api.
     *
     * @param page : The page number requested
     * @param clientAPIConfig : The client api configuration
     * @param filters : extra filters to apply to the request
     * @param loadMore : if true, load the page on top of any existing collection, instead of resetting
     */
    fetchPage: function (page, clientAPIConfig, filters, paginationControl) {
      var self = this;
      // TODO - this may need to handle category IDs eventually
      var subjectId = this.subjectId = clientAPIConfig.productId;
      var contentRequest = this.createContentRequest.apply(this, arguments);
      var hasFilters = filters && filters.length > 0;

      var apiRequests = [
        contentRequest,
        statsRequest({ subjectId: subjectId })
      ];

      var batchContent = api.get('batch', null, apiRequests);
      var checksumKey = this._getChecksum();

      batchContent.fetch('page', checksumKey).done(function (results) {
        // In this block, assume "local" to mean "with locales configured for
        // display" and "global" to mean "across all possible locales."
        var statsResults = _(results).where({ contentType: 'products' });
        var localProductData = statsResults[0];

        if (!localProductData) {
          localProductData = {
            contentType: 'products',
            data: {
              Results: [{
                Content: {},
                Type: 'product'
              }],
              TotalResults: 0
            }
          };
        }

        var contentData = _(results).findWhere({
          contentType: api.nouns(self.contentType)
        });

        var localSubject = localProductData.data.Results[0];
        var list = contentData.data.Results;

        localSubject.Content = localSubject.Content || {};
        if (!localSubject.Content[self.contentType]) {
          localSubject.Content[self.contentType] = { List: list };
        }
        else {
          localSubject.Content[self.contentType].List = list;
        }

        // CASE 1:
        //
        // We're looking at reviews without any filters (e.g., initial page
        // load) and we want to explain any discrepancy between the number of
        // reviews we claim in the PRS and the number of reviews we're
        // actually showing the user.
        //
        // Say there are 100 reviews, but 20 are ratings-only and 30 are from
        // other locales. We want to pretend we're paginating through 100
        // reviews, but when we get to the page with the 50th review we'll
        // want to include an explanation of why there are only 50:
        //
        // - 20 Ratings-Only Reviews
        // - 30 Reviews in Other Languages
        //
        // This way the user isn't annoyed that we promised them 100 reviews
        // and are inexplicably delivering only 50.
        //
        if (self._isReviews && !hasFilters) {
          var counts = self._generateReviewCounts(
            localProductData,
            contentData
          );

          // Keep references to both "TotalResults" (all reviews, globally)
          // and "LocalResults" (just the reviews that will be displayed).
          localSubject.Content[self.contentType].TotalResults = counts.globalCount;
          localSubject.Content[self.contentType].LocalResults = counts.localCount;

          // Update the contentList with both the global total and the local
          // total. We use both of them to make decisions about pagination.
          self.trigger('newglobalresulttotal', counts.globalCount);
          self.trigger('newresulttotal', counts.localCount);

          self.stats = counts;
        }
        // CASE 2:
        //
        // We're looking at questions (for which raw counts are not as
        // important) or comments/answers (secondary types for which global
        // counts don't really make sense)...
        //
        // ... OR we're looking at reviews with user-specified filtering.
        //
        // In these cases we want to accurately represent the number of
        // reviews we have. When a user applies their own filters, presumably
        // they don't get annoyed when there are fewer results than indicated
        // by the global review count, since they're the ones doing the
        // filtering.
        else {
          if (_(contentData.data.TotalResults).isNumber()) {
            self.totalResults = contentData.data.TotalResults;
            self.trigger('newglobalresulttotal', null);
            self.trigger('newresulttotal', contentData.data.TotalResults);
            localSubject.Content[self.contentType].TotalResults = contentData.data.TotalResults;
            localSubject.Content[self.contentType].LocalResults = contentData.data.TotalResults;
            // There might be stale stats. Reset them.
            self.stats = {};
          }
        }

        paginationControl = paginationControl || {};
        if (paginationControl.loadMore) {
          self.loadMore(list);
        }
        else {
          self.reset(list, { doNotScroll: paginationControl.doNotScroll });
        }

        // Trigger an event with the raw response data (useful for
        // initialization).
        self.publish('contentresponse', localProductData.data);
      });
    },

    _generateReviewCounts: function (localProductData, contentData) {
      var counts = {};

      var localSubject = localProductData.data.Results[0];
      var globalStats;
      var onlyShowDisplayedLocaleStatistics = ENV.get('config').statistics.onlyShowDisplayedLocaleStatistics;

      // If a client has selected to only display stats for specific locales,
      // we want to use the filtered stats.
      if (onlyShowDisplayedLocaleStatistics) {
        globalStats = localSubject.Content[this.contentType].FilteredStatistics;
      }
      else {
        globalStats = localSubject.Content[this.contentType].RawStatistics;
      }

      if (!globalStats) {
        // No reviews of any sort for this product, so no stats get returned.
        return {
          globalCount: 0,
          globalRatingsOnlyCount: 0,
          localCount: 0,
          localResults: 0,
          totalResults: 0,
          otherLocaleCount: 0
        };
      }

      // Total number of reviews, by the widest possible definition.
      counts.globalCount = globalStats.TotalCount;

      // Total reviews across all locales that are ratings-only (i.e., don't
      // have text).
      counts.globalRatingsOnlyCount = globalStats.RatingsOnlyCount;

      // Total number of reviews that match the content request we made. This
      // is the number of reviews that will actually be paginated through.
      counts.localCount = counts.localResults = contentData.data.TotalResults;
      counts.totalResults = counts.localResults;

      // Total number of reviews that have text across all locales.
      counts.globalNonRatingsOnlyCount = counts.globalCount - counts.globalRatingsOnlyCount;

      // Total number of reviews that have text but shouldn't be shown
      // because they're from locales not configured for display.
      counts.otherLocaleCount = counts.globalNonRatingsOnlyCount - counts.localCount;
      return counts;
    },

    /**
     * Search content based on keywords from the dev api.
     *
     * @param keyword : the keyward that the search request is based on
     * @param page : The page number requested
     * @param clientAPIConfig : The client api configuration
     * @param subject : the subject that the request is based on
     * @param coverageTypes : the content types that search request covers
     */
    searchContent: function (keyword, page, clientAPIConfig, subject, coverageTypes) {
      var self = this;
      BV.require(['secondary'], function (app) {
        _(self).extend(app.ContentItemCollectionExt.collection);
        self.searchContentExt(keyword, page, clientAPIConfig, subject, coverageTypes);
      });
    },

    /**
     * Request "relatedQuestions" after Review/Answer submission.
     *
     * @param submission : the submission content that the related questions request is based on
     * @param clientAPIConfig : The client api configuration
     * @param subject : the subject that the request is based on
     */
    requestRelated: function (submission, page, clientAPIConfig, subject) {
      var self = this;
      BV.require(['secondary'], function (app) {
        _(self).extend(app.ContentItemCollectionExt.collection);
        self.requestRelatedExt(submission, page, clientAPIConfig, subject);
      });
    },

    fetchPageFromAuthor: function (page, clientAPIConfig, subject) {
      var self = this;
      BV.require(['secondary'], function (app) {
        _(self).extend(app.ContentItemCollectionExt.collection);
        self.fetchPageFromAuthorExt(page, clientAPIConfig, subject);
      });
    },

    /**
     * Return true if this collection contains content items with photos.
     * @return {Boolean}
     */
    hasPhotos: function () {
      return _(this.models).some(function (model) {
        return model.hasPhoto();
      });
    },

    hasMedia: function () {
      return _(this.models).some(function (model) {
        return model.hasMedia();
      });
    }

  });
});

BV.define('bv/util/pageInfo',[
  'ENV',
  'bv/util/contentType',
  'underscore'
], function (ENV, ContentType, _) {
  function pageInfo (requestType, pageNum, resultCount, totalResults, fixedPageSize, simpleMode) {
    var config = ENV.get('config');
    var pageConfig = config.page.details[requestType] || config.page;
    var pageSize = pageConfig.size;
    var pageSize2n = pageConfig.size2n;

    if (fixedPageSize) {
      pageSize = fixedPageSize;
      pageSize2n = fixedPageSize;
      simpleMode = _(simpleMode).isUndefined() ? true : simpleMode;
    }

    return getPageInfo(requestType, pageNum, resultCount, totalResults, pageSize, pageSize2n, simpleMode);
  }

  function getPageInfo (requestType, pageNum, resultCount, totalResults, pageSize, pageSize2n, simpleMode) {
    var start = resultCount ? 1 : 0;
    var end = resultCount || 0;
    var total = Math.max(end, totalResults);

    var numPages = 1;
    if (totalResults > pageSize) {
      numPages += Math.ceil((totalResults - pageSize) / pageSize2n);
    }

    if (pageNum > 1 && start > 0) {
      start = pageSize + pageSize2n * (pageNum - 2) + 1;
      end = start + (resultCount - 1);
    }

    return {
      type: requestType,
      start: start,
      end: end,
      total: total,
      numPages: numPages,
      pageSize: pageNum > 1 ? pageSize2n : pageSize,
      orphanEnd: simpleMode ? (total === end && pageNum !== 1) : (start === end && pageNum !== 1),
      showPages: (numPages > 1 && total),
      currentPage: pageNum,
      lastPageSize: numPages > 1 ? ((totalResults - pageSize) - (pageSize2n * (numPages - 2))) : totalResults,
      simpleMode: simpleMode
    };
  }

  return pageInfo;
});

/**
 * @fileOverview Sets the PrimaryContent attribute on the subject object
 */
BV.define('bv/c2013/model/contentList/setPrimaryContent',[
  'ENV'
], function (ENV) {

  /**
   * @param {Object} subject - subject on which this method modifies PrimaryContent
   * @param {string} contentType - review, video, etc
   * @param {Object} api - reference to bv api
   * @returns {Object} subject - explicitly return the modified subject
   */
  return function (subject, contentType, api) {

    subject.PrimaryContent = subject.Content[contentType];

    if (!subject.PrimaryContent) {
      subject.PrimaryContent = {};
    }

    if (!subject.PrimaryContent.Statistics) {
      subject.PrimaryContent.Statistics = {
        TotalCount: 0,
        TotalSecondaryCount: 0,
        OverallRatingRange: ENV.get('config').submission.rating.range[1]
      };
    }

    if (!subject.PrimaryContent.Type) {
      subject.PrimaryContent.Type = api.noun(contentType);
    }

    return subject;
  };
});

/**
 * @fileOverview contentList model
 */
BV.define('bv/c2013/model/contentList',[
  'ENV',
  'jquery',
  'framework/bmodel',
  'util/url',
  'vendor/moment',
  'underscore',
  'bv/c2013/collection/contentItemCollection',
  'bv/util/pageInfo',
  'bv/api',
  'framework/util/featureHelper',
  'BV',
  'framework/util/bvreporter',
  'bv/c2013/model/contentList/setPrimaryContent'
],
function (
  ENV,
  $,
  BModel,
  url,
  moment,
  _,
  contentItemCollection,
  pageInfo,
  api,
  ftHelper,
  BV,
  BVReporter,
  setPrimaryContent
) {
  return BModel.extend({
    options: {},
    name: 'contentList',
    collectionFeatureName: 'contentItemCollection',

    /**
     * Typical init
     * Sets a sortDfd attribute
     * Subscribes to a handful of events
     * Only subscribes to the sortContent event if it has
     * the contentSort feature
     *
     * @param  {Object} config
     * @param  {Object} options
     */
    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);

      // Required to use this.setupContentSort, which must run
      // even if this doesn't have the contentSort feature
      this.set({
        sortDfd: $.Deferred()
      });

      this.subscribe({
        // Must run even if this doesn't have the contentSort feature
        // This will sort the content according to the default in the config
        setupcontentsort: this.setupContentSort,

        // listen for paging requests
        pageto: this.fetchPage,
        pageinfo: this._enforcePageBounds,

        // listen for filter requests
        filterresults: this.filterPage,

        // handle content/submission deep linking
        deeplink: this.deepLink,
        submission: this.submission,

        // listen for submission success requests
        previewcontent: this.previewContent,
        showhelpfulpositive: this.showHelpfulPositive,
        showhelpfulcritical: this.showHelpfulCritical,

        // listen for summary click that triggers outlet
        showinlightbox: this.showContentInLightbox
      });

      this.on('pageinfo', this._enforcePageBounds);

      if (this.hasFeature('contentSort')) {
        this.subscribe({
          sortcontent: this.sortContent
        });
      }
    },

    /**
     * Calls self.initialized at the appropriate time.
     * If we have a sortDfd attribute, wait for it to resolve before
     * calling self.initialized.
     * Otherwise, just call self.initialized immediately.
     * @param  {Object} self The object to call initialized on
     */
    initReady: function (self) {
      // We set sortDfd in `initialize`, but there are other models inheriting
      // this particular method while overriding `initialize`, so we can't
      // safely assume that we'll always have a sortDfd to work with
      var sortDfd = this.get('sortDfd');
      if (!sortDfd) {
        self.initialized();
      }
      else {
        sortDfd.done(function () {
          self.initialized();
        });
      }
    },

    showContentInLightbox: function () {
      if (this.getComponent().lightbox) {
        this.fetchPage(1);
      }
      else {
        BVReporter.warn('Did not find lightbox display configuration for ' + this.name);
      }
    },

    setupDataProcessing: function () {
      var contentCollection;

      // listen for the first data response from a content collection to detect
      // that data is ready or initData.
      this.subscribe('contentresponse', this.processData);

      contentCollection = this.getContent();
      if (!contentCollection) {
        return;
      }

      // Turn on lazyloading for initial contentCollection
      contentCollection.lazyLoad = true;
      this.listenTo(contentCollection, 'newresulttotal', function (newTotal) {
        this.set('TotalResults', newTotal);
      });
      this.listenTo(contentCollection, 'newglobalresulttotal', function (newTotal) {
        this.set('GlobalTotalResults', newTotal);
      });
    },

    /**
     * Prepare the model's data. Once complete, will resolve the dataProcessed dfd.
     * @param  {json} data normalized from the api
     */
    processData: function (data) {
      var contentType = this.get('contentType');

      // set reference
      var subject = _.clone(data.Results[0]);
      var totalResults;
      var localResults;
      var contentCollection;
      var myPageInfo;

      if (subject.Content) {

        subject = setPrimaryContent(subject, contentType, this.api);

        this.set('initData', subject.Content[contentType]);

        totalResults = subject.PrimaryContent.TotalResults;
        localResults = subject.PrimaryContent.LocalResults;

        // Set the TotalResults # to be the localized results count from the api.
        // If that doesn't exist (ex - in fullProfile's contentList),
        // just set this number to the totalResults from the api.
        this.set('TotalResults', _.isUndefined(localResults) ? totalResults : localResults);
      }
      else {
        this.set('initData', null);
        this.set('TotalResults', 0);
      }

      // Store initData in the ENV so decoupled features can use the data.
      this.componentSet('initData', this.get('initData'));

      this.set('subject', subject);

      // Now that we have data, ignore contentresponse events.
      this.unsubscribe('contentresponse', this.processData);

      contentCollection = this.getContent();
      if (!contentCollection) {
        return;
      }

      this.listenTo(contentCollection, {
        reset: this.contentChanged,
        loadmore: this.moreContentLoaded
      });

      myPageInfo = this.updatePageInfo(subject.Content[contentType].List);
      this.trigger('pageinfo', myPageInfo);

      this.dataReady(data);
    },

    getSubject: function () {
      // Eventually need to make this handle other types?
      return {
        type: 'product',
        id: this.get('clientAPIConfig').productId,
        contentType: this.get('contentType')
      };
    },

    /**
     * Returns an object with data for consumption by the view
     */
    toJSON: function () {
      var config = ENV.get('config');
      var clientAPIConfig = this.get('clientAPIConfig');
      // fixing lint error, 'raw' is defined but never used
      // var raw = BModel.prototype.toJSON.call(this);
      var initData = this.componentGet('initData');
      var res = !initData ? null : initData.List;
      var prod = this.get('subject');
      var result = { Product: prod };
      result[this.api.Nouns(this.get('contentType'))] = res;
      result.clientDisplayName = config.clientDisplayName || null;
      result.clientLogo = config.clientLogo || null;
      result.readOnly = this.readOnly;
      result.showBeFirstButton = !this.readOnly && this.hasFeature('writeReviews');
      result.siteAuthReviews = config.siteAuth.review;
      result.siteAuthLoggedIn = clientAPIConfig.userToken;
      result.date = moment().format('YYYY-MM-DD');
      return result;
    },

    /**
     * create pageInfo based on 'TotalResult', 'currentPage', and newContent length
     * @param newContent : content array reset the contentItemCollection.
     */
    updatePageInfo: function (newContent) {
      var myPageInfo;

      // Update pagination values to align with the new content.
      var currentPage = this.componentGet('currentPage') || 1;
      myPageInfo = pageInfo(
        this.api.noun(this.get('contentType')),
        currentPage,
        newContent.length,
        this.get('TotalResults')
      );

      // Put this information on the component so that we can read it for
      // stub content views.
      this.componentSet('numPages', myPageInfo.numPages);

      this.set({
        TotalResults: this.get('TotalResults'),
        numPages: myPageInfo.numPages,
        startResult: myPageInfo.start
      }, { silent: true });

      // We change this after the fact because we want pageInfo to make
      // decisions based on how many reviews we're going to _show_.
      //
      // If we have 100 global results, but 60 of them are ratings-only
      // reviews and another 30 are in locales not configured for display,
      // and we're showing 5 reviews per page, then we want pagination to
      // show 2 pages of reviews, not 20. But we still want the pagination
      // bar to say "1-5 of 200 Reviews."

      // Keep a reference to the true number of displayed reviews. (If it's
      // 0, for instance, we still want to omit the control bar.)
      myPageInfo.localTotal = myPageInfo.total;
      if (this.get('GlobalTotalResults')) {
        myPageInfo.total = this.get('GlobalTotalResults');
      }

      return myPageInfo;
    },

    _enforcePageBounds: function (pageBoundsInfo) {
      var self = this;
      // Once we get one API response, we know how many pages of data we
      // have, and any subsequent requests outside of those bounds are
      // ignored.
      //
      // But if we ask for an invalid page number early enough that the first
      // API response hasn't returned, we can end up in an out-of-bounds
      // situation. Check for it after the fact.
      var currentPage = pageBoundsInfo.currentPage;
      if (currentPage > pageBoundsInfo.numPages) {
        // Abort! Go to the last page and pretend this never happened.
        // If dataReady hasn't happened yet, the `fetchPage` call won't do
        // anything. So we wait until dataReady, make sure we're still on an
        // invalid page, and ask for the last page again.
        this.dataReadyPromise().done(function () {
          if (self.componentGet('currentPage') === currentPage) {
            self.fetchPage(pageBoundsInfo.numPages);
          }
        });
      }
    },

    /**
     * When the content collection has new data we need to notify our view that
     * there is new content to display and update pagination data
     * (if necessary).
     *
     * @param newContent The new content that has been loaded into our content
     *   collection.
     */
    contentChanged: function (newContent, options) {
      var myPageInfo;
      if (newContent) {
        // Notify interested parties that we have new content.
        this.trigger('change:content', newContent);
      }
      myPageInfo = this.updatePageInfo(newContent);
      this.trigger('pageinfo', myPageInfo, options);
    },

    moreContentLoaded: function (collection, contentLoaded) {
      var newPaginationValues;

      // Update pagination values to align with the new content.
      var currentPage = this.componentGet('currentPage');
      newPaginationValues = pageInfo(
        this.api.noun(this.get('contentType')),
        currentPage,
        contentLoaded.length,
        this.get('TotalResults')
      );

      // We change this after the fact because we want pageInfo to make
      // decisions based on how many reviews we're going to _show_.
      //
      // If we have 100 global results, but 60 of them are ratings-only
      // reviews and another 30 are in locales not configured for display,
      // and we're showing 5 reviews per page, then we want pagination to
      // show 2 pages of reviews, not 20. But we still want the pagination
      // bar to say "1-5 of 200 Reviews."

      // Keep a reference to the true number of displayed reviews. (If it's
      // 0, for instance, we still want to omit the control bar.)
      newPaginationValues.localTotal = newPaginationValues.total;
      if (this.get('GlobalTotalResults')) {
        newPaginationValues.total = this.get('GlobalTotalResults');
      }

      // Change the page info to always have the initial start value for "Load More".
      newPaginationValues.start = this.get('startResult');
      newPaginationValues.loadMore = true;
      this.trigger('pageinfo', newPaginationValues);
    },

    _matchesContentType: function (type) {
      var contentType = this.get('contentType');
      var secondaryContentType = this.get('secondaryContentType');

      try {
        type = api.Nouns(type);
      }
      catch (err) {
        // Unknown content type. Can't possibly match.
        BVReporter.warn('ContentList with contentType', contentType, "didn't recognize content type on deep link:", type);
        return false;
      }

      if (contentType && type === api.Nouns(contentType)) {
        return true;
      }

      if (secondaryContentType && type === api.Nouns(secondaryContentType)) {
        return true;
      }

      // This deep link is meant for a different content list.
      BVReporter.warn('ContentList with contentType', contentType, "didn't respond to content type on deep link:", type);
      return false;
    },

    deepLink: function (content) {
      var pid;
      var self = this;
      var bvType;

      // Bail if our contentType doesn't match the contentType of the deepLink.
      if (!this._matchesContentType(content.contentType)) {
        return;
      }

      pid = this.get('clientAPIConfig').productId;

      bvType = (
        url.getParam(window.location.href, 'bvmessageType') ||
        url.getBvParam(window.location.href, 'messageType')
      );

      BV.require(['secondary', 'bv/c2013/model/contentItem', 'bv/c2013/view/contentItem'],
        function (app, ContentItemModel, ContentItemView) {
          var baseUrl = url.protocol + ENV.get('config').apiconfig.baseUrl;
          var linkType = content.contentType;
          var contentType = self.get('contentType');
          var secondaryContentType = self.get('secondaryContentType');
          var includeTypes = ['Products', 'Authors'];
          var apiHolder;

          // Replacing 'comment' type with 'reviewcomment' to receive correct typePair and use 'reviewcomments.json' call instead of 'reviews.json'. See UIA-8297
          if (linkType === 'comment') {
            linkType = 'reviewcomment';
          }

          if (secondaryContentType && api.Nouns(linkType) === api.Nouns(contentType)) {
            includeTypes.push(api.Nouns(secondaryContentType));
          }
          else if (contentType && api.Nouns(linkType) === api.Nouns(secondaryContentType)) {
            includeTypes.push(api.Nouns(contentType));
          }

          // TODO - it'd be cool if we could use content.contentType here.
          // Update api.js to support.
          apiHolder = api.get(api.nouns(linkType))
            .include(includeTypes)
            .withStatsOn(api.Nouns(linkType))
            .withBaseUrl(baseUrl);

          function deepLinkShow (data) {
            var model;
            var contentView;
            var modelConfig;
            data = data.data;

            if (data.Results && data.Results.length) {
              modelConfig = _(data.Results[0]).extend({
                parent: self
              });

              model = new ContentItemModel(modelConfig);
              contentView = new ContentItemView({
                model: model,
                config: model
              });
              // Hide comment or answer button if this is 'REVIEW_COMMENTED' or
              // 'ANSWER_APPROVED' notification. See CCS-31846 and CCS-32402.
              if (bvType === 'REVIEW_COMMENTED' || bvType === 'ANSWER_APPROVED') {
                contentView.model.secondaryContentNotification = true;
              }

              app.Deeplink.lightbox(contentView);
            }
          }

          if (!_(pid).isUndefined()) {
            apiHolder = apiHolder.forProduct(pid).filterBy('id', '=', content.id);

            if (bvType !== null) {
              if (bvType.indexOf('CONFIRMATION') === -1) {
                apiHolder.fetch('deeplink').done(deepLinkShow);
              }
            }
            else {
              apiHolder.fetch('deeplink').done(deepLinkShow);
            }
          }
        }
      );
    },

    submission: function (config) {
      var clientAPIConfig = this.get('clientAPIConfig');
      config = $.extend({}, clientAPIConfig, {
        campaignId: config.campaignId || clientAPIConfig.campaignId || ''
      });

      // Wait for DOM ready to inject submission.
      this.trigger('showsubmission', config);
    },

    _initContent: function () {
      var content = {};
      var contentCollection = this.getFeatureModels(this.collectionFeatureName) || this.getFeatureModels(ftHelper.getFullName(this.collectionFeatureName));

      if (contentCollection && contentItemCollection) {
        _(contentCollection).forEach(function (collection) {
          content[collection.contentType] = collection;
        });

        this.set({ content: content }, { silent: true });
        return content;
      }

      return null;
    },

    _getContent: function () {
      return this.get('content') || this._initContent();
    },

    getContent: function () {
      var contentType = this.get('contentType');
      var content = this._getContent();
      return _(content).isEmpty() ? null : content[contentType];
    },

    /**
     * Tell our content collection to fetch new content from the server.
     *
     * @param {Number}  pageNum The page of data to fetch.
     * @param {Boolean} force   Force the page to fetch even if we are already
     *   on the requested page.
     */
    fetchPage: function (pageNum, force, paginationControl) {
      var filters = this.get('activeFilters');
      var self = this;
      var contentCollection;
      var sortDfd;

      if (_(pageNum).isObject() && (_(pageNum.pageNum).isNumber() || _(pageNum.pageNum).isString())) {
        pageNum = parseInt(pageNum.pageNum, 10);
      }

      contentCollection = this.getContent();

      // Turn off lazy loading for subsequent pages.
      contentCollection.lazyLoad = pageNum === 1;

      // Do nothing if the pageNum is invalid (possible if it came
      // from the url).
      if (!force && (/* pageNum === ENV.get('currentPage') || */pageNum < 1 || pageNum > this.get('numPages'))) {
        return;
      }

      this.componentSet('currentPage', pageNum);

      // If we haven't processed data, but there is initial data, there is no
      // reason to fetch data again.
      if (this.dataReadyPromise().state() !== 'resolved' && this.componentGet('initData')) {
        return;
      }

      function collectionFetchPage () {
        contentCollection.fetchPage(pageNum, self.get('clientAPIConfig'), filters, paginationControl);
      }

      // If contentSort is enabled, we want to ensure that sorting has been
      // initialized before potentially making an API request.
      sortDfd = this.get('sortDfd');
      if (!sortDfd) {
        collectionFetchPage();
      }
      else {
        this.get('sortDfd').done(function () {
          collectionFetchPage();
        });
      }
    },

    filterPage: function (filters) {
      // Always return to page 1 on a filter.
      this.set('activeFilters', filters);
      this.fetchPage(1, true);
    },

    previewContent: function (response) {
      var contentCollection = this.getContent();
      var previewContent;
      if (!contentCollection) {
        return;
      }

      previewContent = contentCollection.createContentItem(response);
      contentCollection.add(previewContent, { isPreview: true });
    },

    /**
     * Sets up the basic needs of the sort feature.
     * Makes sure we have a contentSort set.
     * Makes sure the component has the defaultSort and currentSort
     * attributes set.
     * Resolves the sortDfd attribute.
     * @param  {Object} sortModel The contentSort model to assign to this model
     */
    setupContentSort: function (sortModel) {
      // TODO: Investigate this. It may be necessary, but it's a complication
      // that makes it harder to reason about components and models.
      this.subModels.contentSort = sortModel;

      this.componentSet({
        defaultSort: sortModel.get('defaultSort'),
        currentSort: sortModel.get('currentSort')
      });
      this.get('sortDfd').resolve(this);
    },

    sortContent: function (sortVal) {
      this.componentSet('currentSort', sortVal);
      this.fetchPage(1, true, { doNotScroll: true });
    },

    showHelpfulPositive: function () {
      this.onDataProcessed(function () {
        if (this.hasFeature('contentSort')) {
          this.subModels.contentSort.set('currentSort', 'mostHelpful');
        }

        this.componentSet('currentSort', 'mostHelpful');
        this.publish('filtercontent', 'Rating', [4, 5], false, { replace: true });
      }, this);
    },

    showHelpfulCritical: function () {
      this.onDataProcessed(function () {
        if (this.hasFeature('contentSort')) {
          this.subModels.contentSort.set('currentSort', 'mostHelpful');
        }

        this.componentSet('currentSort', 'mostHelpful');
        this.publish('filtercontent', 'Rating', [1, 2, 3], false, { replace: true });
      }, this);
    }
  });
});

BV.define('bv/c2013/model/profileContentList',[
  'ENV',
  'framework/bmodel',
  'bv/c2013/model/contentList',
  'underscore'
], function (ENV, BModel, BaseModel, _) {

  return BaseModel.extend({

    name: 'profileContentList',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);

      // listen for paging requests
      this.subscribe('pageto', this.fetchPage);

      this.subscribe('submission', this.submission);

      // listen for submission success requests
      this.subscribe('previewcontent', this.previewContent);
    },

    setupDataProcessing: function () {
      var contentCollection = this.getContent();
      if (!contentCollection) {
        return;
      }

      this.listenTo(contentCollection, 'newresulttotal', function (newTotal) {
        this.set('TotalResults', newTotal);
      });
    },

    fetchPage: function (pageNum, force, paginationControl) {
      var contentCollection = this.getContent();
      var author = this.get('subject');

      this.componentSet('currentPage', pageNum);

      var subject = {
        Type: this.get('subjectType'),
        Id: author ? author.Id : undefined
      };

      contentCollection.fetchPageFromAuthor(pageNum, this.get('clientAPIConfig'), subject);
    }

  });

});

/* START_TEMPLATE */
BV.define('hbs!prsTotalCountAggregate',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <a href=\"#\" class=\"bv-rating-label bv-text-link bv-focusable\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "stars_TotalContentCountAggregate", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "stars_TotalContentCountAggregate", depth1.msgpack, depth0, options)))
    + " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_prsNumberOfReviews", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_prsNumberOfReviews", depth0.msgpack, depth0, options)))
    + "</span> </a> ";
  return buffer;
  }

  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('prsTotalCountAggregate', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/ensureProtocolRelative',['vendor/handlebars/runtime'], function (Handlebars) {
  function ensureProtocolRelative (url) {
    return (url || '').replace(/^http(s)?:\/\//, '//');
  }

  Handlebars.registerHelper('ensureProtocolRelative', ensureProtocolRelative);
  return ensureProtocolRelative;
});

/* START_TEMPLATE */
BV.define('hbs!clientLogo',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/ensureProtocolRelative'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-client-logo-container bv-hidden\"> <span class=\"bv-client-logo-label\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "logoSource", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "logoSource", depth0.msgpack, depth0, options)))
    + " </span> <img src=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, depth0.clientLogo, options) : helperMissing.call(depth0, "ensureProtocolRelative", depth0.clientLogo, options)))
    + "\" alt=\"";
  if (stack2 = helpers.clientDisplayName) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.clientDisplayName; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"/> </div> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.clientLogo, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('clientLogo', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!writeReview',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.siteAuthLoggedIn, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-off-screen\">. ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-off-screen\">. ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_writeReviewSiteAuthModalNotice", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_writeReviewSiteAuthModalNotice", depth0.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  }

  buffer += "<div class=\"bv-write-review-container bv-write-container\"> <button type=\"button\" class=\"bv-write-review bv-focusable bv-submission-button\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "writeReview", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "writeReview", depth0.msgpack, depth0, options)))
    + " ";
  stack2 = helpers['if'].call(depth0, depth0.siteAuthReviews, {hash:{},inverse:self.program(2, program2, data),fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> </div> ";
  return buffer;
  });
Handlebars.registerPartial('writeReview', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!askQuestion',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"bv-ask-question-container bv-write-container\"> <button type=\"button\" class=\"bv-ask-question bv-focusable bv-submission-button\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "askQuestion", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "askQuestion", depth0.msgpack, depth0, options)))
    + " </button> </div> ";
  return buffer;
  });
Handlebars.registerPartial('askQuestion', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!actionBar',['hbs','vendor/handlebars/runtime','hbs!clientLogo', 'hbs!writeReview', 'hbs!askQuestion', 'template/helpers/mountView', 'template/helpers/withIf', 'template/helpers/extmsg', 'template/helpers/ifHasFeature', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <h2 class=\"bv-action-bar-header\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "actionBarHeader_v2", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "actionBarHeader_v2", depth1.msgpack, depth0, options)))
    + "</h2> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.clientLogo, 'clientLogo', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.writeReview, 'writeReview', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), {hash:{},inverse:self.noop,fn:self.program(10, program10, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "question", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "question", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.askQuestion, 'askQuestion', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-action-bar\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentSearch", depth0, options) : helperMissing.call(depth0, "mountView", "contentSearch", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent), options) : helperMissing.call(depth0, "withIf", ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "clientLogo", options) : helperMissing.call(depth0, "ifHasFeature", "clientLogo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "writeReviews", options) : helperMissing.call(depth0, "ifHasFeature", "writeReviews", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "askQuestions", options) : helperMissing.call(depth0, "ifHasFeature", "askQuestions", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('actionBar', t);
t.deps = ["clientLogo","writeReview","askQuestion"];
t.tplMountedViews = ['contentSearch'];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!inlineFormContainer',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  


  return "<div class=\"bv-inline-form-container\"></div>";
  });
Handlebars.registerPartial('inlineFormContainer', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_noReviewsYet', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function noReviewsYet( data ) {
try { return (function(d){
var r = "";
r += "No reviews have been submitted yet.";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `noReviewsYet`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_noReviewsYet', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return noReviewsYet(data);
});
return noReviewsYet;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!noReviewsYet',['hbs','vendor/handlebars/runtime', '_i18n_noReviewsYet'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing;


  buffer += "<span class=\"bv-content-noreviews-label\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_noReviewsYet),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_noReviewsYet", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  });
Handlebars.registerPartial('noReviewsYet', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_firstToWriteReview', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function firstToWriteReview( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Be the first to review this product";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `firstToWriteReview`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_firstToWriteReview', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return firstToWriteReview(data);
});
return firstToWriteReview;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!firstToWriteReview',['hbs','vendor/handlebars/runtime', '_i18n_firstToWriteReview'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing;


  buffer += " <button class=\"bv-write-review-label bv-text-link bv-focusable bv-submission-button\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_firstToWriteReview),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_firstToWriteReview", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> ";
  return buffer;
  });
Handlebars.registerPartial('firstToWriteReview', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_firstToAskQuestion', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function firstToAskQuestion( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Be the first to ask a question";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `firstToAskQuestion`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_firstToAskQuestion', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return firstToAskQuestion(data);
});
return firstToAskQuestion;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!firstToAskQuestion',['hbs','vendor/handlebars/runtime', '_i18n_firstToAskQuestion'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing;


  buffer += " <button class=\"bv-ask-question-label bv-text-link bv-focusable bv-submission-button\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_firstToAskQuestion),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_firstToAskQuestion", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> ";
  return buffer;
  });
Handlebars.registerPartial('firstToAskQuestion', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/loop',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {
  function loop (element, context) {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];
    var result = '';
    var values = [];

    if (Handlebars.Utils.isEmpty(element)) {
      return options.inverse(context);
    }

    if (!_(element.range).isEmpty()) {
      var last = _(element.range).last();
      var first = _(element.range).first();
      first = (first === last) ? 0 : first;
      while (first <= last) {
        values.push(first);
        first++;
      }
    }
    else if (_(element).isObject()) {
      values = element.values;
    }
    else {
      _(element).times(function (n) {
        values.push(n + 1);
      });
    }

    _(values).forEach(function (val, index) {
      var data = {
        value: val,
        total: values.length
      };
      if (context && context.schema) {
        var groupId = context.schema.Id.split('_')[0];
        var msgpackId = [groupId, val].join('_');
        if (context.schema.Type === 'SelectInput') {
          groupId = context.schema.Id;
          msgpackId = [groupId, 'valueLabel' + val].join('_');
        }
        _(data).extend({
          id: context.schema.Id,
          msgpackId: msgpackId,
          groupId: groupId
        });
      }

      if (!Handlebars.Utils.isEmpty(element.labels)) {
        data.label = element.labels[index];
      }
      result += options.fn(data);
    });
    return result;
  }

  Handlebars.registerHelper('loop', loop);
  return loop;
});

/*
 Example usage.
-----------------------------
{{#loop 10 .}}

  {{value}} {{id}} {{msgpackId}}

{{/loop}}
*/
;
BV.define('template/helpers/ratingIconChar',['vendor/handlebars/runtime', 'ratingIconCharMap!'], function (Handlebars, charMap) {

  function ratingIconChar (iconName) {
    var charToUse = charMap[iconName] || '9733';
    return new Handlebars.SafeString('&#' + charToUse + ';');
  }

  Handlebars.registerHelper('ratingIconChar', ratingIconChar);
  return ratingIconChar;
});

/* START_TEMPLATE */
BV.define('hbs!contentPlaceholder',['hbs','vendor/handlebars/runtime','hbs!noReviewsYet', 'hbs!firstToWriteReview', 'hbs!firstToAskQuestion', 'template/helpers/equals', 'template/helpers/renderIcon', 'template/helpers/loop', 'template/helpers/ratingIconChar', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-rating-stars-container bv-rating-none\" aria-readonly=\"true\"> ";
  options = {hash:{
    'classList': ("bv-rating-stars bv-rating-stars-off"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-prs-rating-stars-off", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-prs-rating-stars-off", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_stars_no_rating", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_stars_no_rating", depth1.msgpack, depth0, options)))
    + "</span> </span> ";
  options = {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.showBeFirstButton, false, options) : helperMissing.call(depth0, "equals", depth0.showBeFirstButton, false, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.OverallRatingRange), depth0, options) : helperMissing.call(depth0, "loop", ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.OverallRatingRange), depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var stack1, options;
  options = {hash:{}};
  return escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "rating-stars-on", options)));
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.noReviewsYet, 'noReviewsYet', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.firstToWriteReview, 'firstToWriteReview', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.firstToAskQuestion, 'firstToAskQuestion', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-placeholder\"> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "question", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "question", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentPlaceholder', t);
t.deps = ["noReviewsYet","firstToWriteReview","firstToAskQuestion"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/fixedNumber',['vendor/handlebars/runtime'], function (Handlebars) {

  // Formats a number for display to the given number of decimal places.
  //
  // EXAMPLES:
  //
  // (given data: { pi: 3.1415926 })
  //
  // {{fixedNumber pi}}      outputs "3"
  // {{fixedNumber pi 3}}    outputs "3.141"
  // {{fixedNumber blerg 3}} outputs ""
  //
  function fixedNumber (value, decimal_places) {
    return value ? value.toFixed(decimal_places) : '';
  }

  Handlebars.registerHelper('fixedNumber', fixedNumber);
  return fixedNumber;
});

BV.define('template/helpers/compare',['vendor/handlebars/runtime'], function (Handlebars) {

  function compare () {
    var args = [].slice.call(arguments);
    var context = args[args.length - 1];
    var leftSide = args[0];
    var rightSide = args[2];
    var operator = args[1];
    var result = false;

    switch (operator) {
      case 'lt' :
        result = leftSide < rightSide;
        break;
      case 'lte' :
        result = leftSide <= rightSide;
        break;
      case 'eq' :
        result = leftSide === rightSide;
        break;
      case 'gt' :
        result = leftSide > rightSide;
        break;
      case 'gte' :
        result = leftSide >= rightSide;
        break;
      default :
        return context.inverse(this);
    }

    return result ? context.fn(this) : context.inverse(this);
  }

  Handlebars.registerHelper('compare', compare);
  return compare;
});

BV.define('template/helpers/ifHasSubview',['vendor/handlebars/runtime'], function (Handlebars) {
  function ifHasSubview () {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];

    var viewName = args[0];
    var data = args.length === 2 ? this : args[1];
    var i;
    var subView;
    if (data.viewList && data._subview) {
      for (i = 0; i < data.viewList.length; i++) {
        subView = data.viewList[i];
        if (subView.viewName === viewName) {
          return options.fn(data);
        }
      }
    }
    return options.inverse(data);
  }

  Handlebars.registerHelper('ifHasSubview', ifHasSubview);
  return ifHasSubview;
});

/* START_TEMPLATE */
BV.define('hbs!contentList',['hbs','vendor/handlebars/runtime','hbs!prsTotalCountAggregate', 'hbs!actionBar', 'hbs!inlineFormContainer', 'hbs!contentPlaceholder', 'template/helpers/view', 'template/helpers/notEqual', 'template/helpers/mountView', 'template/helpers/ifHasFeature', 'template/helpers/fixedNumber', 'template/helpers/equals', 'template/helpers/conditionalContainer', 'template/helpers/compare', 'template/helpers/ifHasSubview', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bv-scroll-spy bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bv-scroll-spy bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat bv-scroll-spy\" data-bv-target=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> <!--<![endif]--> <meta name=\"bvDateModified\" content=\"";
  if (stack2 = helpers.date) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.date; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <div class=\"bv-content-list-container\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-header\"> ";
  stack2 = self.invokePartial(partials.actionBar, 'actionBar', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), "review", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("section-summary")
  },inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(13, program13, data)};
  stack2 = ((stack1 = helpers.compare),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.LocalResults), "gt", 1, options) : helperMissing.call(depth0, "compare", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.LocalResults), "gt", 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  options = {hash:{},inverse:self.noop,fn:self.program(20, program20, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options) : helperMissing.call(depth0, "equals", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentFilter", options) : helperMissing.call(depth0, "mountView", "contentFilter", options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "inlineSubmission", options) : helperMissing.call(depth0, "ifHasFeature", "inlineSubmission", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "trustmarkIcon", depth0, options) : helperMissing.call(depth0, "mountView", "trustmarkIcon", depth0, options)))
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <div class=\"bv-stars-container\" itemprop=\"aggregateRating\" itemscope itemtype=\"http://schema.org/AggregateRating\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-rating-ratio-count\"> ";
  stack2 = self.invokePartial(partials.prsTotalCountAggregate, 'prsTotalCountAggregate', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <meta itemprop=\"ratingValue\" content=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.fixedNumber),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), 1, options) : helperMissing.call(depth0, "fixedNumber", ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), 1, options)))
    + "\"/> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.inlineFormContainer, 'inlineFormContainer', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("section-summary-table table-full-width"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("section-summary-inline flex-container-responsive")
  },inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "headToHead", depth0, options) : helperMissing.call(depth0, "mountView", "headToHead", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "tagDistributionSummary", depth0, options) : helperMissing.call(depth0, "mountView", "tagDistributionSummary", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.TotalReviewCount), {hash:{},inverse:self.noop,fn:self.program(11, program11, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "inlineHistogram", depth0, options) : helperMissing.call(depth0, "mountView", "inlineHistogram", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "secondaryRatingSummary", depth0, options) : helperMissing.call(depth0, "mountView", "secondaryRatingSummary", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-control-bar";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.ifHasSubview),stack1 ? stack1.call(depth0, "contentFilterButton", options) : helperMissing.call(depth0, "ifHasSubview", "contentFilterButton", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount", depth0, options) : helperMissing.call(depth0, "mountView", "ugcCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(16, program16, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "relevancyLink", options) : helperMissing.call(depth0, "ifHasFeature", "relevancyLink", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "contentSort", options) : helperMissing.call(depth0, "ifHasFeature", "contentSort", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentFilterButton", options) : helperMissing.call(depth0, "mountView", "contentFilterButton", options)))
    + " </div> ";
  return buffer;
  }
function program14(depth0,data) {
  
  
  return " bv-control-bar-filter-offset";
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "relevancyLink", depth0, options) : helperMissing.call(depth0, "mountView", "relevancyLink", depth0, options)))
    + " ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentSort", depth0, options) : helperMissing.call(depth0, "mountView", "contentSort", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentPlaceholder, 'contentPlaceholder', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += " <div class=\"bv-cleanslate bv-cv2-cleanslate\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared"),
    'dataProductId': (true)
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentList', t);
t.deps = ["prsTotalCountAggregate","actionBar","inlineFormContainer","contentPlaceholder"];
t.tplMountedViews = ['trustmarkIcon','inlineHistogram','secondaryRatingSummary','headToHead','tagDistributionSummary','ugcCount','relevancyLink','contentSort','contentFilterButton','contentFilter'];
return t;
});
/* END_TEMPLATE */
;
BV.define('util/viewport',['window', 'jquery'], function (window, $) {

  return {
    /**
     * Adapted from:
     * author Remy Sharp
     * url http://remysharp.com/2009/01/26/element-in-view-event-plugin/
     */
    height : function () {
      // Safari, Opera
      var height = window.innerHeight;
      var mode = document.compatMode;

      // IE, Gecko
      if ((mode || !$.support.boxModel)) {
        height = (mode === 'CSS1Compat') ?
          // Standards
          document.documentElement.clientHeight :
          // Quirks
          document.body.clientHeight;
      }

      return height;
    },

    /**
     * Get the viewport's scrollTop position. The vertical scroll position is
     * the same as the number of pixels that are hidden from view above the
     * scrollable area.
     *
     * @returns {Number} viewport's scrollTop position.
     */
    scrollTop : function () {
      return (document.documentElement.scrollTop ?
        document.documentElement.scrollTop :
        document.body.scrollTop);
    },

    /**
     * Determine if an element is visible within the viewport.
     *
     * @returns {Boolean} true if the element is visible within the viewport.
     */
    visible : function (el) {
      var vpH = this.height();
      var scrolltop = this.scrollTop();
      var $el = $(el);
      var top = $el.offset().top;
      var height = $el.height();
      return !(scrolltop > (top + height) || scrolltop + vpH < top);
    }
  };

});

/*
 * BV Local configuration and validation
 */

BV.define('bv/util/bvLocal',[
  'underscore',
  'ENV',
  'jquery',
  'util/lookup',
  'BV'
], function (_, ENV, $, lookup, BV) {

  // The BV Local config object. We fall back to an empty object because some
  // QA customers are not configured to have this, and this causes their builds
  // to fail.
  var bvLocalConfig = lookup(ENV.get('config'), 'bvLocal') || {};

  // Compare the raw attributes property of a product response with an array of required attributes.
  var hasAllAttributes = function (attributes, required) {
    var matched = _(attributes)
      .chain()
      .pluck('Value')
      .intersection(required)
      .value();

    return matched.length === required.length;
  };

  var bvLocal = {
    config: bvLocalConfig,

    /**
     * Verify a node's status via the raw products API response provided by the
     * data extension.
     *
     * @returns {Boolean} True if the node is active; false if the node is inactive.
     *
     */
    verifyNode: function (rawData) {
      var results = lookup(rawData, 'results.Results');

      // If there is no results array, get out of here.
      if (!_.isArray(results)) {
        return true;
      }

      var mustMatch = [
        'BV_LOCAL', // 'BV_LOCAL' indicates this node exists in the client's Local Provider feed
        'BV_LOCAL_INACTIVE' // 'BV_LOCAL_INACTIVE' indicates this node has been disabled in the BV Local Provider feed.
      ];

      // If the product contains all the matching attributes, set the `nodeDisabled` flag.
      var matchesDisabled = hasAllAttributes(lookup(results[0], 'Attributes.BV_SUBJECT_TYPE.Values'), mustMatch);

      bvLocalConfig.nodeDisabled = !!matchesDisabled;

      return !bvLocalConfig.nodeDisabled;
    },

    /**
     * Indicates whether the node is disabled.
     *
     * @returns {Boolean} true if node is disabled
     */
    isDisabledNode: function () {
      return bvLocalConfig.enabled && bvLocalConfig.isLocalNode && bvLocalConfig.nodeDisabled;
    },

    /**
     * Indicates whether we are in BV Local land.
     *
     * @return {Boolean} true if we are displaying for BV Local
     */
    isBVLocal: function () {
      return bvLocalConfig.isLocalNode;
    },

    /**
     * Indicates whether firebird should render for this node.
     *
     * @return {Promise} A promise that will resolve with true if rendering should continue,
     * and will resolve with false if rendering should not continue.
     */
    shouldRender: function () {
      var dataExt = BV.extensions.data.get('bvapi');
      var dfd = $.Deferred();

      if (!bvLocalConfig.isLocalNode) {
        dfd.resolve(true);
      }
      else {
        dataExt.getLast('products').done(function (productData) {
          dfd.resolve(bvLocal.verifyNode(productData));
        });
      }

      return dfd.promise();
    },

    /**
     * Registers an image load handler for ClientLogo.
     * We are not guaranteed the logo image exists, so the logo container is
     * intitially hidden and shown upon the image load event.
     *
     * @param  {BView} view The container with a logo image in it
     * @return {undefined}
     */
    attachLogoHandler: function (view) {
      if (!this.isBVLocal() || !view) {
        return;
      }
      else {
        var $logoContainer = view.$el.find('.bv-client-logo-container');
        var handler = _.once(function (e) {
          $logoContainer.removeClass('bv-hidden');
        });

        var $logo = $logoContainer.find('img');
        $logo.on('load', handler);

        // Fire the load event for cached images
        // http://mikefowler.me/2014/04/22/cached-images-load-event/
        if ($logo[0].complete) {
          $logo.load();
        }
      }
    }

  };

  return bvLocal;
});

/**
 * @fileOverview Provide requestAnimationFrame or its polyfill
 */
BV.define('util/requestAnimFrame',['window'], function (window) {
  return window.BV.requestAnimationFrame;
});


/**
 *  @fileOverview View for contentList
 */
BV.define('bv/c2013/view/contentList',[
  'ENV',
  'framework/bview',
  'jquery',
  'underscore',
  'hbs!contentList',
  'mf!bv/c2013/messages/common',
  'util/viewport',
  'window',
  '$BV',
  'BV',
  'bv/util/contentType',
  'bv/util/focusManager',
  'bv/util/loadingOverlay',
  'bv/util/productInfo',
  'bv/util/bvLocal',
  'util/requestAnimFrame',
  'framework/util/bvtracker',
  'body'
],
function (ENV, BView, $, _, template, msgPackCommon, viewport, window, $BV, BV, ContentType, FocusManager, LoadingOverlay, ProductInfo, bvLocal, requestAnimFrame, BVTracker, body) {
  return BView.extend({
    name: 'contentList',
    events: {
      'click .bv-submission-button': 'loadSubmission',
      'hover .bv-shared': 'preloadSubmission',
      'click .bv-text-link': 'markLinkAsFakeVisited',
      'click .bv-rating-label': 'clickReviewCountAggregate'
    },

    clickReviewCountAggregate: function (e) {
      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'ReadReviews',
        detail2: 'Link',
        bvProduct: ProductInfo.RATINGSANDREVIEWS,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
      this.getTopModel().trigger('showreviews', e);
    },

    classList: ['core-container-' + BView.config.version],

    template: template,

    msgpacks: [msgPackCommon],

    init: function (init) {
      var self = this;
      this.$window = $(window);

      this.listenTo(this.model, 'submission', _(this.loadSubmission).bind(this));

      this.subscribe({
        scrolltocontent: this.scrollToContent,
        showinlightbox: this.launchContentInLightbox
      });

      this.model.subscribe('loadmedia', function () {
        self.loadAllMedia();
      });
    },

    _render: function () {
      if (this.model.get('pageview')) {
        this.triggerPageView();
      }
      // Empty out any existing items on reset.
      this.$el.find(this.selector()).find('.bv-content-list').empty();

      return BView.prototype._render.apply(this, arguments);
    },

    attach: function (elToAttach) {
      if (bvLocal.isBVLocal()) {
        bvLocal.attachLogoHandler(this);
      }

      BView.prototype.attach.apply(this, arguments);
      this.model.onDataReady(this.lazyLoad, this);
    },

    loadAllMedia: function () {
      var $el;
      // Load all media thumbnails on the page
      if (this.$viewEl) {
        $el = this.$viewEl.length ? this.$viewEl : this.$el;
        this.showImages($el.find('img'));
      }
    },

    lazyLoad: function () {
      var self = this;
      var $el;
      var $contentItemList;
      var $contentItems;
      var throttled;

      // Lazyloading should only happen the very first time reviews are
      // loaded. If we fail to lazyload, make sure that media orientation
      // is still properly handled.
      var contentCollection = this.model.getContent();
      if (!contentCollection.lazyLoad || !this.$window) {
        return this.loadAllMedia();
      }

      // No need to lazy load if there are no photos or videos.
      if (!contentCollection.hasMedia()) {
        return;
      }

      // Get a list of content items.
      $el = (this.$viewEl && this.$viewEl.length) ? this.$viewEl : this.$el;
      $contentItemList = $el.find('.bv-content-list');
      $contentItems = $contentItemList.find('.bv-content-top-' + ContentType.noun(this.contentType));

      throttled = _.throttle(function () {
        var done = self.loadContentItems($contentItems);

        if (!done) {
          requestAnimFrame(throttled);
        }
      }, 500);

      // Start polling the DOM to see if new content is visible.
      requestAnimFrame(throttled);
    },

    loadContentItems: function ($contentItems) {
      var self = this;
      var $notLoaded = $contentItems.not('.bv-content-loaded');

      if ($notLoaded.length === 0) {
        return true;
      }

      $notLoaded.each(function (index, element) {
        if (viewport.visible(element)) {
          self.showImages($(element).addClass('bv-content-loaded').find('img'));
        }
      });

      return false;
    },

    showImages: function ($media) {
      // Change the data-src property for each image into the src property
      // so that the images will actually load. We delay this to prevent
      // downloading any media we don't have to.
      $media.each(function (index, img) {
        var $img = $(img);
        $img.attr('src', $img.data('src'));
      });
    },

    _calculatePosition: function () {
      var $stickyHeader = $('#BVStickyHeader');
      var $activeFilters = $('.bv-active-filters');
      var viewportHeight = $(window).height();
      var scrollTop = this.$el.length > 0 ? this.$el.offset().top : 0;
      var offset = 0;
      var isFixed;
      var activeFiltersOffset;
      var pageBottomOffset;

      // If there's a sticky header, we need to scroll the offset to composite
      // the sticky header.
      if ($stickyHeader.length > 0) {
        isFixed = $stickyHeader.hasClass('bv-masthead-fixed');
        if (scrollTop > $stickyHeader.offset().top || isFixed) {
          offset = $stickyHeader.height();
        }
      }

      // If there are active filters, we want them to always appear
      // within viewport during scrolling.
      if ($activeFilters.length > 0 && !$activeFilters.hasClass('bv-hidden')) {
        activeFiltersOffset = $activeFilters.offset().top + $activeFilters.outerHeight();
        pageBottomOffset = scrollTop + viewportHeight;
        if (activeFiltersOffset > pageBottomOffset) {
          offset += (pageBottomOffset - activeFiltersOffset);
        }
      }

      return {
        scrollTop: scrollTop,
        offset: offset
      };
    },

    /**
     *  Opens the contentList inside of a lightbox.
     */
    launchContentInLightbox: function () {
      var self;
      if (this.getComponent().lightbox) {
        self = this;
        this.model.onDataReady(function () {
          BV.require(['secondary'], function (app) {
            var mb = app.ModestBox.get('lightbox');
            var mbViews = [self];
            var sortView = self.getFeatureView('contentSort');

            if (mb.opened) {
              return;
            }

            mb.once('afterClose', function (box) {
              var toBeRestored = _(mbViews).pluck('component');
              // The sort view shouldn't be in the mbViews array, but it
              // still needs to be restored.
              if (sortView) {
                toBeRestored.push(sortView.component);
              }
              ENV.get('componentManager').restore(toBeRestored);
            });

            mb.open({ views: mbViews });
          });
        });
      }
    },

    scrollToContent: function (e) {
      var self = this;
      var retryCount = 0;
      var position;

      var showFn = function () {
        try {
          position = self._calculatePosition();

          if (!self.$el.length || position.scrollTop < 0) {
            if (++retryCount < 15) {
              setTimeout(showFn, 200);
            }
            return;
          }

          $('html').add(body()).stop(true, true).animate({
            scrollTop: position.scrollTop - position.offset
          }, 600);
        }
        catch (err) {}
      };

      var moveFn = function () {
        // Using a setTimeout to defer the focus shift until
        // the next turn of the event loop in order to let events
        // bubble properly - without setTimeout, focus won't move
        // in cases where `showContent` below runs synchronously
        setTimeout(function () {
          var $viewEl = $(self.viewEl);
          var $firstFilterButton = $viewEl.find('.bv-active-filters:not(.bv-hidden) .bv-active-filters-list-item:not(.bv-hidden) .bv-active-filter-button:first').eq(0);
          var $firstFocusable;

          if ($firstFilterButton.length) {
            $firstFocusable = $firstFilterButton;
          }
          else {
            $firstFocusable = $viewEl.find('.bv-content-pagination-pages-current.bv-focusable').eq(0);
          }

          if ($firstFocusable.length) {
            FocusManager.moveFocus($firstFocusable);
          }
        }, 0);
      };

      this.showContent({
        showFn: showFn,
        moveFn: moveFn
      });
    },

    showContent: function (opts) {
      var doShowContent = (this.clientAPIConfig || {}).doShowContent || $.noop;
      var callback = function () {
        _(['showFn', 'moveFn']).each(function (key) {
          if (opts[key]) { opts[key](); }
        });
      };

      if (doShowContent(
        null/* application */,
        null/* displayCode */,
        null/* subject */,
        null/* deepLinkId */,
        callback/* callback */,
        null/* source */
      ) !== false) {
        callback();
      }
    },

    getClientAPIConfig: function () {
      var config = _.extend(
        {},
        this.clientAPIConfig,
        {
          campaignId: 'BV_' + ContentType.Noun(this.model.get('contentType')).toUpperCase() + '_DISPLAY',
          mobileRedirect: true
        }
      );

      return config;
    },

    preloadSubmission: _.once(function (e) {
      if (!BV._internal.nopreload) {
        BV.require(['secondary'], function () {});
      }
    }),

    loadSubmission: _.debounce(function (e) {
      var config;
      var contentType;
      var nameStr;
      if (this.readOnly) {
        return;
      }
      e.preventDefault();
      config = this.getClientAPIConfig();
      config.silentMode = false;
      LoadingOverlay.show();

      this.model.trigger('showsubmission', config);
      // saving a flag to use for set focus back onClose event of Thank You Page
      //  (see CCS-33218 for details)
      sessionStorage.setItem('bvSubmissionTriggerElemenet', 'bvContentList');
      contentType = ProductInfo.getType(this);
      nameStr = {
        RatingsAndReviews: 'Write',
        AskAndAnswer: 'Ask'
      }[contentType];
      BVTracker.feature({
        type: 'Used',
        name: nameStr,
        detail1: 'Button',
        detail2: 'ContentTop',
        bvProduct: contentType,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });

    }, 1000, true),

    triggerPageView: function () {
      var pageview = this.model.get('pageview');
      var config;
      var pageviewOptions;

      if (!pageview) {
        return;
      }

      config = this.getClientAPIConfig();

      pageviewOptions = {
        type: 'Product',
        label: 'Default',
        productId: config.productId,
        bvProduct: pageview.bvProduct,
        categoryId: ProductInfo.getCategoryId(this)
      };
      // Additional parameters for A&A. Set to zero if no questions or answers
      if (pageview.bvProduct === 'AskAndAnswer') {
        pageviewOptions.numQuestions = this.model.get('subject').TotalQuestionCount || 0;
        pageviewOptions.numAnswers = this.model.get('subject').TotalAnswerCount || 0;
      }
      BVTracker.pageview(pageviewOptions, this.model);
    },

    markLinkAsFakeVisited: function (e) {
      $(e.target).addClass('bv-fake-visited');
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!profileContentList',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/compare', 'template/helpers/mountView', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div data-bv-target=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" role=\"tabpanel\" class=\"bv-focusable\" tabindex=\"0\"> <span class=\"bv-off-screen\"> ";
  options = {hash:{
    'prefix': ("displaytext_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Type), depth0.msgpack, depth0, options)))
    + " </span> ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.compare),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), "gt", 1, options) : helperMissing.call(depth0, "compare", ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), "gt", 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-control-bar\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount", depth0, options) : helperMissing.call(depth0, "mountView", "ugcCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared full-profile-content-list")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('profileContentList', t);
t.deps = [];
t.tplMountedViews = ['ugcCount'];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview View for profileContentList.
 */
BV.define('bv/c2013/view/profileContentList',[
  'framework/bview',
  'bv/c2013/view/contentList',
  'hbs!profileContentList',
  'jquery',
  'underscore',
  'mf!bv/c2013/messages/profile'
], function (BView, BaseView, template, $, _, msgPack) {

  return BaseView.extend({

    name: 'profileContentList',
    classList: ['core-container-' + BView.config.version],
    templateName: 'profileContentList',

    events: {

    },

    template: template,

    msgpacks: [msgPack],

    init: function () {
      // Leave it empty to override the contentList view's init function
    },

    attach: function (elToAttach) {
      BView.prototype.attach.apply(this, arguments);
      // we don't need lazyload for full profile.
    }

  });

});

/* START_TEMPLATE */
BV.define('hbs!contentItemCollection',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("ol"),
    'classList': ("content-list"),
    'alwaysRender': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentItemCollection', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.3
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/

// BAZAARVOICE MODS
// =================
//
// This file shouldn't be executed on the server so we made a couple modifications
// 1. We wrapped the file in a define block instead of using the vender provided UMD.
//
// 2. We check whether BV.serverRender exists so that we don't access browser specific
//    things such as window or navigator. (ie line 193)
BV.define('vendor/fastclick',['BV'], function (BV) {

  // This is a browser module so we don't want to execute it on the server
  if(BV.serverRender) {
    return {};
  }

  /**
   * Instantiate fast-clicking listeners on the specified layer.
   *
   * @constructor
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
  function FastClick(layer, options) {
    var oldOnClick;

    options = options || {};

    /**
     * Whether a click is currently being tracked.
     *
     * @type boolean
     */
    this.trackingClick = false;


    /**
     * Timestamp for when click tracking started.
     *
     * @type number
     */
    this.trackingClickStart = 0;


    /**
     * The element being tracked for a click.
     *
     * @type EventTarget
     */
    this.targetElement = null;


    /**
     * X-coordinate of touch start event.
     *
     * @type number
     */
    this.touchStartX = 0;


    /**
     * Y-coordinate of touch start event.
     *
     * @type number
     */
    this.touchStartY = 0;


    /**
     * ID of the last touch, retrieved from Touch.identifier.
     *
     * @type number
     */
    this.lastTouchIdentifier = 0;


    /**
     * Touchmove boundary, beyond which a click will be cancelled.
     *
     * @type number
     */
    this.touchBoundary = options.touchBoundary || 10;


    /**
     * The FastClick layer.
     *
     * @type Element
     */
    this.layer = layer;

    /**
     * The minimum time between tap(touchstart and touchend) events
     *
     * @type number
     */
    this.tapDelay = options.tapDelay || 200;

    /**
     * The maximum time for a tap
     *
     * @type number
     */
    this.tapTimeout = options.tapTimeout || 700;

    if (FastClick.notNeeded(layer)) {
      return;
    }

    // Some old versions of Android don't have Function.prototype.bind
    function bind(method, context) {
      return function() { return method.apply(context, arguments); };
    }


    var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
    var context = this;
    for (var i = 0, l = methods.length; i < l; i++) {
      context[methods[i]] = bind(context[methods[i]], context);
    }

    // Set up event handlers as required
    if (deviceIsAndroid) {
      layer.addEventListener('mouseover', this.onMouse, true);
      layer.addEventListener('mousedown', this.onMouse, true);
      layer.addEventListener('mouseup', this.onMouse, true);
    }

    layer.addEventListener('click', this.onClick, true);
    layer.addEventListener('touchstart', this.onTouchStart, false);
    layer.addEventListener('touchmove', this.onTouchMove, false);
    layer.addEventListener('touchend', this.onTouchEnd, false);
    layer.addEventListener('touchcancel', this.onTouchCancel, false);

    // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
    // layer when they are cancelled.
    if (!Event.prototype.stopImmediatePropagation) {
      layer.removeEventListener = function(type, callback, capture) {
        var rmv = Node.prototype.removeEventListener;
        if (type === 'click') {
          rmv.call(layer, type, callback.hijacked || callback, capture);
        } else {
          rmv.call(layer, type, callback, capture);
        }
      };

      layer.addEventListener = function(type, callback, capture) {
        var adv = Node.prototype.addEventListener;
        if (type === 'click') {
          adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
            if (!event.propagationStopped) {
              callback(event);
            }
          }), capture);
        } else {
          adv.call(layer, type, callback, capture);
        }
      };
    }

    // If a handler is already declared in the element's onclick attribute, it will be fired before
    // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
    // adding it as listener.
    if (typeof layer.onclick === 'function') {

      // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
      // - the old one won't work if passed to addEventListener directly.
      oldOnClick = layer.onclick;
      layer.addEventListener('click', function(event) {
        oldOnClick(event);
      }, false);
      layer.onclick = null;
    }
  }

  /**
  * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  *
  * @type boolean
  */
  var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

  /**
   * Android requires exceptions.
   *
   * @type boolean
   */
  var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


  /**
   * iOS requires exceptions.
   *
   * @type boolean
   */
  var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


  /**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */
  var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


  /**
   * iOS 6.0(+?) requires the target element to be manually derived
   *
   * @type boolean
   */
  var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);

  /**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */
  var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

  /**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */
  FastClick.prototype.needsClick = function(target) {
    switch (target.nodeName.toLowerCase()) {

    // Don't send a synthetic click to disabled inputs (issue #62)
    case 'button':
    case 'select':
    case 'textarea':
      if (target.disabled) {
        return true;
      }

      break;
    case 'input':

      // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
      if ((deviceIsIOS && target.type === 'file') || target.disabled) {
        return true;
      }

      break;
    case 'label':
    case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
    case 'video':
      return true;
    }

    // BV CHANGE: Also ignore anything with a 'bv-fastclick-ignore' class.
    return (/\bneedsclick\b|\bbv-fastclick-ignore\b/).test(target.className);
  };


  /**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */
  FastClick.prototype.needsFocus = function(target) {
    switch (target.nodeName.toLowerCase()) {
    case 'textarea':
      return true;
    case 'select':
      return !deviceIsAndroid;
    case 'input':
      switch (target.type) {
      case 'button':
      case 'checkbox':
      case 'file':
      case 'image':
      case 'radio':
      case 'submit':
        return false;
      }

      // No point in attempting to focus disabled inputs
      return !target.disabled && !target.readOnly;
    default:
      return (/\bneedsfocus\b/).test(target.className);
    }
  };


  /**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */
  FastClick.prototype.sendClick = function(targetElement, event) {
    var clickEvent, touch;

    // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
    if (document.activeElement && document.activeElement !== targetElement) {
      document.activeElement.blur();
    }

    touch = event.changedTouches[0];

    // Synthesise a click event, with an extra attribute so it can be tracked
    clickEvent = document.createEvent('MouseEvents');
    clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    clickEvent.forwardedTouchEvent = true;
    targetElement.dispatchEvent(clickEvent);
  };

  FastClick.prototype.determineEventType = function(targetElement) {

    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
      return 'mousedown';
    }

    return 'click';
  };


  /**
   * @param {EventTarget|Element} targetElement
   */
  FastClick.prototype.focus = function(targetElement) {
    var length;

    // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
      length = targetElement.value.length;
      targetElement.setSelectionRange(length, length);
    } else {
      targetElement.focus();
    }
  };


  /**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */
  FastClick.prototype.updateScrollParent = function(targetElement) {
    var scrollParent, parentElement;

    scrollParent = targetElement.fastClickScrollParent;

    // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
    // target element was moved to another parent.
    if (!scrollParent || !scrollParent.contains(targetElement)) {
      parentElement = targetElement;
      do {
        if (parentElement.scrollHeight > parentElement.offsetHeight) {
          scrollParent = parentElement;
          targetElement.fastClickScrollParent = parentElement;
          break;
        }

        parentElement = parentElement.parentElement;
      } while (parentElement);
    }

    // Always update the scroll top tracker if possible.
    if (scrollParent) {
      scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
    }
  };


  /**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */
  FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    if (eventTarget.nodeType === Node.TEXT_NODE) {
      return eventTarget.parentNode;
    }

    return eventTarget;
  };


  /**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchStart = function(event) {
    var targetElement, touch, selection;

    // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
    if (event.targetTouches.length > 1) {
      return true;
    }

    targetElement = this.getTargetElementFromEventTarget(event.target);
    touch = event.targetTouches[0];

    if (deviceIsIOS) {

      // Only trusted events will deselect text on iOS (issue #49)
      selection = window.getSelection();
      if (selection.rangeCount && !selection.isCollapsed) {
        return true;
      }

      if (!deviceIsIOS4) {

        // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
        // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
        // with the same identifier as the touch event that previously triggered the click that triggered the alert.
        // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
        // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
        // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
        // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
        // random integers, it's safe to to continue if the identifier is 0 here.
        if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
          event.preventDefault();
          return false;
        }

        this.lastTouchIdentifier = touch.identifier;

        // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
        // 1) the user does a fling scroll on the scrollable layer
        // 2) the user stops the fling scroll with another tap
        // then the event.target of the last 'touchend' event will be the element that was under the user's finger
        // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
        // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
        this.updateScrollParent(targetElement);
      }
    }

    this.trackingClick = true;
    this.trackingClickStart = event.timeStamp;
    this.targetElement = targetElement;

    this.touchStartX = touch.pageX;
    this.touchStartY = touch.pageY;

    // Prevent phantom clicks on fast double-tap (issue #36)
    if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
      event.preventDefault();
    }

    return true;
  };


  /**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.touchHasMoved = function(event) {
    var touch = event.changedTouches[0], boundary = this.touchBoundary;

    if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
      return true;
    }

    return false;
  };


  /**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchMove = function(event) {
    if (!this.trackingClick) {
      return true;
    }

    // If the touch has moved, cancel the click tracking
    if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
      this.trackingClick = false;
      this.targetElement = null;
    }

    return true;
  };


  /**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */
  FastClick.prototype.findControl = function(labelElement) {

    // Fast path for newer browsers supporting the HTML5 control attribute
    if (labelElement.control !== undefined) {
      return labelElement.control;
    }

    // All browsers under test that support touch events also support the HTML5 htmlFor attribute
    if (labelElement.htmlFor) {
      return document.getElementById(labelElement.htmlFor);
    }

    // If no for attribute exists, attempt to retrieve the first labellable descendant element
    // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
    return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
  };


  /**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchEnd = function(event) {
    var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

    if (!this.trackingClick) {
      return true;
    }

    // Prevent phantom clicks on fast double-tap (issue #36)
    if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
      this.cancelNextClick = true;
      return true;
    }

    if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
      return true;
    }

    // Reset to prevent wrong click cancel on input (issue #156).
    this.cancelNextClick = false;

    this.lastClickTime = event.timeStamp;

    trackingClickStart = this.trackingClickStart;
    this.trackingClick = false;
    this.trackingClickStart = 0;

    // On some iOS devices, the targetElement supplied with the event is invalid if the layer
    // is performing a transition or scroll, and has to be re-detected manually. Note that
    // for this to function correctly, it must be called *after* the event target is checked!
    // See issue #57; also filed as rdar://13048589 .
    if (deviceIsIOSWithBadTarget) {
      touch = event.changedTouches[0];

      // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
      targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
      targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
    }

    targetTagName = targetElement.tagName.toLowerCase();
    if (targetTagName === 'label') {
      forElement = this.findControl(targetElement);
      if (forElement) {
        this.focus(targetElement);
        if (deviceIsAndroid) {
          return false;
        }

        targetElement = forElement;
      }
    } else if (this.needsFocus(targetElement)) {

      // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
      // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
      if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
        this.targetElement = null;
        return false;
      }

      this.focus(targetElement);
      this.sendClick(targetElement, event);

      // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
      // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
      if (!deviceIsIOS || targetTagName !== 'select') {
        this.targetElement = null;
        event.preventDefault();
      }

      return false;
    }

    if (deviceIsIOS && !deviceIsIOS4) {

      // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
      // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
      scrollParent = targetElement.fastClickScrollParent;
      if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
        return true;
      }
    }

    // Prevent the actual click from going though - unless the target node is marked as requiring
    // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
    if (!this.needsClick(targetElement)) {
      event.preventDefault();
      this.sendClick(targetElement, event);
    }

    return false;
  };


  /**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */
  FastClick.prototype.onTouchCancel = function() {
    this.trackingClick = false;
    this.targetElement = null;
  };


  /**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onMouse = function(event) {

    // If a target element was never set (because a touch event was never fired) allow the event
    if (!this.targetElement) {
      return true;
    }

    if (event.forwardedTouchEvent) {
      return true;
    }

    // Programmatically generated events targeting a specific element should be permitted
    if (!event.cancelable) {
      return true;
    }

    // Derive and check the target element to see whether the mouse event needs to be permitted;
    // unless explicitly enabled, prevent non-touch click events from triggering actions,
    // to prevent ghost/doubleclicks.
    if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

      // Prevent any user-added listeners declared on FastClick element from being fired.
      if (event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      } else {

        // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        event.propagationStopped = true;
      }

      // Cancel the event
      event.stopPropagation();
      event.preventDefault();

      return false;
    }

    // If the mouse event is permitted, return true for the action to go through.
    return true;
  };


  /**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onClick = function(event) {
    var permitted;

    // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
    if (this.trackingClick) {
      this.targetElement = null;
      this.trackingClick = false;
      return true;
    }

    // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
    if (event.target.type === 'submit' && event.detail === 0) {
      return true;
    }

    permitted = this.onMouse(event);

    // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
    if (!permitted) {
      this.targetElement = null;
    }

    // If clicks are permitted, return true for the action to go through.
    return permitted;
  };


  /**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */
  FastClick.prototype.destroy = function() {
    var layer = this.layer;

    if (deviceIsAndroid) {
      layer.removeEventListener('mouseover', this.onMouse, true);
      layer.removeEventListener('mousedown', this.onMouse, true);
      layer.removeEventListener('mouseup', this.onMouse, true);
    }

    layer.removeEventListener('click', this.onClick, true);
    layer.removeEventListener('touchstart', this.onTouchStart, false);
    layer.removeEventListener('touchmove', this.onTouchMove, false);
    layer.removeEventListener('touchend', this.onTouchEnd, false);
    layer.removeEventListener('touchcancel', this.onTouchCancel, false);
  };


  /**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */
  FastClick.notNeeded = function(layer) {
    var metaViewport;
    var chromeVersion;
    var blackberryVersion;

    // Devices that don't support touch don't need FastClick
    if (typeof window.ontouchstart === 'undefined') {
      return true;
    }

    // Chrome version - zero for other browsers
    chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

    if (chromeVersion) {

      if (deviceIsAndroid) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          }
          // Chrome 32 and above with width=device-width or less don't need FastClick
          if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        }

      // Chrome desktop doesn't need FastClick (issue #15)
      } else {
        return true;
      }
    }

    if (deviceIsBlackBerry10) {
      blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

      // BlackBerry 10.3+ does not require Fastclick library.
      // https://github.com/ftlabs/fastclick/issues/251
      if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // user-scalable=no eliminates click delay.
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          }
          // width=device-width (or less than device-width) eliminates click delay.
          if (document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        }
      }
    }

    // IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
    if (layer.style.msTouchAction === 'none') {
      return true;
    }

    // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
    // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
    if (layer.style.touchAction === 'none') {
      return true;
    }

    return false;
  };


  /**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
  FastClick.attach = function(layer, options) {
    return new FastClick(layer, options);
  };

  return FastClick;
});
/**
 * This is a mixin to add focusable functionality to a view. It can't really be
 * used on its own for anything. You can mix this in with a view like this:
 *
 *   var myView = BView.extend({
 *     doStuff : function () {
 *       // ...
 *       this.moveFocus($someElement);
 *     }
 *   });
 *
 *   myView = myView.extend(FocusableView);
 *
 *   return myView;
 */

BV.define('bv/ui-core/focusableview',[
  'bv/util/focusManager',
  'underscore',
  'framework/util/bvtracker',
  'bv/strings'
], function (focusManager, _, BVTracker, str) {
  var FocusableView = {};

  _([
    'registerFocusableLayer',
    'deregisterFocusableLayer',
    'deregisterFocusableLayerById',
    'moveFocus',
    'addFocusables',
    'addFocusablesInline',
    'removeFocusables',
    'rescanFocusLayer',
    'refocusLayer'
  ]).each(function (method) {
    FocusableView[method] = function () {
      try {
        return focusManager[method].apply(focusManager, arguments);
      } catch (e) {
        BVTracker.error({
          name: str.errors.UI,
          detail1: 'Focus Error',
          detail2: e.toString()
        });
      }
    };
  });

  _([
    'layer'
  ]).each(function (property) {
    FocusableView[property] = focusManager[property];
  });

  return FocusableView;
});

/**
 * @fileOverview  Module for determining whether the CSS required
 * for Firebird display has loaded.
 */
BV.define('bv/util/cssLoadCheck',[
  'ENV',
  'body',
  'jquery',
  'client!framework/util/ie',
  'framework/util/bvtracker',
  'framework/util/bvreporter',
  'bv/strings',
  'document'
], function (ENV, body, $, IE, BVTracker, BVReporter, str, document) {
  // Create a deferred that resolves when css has loaded
  var cssDfd = $.Deferred();
  var promise = cssDfd.promise();

  if (!document) {
    cssDfd.resolve();
    return promise;
  }

  var CSS_LOAD_CHECK_INTERVAL = 50; // check every 50ms to see if css has loaded
  var CSS_LOAD_CHECK_WAIT = 20000; // Stop checking if css hasn't loaded after 20s
  var CSS_LOAD_COUNT_MAX = Math.floor(CSS_LOAD_CHECK_WAIT / CSS_LOAD_CHECK_INTERVAL);
  var count = 0;
  var cssLoadedEl = document.createElement('div');
  var $cssLoadedEl = $(cssLoadedEl);

  /* For those who might see this another day and think, "I can optimize!"
   * Here's what will break if you try to do so:
   * - Using jQuery's `css` method: Broke IE9 Standards mode (which makes me go O_o but anyhow)
   * - Using the DOM node's `cssText` property: Broke IE8 Quirks
   * - Using this approach but only specifying `'0'` and not `'0px'`: Broke IE9 Quirks
   *
   * As much as it stinks, this is probably as optimal as the next few lines can get.
   */
  cssLoadedEl.style.height = '0px';
  cssLoadedEl.style.width = '0px';
  cssLoadedEl.style.border = '0px';

  cssLoadedEl.className = 'bv-verify-css-loaded';

  IE = IE();

  function checkStylesLoaded () {
    /* At one point, this check used to simply read:
     *
     *   if ( body() && !cssLoadedEl.parentNode)
     *
     * However, it turns out that if a version of Modernizr 2.6-ish is on the page,
     * our created element has a parentNode value that is truthy, but only in IE8.
     * Whether we used document.createElement or $('<div></div>'), the above holds.
     *
     * Additionally, it's going to be safer to ensure that not only do we have a
     * parent, but that it is the body, to ensure that parent nodes aren't messing
     * with our styles in any other way. So, the condition was modified like so:
     *
     *   var bodyEl = body();
     *   if ( bodyEl && !cssLoadedEl.parentNode !== bodyEl )
     *
     * However, that would fail on the next line where it would try to append the
     * cssLoadedEl into the body, throwing this error:
     *
     *   HTML Parsing Error: Unable to modify the parent container element before
     *   the child element is closed (KB927917)
     *
     * It would throw so hard that a simple try/catch wouldn't catch it, and all
     * rendering simply failed. It also would cause IE8 to crash on some
     * occasions, with no warning whatsoever.
     *
     * Therefore, at this point, we're doing an IE sniff, and if it's oldIE,
     * we're deferring until DOM Ready to check for loaded styles again. All other
     * browsers handle the early injection just fine. It's not pretty, but it's
     * the best and safest option that we have at this point.
     */
    if (IE && IE < 9 && !$.isReady) {
      $(checkStylesLoaded);
      return;
    }

    var bodyEl = body();
    if (bodyEl && cssLoadedEl.parentNode !== bodyEl) {
      bodyEl.appendChild(cssLoadedEl);
    }

    if ($cssLoadedEl.css('display') === 'none') {
      BVReporter.info('CSS load detected');
      ENV.set('cssIsLoaded', true);
      cssDfd.resolve();
      return;
    }

    if (count > CSS_LOAD_COUNT_MAX) {
      BVTracker.error({
        name: str.errors.TIMEOUT,
        detail1: 'CSS',
        detail2: 'Failed to load after ' + CSS_LOAD_CHECK_WAIT + 'ms'
      });
      cssDfd.reject();
      return;
    }

    setTimeout(checkStylesLoaded, CSS_LOAD_CHECK_INTERVAL);
    count++;
  }

  checkStylesLoaded();

  return promise;
});

/* START_TEMPLATE */
BV.define('hbs!modestboxZone',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"bv-mboxzone-";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role='region' class=\"bv-mboxzone ";
  if (stack1 = helpers['class']) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0['class']; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"/>";
  return buffer;
  });
Handlebars.registerPartial('modestboxZone', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!modestboxOverlay',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  


  return "<div id=\"bv-mbox-overlay-id\" class=\"bv-mbox-overlay\"/> ";
  });
Handlebars.registerPartial('modestboxOverlay', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_cancel', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function cancel( data ) {
try { return (function(d){
var r = "";
r += "Cancel";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `cancel`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_cancel', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return cancel(data);
});
return cancel;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!modestboxClose',['hbs','vendor/handlebars/runtime', 'template/helpers/renderIcon', 'template/helpers/extmsg', '_i18n_cancel'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return " &#x2718; ";
  }

  buffer += "<button type=\"button\" name=\"";
  if (stack1 = helpers._i18n_cancel) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_cancel; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" class=\"bv-mbox-close bv-focusable\" tabindex=\"0\" aria-labelledby=\"bv-mbox-close-label bv-mbox-breadcrumb-item\"> ";
  options = {hash:{
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-close", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-close", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span id=\"bv-mbox-close-label\" class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "close", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "close", depth0.msgpack, depth0, options)))
    + "</span> </button> ";
  return buffer;
  });
Handlebars.registerPartial('modestboxClose', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!modestboxInner',['hbs','vendor/handlebars/runtime', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "role=\"region\" aria-label=\"\"";
  }

function program3(depth0,data) {
  
  
  return "role=\"dialog\"";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.submissionUnavailablePage, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.id, "terms-and-conditions", options) : helperMissing.call(depth0, "equals", depth0.id, "terms-and-conditions", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return " aria-describedby=\"bv-terms-conditions\" ";
  }

function program9(depth0,data) {
  
  
  return "aria-label=\"Duplicate Review Error.\" aria-describedby=\"bv-mbox-label-text\" role=\"alertdialog\" ";
  }

function program11(depth0,data) {
  
  
  return "aria-label=\"Cannot Submit Review Error.\" aria-describedby=\"bv-mbox-label-text\" role=\"alertdialog\" ";
  }

function program13(depth0,data) {
  
  
  return " <h2 class=\"bv-mbox-breadcrumb\"></h2> ";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(18, program18, data),fn:self.program(16, program16, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.id, "lightbox", options) : helperMissing.call(depth0, "equals", depth0.id, "lightbox", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program16(depth0,data) {
  
  
  return " <h1 class=\"bv-mbox-breadcrumb\"></h2> ";
  }

function program18(depth0,data) {
  
  
  return " <h2 class=\"bv-mbox-breadcrumb\"></h1> ";
  }

  buffer += " <div class=\"bv-mbox-inner ";
  if (stack1 = helpers.wrapClass) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.wrapClass; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " bv-mbox-";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" ";
  stack1 = helpers.unless.call(depth0, depth0.ariaDialog, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "> <div class=\"bv-mbox-wrapper ";
  if (stack1 = helpers.injectionClass) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.injectionClass; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <div id=\"";
  if (stack1 = helpers.injectionId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.injectionId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"bv-mbox\" ";
  stack1 = helpers['if'].call(depth0, depth0.ariaDialog, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " aria-modal=\"true\" ";
  stack1 = helpers.unless.call(depth0, depth0.duplicatePage, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.duplicatePage, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.submissionUnavailablePage, {hash:{},inverse:self.noop,fn:self.program(11, program11, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " > <div class=\"bv-mbox-sidebar\"></div> <!--[if lt IE 7]> <div class=\"bv-mbox-content-container bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-mbox-content-container bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-mbox-content-container bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-mbox-content-container bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-mbox-content-container\"> <!--<![endif]--> ";
  stack1 = helpers['if'].call(depth0, depth0.inline, {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <div class=\"bv-mbox-injection-container\"></div> </div> </div> </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('modestboxInner', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!modestboxBreadcrumb',['hbs','vendor/handlebars/runtime', 'template/helpers/renderIcon'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span data-bv-mbox-layer-index=\"";
  if (stack1 = helpers.index) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.index; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"bv-mbox-breadcrumb-item\" id=\"bv-mbox-breadcrumb-item\"> ";
  stack1 = helpers.unless.call(depth0, depth0.last, {hash:{},inverse:self.program(8, program8, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.last, {hash:{},inverse:self.noop,fn:self.program(10, program10, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a href=\"#\" class='bv-focusable'> ";
  stack1 = helpers['if'].call(depth0, depth0.titleIcon, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <span ";
  stack1 = helpers['if'].call(depth0, depth0.titleIcon, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> </a> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var stack1, stack2, options;
  options = {hash:{
    'classList': ("bv-submission-icon")
  },inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-thank-you", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-thank-you", options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  }
function program4(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.titleIcon) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.titleIcon; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

function program6(depth0,data) {
  
  
  return "class=\"bv-submission-icon-text\"";
  }

function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.titleIcon, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <span ";
  stack1 = helpers['if'].call(depth0, depth0.titleIcon, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> ";
  return buffer;
  }

function program10(depth0,data) {
  
  
  return "<span class=\"bv-mbox-breadcrumb-divider\">/</span> ";
  }

  stack1 = helpers.each.call(depth0, depth0.titles, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('modestboxBreadcrumb', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/*  eslint-disable no-unused-expressions, no-shadow */
BV.define('bv/ui-core/modestbox',[
  'underscore',
  'jquery',
  'backbone',
  'window',
  'document',
  'body',
  'BV',

  'vendor/fastclick',
  'bv/ui-core/focusableview',
  'bv/util/loadingOverlay',
  'bv/util/cssLoadCheck',
  'util/specialKeys',
  'util/highContrast',
  'bv/strings',

  'framework/bview',
  'framework/util/bvtracker',

  'hbs!modestboxZone',
  'hbs!modestboxOverlay',
  'hbs!modestboxClose',
  'hbs!modestboxInner',
  'hbs!modestboxBreadcrumb',

  'mf!bv/c2013/messages/common'
], function (_, $, Backbone, window, document, body, BV, FastClick, FocusableView, LoadingOverlay, cssLoadCheck, specialKeys, has, str, BView, BVTracker, tmplZone, tmplOverlay, tmplClose, tmplInner, tmplBreadcrumb, msgPackCommon) {

  // TODO: Figure out if we need these options:
  //
  // * goBackUponClose (dunno)

  // TODO: In view/submission.js, we have a custom ariaStatus message
  // notifying the user that the modal has changed views. Should we
  // generalize that?

  // TODO: We create two properties `container` and `$container` on Layer which
  // point to the same element. We should consider removing one of them to
  // prevent confusion.

  // MODESTBOX
  // =========
  //
  // A drop-in replacement for SpiffyBox. ModestBox is not a braggart. It
  // underpromises and overdelivers.
  //
  //
  //
  // GOALS
  // -----
  //
  // 1. SpiffyBox had way, way too much knowledge of the other parts of
  //    Firebird. Ideally, it shouldn't need to know about whether it's on a
  //    container page, or whether a view has an `rpc` property. Instead of
  //    putting that stuff into ModestBox, we expose an event system for both
  //    layers and boxes.
  //
  //    So if you're editing this file later on and giving ModestBox knowledge
  //    of some weird edge case, you're doing it wrong. Instead, try to hook
  //    into the event system. If you need to inject some code at a point that
  //    isn't covered by existing events, make a new event.
  //
  // 2. SpiffyBox had a bunch of overlapping and underdocumented options. If
  //    you didn't know what you were doing, you could get it into some pretty
  //    weird states.
  //
  //    ModestBox aims to simplify the options and make them implicit as
  //    often as possible.
  //
  //
  // MODESTBOX EVENTS
  // ----------------
  //
  // SpiffyBox had four callbacks: `beforeShow, `afterShow`, `beforeClose`,
  // and `afterClose`. This was confusing; "show" applies to the layer, but
  // "close" applies to the box as a whole.
  //
  // Now, there are eight events: four for the box and four for each layer.
  // Both the `Box` and the `Layer` classes mix in `Backbone.Events` to
  // present a familiar event interface.
  //
  // ### BOX EVENTS
  //
  // The box events are `beforeOpen`, `afterOpen`, `beforeClose`, and
  // `afterClose`. If you're using a shared Box instance, like `lightbox`,
  // you'll probably want to use the `once` method (rather than the `on`
  // method) so that your callback applies only to the _very next_ open/close
  // events. Otherwise, once they've been attached, your callbacks will run
  // even when other pieces of the app use the box.
  //
  //      var box = ModestBox.get('lightbox');
  //      // Hook into the next open/close of this box.
  //      box.once('beforeOpen', function () { /* do some stuff */ });
  //      box.once('afterClose', function () { /* undo some stuff */ });
  //
  //      // ...
  //      box.open(someConfig);
  //
  //
  // If, on the other hand, you're using a Box instance that only you know
  // about, you can use the `on` method. Just be sure to attach the callbacks
  // only once, rather than before each time you open the box.
  //
  // ### LAYER EVENTS
  //
  // The layer events are `beforeShow`, `afterShow`, `beforeHide`, `afterHide`
  // and `afterDetach`. Because we don't really expose the `Layer` instance to the
  // outside world, you'll want to pass these in as options for the layer.
  // (Refer to the bottom of the file for documentation of these options.)
  //
  //
  // CAVEATS
  // -------
  //
  // 1. The `open` method is _not_ guaranteed to be synchronous. We wait
  //    until the CSS has loaded before we attempt to inject any HTML, so don't
  //    assume you can call `open` and then do something with the box on the
  //    very next line. If you need to do something immediately after a box
  //    opens, use the box's `afterOpen` event.
  //

  // Duration, in milliseconds, of the open/close animation
  // +100ms of 'fudge time'
  var OPEN_DURATION = 500;

  // Duration, in milliseconds, of the slide-in/slide-out layer animations
  // (plus 100ms of fudge time).
  var TRANSITION_DURATION = 300;

  var $window = $(window);
  var $document = $(document);

  // We don't need this in server render. Skip it.
  if (window.BV && window.BV.serverRender) {
    return;
  }
  // Manages something meant to happen at a regular interval.
  function Interval (config) {
    this.fn = config.fn;
    this.frequency = config.frequency;
    this.cleanup = config.cleanup || $.noop;

    this.id = null;

    this.start();
  }

  _(Interval.prototype).extend({
    start: function () {
      this.stop();
      this.id = setInterval(this.fn, this.frequency);
    },

    stop: function () {
      if (!this.id) {
        return;
      }

      window.clearInterval(this.id);
      this.id = null;

      this.cleanup();
    }
  });

  // Manages a group of Intervals.
  function IntervalList () {
    this.intervals = [];
  }

  _(IntervalList.prototype).extend({
    add: function (config) {
      var interval = (config instanceof Interval) ? config : new Interval(config);
      this.intervals.push(interval);
    },

    startAll: function () {
      _(this.intervals).invoke('start');
    },

    stopAll: function () {
      _(this.intervals).invoke('stop');
    }
  });


  // BOX
  // ===
  //
  // A Box manages a collection of Layers. It handles custodial tasks like
  // swapping out class names on the box itself and resizing when the size of
  // the content changes.
  //
  function Box (id) {
    this.id = id;
    this.layers = [];
    this.intervalList = new IntervalList();

    // Create the close-button HTML fragment and keep it around.
    this.$mboxClose = $(tmplClose({ msgpack: msgPackCommon }));

    this.on('afterClose', FocusableView.refocusLayer);
  }

  _(Box.prototype).extend(Backbone.Events, {

    _addLayer: function (layer) {
      layer.on('afterShow', this._applyLayerConfig);
      this.layers.push(layer);
      this._checkSize();
      return layer;
    },

    // Remove the Nth-from-bottom layer, or the topmost layer if no index is given.
    _removeLayer: function (index) {
      var layer;
      var self;
      if (typeof index === 'undefined') {
        index = this.layers.length - 1;
      }

      layer = this.layers.splice(index, 1)[0];
      self = this;
      _.delay(function () {
        if (!self.opened || self.layers.length === 0) {
          return;
        }
        self._checkSize();
      }, TRANSITION_DURATION);
      return layer;
    },

    _checkSize: function () {
      // As soon as we have more than one layer, we add `bv-mbox-multi` to
      // the box's enclosing element. The presence of this class triggers the
      // slide-in animation when a new layer appears.
      //
      // When we remove a layer, we until after the animation is done
      // (assuming it happened) to check whether we need to remove this
      // class. We do that so that the departing layer can animate out.
      this.$layerList.toggleClass('bv-mbox-multi', this.layers.length > 1);
    },

    _cleanupContainers: function () {
      var $overlay;
      if (this.overlay) {
        // Do some voodoo here to make the weird rendering bugs in Safari
        // 6.0.2 on Mountain Lion to go away.
        $overlay = $('#bv-mbox-overlay-id');
        $overlay.addClass('bv-hiding');

        _.delay(function () {
          if ($overlay.hasClass('bv-hiding')) {
            $overlay.addClass('bv-mbox-overlay-hide');
          }
        }, 20);
      }

      $('#bv-mboxzone-' + this.id).remove();
    },

    _injectContainer: function (config) {
      var $appendTo = config.bodyAppend ? $(body()) : $(config.container);
      var classNames = [];
      var $mboxZone;
      if ($appendTo.closest('.bv-cv2-cleanslate').length === 0) {
        classNames.push('bv-cleanslate', 'bv-cv2-cleanslate');
        if (has('high-contrast')) {
          classNames.push('bv-highcontrast');
        }
      }
      if (!config.bodyAppend) {
        // We must not be in lightbox mode. Thus we want this class name to
        // be on the box from the beginning so we don't trigger an animation.
        // (TODO: I _think_ this is why. Investigate.)
        classNames.push('bv-mbox-opened');
      }

      $mboxZone = $(tmplZone({ id: this.id, 'class': classNames.join(' ') }));
      $mboxZone.appendTo($appendTo);

      if (!config.inline) {
        // We're in lightbox mode. Render and inject the overlay.
        if (config.overlay) {
          $('#bv-mbox-overlay-id').remove();
          $(tmplOverlay()).insertBefore($mboxZone);
          // Added special class for iPads to prevent a weird visual glitch: a white area that
          // appears on the bottom or on the top of overlay element. See CCS-11756 and CCS-16451
          if (navigator.userAgent.match(/iPad/i)) {
            $('#bv-mbox-overlay-id').addClass('ipad');
          }
        }
        $mboxZone.addClass('bv-mbox-lightbox');
      }

      // TODO: Should this be elsewhere?
      new FastClick($mboxZone.get(0));

      // Ensure that a stray <a href='#'> doesn't change the URL when it's
      // clicked on.
      //
      // This is added as a direct handler because I can't get it to fire
      // reliably as a delegated handler, and I don't know why. -APD
      $mboxZone.on('click', function (event) {
        var $target = $(event.target);
        if ($target.closest('a[href="#"]').length > 0) {
          event.preventDefault();
        }
      });

      return $mboxZone;
    },

    // Given a layer instance, renders the necessary HTML for that layer.
    _createView: function (layer) {
      // The `bv-core-container-0` class needs to be added if we can't find one in our hierarchy.
      var coreContainerClass = 'bv-core-container-' + BView.config.version;
      var needsCoreContainerClass = this.$container.closest('.' + needsCoreContainerClass).length === 0;

      var data = {
        id: this.id,
        ariaTitle: layer.ariaTitle || '',
        ariaDialog: layer.ariaDialog,
        sidebar: !!layer.sidebar,
        wrapClass: needsCoreContainerClass ? coreContainerClass : '',
        injectionId: this.injectionId,
        injectionClass: this._classesForContainer(layer).join(' '),
        inline: layer.inline,
        duplicatePage: layer.duplicatePage || false,
        submissionUnavailablePage: layer.submissionUnavailablePage || false,
        submissionPage: layer.submissionPage || false,
        ariaDescribedby: layer.ariaDescribedby || false,
        ariaLabeledBy: layer.ariaLabeledBy || false
      };

      return $(tmplInner(data));
    },

    _classesForContainer: function (config) {
      var classList = config.classList.slice(0);
      classList.push(config.sidebar ? 'wide' : 'narrow');

      if (config.overElement) {
        classList.push('over');
      }
      if (config.mobile) {
        classList.push('mobile');
      }
      else if (config.inline) {
        classList.push('inline');
      }
      else {
        classList.push('box');
      }

      return _(classList).map(function (name) { return 'bv-mbox-' + name; });
    },

    // For any tasks that need to be redone when the current layer changes.
    // Called at the very _end_ of any method that changes the layer stack,
    // so if it's ultra-time-sensitive it shouldn't go here.
    _onStackChange: function () {
      var newLayer;
      if (!this.opened || this.layers.length === 0) {
        return;
      }

      newLayer = _(this.layers).last();

      LoadingOverlay.hide();
      this._updateBreadcrumb();
      this._manageSidebar(newLayer);
    },

    _manageSidebar: function (layer) {
      var $mboxWrapper = this.$viewEl.find('.bv-mbox-wrapper');
      var $mboxSidebar = $mboxWrapper.find('.bv-mbox-sidebar');
      var sidebar = layer ? layer.sidebar : null;

      if (sidebar) {
        // First, we know it'll need to manage its own events.
        sidebar._actAsEventManager();

        $mboxWrapper
          .addClass('bv-mbox-wide')
          .removeClass('bv-mbox-narrow');

        $mboxSidebar
          .addClass('bv-sidebar-enabled')
          .removeClass('bv-sidebar-disabled');

        // Insert the view in the proper place in the view hierarchy.
        sidebar.remove();
        sidebar.setElement($mboxSidebar[0]);
        sidebar.render();
      }
      else {
        // This layer has no sidebar. Get rid of any sidebar that may exist
        // from a previous layer.

        // Hide the sidebar first...
        $mboxWrapper
          .find('.bv-mbox-sidebar')
          .removeClass('bv-sidebar-enabled')
          .addClass('bv-sidebar-disabled')
          .empty();

        // ...before the CSS transition that triggers when we do this. (But
        // only do this if we previously had the `wide` class name; some
        // boxes, like the media viewer, don't use either the -wide or the
        // -narrow class name.)
        if ($mboxWrapper.hasClass('bv-mbox-wide')) {
          $mboxWrapper.removeClass('bv-mbox-wide');
          $mboxWrapper[0].offsetHeight;
          $mboxWrapper.addClass('bv-mbox-narrow');
        }
      }
    },

    _updateBreadcrumb: function () {
      // Turn the layers into the data necessary for rendering their titles
      // in a Handlebars template.
      var titles = [];
      var topLayer;
      var ariaLabel;
      var ariaDescribedby;
      var ariaLabeledBy;

      _(this.layers).each(function (layer, index) {
        // Skip layers that don't have titles.
        if (!layer.title) {
          return;
        }
        titles.push({
          title: layer.title,
          ariaTitle: layer.ariaTitle || layer.title,
          titleIcon: layer.titleIcon,
          index: index,
          last: index === this.layers.length - 1
        });
      }, this);

      topLayer = _(this.layers).last();

      // If breadcrumbs are disabled for this layer, show only this layer's
      // title.
      if (!topLayer.showBreadcrumb) {
        if (titles.length > 1) {
          titles = _(titles).filter(function (title) { return title.last; });
        }
        else if (titles.length === 1 && !titles[0].last) {
          titles = [];
        }
      }

      ariaLabel = topLayer.ariaTitle;
      if (!ariaLabel) {
        // This layer doesn't have its own ARIA title, so we should set
        // `aria-label` to the last tile, whether we're in breadcrumbs mode
        // or not.
        if (titles.length === 0) {
          // Explicitly empty out the label. Not ideal, but better this than
          // an inaccurate label from another layer.
          ariaLabel = '';
        }
        else {
          ariaLabel = _(titles).find(function (title) { return title.last; }).ariaTitle;
        }
      }

      // We use `aria-label` instead of `aria-labelledby` because the latter
      // requires that a DOM element be present with the title text.
      // Sometimes we want a layer to have an `ariaTitle` without a `title`,
      // or to have a different `ariaTitle` than a `title`.
      if (ariaLabel) {
        $('#bv-mbox-' + this.id + '-list').attr('aria-label', ariaLabel);
      }
      else {
        $('#bv-mbox-' + this.id + '-list').removeAttr('aria-label');
      }

      // Updating aria properties when the modal is changed
      ariaDescribedby = topLayer.ariaDescribedby;
      ariaLabeledBy = topLayer.ariaLabeledBy;

      if (ariaDescribedby) {
        $('#bv-mbox-' + this.id + '-list').attr('aria-describedby', ariaDescribedby);
      }
      else {
        $('#bv-mbox-' + this.id + '-list').removeAttr('aria-describedby');
      }

      if (ariaLabeledBy) {
        $('#bv-mboxzone-' + this.id).attr('aria-labelledby', ariaLabeledBy);
      }
      else {
        $('#bv-mboxzone-' + this.id).removeAttr('aria-labelledby');
      }

      // Remove all delegated click events from the breadcrumb element.
      this.$breadcrumb.off('click.bv-mbox-breadcrumb', '**');

      if (titles.length === 0) {
        // No titles to show.
        this.$breadcrumb.addClass('bv-hidden');
        return;
      }

      this.$breadcrumb.removeClass('bv-hidden');
      this.$breadcrumb.html(tmplBreadcrumb({ titles: titles }));

      // Fire an event when the title changes so that (e.g.) the container
      // page can update its title.
      this.trigger('changeTitle', this, topLayer.title, _.map(titles, function (l) { return l.title; }));


      // Set up the handler that navigates through the breadcrumbs when we
      // click on them.
      // TODO: Can this be moved? Also, we probably don't have to reapply
      // this every time we update the breadcrumb.
      // function breadcrumbHandler (event) {
      //   event.stopPropagation();
      //   event.preventDefault();

      //   var index = $(event.target).closest('li').attr('data-bv-mbox-layer-index');
      //   var totalLayers = self.layers.length;
      //   self.pop( totalLayers - (index + 1) );
      // }

      // self.$breadcrumb.on('click.bv-mbox-breadcrumb', 'a', breadcrumbHandler);
    },

    // TODO: I hate that this function exists. Figure out a better way to do
    // this.
    _adjustOffset: function (offset) {
      var delta = 0;
      var $stickyHeader = $('#BVStickyHeader');
      var isLightbox = !(this.inline || this.over);
      var isFixed;
      if (isLightbox) {
        // For lightboxes, put some space between the box and the edge of the
        // viewport.
        delta -= 40;
      }

      if (!isLightbox && $stickyHeader.length) {
        // We have to account for the sticky header when we move scroll, or
        // else it will overlap with the box.
        isFixed = $stickyHeader.hasClass('bv-masthead-fixed');
        if (isFixed || offset > $stickyHeader.offset().top) {
          delta -= $stickyHeader.height();
        }
      }

      return offset + delta;
    },


    // Move scroll to the top of the box, or restore a previous scroll value
    // if `topOffset` is provided.
    //
    // Our scrolling behavior is weird. A quick summary:
    //
    // 1. If it's a lightbox, we scroll to the top of the box (without
    //    animation) when it is opened. When it is closed, we restore the
    //    previous scroll position.
    //
    // 2. If it's got an $overElement, or if it's inline, we scroll to the top
    //    of the box (with animation) when it is opened. When it is closed,
    //    we do nothing.
    //
    // 3. If `silentMode` is `true`, we don't scroll at all.
    //
    _moveScroll: function (shouldAnimate, topOffset) {
      var $element;
      var windowScroll;
      if (!this.$container.length) {
        return;
      }

      if (typeof shouldAnimate === 'undefined') {
        shouldAnimate = false;
      }

      if (typeof topOffset === 'undefined') {
        $element = this.inline ? this.$container : this.$overElement || this.$container;

        topOffset = $element.offset().top;
        windowScroll = $window.scrollTop();

        // Adjust the offset to account for special cases. (Ugh.)
        topOffset = this._adjustOffset(topOffset);

        // If we're animating, we should move the overElement to the top of
        // the viewport no matter what, because we want to get as much of the
        // box on the page as possible. Otherwise, all we care about is if
        // the top of the box is visible in the viewport. If it is, we don't
        // need to scroll.
        if (!shouldAnimate && topOffset >= windowScroll) {
          return;
        }
      }

      // Scroll the window so that the top of the box is at the top of the
      // viewport.
      if (shouldAnimate) {
        $('html').add(body()).delay(500).animate({ scrollTop: topOffset });
      }
      else {
        $window.scrollTop(topOffset);
      }
    },

    _fakeInlinePosition: function ($real, $fake) {
      var fakeOffset;
      var fakeOuterWidth;
      var realOuterHeight;
      function sameValues (fakeOffset, fakeOuterWidth, realOuterHeight) {
        if (!this._lastFakeOffset || !this._lastFakeOuterWidth || !this._lastRealOuterHeight) {
          return false;
        }
        if (this._lastFakeOffset.top !== fakeOffset.top || this._lastFakeOffset.left !== fakeOffset.left) {
          return false;
        }
        if (this._lastFakeOuterWidth !== fakeOuterWidth || this._lastRealOuterHeight !== realOuterHeight) {
          return false;
        }

        return true;
      }

      fakeOffset = $fake.offset();
      fakeOuterWidth = $fake.outerWidth(true);
      realOuterHeight = $real.outerHeight(true);

      if (sameValues(fakeOffset, fakeOuterWidth, realOuterHeight)) {
        return;
      }

      // Have the actual container mimic the would-be container's width.
      $real.width(fakeOuterWidth);

      // Make sure the would-be container has been made tall enough to look
      // like it contains the actual container.
      $fake.height(realOuterHeight);

      // Position the actual container so that it looks like it's inside the
      // would-be container.
      $real.css({
        position: 'absolute',
        top: fakeOffset.top,
        left: fakeOffset.left
      });

      // Remember these values for the next time we check.
      this._lastFakeOffset = fakeOffset;
      this._lastFakeOuterWidth = fakeOuterWidth;
      this._lastRealOuterHeight = realOuterHeight;

    },

    // update the state of the box depending on the specific layer options
    _applyLayerConfig: function (layer) {
      // Close button visibiliity
      var showCloseButton = layer.showCloseButton;
      if (!layer.box.hasMultipleLayers() && layer.preventClose) {
        showCloseButton = false;
      }
      layer.box.$mboxClose[(showCloseButton ? 'remove' : 'add') + 'Class']('bv-hidden');
    },


    // PUBLIC METHODS
    // ==============

    hasMultipleLayers: function () {
      // To the outside world, a box should be considered to have multiple
      // layers up until a given layer is done transitioning out. So we don't
      // check the current length of the `this.layers` array; we check if the
      // `bv-mbox-multi` class name is still on the container.
      return this.$layerList.hasClass('bv-mbox-multi');
    },

    // Creates a layer with the passed-in options, then opens the lightbox.
    open: function (cfg) {
      var self = this;

      // We do our rendering outside of the standard view lifecycle, so we
      // need to do our own check to ensure the CSS has loaded before we open
      // a box.
      cssLoadCheck.done(function () { self._open(cfg); });
    },

    _open: function (cfg) {
      var self = this;
      var newLayer = new Layer(cfg, this);
      var appendToBody;
      var resizeHandler;
      var lastSeenHeight;
      var shouldAnimate;
      if (this.opened) {
        BVTracker.error({
          name: str.errors.UI,
          detail1: 'Modestbox Error',
          detail2: 'Box already open'
        });
        return;
      }

      // Remember the initial window scroll offset as early as possible,
      // before any of our DOM changes affect it. If we're moving scroll
      // position for the box, this is where we want scroll to return when
      // the box is closed.
      this._originalScroll = null;
      if (!newLayer.silentMode) {
        // Remember the existing scroll position.
        this._originalScroll = $window.scrollTop();
      }

      // We need to copy some of the layer's options over to the box.

      // Is there a specific URL we should return to on close?
      this.closeUrl = newLayer.closeUrl || null;

      // Are we anchoring to a specific element?
      this.$overElement = newLayer.$overElement || null;

      // Are we inline?
      this.inline = newLayer.inline;

      // Should we create an overlay?
      this.overlay = newLayer.overlay;

      // We should append to the body even when a `container` option is
      // specified _except_ under certain circumstances.
      appendToBody = true;
      if (newLayer.inline && newLayer.$container) {
        // We have a container...
        if (newLayer._inForm) {
          // ...but it's in a form, so we must append to the body and
          // _pretend_ we're in that container.
          appendToBody = true;
        }
        else {
          // ...and it's not in a form, so we can append directly to the
          // container.
          appendToBody = false;
        }
      }

      // Render and inject the container.
      this.$container = this._injectContainer({
        bodyAppend: appendToBody,
        inline: newLayer.inline,
        container: newLayer.container,
        overlay: newLayer.overlay
      });

      this.injectionId = 'bv-mbox-' + this.id + '-list';

      // This creates the boilerplate for the layer container. We give it the
      // newly-created layer because some of those options affect the HTML that
      // gets generated.
      this.$viewEl = this._createView(newLayer);

      if (this.$overElement) {
        resizeHandler = (function ($wrapper) {
          return function () {
            var offset = self.$overElement.offset();

            if (self._lastOverOffset && (offset.top === self._lastOverOffset.top) &&
             (offset.left === self._lastOverOffset.left)) {
              return;
            }

            // Adjust the container so that it appears directly over the
            // element in question.
            self.$container.css({ top: offset.top, left: offset.left });
            if (!self.inline) {
              // Unless it's inline, we also want the container's width to
              // match that of the element.
              $wrapper.css({ width: self.$overElement.outerWidth() });
            }
            // Scroll into view after orientation was changed. See CCS-32237.
            if (!isScrolledIntoView(self.$container)) {
              shouldAnimate = self.$overElement || self.inline;
              self._moveScroll(shouldAnimate);
            }
          };
        })(this.$viewEl.find('.bv-mbox-wrapper'));

        resizeHandler();

        $window.on('resize.' + self.id, _.debounce(resizeHandler, 200));
      }

      function isScrolledIntoView (element) {
        var viewTop = $window.scrollTop();
        var viewBottom = viewTop + $window.height();
        var elementOffsetTop = $(element).offset().top;
        var elementOffsetBottom = elementOffsetTop + $(element).height();
        // Use delta as some kind of threshold of sensitivity.
        // Value 40 was taken from _adjustOffset function.
        var delta = ((elementOffsetTop - viewTop) <= 40);

        return ((elementOffsetBottom <= viewBottom) && (elementOffsetTop >= viewTop) && delta);
      }

      this.$breadcrumb = this.$viewEl.find('.bv-mbox-breadcrumb');

      // This element is where the HTML for new layers will get appended.
      this.$layerList = this.$viewEl.find('.bv-mbox-injection-container');


      this.trigger('beforeOpen', this);

      // Inject the HTML we generated into the container.
      this.$container.height('auto').empty().append(this.$viewEl);

      function closeHandler (event) {
        var topLayer;
        event.stopPropagation();
        topLayer = _(self.layers).last();

        // don't close if this is the only layer and we're not supposed to
        if (!self.hasMultipleLayers() && topLayer.preventClose) {
          return;
        }

        if (topLayer && topLayer.closeAll) {
          self.close();
        }
        else {
          self.pop();
        }
      }


      this.$mboxClose.prependTo(this.$viewEl.find('.bv-mbox')).addClass('bv-hidden');

      // When focus is on the close button and Enter is pressed, three
      // events fire in order: keydown, then click, then keyup. In this
      // situation we want keyup to close the window, not click, because
      // click will move focus and cause keyup to happen on whichever
      // element gets focus next.
      (function (self) {
        var closeOnClick = true;

        self.$mboxClose
          .on('click.' + self.id, function (e) {
            if (closeOnClick) {
              closeHandler(e);
            }
          })
          .on('keydown.' + self.id, function (e) {
            if (e.keyCode === specialKeys.ENTER) {
              closeOnClick = false;
            }
          })
          .on('keyup.' + self.id, function (e) {
            if (e.keyCode === specialKeys.ENTER) {
              closeHandler(e);
              closeOnClick = true;
            }
          });
      })(this);


      // TODO: Should we only hook this up when the close button is shown?
      if (!newLayer.inline) {
        // ESC should close the box, *except* ...
        //
        // When a select element in a modestbox has focus, we need to change
        // how we handle the user hitting ESC: if the user is keyboard navigating
        // within the select, we don't want ESC to close the lightbox. Luckily,
        // select elements swallow the keyup event, so when we see a keydown event
        // with ESC, we know that if we see a keyup event with ESC, we must not
        // be in a select.
        //
        // UIA-4394

        $document.on('keydown.' + self.id, function (e) {
          if (e.keyCode !== specialKeys.ESCAPE || self.ignoreKeys) {
            return;
          }

          $document.on('keyup.' + self.id, function (e) {
            if (e.keyCode === specialKeys.ESCAPE) {
              $document.off('keyup.' + self.id);
              closeHandler(e);
            }
          });
        });
      }

      // TODO: We used to do some stuff here if we were on a container page.
      // Wire it up to the `beforeOpen` or `afterOpen` event.
      this.opened = true;

      // We've done all the necessary setup stuff. We're ready to add the new
      // layer to the stack.
      this.push(newLayer);

      // Wait until after we append the new layer to add this class name so
      // that it triggers the scale-up transition on the box.
      this.$container.addClass('bv-mbox-opened');


      if (newLayer.container && newLayer._inForm) {
        // We wanted to inject into a certain element, but because we'd have
        // been injecting inside of another form, we had to append to the body
        // instead. So we need to fake it. Position the box so that it appears
        // to be within the layer's container.

        this._fakeInlinePosition(this.$container, newLayer.$container);
        this.intervalList.add({
          fn: function () {
            // Sometimes we want to force a box to be a certain height.
            if (self.skipResizing) {
              return;
            }
            self._fakeInlinePosition(self.$container, newLayer.$container);
          },
          frequency: 200,
          cleanup: function () {
            newLayer.$container.height('');
          }
        });
      }


      // A layer's view can change in size at any point. We need to monitor it
      // and adjust our size accordingly.
      lastSeenHeight = -1;

      function resize () {
        var layerHeight;
        if (!self.opened || self.layers.length === 0) {
          return;
        }

        // Sometimes we want to force a box to be a certain height.
        if (self.skipResizing) {
          return;
        }

        layerHeight = _(self.layers).last().$target.outerHeight(true);

        if (lastSeenHeight === layerHeight) {
          return;
        }

        lastSeenHeight = layerHeight;

        // The height of the content has changed.
        if ($.importantizer && $.importantizer.state() === 'resolved') {
          self.$layerList.height(layerHeight);
        }
        // If importantizer isn't resolved (likely because DOM ready hasn't
        // fired), fall back to cssText. This will kill any other inline
        // styles on the element.
        else {
          self.$layerList.css('cssText', 'height: ' + layerHeight + 'px !important;');
        }
      }

      resize();

      this.intervalList.add({
        fn: resize,
        frequency: 200
      });

      if (newLayer.silentMode) {
        // Null this out so that we don't try to restore scroll when the box
        // is closed.
        this._originalScroll = null;
      }
      else {
        // If we're floating, animate moving the scroll position to the top of
        // the floating box. If not, then we don't need the animation because
        // the metaphor is one of jumping to a new layer, not moving within an
        // existing layer.
        shouldAnimate = this.$overElement || this.inline;
        this._moveScroll(shouldAnimate);
      }

      this.trigger('afterOpen', this);

      // We don't need `onStackChange` here because it got taken care of when
      // we called `push`.

      // Made full review from "show full review" modestbox focusable and readable by screen readers. See ССS-34281.
      if (this.$viewEl.find('.bv-content-item-author-profile-offset').length) {
        this.$viewEl.find('.bv-content-item-author-profile-offset').addClass('bv-focusable').attr('tabindex', 0);
      }

      return this;
    },

    // Hide the box. Happens when the last layer is popped off the stack, or
    // when a layer specifically tells a box to close even though it's not
    // the last layer.
    close: function () {
      var shouldRestoreScroll;
      if (!this.opened) {
        return this;
      }

      this.intervalList.stopAll();

      this.trigger('beforeClose', this);

      // We're not going to animate. Immediately destroy and dereference all
      // the layers.
      _(this.layers).invoke('destroy');
      this.layers = [];

      this._cleanupContainers();

      this.opened = false;

      $window.off('.' + this.id);
      $document.off('.' + this.id);

      // TODO: Remove BV hash?

      // We only restore scroll position if it's a lightbox.
      shouldRestoreScroll = !(this.$overElement || this.inline);

      if (shouldRestoreScroll && typeof this._originalScroll === 'number') {
        // Restore the original scroll position.
        this._moveScroll(false, this._originalScroll);
        this._originalScroll = null;
      }

      this.trigger('afterClose', this);

      return this;
    },

    // Add a new layer to the top of the box's layer stack.
    push: function (cfg) {
      var newLayer;
      var topLayer;
      if (!this.opened) {
        BVTracker.error({
          name: str.errors.UI,
          detail1: 'Modestbox Error',
          detail2: 'Box not open'
        });
        return;
      }

      newLayer = (cfg instanceof Layer) ? cfg : new Layer(cfg, this);
      topLayer = _(this.layers).last();

      this._addLayer(newLayer);

      // Trigger the animations (roughly) at the same time. This will create
      // the effect of sliding from one layer to another.
      if (topLayer) {
        topLayer._transitionOut('left');
      }

      newLayer.attach();
      newLayer._transitionIn('right');

      // TODO: Handle URL hash?

      // When we push a new layer, scroll to the top.
      this._moveScroll();

      this._onStackChange();
    },

    // Remove the topmost layer (or topmost N layers) from the box's layer
    // stack.
    pop: function (layerCount) {
      if (!layerCount) {
        return this.replace();
      }

      while (layerCount > 0) {
        this.pop();
        layerCount--;
      }

      return this;
    },

    // Replace an the topmost layer with a new layer. If called with no
    // arguments, removes the topmost layer.
    replace: function (replacementCfg) {
      var topLayer;
      var newLayer;
      if (replacementCfg) {
        // If we have a replacement layer, we add it on first because we want
        // it to feel like adding a layer. Only difference is that after we
        // slide to the new layer, we quietly remove the old one from the
        // stack.
        this.push(replacementCfg);
      }

      if (replacementCfg) {
        // We put a new layer on top, so remove what is now the
        // second-from-top layer.
        topLayer = this._removeLayer(this.layers.length - 2);
      }
      else {
        // Just remove the topmost layer.
        topLayer = this._removeLayer();
      }

      if (this.layers.length === 0) {
        // We're out of layers, so we should close the box. But first, we
        // should explicitly destroy the layer we just removed so that the
        // proper events fire.
        topLayer.destroy();
        this.close();
      }
      else if (!replacementCfg) {
        // We still have layers, and there was no replacement layer, so we
        // need to transition back to the previous layer in the stack.
        topLayer._transitionOut('right');
        topLayer.on('afterHide', function (layer) { layer.detach(); });

        newLayer = _(this.layers).last();
        newLayer._transitionIn('left');

        // We need to ensure that `_onStackChange` gets called exactly once.
        // If `replacementCfg` exists, then we've called `push`, which will
        // call `_onStackChange` itself. Otherwise, we'll hit this code path
        // and call it explicitly.
        this._onStackChange();
      }

      return this;
    },

    // If the lightbox is open, push a new layer onto the stack. Otherwise,
    // open the lightbox with this layer at the bottom.
    pushOrOpen: function (cfg) {
      this.opened ? this.push(cfg) : this.open(cfg);
      return this;
    },

    // If the lightbox is open, replace the topmost layer with this layer.
    // Otherwise, open the lightbox with this layer at the bottom.
    replaceOrOpen: function (cfg) {
      this.opened ? this.replace(cfg) : this.open(cfg);
      return this;
    }

  });


  // LAYER
  // =====
  //
  // An individual view within a ModestBox instance. Layers are added and
  // subtracted from the instance's layer collection, and the ModestBox will
  // always show the layer that's on top.
  function Layer (cfg, box) {
    this._configure(cfg, box);

    initFocusManagerForLayer(this);

    this._createInjectionTarget();
  }


  // OPTIONS
  // =======

  Layer.DEFAULT_OPTIONS = {

    // OPTIONS THAT APPLY TO BOXES
    // ---------------------------
    // These are options that affect boxes in one way or another, but we have
    // the box grab them from the layer config for simplicity's sake. In
    // general, none of these will affect the box unless you pass them in a
    // call to `open`; if you call `push` or `replace`, the box is already
    // open, and it has made certain choices that can't reasonably be undone
    // until the box is closed again.
    //
    // (If we didn't do it this way, we'd have to require the developer to
    // separate these options into two different calls: one for the box and
    // one for the layer. Also, it makes good UI sense to ignore conflicting
    // options in subsequent layers, because some options simply can't be
    // changed after the fact, and some options would lead to an awful user
    // experience if we _did_ change them after the fact.)


    // A list of classes to add to the box container. Note that each of these
    // will be prepended with "bv-mbox" -- such that, e.g. ['foo', 'bar']
    // will become "bv-mbox-foo bv-mbox-bar" in the `class` attribute.
    classList: [],

    // An element to associate this box with. If the box is inline, the
    // viewport will scroll to the top of this element when loading. If the
    // box is not inline, it will be positioned so that it is directly above
    // this element and shares its width.
    overElement: null,

    // Whether the box should act like a static element instead of "floating"
    // above content. We accomplish this by injecting the box into the
    // specified `container` element. (If we can't insert the box in that
    // part of the page, we'll fake it with CSS so that it looks that way.)
    inline: false,

    // Whether the box should create an overlay. If `false`, the box won't
    // create an overlay, but will otherwise behave identically. (This is
    // useful because sometimes we want a box to lack an overlay but we don't
    // want it to behave like an inline box.)
    //
    // Note that an inline box won't have an overlay, even if this option is
    // set to `true`.
    overlay: true,

    // An element (DOM node or jQuery object) to inject the box into. This
    // option _only_ applies if `inline` is true; otherwise, we assume it's a
    // lightbox-style thing that occupies a higher layer, and in that case we
    // _must_ append to the body in order to be sure that we'll cover the
    // whole page.
    //
    // For backwards-compatibility reasons, we don't actually inject into the
    // element in question; we try to find an element with a class name of
    // `bv-inline-form-container` and inject into _that_. (We would like to
    // change this behavior at some point.)
    container: null,

    // In normal mode, we scroll the box into the viewport to bring it to the
    // user's attention. In silent mode, we don't.
    silentMode: false,

    // Whether the box should have a `role="dialog"` attribute.
    //
    // This is complicated. The semantics of `role="dialog"` are specific,
    // and the accessibility consultants have told us that we can't simply
    // assume that a given box, even if it's a lightbox, should function as a
    // dialog for ARIA purposes.
    //
    // The presence of `role="dialog"` causes JAWS to enter "application
    // mode", in which the screen reader treats the content less like a web
    // page and more like an app. That means arbitrary content won't get read
    // unless it's somehow part of a form.
    //
    // Therefore, if the purpose of your dialog is to get the user to enter
    // information into a form, and there are no substantial non-form areas
    // of the dialog's content, the `ariaDialog` option should be `true`. If
    // the purpose of your dialog is to show ordinary content, `ariaDialog`
    // should be `false`. If you're not sure, leave it on `false`.
    ariaDialog: false,

    // Where the box should be closeable. This is the case where the box
    // and its contents are the only thing on a page and the box should never
    // close. However, additional layers should be closeable to achive
    // layer-stack navigation.
    preventClose: false,


    // OPTIONS THAT APPLY ONLY TO LAYERS
    // ---------------------------------
    // These are options that affect only the layer, and thus can be
    // different across the layers in a stack.


    // The "target" is the element that the layer's view(s) get injected
    // into. You can optionally specify a class that should be added to this
    // element.
    targetClass: '',

    // Whether to show the close button at the top corner of the box.
    showCloseButton: true,

    // Whether to show a breadcrumb representing all the views on the layer
    // stack. By default, we show just the title of the topmost layer (unless
    // it's absent, in which case we show nothing).
    showBreadcrumb: false,

    // If true, the box will tell the focus manager to auto-focus when the
    // layer is registered. (The particulars of which thing gets auto-focused
    // are up to focus manager to decide.)
    autoFocus: true,

    // If true, closing this layer will close the entire box, whether or not
    // there are any layers underneath. If false, closing this layer will
    // return to the layer below, and will close the box _only_ if there is
    // no such layer.
    closeAll: false,


    // CALLBACKS
    // ---------
    //
    // Since we don't really expose the individual Layer instances to outside
    // code, we map these options to the corresponding events in the layer
    // lifecycle. Each one gets the layer itself as an argument.


    // Fires just before a layer is visible. The layer's HTML is guaranteed
    // to be on the page.
    beforeShow: null,

    // Fires after a layer is visible.
    afterShow: null,

    // Fires when a layer is about to leave the page.
    beforeHide: null,

    // Fires after a layer has left the page. If the layer was animated off
    // the page, this happens before the layer's HTML is removed from the
    // document. If the layer was removed immediately (as happens when a box
    // is closed), this happens _after_ the layer is removed from the
    // document.
    afterHide: null,

    // Fires after a layer detaches. This happens after the `afterHide` event.
    afterDetach: null

  };

  // The different ways that layers slide onto and off of the page.
  Layer.TRANSITIONS = {
    enterFromLeft: function ($el) {
      $el.removeClass('bv-mbox-left').addClass('bv-mbox-current');
    },

    enterFromRight: function ($el) {
      $el.removeClass('bv-mbox-right').addClass('bv-mbox-current');
    },

    exitToLeft: function ($el) {
      $el.removeClass('bv-mbox-current').addClass('bv-mbox-left');
    },

    exitToRight: function ($el) {
      $el.removeClass('bv-mbox-current').addClass('bv-mbox-right');
    }
  };

  _(Layer.prototype).extend(Backbone.Events, {

    // PRIVATE METHODS
    // ===============

    _configure: function (cfg, box) {
      var self = this;
      var config;
      var $inlineForm;
      this.box = box;

      if (cfg.container) {
        this.$container = $(cfg.container);
      }

      if (cfg.overElement) {
        this.$overElement = $(cfg.overElement);
      }
      else {
        this.$overElement = null;
      }

      this.views = cfg.views || [cfg.view];
      if (!this.views) {
        BVTracker.error({
          name: str.errors.UI,
          detail1: 'Modestbox Error',
          detail2: 'No view for layer'
        });
        return;
      }
      delete cfg.views;
      delete cfg.view;

      config = _.extend({}, Layer.DEFAULT_OPTIONS, cfg);

      // Turn the callback options into event listeners.
      _(['beforeShow', 'afterShow', 'beforeHide', 'afterHide', 'afterDetach']).each(function (eventName) {
        if (config[eventName]) {
          // Call the handler in the context of the layer. (We do this for
          // backward compatibility.)
          this.on(eventName, function () { config[eventName].apply(self, arguments); });
        }
      }, this);

      // TODO: Should we be more precise?
      _(this).extend(config);

      if (this.inline) {
        if (!this.$container || this.$container.length === 0) {
          BVTracker.error({
            name: str.errors.UI,
            detail1: 'Modestbox Error',
            detail2: 'An existing container is required for inline mode'
          });

          return;
        }

        if (this.$container.closest('form').length > 0) {
          // The container is within a form. If this view has a form, we can't
          // actually inject it into the container; we've got to append it
          // directly to the body, outside the form, so the browser doesn't get
          // confused. Set a flag now so that the box knows this when it's
          // about to append.
          this._inForm = true;
        }

        $inlineForm = this.$container.find('.bv-inline-form-container');

        // In inline mode, we actually inject into a specific element within
        // the container.
        //
        // TODO: This is a weird, magical exception. Can't this be done
        // elsewhere?
        if ($inlineForm.length) {
          this.container = $inlineForm.get(0);
          this.$container = $inlineForm.first();
        }
      }
    },

    _createInjectionTarget: function () {
      var $target = $('<div class="bv-mbox-injection-target"></div>');
      $target.addClass(this.targetClass || '');
      this.$target = $target;
      return $target;
    },

    _makeTransition: function (type, callback) {
      var willAnimate = this.box.hasMultipleLayers();
      var self = this;
      var $el = this.$target;
      var delayTime;
      // Do the DOM operation that will trigger the given animation.
      Layer.TRANSITIONS[type]($el);

      // If we're animating, fire the callback after animation is done;
      // otherwise fire immediately.
      function done () {
        callback(self, $el);
      }

      delayTime = willAnimate ? TRANSITION_DURATION : OPEN_DURATION;
      _.delay(done, delayTime);
    },

    _transitionIn: function (direction) {
      var $el = this.$target;
      var self = this;
      var type = { left: 'enterFromLeft', right: 'enterFromRight' }[direction];

      // Add this class first. This is the direction the layer will approach from.
      $el.addClass('bv-mbox-' + direction);
      // Reading this property forces the browser to apply all pending style
      // and layout changes. This way, we can add the class name that will
      // trigger the animation without having to do a `setTimeout` call.
      $el[0].offsetHeight;

      this.trigger('beforeShow', this);

      this._makeTransition(type, function (layer, $el) {
        self.trigger('afterShow', self);
      });
    },

    _transitionOut: function (direction) {
      var $el = this.$target;
      var self = this;
      var type = { left: 'exitToLeft', right: 'exitToRight' }[direction];

      this.trigger('beforeHide', this);

      // Reading this property forces the browser to apply all pending style
      // and layout changes. This way, we can add the class name that will
      // trigger the animation without having to do a `setTimeout` call.
      $el[0].offsetHeight;

      self._makeTransition(type, function () {
        self.trigger('afterHide', self);
      });
    },

    // PUBLIC METHODS
    // ==============
    //
    // These get called by the box itself. (This doesn't mean it's a good
    // idea to call them in your own code.)

    attach: function () {
      var box = this.box;
      _(this.views).each(function (view) {
        view.detach();
        view.setElement(this.$target[0]);

        // We're manually rendering the views that were passed in. Either
        // they belong to a component (but are being rendered in a
        // disjoint section of the DOM), or they don't belong to a
        // component. Either way, we know this view needs to manage its
        // own events.
        //
        // Normally, we don't want outside stuff reaching in and telling
        // our views what to do, but it's better to do it here, in one
        // place, than to litter a flag across the dozens of views that
        // use modestbox.
        view._actAsEventManager();

        view.render();

        view.on('close', function () { box.pop(); });
        view.on('scroll', function () { box._moveScroll(); });
      }, this);

      this.$target.appendTo(box.$layerList);
      this._detached = false;
    },

    // Called when a layer is removed after being transitioned out.
    detach: function () {
      var self = this;
      _(this.views).each(function (view) {
        // TODO: Can this be done elsewhere? No reason why modestbox needs to
        // know about RPC channels, of all things.
        if (view.rpc) {
          view.rpc.destroy();
        }

        view.undelegateEvents();
        view.off('close');
        view.off('scroll');
        view.remove();
      });

      this._detached = true;

      _.defer(function () {
        self.trigger('afterDetach', self);
      });
    },

    // Called when a layer is removed immediately without transitioning out.
    // (If it's already transitioned out, use `detach`, or else duplicate
    // events will fire.)
    destroy: function () {
      if (!this._detached) {
        this.trigger('beforeHide', this);
        this.detach();
        this.trigger('afterHide', this);
      }
    }

  });


  // FOCUS MANAGER
  // =============
  //
  // Hook into the layer life-cycle so that we register a new focusable layer
  // when a new box layer appears, and deregister a layer as it's
  // disappearing.
  //

  function registerFocusOnLayer (layer) {
    var injectionId;
    var focusables;
    var $elToFocus;
    if (layer.inline && !layer.showCloseButton) {
      // This is an inline modestbox.
      FocusableView.addFocusablesInline(layer.box.$layerList.find('.bv-focusable'));
      return;
    }

    injectionId = '#' + layer.box.injectionId;

    // This is a regular modestbox.
    // Register a new layer, but be sure to prepend each selector with the
    // box's unique ID in case more than one box is open at once.
    focusables = [
      injectionId + ' .bv-mbox-close.bv-focusable',
      injectionId + ' .bv-mbox-breadcrumb .bv-focusable',
      injectionId + ' .bv-mbox-current .bv-focusable'
    ].join(', ');

    FocusableView.registerFocusableLayer($document, focusables, false, true);
    if (layer.autoFocus) {
      // We search from the first focusable inside the box, rather than
      // inside the layer, because we want to be able to focus the close
      // button if it exists, and it's outside the layer area.
      $elToFocus = layer.box.$viewEl.find('.bv-focusable:first');
      setTimeout(function () {
        FocusableView.moveFocus($elToFocus);
      }, 0);
    }
  }

  function deregisterFocusOnLayer (layer) {
    // While deregistering a focus layer, only move focus when the Modest Box
    // fully closes, and not just when a layer is hidden.
    FocusableView.deregisterFocusableLayer(false, true);
  }

  function initFocusManagerForLayer (layer) {
    layer.on('afterShow', registerFocusOnLayer);
    layer.on('afterHide', deregisterFocusOnLayer);
  }

  return {
    _instances: {},

    // Gets a specific Box instance, creating it first if it doesn't exist
    // yet.
    get: function (id) {
      var instances = this._instances;
      var instance;
      id = id || 'lightbox';
      instance = instances[id];

      if (!instance) {
        instance = new Box(id);
        instances[id] = instance;
      }

      return instance;
    }
  };

});

/* START_TEMPLATE */
BV.define('hbs!contentAvatar',['hbs','vendor/handlebars/runtime', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " <div class=\"bv-content-item-author-profile-offset bv-content-item-author-profile-offset-on\"> ";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "socialAvatar", options) : helperMissing.call(depth0, "ifHasFeature", "socialAvatar", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " <div class=\"bv-content-item-avatar-offset bv-content-item-avatar-offset-on\"> ";
  }

function program6(depth0,data) {
  
  
  return " <div class=\"bv-content-item-avatar-offset bv-content-item-avatar-offset-off\"> ";
  }

  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "inlineProfile", options) : helperMissing.call(depth0, "ifHasFeature", "inlineProfile", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAvatar', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!subjectInfo',['hbs','vendor/handlebars/runtime', 'template/helpers/withIf'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <img class=\"bv-subject-image\" src=\"";
  if (stack1 = helpers.ImageUrl) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.ImageUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\"";
  stack1 = helpers['if'].call(depth0, depth0.Name, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"/> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Brand, options) : helperMissing.call(depth0, "withIf", depth0.Brand, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  if (stack2 = helpers.Name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2);
  return buffer;
  }
function program3(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, depth0.Name, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-subject-name-header\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Brand, options) : helperMissing.call(depth0, "withIf", depth0.Brand, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  if (stack2 = helpers.Name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </span> ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Name, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " - ";
  return buffer;
  }

  buffer += "<div class=\"bv-subject-info\"> ";
  stack1 = helpers['if'].call(depth0, depth0.ImageUrl, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Name, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('subjectInfo', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!brandLogo',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <img class=\"bv-brand-logo-image\" src=\"";
  if (stack1 = helpers.BrandImageLogoURL) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.BrandImageLogoURL; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

  buffer += "<div class=\"bv-brand-logo\"> ";
  stack1 = helpers['if'].call(depth0, depth0.BrandImageLogoURL, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('brandLogo', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentBadgeSummary',['hbs','vendor/handlebars/runtime', 'template/helpers/conditionalContainer', 'template/helpers/equals', 'template/helpers/mountView', 'template/helpers/renderBadge'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.contentType, "Answers", options) : helperMissing.call(depth0, "equals", depth0.contentType, "Answers", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers.each.call(depth0, depth0.OrderedBadges, {hash:{},inverse:self.noop,fn:self.programWithDepth(program5, data, depth1)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.CampaignId, "BVCROWDSOURCE", options) : helperMissing.call(depth0, "equals", depth0.CampaignId, "BVCROWDSOURCE", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "crowdSourcedAnswerBadge", depth0, options) : helperMissing.call(depth0, "mountView", "crowdSourcedAnswerBadge", depth0, options)))
    + " ";
  return buffer;
  }

function program5(depth0,data,depth2) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'badgeId': (depth0.id),
    'badgeType': (depth0.badgeType),
    'iconChar': (depth0.iconChar),
    'msgKey': (depth0.msgKey),
    'msgPack': (depth2.msgpack),
    'msgPrefix': (depth0.msgPrefix)
  }};
  buffer += escapeExpression(((stack1 = helpers.renderBadge),stack1 ? stack1.call(depth0, depth0.Badges, options) : helperMissing.call(depth0, "renderBadge", depth0.Badges, options)))
    + " ";
  return buffer;
  }

  buffer += " "
    + " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-badges-container")
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentBadgeSummary', t);
t.deps = [];
t.tplMountedViews = ['crowdSourcedAnswerBadge'];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!responseFrom',['hbs','vendor/handlebars/runtime', 'template/helpers/equals', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <h4 class=\"bv-content-title\"> ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.ResponseSource, "Review Response", options) : helperMissing.call(depth0, "equals", depth0.ResponseSource, "Review Response", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </h4> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "responseFrom_reviewresponse", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "responseFrom_reviewresponse", depth0.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "responseFrom", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "responseFrom", depth0.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.Type, "clientresponse", options) : helperMissing.call(depth0, "equals", depth0.Type, "clientresponse", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('responseFrom', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview Percentage helper
 */
BV.define('template/helpers/percentage',[
  'vendor/handlebars/runtime',
  'framework/util/bvreporter'
], function (Handlebars, BVReporter) {

  /**
   * Determines what percent a value is out of a range.
   *
   * Rounding occurs in several places.
   * First, decimalPlaces is rounded to the nearest integer.
   * x.0 - x.4 -> x, x.5 - x.9 -> x + 1
   *
   * Second, value is rounded to decimalPlaces places after the decimalPoint
   * decimalPlaces = 1, x.y0 - x.y4 -> x.y, x.y5 - x.y9 -> x.(y + 1)
   *
   * Third, the result is rounded to the nearest integer.
   * x.0 - x.4 -> x, x.5 - x.9 -> x + 1
   *
   * In the event of a numerically invalid value (less than zero) or range
   * (zero or less), zero is returned.
   *
   * Range is NOT rounded.
   *
   * @param  {Number} value         The value whose percentage we will find
   * @param  {Number} range         The range from which the percentage will be determined
   * @param  {Number} decimalPlaces Optional: The number of decimal places to round the value to
   *                                Defaults to 1
   * @param  {Object} options       Optional: An options object
   *                                  rangeStart  {Number} An offset for the entire range. eg, 1 if its 1 to 5
   *                                  offset      {Number} An offset for the return value
   * @return {Number}               The rounded integer percentage
   */
  function percentage (value, range, decimalPlaces, options) {

    // Check arguments
    if (value === void undefined) {
      BVReporter.warn('Percentage helper being called without a value');
      return 0;
    }

    if (value < 0) {
      BVReporter.warn('Percentage helper being called with an invalid value');
      return 0;
    }

    if (range === void undefined) {
      BVReporter.warn('Percentage helper being called without a range');
      return 0;
    }

    if (range <= 0) {
      BVReporter.warn('Percentage helper being called with an invalid range');
      return 0;
    }

    decimalPlaces = decimalPlaces || 1;

    // First, check if hbs passed the options hash as the
    // third 'decimalPlaces' argument
    if (decimalPlaces.hash) {
      options = decimalPlaces;
      decimalPlaces = 1;
    }

    decimalPlaces = Math.round(decimalPlaces);

    // Default values for these arguments
    options = options || {};
    options.hash = options.hash || {};

    // Round the value to the specified number of decimal places
    // Of course, IE's implementation of toFixed is broken and doesn't
    // round correctly, so we have to do that ourselves
    var places = Math.pow(10, decimalPlaces);
    value = Math.round(value * places) / places;

    // Not all ranges are 0 - 5, sliders start at 1. We need to alter
    // the naive formula slightly to deal with this.
    var rangeStart = options.hash.rangeStart || 0;

    // Get the percentage and round it to the nearest int
    var percent = Math.round(((value - rangeStart) / (range - rangeStart)) * 100);

    // If we have an offset, apply it now
    if (options.hash.offset) {
      percent += parseFloat(options.hash.offset);
    }

    return percent;
  }

  Handlebars.registerHelper('percentage', percentage);
  return percentage;
});

/* START_TEMPLATE */
BV.define('hbs!contentStars',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/renderIcon', 'template/helpers/loop', 'template/helpers/ratingIconChar', 'template/helpers/percentage'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-content-rating bv-rating-ratio\" itemprop=\"reviewRating\" itemscope itemtype=\"http://schema.org/Rating\"> <meta itemprop=\"ratingValue\" content=\"";
  if (stack1 = helpers.Rating) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Rating; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <meta itemprop=\"bestRating\" content=\"";
  if (stack1 = helpers.RatingRange) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingRange; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <span class=\"bv-rating-stars-container\"> <abbr title=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_ratingStars", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_ratingStars", depth0.msgpack, depth0, options)))
    + "\" class=\"bv-rating bv-rating-stars bv-rating-stars-off\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-rating-stars-off", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-rating-stars-off", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </abbr> <abbr title=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_ratingStars", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_ratingStars", depth0.msgpack, depth0, options)))
    + "\" class=\"bv-rating-max bv-rating-stars bv-rating-stars-on bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.Rating, depth0.RatingRange, options) : helperMissing.call(depth0, "percentage", depth0.Rating, depth0.RatingRange, options)))
    + "\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-rating-stars-on", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-rating-stars-on", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </abbr> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_ratingStars", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_ratingStars", depth0.msgpack, depth0, options)))
    + "</span> </span> </span> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var stack1, stack2, options;
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.RatingRange, depth0, options) : helperMissing.call(depth0, "loop", depth0.RatingRange, depth0, options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  }
function program3(depth0,data) {
  
  var stack1, options;
  options = {hash:{}};
  return escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "rating-stars-on", options)));
  }

  stack1 = helpers['if'].call(depth0, depth0.Rating, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentStars', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentReference',['hbs','vendor/handlebars/runtime', 'template/helpers/withIf'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Url, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <span class=\"bv-reference-title\"> ";
  stack1 = helpers['if'].call(depth0, depth0.Product, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> ";
  stack1 = helpers['if'].call(depth0, depth0.Url, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a class=\"bv-content-reference-link\" href=\"";
  if (stack1 = helpers.Url) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Url; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" > ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + escapeExpression(((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " ";
  return buffer;
  }

function program8(depth0,data) {
  
  
  return " </a> ";
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Reference, options) : helperMissing.call(depth0, "withIf", depth0.Reference, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentReference', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentTimeAgo',['hbs','vendor/handlebars/runtime', 'template/helpers/ago'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <meta itemprop=\"datePublished\" content=\"";
  options = {hash:{
    'format': ("YYYY-MM-DD")
  }};
  buffer += escapeExpression(((stack1 = helpers.ago),stack1 ? stack1.call(depth0, depth0.LastModeratedTime, options) : helperMissing.call(depth0, "ago", depth0.LastModeratedTime, options)))
    + "\"> ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-datetime\" role=\"presentation\"> <meta itemprop=\"dateCreated\" content=\"";
  options = {hash:{
    'format': ("YYYY-MM-DD")
  }};
  buffer += escapeExpression(((stack1 = helpers.ago),stack1 ? stack1.call(depth0, depth0.SubmissionTime, options) : helperMissing.call(depth0, "ago", depth0.SubmissionTime, options)))
    + "\"> ";
  stack2 = helpers['if'].call(depth0, depth0.LastModeratedTime, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-content-datetime-dot\" aria-hidden=\"true\">&middot;</span> <span class=\"bv-content-datetime-stamp\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ago),stack1 ? stack1.call(depth0, depth0.SubmissionTime, options) : helperMissing.call(depth0, "ago", depth0.SubmissionTime, options)))
    + " &nbsp;</span> </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentTimeAgo', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentMeta',['hbs','vendor/handlebars/runtime','hbs!contentReference', 'hbs!contentAuthorInner', 'hbs!contentTimeAgo', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentReference, 'contentReference', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorInner, 'contentAuthorInner', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-meta-wrapper\"> <div class=\"bv-content-meta\" role=\"presentation\"> <div class=\"bv-content-reference-data bv-content-author-name\"> ";
  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "productImage", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "productImage", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentTimeAgo, 'contentTimeAgo', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentMeta', t);
t.deps = ["contentReference","contentAuthorInner","contentTimeAgo"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * When displaying content turn urls and email addresses into links and double newlines into additional paragraphs
 *
 * We use two regex's to find instances of urls and email addresses which we put together into an array of matching strings.
 * This is done such that the matches are in order, except all email addresses follow urls eg "url1 email1 url2 email2" ->
 * ["url1","url2","email1","email2"]. We do this because urls have a higher priority due to them sometimes containing emails.
 * Taking these matched strings, we trim them down to remove things like surrounding parentheses and ending periods.
 * We then search through the text for these matches one after the next and splice in a link to replace them.
 * We search the whole string and use a mask to indicate what text we've already replaced so similar matches don't clash.
 * The mask is a string of equal length to the text with characters of either 0 or 1. 0 means that it hasn't been modified
 * at this point and 1 would mean that it has. The algorithm goes something like this:
 * Foreach string in matches, find the first match in the text where the substring in the sameplace in the mask contains no 1's.
 * Replace that substring in the text with a link and the substring at the same indices in the mask with all 1's.
 * "We write a fair bit to foo@bar.com on the http://dogsledmonthly.com website. We also like http://sleddogfancy.com but don't think its as good as http://dogsledmonthly.com"
 * "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
 * first match transforms to
 * "We write a fair bit to foo@bar.com on the <a href="http://dogsledmonthly.com">http://dogsledmonthly.com</a> website. We also like http://sleddogfancy.com but don't think its as good as http://dogsledmonthly.com"
 * "000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
 * The reason we use a mask is in case one match matches another match which is obvious if the same link happens twice for
 * example and less so when its coincidental like having an email address in a url. The main reason this is so messy is that
 * we have to go over it at least a second time, but have to prevent ourselves from messing with any parts we've already touched.
 * Technically the code still doesn't handle a valid url that ends in a period but there's not much we can do about that.
 */

BV.define('template/helpers/paragraphize',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {
  var regExp = {
    url: /\(?\b(?:(http|https|ftp):\/\/)+((?:www.)?[a-zA-Z0-9\-\.]+[\.][a-zA-Z]{2,4}|localhost(?=\/)|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::(\d*))?(?=[\s\/,\.\)])([\/]{1}[^\s\?]*[\/]{1})*(?:\/?([^\s\n\?\[\]\{\}\#]*(?:(?=\.)){1}|[^\s\n\?\[\]\{\}\.\#]*)?([\.]{1}[^\s\?\#]*)?)?(?:\?{1}([^\s\n\#\[\]\(\)]*))?([\#][^\s\n]*)?\)?/ig,
    email: /[_a-z0-9\-]+(\.[_a-z0-9\-]+)*@[a-z0-9\-]+(\.[a-z0-9\-]+)*(\.[a-z]{2,4})/ig
  };

  function paragraphize (context, options) {
    if (typeof context === 'string') {
      context = _.escape(context);

      // build up an ordered list of matches with priority to earlier regexes
      // "url1 email1 url2 email2" -> ["url1","url2","email1","email2"]
      if (options.hash.enableLinks) {
        var matches = [];
        _(regExp).chain().values().forEach(function (exp) {
          var findMatches = context.match(exp);
          if (findMatches) {
            matches = matches.concat(findMatches);
          }
        });

        // we need a mask to keep track of where we've already replaced so we don't permute any given segment twice
        var mask = context.replace(/./g, '0');

        // for each match we want to clean it up and replace it with a proper link
        _(matches).forEach(function (m) {

          // disregard enclosing parentheses. This could be done in the regular expression but doubles its length
          if (m.charAt(0) === '(') {
            m = m.slice(1, m.indexOf(')'));
          }
          // No more ending period.
          if (m.charAt(m.length - 1) === '.') {
            m = m.slice(0, m.length - 1);
          }
          // loop through the string looking for a match that we haven't replaced already
          var startIndex = 0;
          while (context.indexOf(m, startIndex) > -1) {
            var index = context.indexOf(m, startIndex);
            if (mask.substring(index, index + m.length).indexOf('1') === -1) {
              var href = (m.indexOf('http') > -1) ?
                          ' href="' + m + '"' :
                          (
                            (m.indexOf('@') > -1) ?
                            ' href="mailto:' + m + '"' :
                            ''
                          );
              href = '<a class="bv-text-link"' + href + '>' + m + '</a>';
              context = context.substring(0, index) + href + context.substring(index + m.length, context.length);
              mask = mask.substring(0, index) + href.replace(/./g, '1') + mask.substring(index + m.length, mask.length);
              startIndex = context.length;
            }
            else {
              // move the starting index up to the next unchanged character after the next changed one.
              startIndex = mask.indexOf('0', mask.indexOf('1', startIndex));
            }
          }
        });
      }

      // wrap things in appropriate paragraph tags
      // handle Unix style of newline breaks
      context = context.split('\n\n').join('</p><p>');
      // handle Windows style of newline breaks
      context = context.split('\r\n\r\n').join('</p><p>');
      return new Handlebars.SafeString('<p>' + context + '</p>');
    }
    // bail on unknown types
    return context;
  }

  Handlebars.registerHelper('paragraphize', paragraphize);
  return paragraphize;
});

/* START_TEMPLATE */
BV.define('hbs!contentTitle',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/ifHasFeature', 'template/helpers/paragraphize'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <h3 class=\"bv-content-title\" itemprop=\"headline\"> ";
  stack1 = helpers['if'].call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0._isPreview, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </h3> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " "
    + " <span class=\"bv-off-screen\"> ";
  options = {hash:{
    'prefix': ("")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "headToHeadSummary", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "headToHeadSummary", depth0.msgpack, depth0, options)))
    + " </span> ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.Title) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryContentLink", options) : helperMissing.call(depth0, "ifHasFeature", "secondaryContentLink", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a class=\"bv-secondary-content-link bv-focusable\" href=\"#\" data-contentId=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (stack1 = helpers.Title) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</a> ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-content-summary-title bv-focusable\" tabindex=\"0\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.paragraphize),stack1 ? stack1.call(depth0, depth0.QuestionDetails, options) : helperMissing.call(depth0, "paragraphize", depth0.QuestionDetails, options)))
    + " </div> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.Title, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.QuestionDetails, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentTitle', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_secondaryContentCommentLink', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function secondaryContentCommentLink( data ) {
try { return (function(d){
var r = "";
r += "comments";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `secondaryContentCommentLink`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_secondaryContentCommentLink', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return secondaryContentCommentLink(data);
});
return secondaryContentCommentLink;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_secondaryContentAnswerLink', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function secondaryContentAnswerLink( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalSecondaryContentCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "answer";
return r;
},
"other" : function(d){
var r = "";
r += "answers";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `secondaryContentAnswerLink`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_secondaryContentAnswerLink', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return secondaryContentAnswerLink(data);
});
return secondaryContentAnswerLink;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!secondaryContentLink',['hbs','vendor/handlebars/runtime', 'template/helpers/exists', 'template/helpers/equals', '_i18n_secondaryContentCommentLink', '_i18n_secondaryContentAnswerLink'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.SecondaryType, "answer", options) : helperMissing.call(depth0, "equals", depth0.SecondaryType, "answer", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-content-title\">";
  if (stack2 = helpers.TotalSecondaryContentCount) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.TotalSecondaryContentCount; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> <span class=\"bv-content-data-label\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.SecondaryType, "comment", options) : helperMissing.call(depth0, "equals", depth0.SecondaryType, "comment", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.SecondaryType, "answer", options) : helperMissing.call(depth0, "equals", depth0.SecondaryType, "answer", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> <meta itemprop=\"interactionCount\" content=\"User";
  if (stack2 = helpers.secondaryContentType) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.secondaryContentType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + ":";
  if (stack2 = helpers.TotalSecondaryContentCount) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.TotalSecondaryContentCount; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"/> ";
  options = {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.SecondaryType, "answer", options) : helperMissing.call(depth0, "equals", depth0.SecondaryType, "answer", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <button type=\"button\" class=\"bv-content-data-count bv-secondary-content-link bv-focusable\" data-contentId=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a class=\"bv-content-data-count bv-secondary-content-link bv-focusable\" tabindex=\"0\" href=\"#\" data-contentId=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_secondaryContentCommentLink),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_secondaryContentCommentLink", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_secondaryContentAnswerLink),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_secondaryContentAnswerLink", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program10(depth0,data) {
  
  
  return " </button> ";
  }

function program12(depth0,data) {
  
  
  return " </a> ";
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.TotalSecondaryContentCount, options) : helperMissing.call(depth0, "exists", depth0.TotalSecondaryContentCount, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('secondaryContentLink', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentDataSummary',['hbs','vendor/handlebars/runtime','hbs!contentBadgeSummary', 'hbs!responseFrom', 'hbs!contentStars', 'hbs!contentMeta', 'hbs!contentTitle', 'hbs!secondaryContentLink', 'template/helpers/notEqual', 'template/helpers/ifHasFeature', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentBadgeSummary, 'contentBadgeSummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentStars, 'contentStars', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryContentLink", options) : helperMissing.call(depth0, "ifHasFeature", "secondaryContentLink", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.secondaryContentLink, 'secondaryContentLink', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-data-summary\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.contentType, "Comments", options) : helperMissing.call(depth0, "notEqual", depth0.contentType, "Comments", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-content-header-meta\"> ";
  stack2 = self.invokePartial(partials.responseFrom, 'responseFrom', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "stars", options) : helperMissing.call(depth0, "ifHasFeature", "stars", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentMeta, 'contentMeta', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.contentType, "Comments", options) : helperMissing.call(depth0, "equals", depth0.contentType, "Comments", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-content-title-container\"> ";
  stack2 = self.invokePartial(partials.contentTitle, 'contentTitle', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  stack2 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentDataSummary', t);
t.deps = ["contentBadgeSummary","responseFrom","contentStars","contentMeta","contentTitle","secondaryContentLink"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/unlessHasFeature',[
  'vendor/handlebars/runtime'
], function (Handlebars) {

  function unlessHasFeature () {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];
    var fn = options.fn, inverse = options.inverse;
    options.fn = inverse;
    options.inverse = fn;

    return Handlebars.helpers.ifHasFeature.apply(this, args);
  }

  Handlebars.registerHelper('unlessHasFeature', unlessHasFeature);
  return unlessHasFeature;
});

/* START_TEMPLATE */
BV.define('hbs!contentHeader',['hbs','vendor/handlebars/runtime','hbs!subjectInfo', 'hbs!brandLogo', 'hbs!contentAuthorIcon', 'hbs!contentDataSummary', 'template/helpers/ifHasFeature', 'template/helpers/unlessHasFeature', 'template/helpers/withIf'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(9, program9, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "productImage", options) : helperMissing.call(depth0, "ifHasFeature", "productImage", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Reference, options) : helperMissing.call(depth0, "withIf", depth0.Reference, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.ImageUrl, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.subjectInfo, 'subjectInfo', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.ImageUrl), {hash:{},inverse:self.noop,fn:self.program(7, program7, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.subjectInfo, 'subjectInfo', depth0.Product, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.IsBrandAnswer, {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.brandLogo, 'brandLogo', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(13, program13, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "inlineProfile", options) : helperMissing.call(depth0, "unlessHasFeature", "inlineProfile", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program13(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "socialAvatar", options) : helperMissing.call(depth0, "ifHasFeature", "socialAvatar", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-author-avatar\"> ";
  stack1 = self.invokePartial(partials.contentAuthorIcon, 'contentAuthorIcon', depth0.Author, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-header\"> ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentDataSummary, 'contentDataSummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentHeader', t);
t.deps = ["subjectInfo","brandLogo","contentAuthorIcon","contentDataSummary"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_contentProsLabel', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function contentProsLabel( data ) {
try { return (function(d){
var r = "";
r += "Pros:";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `contentProsLabel`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_contentProsLabel', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return contentProsLabel(data);
});
return contentProsLabel;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_contentConsLabel', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function contentConsLabel( data ) {
try { return (function(d){
var r = "";
r += "Cons:";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `contentConsLabel`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_contentConsLabel', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return contentConsLabel(data);
});
return contentConsLabel;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentData',['hbs','vendor/handlebars/runtime','hbs!contentRecommended', 'hbs!contentMediaList', 'hbs!contentSyndicationSummary', 'hbs!contentProductFamilySummary', 'template/helpers/conditionalContainer', 'template/helpers/ifHasFeature', 'template/helpers/eachWithSeparator', '_i18n_contentProsLabel', '_i18n_contentConsLabel'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "prosCons", options) : helperMissing.call(depth0, "ifHasFeature", "prosCons", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-content-product-questions\"> ";
  stack2 = helpers.each.call(depth0, depth0.ProductQuestionsList, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  options = {hash:{},inverse:self.noop,fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "tags", options) : helperMissing.call(depth0, "ifHasFeature", "tags", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "recommended", options) : helperMissing.call(depth0, "ifHasFeature", "recommended", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " ";
  stack2 = self.invokePartial(partials.contentMediaList, 'contentMediaList', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers.unless.call(depth0, depth0.isSearchResult, {hash:{},inverse:self.noop,fn:self.program(16, program16, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Pros, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Cons, {hash:{},inverse:self.noop,fn:self.program(7, program7, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dl class=\"bv-content-data-pros\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-icon\" aria-hidden=\"true\">+</span> <span class=\"bv-content-data-label\"> "
    + " ";
  if (stack1 = helpers._i18n_contentProsLabel) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_contentProsLabel; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> </dt> ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.eachWithSeparator),stack1 ? stack1.call(depth0, depth0.Pros, ",", options) : helperMissing.call(depth0, "eachWithSeparator", depth0.Pros, ",", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dd class=\"bv-content-data-value\">"
    + escapeExpression(((stack1 = depth0.content),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + escapeExpression(((stack1 = depth0.separator),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</dd> ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dl class=\"bv-content-data-cons\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-icon\" aria-hidden=\"true\">-</span> <span class=\"bv-content-data-label\"> "
    + " ";
  if (stack1 = helpers._i18n_contentConsLabel) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_contentConsLabel; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> </dt> ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.eachWithSeparator),stack1 ? stack1.call(depth0, depth0.Cons, ",", options) : helperMissing.call(depth0, "eachWithSeparator", depth0.Cons, ",", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dl class=\"bv-content-data-product-questions\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-label\">"
    + escapeExpression(((stack1 = depth0.Label),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> </dt> <dd class=\"bv-content-data-value\">"
    + escapeExpression(((stack1 = depth0.Value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</dd> </dl> ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-content-tag-dimensions\"> ";
  stack1 = helpers.each.call(depth0, depth0.TagDimensionsList, {hash:{},inverse:self.noop,fn:self.program(12, program12, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dl class=\"bv-content-data-tag-dimensions\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-icon\" aria-hidden=\"true\">#</span> <span class=\"bv-content-data-label\">"
    + escapeExpression(((stack1 = depth0.Label),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> </dt> ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.eachWithSeparator),stack1 ? stack1.call(depth0, depth0.Values, ",", options) : helperMissing.call(depth0, "eachWithSeparator", depth0.Values, ",", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentRecommended, 'contentRecommended', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-data-syndication")
  },inverse:self.noop,fn:self.program(17, program17, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program17(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "reviewAttribution", options) : helperMissing.call(depth0, "ifHasFeature", "reviewAttribution", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.IsSyndicated, {hash:{},inverse:self.noop,fn:self.program(19, program19, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.IsFromProductFamily, {hash:{},inverse:self.noop,fn:self.program(21, program21, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentSyndicationSummary, 'contentSyndicationSummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program21(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentProductFamilySummary, 'contentProductFamilySummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("content-data")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentData', t);
t.deps = ["contentRecommended","contentMediaList","contentSyndicationSummary","contentProductFamilySummary"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_recommendsProduct', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function recommendsProduct( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "I recommend this product.";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `recommendsProduct`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_recommendsProduct', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return recommendsProduct(data);
});
return recommendsProduct;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_notRecommendProduct', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function notRecommendProduct( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "I do not recommend this product.";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `notRecommendProduct`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_notRecommendProduct', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return notRecommendProduct(data);
});
return notRecommendProduct;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentRecommended',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/equals', '_i18n_recommendsProduct', '_i18n_notRecommendProduct'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dl class=\"bv-content-data-recommend-yes\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-icon\" aria-hidden=\"true\">&#10004;</span> <span class=\"bv-content-data-label\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "ProductIsRecommended", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "ProductIsRecommended", depth1.msgpack, depth0, options)))
    + "</span>, </dt> <dd class=\"bv-content-data-value\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_recommendsProduct),stack1 ? stack1.call(depth0, depth0.Author, options) : helperMissing.call(depth0, "_i18n_recommendsProduct", depth0.Author, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dd> </dl> ";
  return buffer;
  }

function program3(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dl class=\"bv-content-data-recommend-no\"> <dt class=\"bv-content-data-label-container\"> <span class=\"bv-content-data-icon\" aria-hidden=\"true\">&#10008;</span> <span class=\"bv-content-data-label\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "ProductIsNotRecommended", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "ProductIsNotRecommended", depth1.msgpack, depth0, options)))
    + "</span>, </dt> <dd class=\"bv-content-data-value\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_notRecommendProduct),stack1 ? stack1.call(depth0, depth0.Author, options) : helperMissing.call(depth0, "_i18n_notRecommendProduct", depth0.Author, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dd> </dl> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.IsRecommended, {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.IsRecommended, false, options) : helperMissing.call(depth0, "equals", depth0.IsRecommended, false, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentRecommended', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentMediaList',['hbs','vendor/handlebars/runtime', 'template/helpers/conditionalContainer', 'template/helpers/extmsg', 'template/helpers/ago', 'template/helpers/ensureProtocolRelative'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Videos, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Photos, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.each.call(depth0, depth0.Videos, {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li role=\"presentation\" class=\"bv-media-item bv-media-item-video bv-focusable\" tabindex=\"0\" data-bv-mediatype=\"Videos\" data-bv-media-id=\"";
  if (stack1 = helpers.VideoId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.VideoId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" itemprop=\"video\" itemscope itemtype=\"http://schema.org/VideoObject\"> <div class=\"bv-media-item-wrapper\"> <div class=\"bv-media-item-spinner-container\"> <div class=\"bv-media-item-spinner\"></div> </div> "
    + " <a class=\"bv-image-wrapper bv-focusable\" tabindex=\"0\" href=\"#\"> <span aria-hidden=\"true\" class=\"bv-media-item-icon bv-video-item-icon\">&#9658;</span> <span class=\"bv-off-screen\">";
  if (stack1 = helpers.Caption) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Caption; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_play_media", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_play_media", depth1.msgpack, depth0, options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_showMediaModalNotice", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_showMediaModalNotice", depth1.msgpack, depth0, options)))
    + " </span> <meta itemprop=\"thumbnail\" content=\"//img.youtube.com/vi/";
  if (stack2 = helpers.VideoId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.VideoId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "/0.jpg\"> <meta itemprop=\"thumbnailURL\" content=\"http://img.youtube.com/vi/";
  if (stack2 = helpers.VideoId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.VideoId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "/0.jpg\"> <meta itemprop=\"description\" content=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <meta itemprop=\"name\" content=\"";
  if (stack2 = helpers.VideoId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.VideoId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <meta itemprop=\"uploadDate\" content=\"";
  options = {hash:{
    'format': ("YYYY-MM-DD")
  }};
  buffer += escapeExpression(((stack1 = helpers.ago),stack1 ? stack1.call(depth0, depth1.SubmissionTime, options) : helperMissing.call(depth0, "ago", depth1.SubmissionTime, options)))
    + "\"> <img ";
  stack2 = helpers['if'].call(depth0, depth1.lazyLoad, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "src=\"//img.youtube.com/vi/";
  if (stack2 = helpers.VideoId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.VideoId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "/0.jpg\" alt=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" title=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </a> </div> <span class=\"bv-media-item-border\" role=\"presentation\"></span> </li> ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return "class=\"bv-media-item-lazyload\" data-";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.each.call(depth0, depth0.Photos, {hash:{},inverse:self.noop,fn:self.programWithDepth(program7, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li role=\"presentation\" class=\"bv-media-item bv-media-item-photo bv-focusable\" tabindex=\"0\" data-bv-mediatype=\"Photos\" data-bv-media-id=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" itemprop=\"image\" itemscope itemtype=\"http://schema.org/ImageObject\"> <div class=\"bv-media-item-wrapper\"> <div class=\"bv-media-item-spinner-container\"> <div class=\"bv-media-item-spinner\"></div> </div> "
    + " <a class=\"bv-image-wrapper bv-focusable\" tabindex=\"0\" href=\"#\"> <meta itemprop=\"image\" content=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.normal)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options) : helperMissing.call(depth0, "ensureProtocolRelative", ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.normal)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options)))
    + "\"> <meta itemprop=\"thumbnail\" content=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.thumbnail)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options) : helperMissing.call(depth0, "ensureProtocolRelative", ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.thumbnail)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options)))
    + "\"> <meta itemprop=\"description\" content=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <span class=\"bv-off-screen\">";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_photo", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_photo", depth1.msgpack, depth0, options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_showMediaModalNotice", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_showMediaModalNotice", depth1.msgpack, depth0, options)))
    + " </span> <img ";
  stack2 = helpers['if'].call(depth0, depth1.lazyLoad, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "src=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.normal)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options) : helperMissing.call(depth0, "ensureProtocolRelative", ((stack1 = ((stack1 = depth0.Sizes),stack1 == null || stack1 === false ? stack1 : stack1.normal)),stack1 == null || stack1 === false ? stack1 : stack1.Url), options)))
    + "\" alt=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" title=\"";
  if (stack2 = helpers.Caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </a> </div> <span class=\"bv-media-item-border\" role=\"presentation\"></span> </li> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("ul"),
    'classList': ("content-media-container"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentMediaList', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!syndicationLogo',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a href=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.ContentLink)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"><img class=\"bv-brand-logo-image\" src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.LogoImageUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" alt=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.Name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/></a> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <img class=\"bv-brand-logo-image\" src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.LogoImageUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" alt=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.Name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

  buffer += "<div class=\"bv-brand-logo\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.ContentLink), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('syndicationLogo', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentSyndicationSummary',['hbs','vendor/handlebars/runtime','hbs!syndicationLogo', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <div class=\"bv-syndication-summary\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.LogoImageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.ContentLink), {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.syndicationLogo, 'syndicationLogo', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-badge-syndicated\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "syndicationText", depth0.msgpack, depth0.SyndicationSource, options) : helperMissing.call(depth0, "extmsg", "syndicationText", depth0.msgpack, depth0.SyndicationSource, options)))
    + "</span> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-badge-syndicated\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "syndicationTextNoLink", depth0.msgpack, depth0.SyndicationSource, options) : helperMissing.call(depth0, "extmsg", "syndicationTextNoLink", depth0.msgpack, depth0.SyndicationSource, options)))
    + "</span> ";
  return buffer;
  }

  buffer += " "
    + " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SyndicationSource),stack1 == null || stack1 === false ? stack1 : stack1.Name), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentSyndicationSummary', t);
t.deps = ["syndicationLogo"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentProductFamilySummary',['hbs','vendor/handlebars/runtime', 'template/helpers/withIf', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Name, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth1)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth2) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-product-family-summary\"> ";
  stack1 = helpers['if'].call(depth0, depth0.Url, {hash:{},inverse:self.programWithDepth(program5, data, depth0, depth2),fn:self.programWithDepth(program3, data, depth0, depth2)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }
function program3(depth0,data,depth1,depth3) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-badge-product-family\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "productFamilyText", depth3.msgpack, depth1, options) : helperMissing.call(depth0, "extmsg", "productFamilyText", depth3.msgpack, depth1, options)))
    + "</span> ";
  return buffer;
  }

function program5(depth0,data,depth1,depth3) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-badge-product-family\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "productFamilyTextNoLink", depth3.msgpack, depth1, options) : helperMissing.call(depth0, "extmsg", "productFamilyTextNoLink", depth3.msgpack, depth1, options)))
    + "</span> ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Reference, options) : helperMissing.call(depth0, "withIf", depth0.Reference, options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  });
Handlebars.registerPartial('contentProductFamilySummary', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/eachWithSeparator',['vendor/handlebars/runtime'], function (Handlebars) {

  function eachWithSeparator (context, separator, options) {
    var fn = options.fn, inverse = options.inverse;
    var ret = '';
    var currentContext;

    if (context && context.length > 0) {
      for (var i = 0, j = context.length; i < j; i++) {
        currentContext = {
          content: context[i],
          separator: ''
        };
        if ((j > 1) && i !== (j - 1)) {
          currentContext.separator = separator;
        }
        ret = ret + fn(currentContext);
      }
    } else {
      ret = inverse(this);
    }
    return ret;
  }

  Handlebars.registerHelper('eachWithSeparator', eachWithSeparator);
  return eachWithSeparator;
});

/* START_TEMPLATE */
BV.define('hbs!contentBody',['hbs','vendor/handlebars/runtime','hbs!contentData', 'template/helpers/ifHasFeature', 'template/helpers/schemaType', 'template/helpers/equals', 'template/helpers/paragraphize', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(5, program5, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryRatings", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "secondaryRatings", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0._ReferenceHasSecondaryRatings, {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " <div class=\"bv-content-details-offset-on\"> ";
  }

function program5(depth0,data) {
  
  
  return " <div class=\"bv-content-details-offset-off\"> ";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-content-summary-body-text\" ";
  stack1 = helpers['if'].call(depth0, depth0.translationActive, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "> ";
  options = {hash:{},inverse:self.program(15, program15, data),fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.Type, "clientresponse", options) : helperMissing.call(depth0, "equals", depth0.Type, "clientresponse", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.translationActive, {hash:{},inverse:self.noop,fn:self.program(22, program22, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "lang=\"";
  if (stack1 = helpers.translationLanguageCode) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.translationLanguageCode; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.ResponseSource, "Review Response", options) : helperMissing.call(depth0, "equals", depth0.ResponseSource, "Review Response", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.Text) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'enableLinks': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.paragraphize),stack1 ? stack1.call(depth0, depth0.Text, options) : helperMissing.call(depth0, "paragraphize", depth0.Text, options)))
    + " ";
  return buffer;
  }

function program15(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.isSearchResult, {hash:{},inverse:self.program(18, program18, data),fn:self.program(16, program16, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.paragraphize),stack1 ? stack1.call(depth0, depth0.shortText, options) : helperMissing.call(depth0, "paragraphize", depth0.shortText, options)))
    + " ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.IsBrandAnswer, {hash:{},inverse:self.program(19, program19, data),fn:self.program(13, program13, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(20, program20, data),fn:self.program(13, program13, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.CampaignId, "BV_QA_PORTAL_ANSWER_MANAGEMENT", options) : helperMissing.call(depth0, "equals", depth0.CampaignId, "BV_QA_PORTAL_ANSWER_MANAGEMENT", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program20(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.paragraphize),stack1 ? stack1.call(depth0, depth0.Text, options) : helperMissing.call(depth0, "paragraphize", depth0.Text, options)))
    + " ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-translated-by-google\"> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translateContentAttribution", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translateContentAttribution", depth0.msgpack, depth0, options)))
    + " </span> </span> ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  stack1 = helpers['if'].call(depth0, depth0.translationPending, {hash:{},inverse:self.program(27, program27, data),fn:self.program(25, program25, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " "
    + " <a class=\"bv-text-link bv-content-summary-translate-btn\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translateContentPending", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translateContentPending", depth0.msgpack, depth0, options)))
    + " </a> ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.translationFailed, {hash:{},inverse:self.program(30, program30, data),fn:self.program(28, program28, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program28(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " "
    + " <div class=\"bv-translation-message\"> <span class=\"bv-translation-message-text\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translateContentFailure", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translateContentFailure", depth0.msgpack, depth0, options)))
    + " </span> <a class=\"bv-text-link bv-content-summary-translate-btn bv-focusable\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translateContentRetry", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translateContentRetry", depth0.msgpack, depth0, options)))
    + " </a> </div> ";
  return buffer;
  }

function program30(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.translationActive, {hash:{},inverse:self.program(33, program33, data),fn:self.program(31, program31, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program31(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " "
    + " <a class=\"bv-text-link bv-content-summary-translate-btn bv-focusable\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_untranslateContent", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_untranslateContent", depth0.msgpack, depth0, options)))
    + " </a> ";
  return buffer;
  }

function program33(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " "
    + " <a class=\"bv-text-link bv-content-summary-translate-btn bv-focusable\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translateContent", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translateContent", depth0.msgpack, depth0, options)))
    + " </a> ";
  return buffer;
  }

  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.program(5, program5, data),fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <div class=\"bv-content-summary\"> <div class=\"bv-content-summary-body\" itemprop=\"";
  options = {hash:{
    'answer': ("text"),
    'comment': ("text"),
    'review': ("reviewBody"),
    'def': ("text")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> ";
  stack2 = helpers['if'].call(depth0, depth0.Text, {hash:{},inverse:self.noop,fn:self.program(7, program7, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.translatable, {hash:{},inverse:self.noop,fn:self.program(24, program24, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentData, 'contentData', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentBody', t);
t.deps = ["contentData"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview Slider width helper
 */
BV.define('template/helpers/sliderUnitWidth',[
  'vendor/handlebars/runtime',
  'framework/util/bvreporter'
], function (Handlebars, BVReporter) {

  /**
   *  Figures out a CSS width value for a slider unit based on how many units
   *  are in the range.
   *
   *  This is separate from the `percentage` helper because that was designed
   *  to return a value rounded to the nearest integer, and that doesn't work
   *  for CSS width values.
   *
   *  Called with one argument, it gives the width of a gauge segment. For
   *  example, if we have seven notches on a gauge, we need to define six
   *  segments, so we'll call {{sliderUnitWidth 6}} in the template, and we'll
   *  receive `16.667` as the value. Which means that each segment should have
   *  a CSS `width` value of `16.667%`.
   *
   *  Called with two arguments, it figures out where a marker needs to be on
   *  the gauge. So if we have seven notches, and the marker should be at 4.8,
   *  we'll call {{sliderUnitWidth 7 4.8}} and end up with `63.335`, meaning
   *  the marker should have a CSS `width` value of `63.335%`.
   *
   *  I know it's weird that the `total` argument represents slightly different
   *  things depending on how many arguments it was called with, but I can't
   *  do that math in the Handlebars template itself, and the alternative of
   *  creating _two_ helpers seemed slightly more evil.
   *
   * @param  {Number} total     As the lone argument, the number of gauge
   *                            segments. As the first argument of two, the
   *                            number of gauge notches.
   * @param  {Number} progress  Optional; the value on the gauge that should
   *                            be rendered.
   * @return {Number}           A number (rounded to five significant figures)
   *                            that represents a percentage out of 100.
   *                            Designed to be used immediately as a CSS
   *                            percentage value.
   */

  // TODO: In theory, we can run into a scenario where we have segments whose
  // widths add up to more than 100%. For instance, when there are six
  // segments, each with a width of 16.667%, that'll give us a total width of
  // 100.002%. Browsers seem to be nimble enough not to wrap the sliders to a
  // second line in this case even though we've gone slightly over our width
  // budget. If that changes, we'll need to write logic to give the widths a
  // very small fudge factor -- small enough not to be noticeable to the
  // naked eye.
  function sliderUnitWidth (total, progress) {
    var SIGNIFICANT_FIGURES = 5;

    // Rounds to five significant figures, then multiplies by 100 to give us
    // a percentage integer.
    function roundOff (value) {
      var places = Math.pow(10, SIGNIFICANT_FIGURES);
      value = Math.round(value * places) / places;
      return value * 100;
    }

    var returnValue;

    if (arguments.length <= 1) {
      // We were given no arguments, so we can't proceed. (Options is always the last argument.)
      BVReporter.warn('sliderUnitWidth helper being called without a value');
      return;
    }
    else if (arguments.length === 2) {
      // We gave one argument (options is always the last argument). Hence
      // we're asking for how wide each individual gauge unit should be.
      returnValue = roundOff(1 / total);
    }
    else {
      // We gave two arguments. Hence we're asking where to place the marker
      // on the gauge.
      //
      // The gauge value starts at 1, not 0, so we subtract 1 from
      // `progress`. This makes a `progress` value of `1` return `0`, which
      // is where it should be on the gauge.
      //
      // We also subtract 1 from `total` so that we're aligned with the
      // number of segments on the gauge. This makes a `progress` value of 5
      // (when there are 5 notches) properly return `100` instead of `80`.
      returnValue = roundOff((progress - 1) / (total - 1));
      // returnValue = (widthOfOneUnit(total - 1) * (progress - 1));
    }

    return returnValue;
  }

  Handlebars.registerHelper('sliderUnitWidth', sliderUnitWidth);
  return sliderUnitWidth;
});

/* START_TEMPLATE */
BV.define('hbs!contentSliderDisplay',['hbs','vendor/handlebars/runtime', 'template/helpers/loop', 'template/helpers/sliderUnitWidth', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "<li class=\"bv-content-slider-segment bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.sliderUnitWidth),stack1 ? stack1.call(depth0, depth0.total, options) : helperMissing.call(depth0, "sliderUnitWidth", depth0.total, options)))
    + "\" role=\"presentation\"></li>";
  return buffer;
  }

  buffer += "<span class=\"bv-content-slider-container\"> <ul class=\"bv-content-slider-bar\" role=\"presentation\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.SliderSegments, options) : helperMissing.call(depth0, "loop", depth0.SliderSegments, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> <span class=\"bv-content-slider-halfway\"></span> <div class=\"bv-content-slider-value-container\"> <span class=\"bv-content-slider-value\" data-bv-margin-from-stats=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.sliderUnitWidth),stack1 ? stack1.call(depth0, depth0.ValueRange, depth0.Value, options) : helperMissing.call(depth0, "sliderUnitWidth", depth0.ValueRange, depth0.Value, options)))
    + "\"></span> </div> </span> <span class=\"bv-content-slider-sublabel1\" aria-describedby=\"";
  if (stack2 = helpers.uniqueId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.uniqueId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-sublabel1\" aria-hidden=\"true\"> ";
  if (stack2 = helpers.MinLabel) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.MinLabel; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </span> <span class=\"bv-off-screen\" id=\"";
  if (stack2 = helpers.uniqueId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.uniqueId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-sublabel1\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offScreenContentSecondaryValueOfOneMeans", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offScreenContentSecondaryValueOfOneMeans", depth0.msgpack, depth0, options)))
    + " ";
  if (stack2 = helpers.MinLabel) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.MinLabel; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> <span class=\"bv-content-slider-sublabel2\" aria-describedby=\"";
  if (stack2 = helpers.uniqueId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.uniqueId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-sublabel2\" aria-hidden=\"true\"> ";
  if (stack2 = helpers.MaxLabel) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.MaxLabel; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </span> <span class=\"bv-off-screen\" id=\"";
  if (stack2 = helpers.uniqueId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.uniqueId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-sublabel2\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offScreenContentSecondaryValueMaxMeans", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offScreenContentSecondaryValueMaxMeans", depth0.msgpack, depth0, options)))
    + " ";
  if (stack2 = helpers.MaxLabel) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.MaxLabel; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> <span class=\"bv-off-screen\"> ";
  if (stack2 = helpers.Label) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Label; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + ", ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offScreenSecondaryRating", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offScreenSecondaryRating", depth0.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  });
Handlebars.registerPartial('contentSliderDisplay', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview Template helper to render a slider for display
 */
BV.define('template/helpers/renderSlider',['vendor/handlebars/runtime', 'hbs!contentSliderDisplay', 'underscore'], function (Handlebars, template, _) {

  function renderSlider (msgpack, context) {
    // We need to render a slider but there's some context that gets lost when
    // invoking partial templates and some that is different between secondary
    // rating lists and secondary ratings summary. Hence we will have a helper
    // to consolidate context and simplify the template and its invocation.
    var outputString;
    // standardize the msgpack
    var standardizedMsgpack = _.extend({}, {
      offScreenContentSecondaryValueOfOneMeans: msgpack.offscreen_secondary_rating_summary_value_of_one_means,
      offScreenContentSecondaryValueMaxMeans: msgpack.offscreen_secondary_rating_summary_value_max_means,
      offScreenSecondaryRating: msgpack.offscreen_secondary_rating_summary
    }, msgpack);

    // standardize the context
    var standardizedContext = _.extend({}, {
      Value: context.AverageRating,
      ValueRange: context.RatingRange,
      msgpack: standardizedMsgpack,
      // pass over a unique id to resolve issue with JAWS (see CCS-3036)
      uniqueId: _.uniqueId('bv-rating-aria-description-')
    }, context);

    standardizedContext.SliderSegments = standardizedContext.ValueRange - 1;
    outputString = template(standardizedContext);
    return new Handlebars.SafeString(outputString);
  }

  Handlebars.registerHelper('renderSlider', renderSlider);
  return renderSlider;
});

/* START_TEMPLATE */
BV.define('hbs!contentSecondaryRatingsList',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/equals', 'template/helpers/loop', 'template/helpers/percentage', 'template/helpers/renderSlider'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-secondary-ratings\" role=\"presentation\"> <dl class=\"bv-content-secondary-ratings\"> ";
  stack1 = helpers.each.call(depth0, depth0.SecondaryRatingList, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dl> </div> ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.HideDisplay, {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0, depth1)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dt class=\"bv-content-secondary-ratings-label\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Label)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + "</dt> ";
  options = {hash:{},inverse:self.programWithDepth(program6, data, depth0, depth2),fn:self.programWithDepth(program4, data, depth2)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.DisplayType, "SLIDER", options) : helperMissing.call(depth0, "equals", depth0.DisplayType, "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data,depth3) {
  
  var buffer = "", stack1, options;
  buffer += " <dd class=\"bv-content-slider\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.renderSlider),stack1 ? stack1.call(depth0, depth3.msgpack, depth0, options) : helperMissing.call(depth0, "renderSlider", depth3.msgpack, depth0, options)))
    + " </dd> ";
  return buffer;
  }

function program6(depth0,data,depth1,depth3) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dd class=\"bv-popup-histogram-ratings-bar\"> <span class=\"bv-content-secondary-ratings-container\"> <ul class=\"bv-content-secondary-ratings-bars\" role=\"presentation\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.ValueRange, options) : helperMissing.call(depth0, "loop", depth0.ValueRange, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> <span class=\"bv-content-secondary-ratings-value bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.Value, depth0.ValueRange, 1, options) : helperMissing.call(depth0, "percentage", depth0.Value, depth0.ValueRange, 1, options)))
    + "\"></span> <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Label)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + ", ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_secondary_rating", depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_secondary_rating", depth3.msgpack, depth0, options)))
    + "</span> </span> </dd> ";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return "<li class=\"bv-content-secondary-ratings-bar\" role=\"presentation\"></li>";
  }

  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SecondaryRatingList),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentSecondaryRatingsList', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentSecondaryRatingsInline',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/percentage'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-secondary-ratings\"> <dl class=\"bv-content-secondary-ratings\"> ";
  stack1 = helpers.each.call(depth0, depth0.SecondaryRatingList, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dl> </div> ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <dt class=\"bv-content-secondary-ratings-label\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Label)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + "</dt> <dd class=\"bv-popup-histogram-ratings-bar\"> <span class=\"bv-content-secondary-ratings-container\"> <span class=\"bv-content-secondary-ratings-value bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.Value, depth0.ValueRange, 1, options) : helperMissing.call(depth0, "percentage", depth0.Value, depth0.ValueRange, 1, options)))
    + "\"></span> </span> </dd> ";
  return buffer;
  }

  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.SecondaryRatingList),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentSecondaryRatingsInline', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!content',['hbs','vendor/handlebars/runtime','hbs!contentHeader', 'hbs!contentBody', 'hbs!contentSecondaryRatingsList', 'hbs!contentSecondaryRatingsInline', 'template/helpers/ifHasFeature', 'template/helpers/conditionalContainer'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var stack1, stack2, options;
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryContentLink", options) : helperMissing.call(depth0, "ifHasFeature", "secondaryContentLink", options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  }
function program2(depth0,data) {
  
  
  return "bv-content-core-float";
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryRatings", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "secondaryRatings", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentSecondaryRatingsList, 'contentSecondaryRatingsList', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryRatingsInline", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "secondaryRatingsInline", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentSecondaryRatingsInline, 'contentSecondaryRatingsInline', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-container\"> <div class='bv-content-core ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'> ";
  stack1 = self.invokePartial(partials.contentHeader, 'contentHeader', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentBody, 'contentBody', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-details-container")
  },inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('content', t);
t.deps = ["contentHeader","contentBody","contentSecondaryRatingsList","contentSecondaryRatingsInline"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!previewMessage',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-content-preview-message\" role=\"alert\"> ";
  options = {hash:{
    'prefix': ("contentPreview_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + " </div> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0._isPreview, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });
Handlebars.registerPartial('previewMessage', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentActions',['hbs','vendor/handlebars/runtime', 'template/helpers/conditionalContainer', 'template/helpers/notEqual', 'template/helpers/mountView', 'template/helpers/extmsg', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.contentType, "ClientResponses", options) : helperMissing.call(depth0, "notEqual", depth0.contentType, "ClientResponses", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.translationActive, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "feedback", depth0, options) : helperMissing.call(depth0, "mountView", "feedback", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-translation-disclaimer\"> <button type=\"button\" class=\"bv-translation-disclaimer-btn\"> <span aria-hidden=\"true\">ℹ</span> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentItem_translationTermsButtonLabel", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentItem_translationTermsButtonLabel", depth0.msgpack, depth0, options)))
    + " </button> </div> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.noop,fn:self.program(7, program7, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.IsSyndicated, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  stack1 = helpers.unless.call(depth0, depth0.secondaryContentNotification, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "secondaryContentBtn", options) : helperMissing.call(depth0, "ifHasFeature", "secondaryContentBtn", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("secondary-content-actions-container")
  },inverse:self.noop,fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <button type=\"button\" aria-label=\"";
  options = {hash:{
    'prefix': ("offscreen_content_secondary_btn_"),
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + "\" class=\"bv-content-btn bv-content-secondary-btn bv-focusable\"> ";
  options = {hash:{
    'prefix': ("content_secondary_btn_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + " </button> ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("content-actions-container active-feedback")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-actions-container")
  },inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentActions', t);
t.deps = [];
t.tplMountedViews = ['feedback'];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentItem',['hbs','vendor/handlebars/runtime','hbs!contentAvatar', 'hbs!content', 'hbs!previewMessage', 'hbs!contentActions', 'hbs!inlineFormContainer', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/renderIcon', 'template/helpers/mountView', 'template/helpers/ifHasFeature', 'template/helpers/withIf', 'template/helpers/equals', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.isRelatedQuestion, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "inlineProfile", depth0, options) : helperMissing.call(depth0, "mountView", "inlineProfile", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.program(12, program12, data),fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "productImage", options) : helperMissing.call(depth0, "ifHasFeature", "productImage", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.content, 'content', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.previewMessage, 'previewMessage', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentActions, 'contentActions', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.secondaryContentType, "Comments", options) : helperMissing.call(depth0, "equals", depth0.secondaryContentType, "Comments", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(16, program16, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "inlineSubmission", options) : helperMissing.call(depth0, "ifHasFeature", "inlineSubmission", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <a title=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "close", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "close", depth0.msgpack, depth0, options)))
    + "\" class=\"bv-content-item-close bv-focusable\" href=\"#\" onclick=\"return false;\"> ";
  options = {hash:{
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-close", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-close", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </a> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " &#x2718; ";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(10, program10, data),fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Reference, options) : helperMissing.call(depth0, "withIf", depth0.Reference, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.ImageUrl, {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return " <div class=\"bv-content-item-product-image-offset bv-content-item-product-image-offset-on\"> ";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.ImageUrl), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  
  return " <div class=\"bv-content-item-product-image-offset-off\"> ";
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAvatar, 'contentAvatar', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.inlineFormContainer, 'inlineFormContainer', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  
  return " <div class=\"bv-secondary-submission\"> <div class=\"bv-submission bv-fake-submission bv-fake-inline\"> </div> </div> ";
  }

  buffer += " ";
  options = {hash:{
    'tag': ("li"),
    'classList': ("content-item"),
    'dataContentId': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentItem', t);
t.deps = ["contentAvatar","content","previewMessage","contentActions","inlineFormContainer"];
t.tplMountedViews = ['inlineProfile'];
return t;
});
/* END_TEMPLATE */
;
/* eslint-disable quote-props, quotes, max-len */
/**
 * @fileOverview Contains locale-specific translations of Google Translate's
 * disclaimer.
 */
BV.define('bv/util/googleTranslateDisclaimer',[], function GoogleTranslateDisclaimer () {
  // Google's terms require us to make this disclaimer available when machine
  // translation is used on a page. We don't want to localize it the usual way
  // because it should not be editable by clients. So we're copying the pattern
  // we used in `localeMapping.js` — another scenario in which we had to
  // localize strings in a non-editable fashion.

  // NOTE: We have translations for the following languages which do not have
  // corresponding entries in `localeMapping.js`:
  //
  // * Kirghiz; Kyrgyz (Kyrgyzstan)
  // * Mongolian [Cyrillic Script]
  // * Armenian (Armenia)
  // * Hebrew
  // * Georgian (Georgia)
  // * Belarusian
  // * Albanian
  //
  // We're including them nonetheless because there's no compelling reason to
  // leave them out.

  var EN_DEFAULT = "THIS SERVICE MAY CONTAIN TRANSLATIONS POWERED BY GOOGLE. GOOGLE DISCLAIMS ALL WARRANTIES RELATED TO THE TRANSLATIONS, EXPRESS OR IMPLIED, INCLUDING ANY WARRANTIES OF ACCURACY, RELIABILITY, AND ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.";

  var ZH_SIMPLIFIED = "本服务可能包含由 GOOGLE 提供的翻译。GOOGLE 不承担与翻译有关的所有明示或暗示担保，包括对准确性、可靠性的任何担保，以及对适销性、特定用途的适用性和不侵权的任何暗示担保。";

  var ZH_TRADITIONAL = "本服務可能包含 GOOGLE 提供的翻譯服務。GOOGLE 概不承擔與翻譯有關的所有明示或暗示保證，包括對準確性、可靠性的任何保證，以及對適銷性、特定用途的適用性和不侵權的任何暗示保證。";

  var DISCLAIMER_MAPPINGS = {
    // LANGUAGE DEFAULTS
    // =================
    // Since this message's content does not refer to the locale itself, most
    // locales can simply use the generic translation for their language.

    // English
    'en': EN_DEFAULT,
    // Arabic
    'ar': "قد تحتوي هذه الخدمة على ترجمة مدعومة من قِبل GOOGLE. تخلي GOOGLE مسؤوليتها عن جميع الضمانات المتعلقة بالترجمة، الصريح منها أو الضمني، بما في ذلك ضمانات الدقة والموثوقية وأية ضمانات ضمنية لإمكانية العرض في الأسواق والملاءمة لغرض معين وضمانات عدم الانتهاك.",
    // Belarusian
    'be': "ГЭТЫ СЭРВІС МОЖА ЗМЯШЧАЦЬ ПЕРАКЛАДЫ АД GOOGLE. КАМПАНІЯ GOOGLE НЕ ДАЕ НІЯКІХ ЯЎНЫХ АБО НЯЯЎНЫХ ГАРАНТЫЙ АДНОСНА ПЕРАКЛАДАЎ, У ТЫМ ЛІКУ АДНОСНА ІХ ДАКЛАДНАСЦІ, НАДЗЕЙНАСЦІ, А ТАКСАМА ЛЮБЫХ НЯЯЎНЫХ ГАРАНТЫЙ АБ МАГЧЫМАСЦІ КАМЕРЦЫЙНАГА ВЫКАРЫСТАННЯ, ПРЫГОДНАСЦІ ДА ПЭЎНЫХ МЭТ І НЕПАРУШЭННЯ ПРАВОЎ.",
    // Bulgarian
    'bg': "АЗИ УСЛУГА МОЖЕ ДА СЪДЪРЖА ПРЕВОДИ, НАПРАВЕНИ С ПОМОЩТА НА GOOGLE. GOOGLE ОТХВЪРЛЯ ВСИЧКИ ГАРАНЦИИ, СВЪРЗАНИ С ПРЕВОДИТЕ, ИЗРИЧНИ ИЛИ ПОДРАЗБИРАЩИ СЕ, ВКЛЮЧИТЕЛНО ВСЯКАКВИ ГАРАНЦИИ ЗА ТОЧНОСТ, НАДЕЖДНОСТ И ВСЯКАКВИ ПОДРАЗБИРАЩИ СЕ ГАРАНЦИИ ЗА ПРОДАВАЕМОСТ, ПРИГОДНОСТ ЗА ОПРЕДЕЛЕНА ЦЕЛ И НЕНАРУШЕНИЕ.",
    // Catalan
    'ca': "AQUEST SERVEI POT INCLOURE TRADUCCIONS FETES AMB GOOGLE. GOOGLE NO ES FA RESPONSABLE DE CAP GARANTIA RELACIONADA AMB LES TRADUCCIONS, EXPRESSES O IMPLÍCITES, INCLOSES LES GARANTIES DE PRECISIÓ I DE FIABILITAT, NI DE CAP GARANTIA DE COMERCIALITZACIÓ O ADEQUACIÓ PER A UN ÚS CONCRET I NO INFRACCIÓ.",
    // Czech
    'cs': "TATO SLUŽBA MŮŽE OBSAHOVAT PŘEKLADY PŘELOŽENÉ POMOCÍ SLUŽBY GOOGLE. GOOGLE SE ZŘÍKÁ VEŠKERÝCH ZÁRUK V SOUVISLOSTI S PŘEKLADY, VÝSLOVNÝCH NEBO ODVOZENÝCH, VČETNĚ JAKÝCHKOLI ZÁRUK PŘESNOSTI, SPOLEHLIVOSTI A ODVOZENÝCH ZÁRUK PRODEJNOSTI, VHODNOSTI PRO URČITÝ ÚČEL A NEPORUŠENÍ.",
    // Danish
    'da': "DENNE TJENESTE KAN INDEHOLDE OVERSÆTTELSER, DER LEVERES AF GOOGLE. GOOGLE FRASKRIVER SIG ALLE GARANTIER I FORBINDELSE MED OVERSÆTTELSER, UDTRYKKELIGE ELLER UNDERFORSTÅEDE, HERUNDER GARANTIER FOR NØJAGTIGHED, PÅLIDELIGHED OG ALLE UNDERFORSTÅEDE GARANTIER FOR SALGBARHED, EGNETHED TIL ET BESTEMT FORMÅL OG IKKE-KRÆNKELSE.",
    // German
    'de': "DIESER DIENST KANN VON GOOGLE UNTERSTÜTZTE ÜBERSETZUNGEN ENTHALTEN. GOOGLE LEHNT ALLE AUSDRÜCKLICHEN UND IMPLIZIERTEN GEWÄHRLEISTUNGEN IM HINBLICK AUF DIESE ÜBERSETZUNGEN AB, EINSCHLIESSLICH ALLER GEWÄHRLEISTUNGEN BEZÜGLICH GENAUIGKEIT, ZUVERLÄSSIGKEIT SOWIE IMPLIZIERTER GEWÄHRLEISTUNGEN FÜR MARKTGÄNGIGKEIT, EIGNUNG FÜR EINEN BESTIMMTEN ZWECK UND NICHT-REGELVERLETZUNG.",
    // Greek
    'el': "ΑΥΤΗ Η ΥΠΗΡΕΣΙΑ ΕΝΔΕΧΕΤΑΙ ΝΑ ΠΕΡΙΕΧΕΙ ΜΕΤΑΦΡΑΣΕΙΣ ΠΟΥ ΠΑΡΕΧΟΝΤΑΙ ΑΠΟ ΤΗΝ GOOGLE. Η GOOGLE ΑΠΟΠΟΙΕΙΤΑΙ ΟΛΩΝ ΤΩΝ ΕΓΓΥΗΣΕΩΝ, ΡΗΤΩΝ Ή ΣΙΩΠΗΡΩΝ, ΠΟΥ ΣΧΕΤΙΖΟΝΤΑΙ ΜΕ ΤΙΣ ΜΕΤΑΦΡΑΣΕΙΣ, ΣΥΜΠΕΡΙΛΑΜΒΑΝΟΜΕΝΩΝ ΤΥΧΟΝ ΕΓΓΥΗΣΕΩΝ ΩΣ ΠΡΟΣ ΤΗΝ ΑΚΡΙΒΕΙΑ ΚΑΙ ΤΗΝ ΑΞΙΟΠΙΣΤΙΑ, ΚΑΙ ΤΥΧΟΝ ΣΙΩΠΗΡΩΝ ΕΓΓΥΗΣΕΩΝ ΕΜΠΟΡΕΥΣΙΜΟΤΗΤΑΣ, ΚΑΤΑΛΛΗΛΟΤΗΤΑΣ ΓΙΑ ΣΥΓΚΕΚΡΙΜΕΝΟ ΣΚΟΠΟ ΚΑΙ ΜΗ ΠΑΡΑΒΙΑΣΗΣ.",
    // Spanish
    'es': "ESTE SERVICIO PUEDE CONTENER TRADUCCIONES REALIZADAS CON GOOGLE. GOOGLE RENUNCIA A TODAS LAS GARANTÍAS RELATIVAS A ESTAS TRADUCCIONES, EXPLÍCITAS O IMPLÍCITAS, LO QUE INCLUYE CUALQUIER GARANTÍA RESPECTO A SU PRECISIÓN, FIABILIDAD Y CUALQUIER GARANTÍA IMPLÍCITA DE COMERCIABILIDAD, APTITUD PARA UN PROPÓSITO DETERMINADO Y NO INFRACCIÓN.",
    // Estonian
    'et': "SEE TEENUS VÕIB SISALDADA GOOGLE 'I TÕLKEID. GOOGLE ÜTLEB LAHTI MIS TAHES OTSESTEST VÕI KAUDSETEST GARANTIIDEST SEOSES NENDE TÕLGETEGA, SEALHULGAS MIS TAHES GARANTIIDEST TÕLGETE TÄPSUSE JA USALDUSVÄÄRSUSE OSAS NING MIS TAHES KAUDSETEST GARANTIIDEST TÕLGETE TURUSTATAVUSE, TEATUD OTSTARBEKS SOBIVUSE JA ÕIGUSTE MITTERIKKUMISE OSAS.",
    // Basque
    'eu': "ZERBITZU HONEK GOOGLEK SUSTATUTAKO ITZULPENAK IZAN DITZAKE. GOOGLEK UKO EGITEN DIE ITZULPENEI LOTUTAKO LEGE-BERME GUZTIEI, IZAN ESPLIZITUAK EDO INPLIZITUAK, ZEHAZTASUN- ETA SINESGARRITASUN-BERMEEI ETA KOMERTZIALIZATZEKO AUKERARI, HELBURU JAKIN BATEN EGOKITASUNARI ETA ARAUAK EZ HAUSTEARI LOTUTAKO BERME INPLIZITUEI BARNE.",
    // Finnish
    'fi': "TÄMÄ PALVELU VOI SISÄLTÄÄ GOOGLEN TARJOAMIA KÄÄNNÖKSIÄ. GOOGLE KIELTÄÄ KAIKKI TÄLLAISIIN KÄÄNNÖKSIIN LIITTYVÄT SUORAT TAI KONKLUDENTTISET TAKUUT, MUKAAN LUKIEN KAIKKI TAKUUT TARKKUUDESTA TAI LUOTETTAVUUDESTA, SEKÄ KAIKKI KONKLUDENTTISET TAKUUT KAUPATTAVUUDESTA, SOPIVUUDESTA TIETTYYN TARKOITUKSEEN JA OIKEUKSIEN LOUKKAAMATTOMUUDESTA.",
    // French
    'fr': "CE SERVICE PEUT CONTENIR DES TRADUCTIONS FOURNIES PAR GOOGLE. GOOGLE EXCLUT TOUTE GARANTIE, EXPRESSE OU IMPLICITE, RELATIVE AUX TRADUCTIONS, ET NOTAMMENT QUANT À LEUR EXACTITUDE ET LEUR FIABILITÉ, AINSI QUE TOUTE GARANTIE IMPLICITE DE QUALITÉ MARCHANDE, D'ADÉQUATION À UN USAGE PARTICULIER ET D'ABSENCE DE CONTREFAÇON.",
    // Croatian (not yet translated)
    'hr': "OVA USLUGA MOŽE SADRŽAVATI PRIJEVODE KOJE OMOGUĆUJE GOOGLE. GOOGLE SE ODRIČE SVIH JAMSTAVA POVEZANIH S PRIJEVODIMA, IZRIČITIH ILI IMPLICITNIH, UKLJUČUJUĆI SVA JAMSTVA TOČNOSTI, POUZDANOSTI, KAO I SVIH IMPLICITHIH JAMSTAVA O SPOSOBNOSTI PRODAJE, PRIKLADNOSTI ZA ODREĐENU NAMJENU I NEPOSTOJANJU POVREDE.",
    // Hungarian
    'hu': "EZ A SZOLGÁLTATÁS GOOGLE ÁLTALI FORDÍTÁSOKAT IS TARTALMAZHAT. A GOOGLE ELUTASÍT MINDEN, A FORDÍTÁSSAL, KIFEJEZETT VAGY HALLGATÓLAGOS JÓTÁLLÁST, BELEÉRTVE A PONTOSSÁGRA, MEGBÍZHATÓSÁGRA, ÉS AZ ELADHATÓSÁGRA, AZ ADOTT CÉLRA VALÓ ALKALMASSÁGRA ÉS A JOGSÉRTÉSRE VONATKOZÓ BÁRMELY VÉLELMEZETT GARANCIÁT.",
    // Armenian
    'hy': "ԱՅՍ ԾԱՌԱՅՈՒԹՅՈՒՆԸ ԿԱՐՈՂ Է ՊԱՐՈՒՆԱԿԵԼ ԹԱՐԳՄԱՆՈՒԹՅՈՒՆՆԵՐ ՕԺԱՆԴԱԿՎԱԾ GOOGLE-Ի ԿՈՂՄԻՑ GOOGLE-Ը ՀՐԱԺԱՐՎՈՒՄ Է ԹԱՐԳՄԱՆՈՒԹՅՈՒՆՆԵՐԻ ՀԵՏ ԿԱՊՎԱԾ ԲՈԼՈՐ ԵՐԱՇԽԻՔՆԵՐԻՑ՝ ՈՒՂՂԱԿԻ ԿԱՄ ԱՆՈՒՂՂԱԿԻ, ԱՅԴ ԹՎՈՒՄ ՆԱԵՎ ՃՇԳՐՏՈՒԹՅԱՆ, ՎՍՏԱՀԵԼԻՈՒԹՅԱՆ ԵՎ ԱՌԵՎՏՐԱԿԱՆ ՆՊԱՏԱԿՆԵՐԻ ՊԻՏԱՆԵԼԻՈՒԹՅԱՆ ՀԱՄԱՐ ԱՆՈՒՂՂԱԿԻ ԵՐԱՇԽԻՔՆԵՐԻՑ, ՈՐՈՇԱԿԻ ՆՊԱՏԱԿԻ ՀԱՄԱՊԱՏԱՍԽԱՆՈՒԹՅԱՆ ԵՎ ՕՐԵՆՔՆԵՐԻ ՊԱՀՊԱՆՄԱՆ ԵՐԱՇԽԻՔՆԵՐԻՑ:",
    // Indonesian
    'id': "LAYANAN INI DAPAT BERISI TERJEMAHAN YANG DIDUKUNG OLEH GOOGLE. GOOGLE TIDAK BERTANGGUNG JAWAB ATAS HASIL TERJEMAHAN, BAIK SECARA TERSURAT MAUPUN TERSIRAT, BEGITU PULA ATAS KEAKURATAN, RELIABILITAS, DAN SEGALA JAMINAN TERSIRAT TERKAIT KELAYAKAN UNTUK DIPERDAGANGKAN, KESESUAIAN UNTUK TUJUAN TERTENTU, DAN KETIADAAN PELANGGARAN.",
    // Icelandic
    'is': "ÞESSI ÞJÓNUSTA GÆTI INNIHALDIÐ ÞÝÐINGAR FRÁ GOOGLE. GOOGLE AFSALAR SÉR ALLRI ÁBYRGÐ SEM TENGIST ÞÝÐINGUM, BEINUM EÐA UNDIRSKILDUM, ÞAR MEÐ TALIÐ HVERSKONAR ÁBYRGÐ Á NÁKVÆMNI, ÁREIÐANLEIKA OG HVERSKONAR UNDIRSKILDA ÁBYRGÐ Á SELJANLEIKA, HÆFI FYRIR TILTEKIN TILGANG OG AÐ ÞAÐ BRJÓTI EKKI Í BÁGA.",
    // Italian
    'it': "QUESTO SERVIZIO PUÒ CONTENERE TRADUZIONI OFFERTE DA GOOGLE. GOOGLE DECLINA TUTTE LE GARANZIE RELATIVE ALLE TRADUZIONI, ESPLICITE O IMPLICITE, INCLUSE LE GARANZIE DI ACCURATEZZA, AFFIDABILITÀ E QUALSIASI GARANZIA IMPLICITA DI COMMERCIABILITÀ, IDONEITÀ PER UNO SCOPO PARTICOLARE E NON VIOLAZIONE.",
    // Hebrew
    'iw': "שירות זה עשוי להכיל תרגומים שבוצעו על ידי Google. Google מוותרת בזאת על כל אחריות לגבי התרגומים, בין אם במפורש או במרומז, לרבות אחריות לדיוק, מהימנות וכל אחריות מרומזת ליכולת סחירות, התאמה למטרה מסוימת ואי-הפרה.",
    // Japanese
    'ja': "本サービスにはGOOGLEが提供する翻訳が含まれる場合があります。GOOGLEは、正確性、信頼性、およびいかなる売買可能性の保証、特定の目的に対する黙示的な適合性および権利の侵害を含む、いかなる翻訳に関する保証を、明示的または暗示的に関わらず、一切放棄します。",
    // Georgian
    'ka': "ეს სერვისი შეიძლება შეიცავდეს Google-ის მიერ უზრუნველყოფილ თარგმანებს. Google უარყოფს თარგმანთან დაკავშირებულ ყოველგვარ უშუალო თუ ირიბ პასუხისმგებლობას, მათ შორის, არ იძლევა სიზუსტისა და საიმედოობის თუ კომერციული ვარგისიანობის, კონკრეტული მიზნებისთვის შესაფერისობის ან ინტელექტუალური უფლებების დაურღვევლობის ნაგულისხმევ გარანტიებს.",
    // Kazakh
    'kk': "БҰЛ ҚЫЗМЕТТЕ GOOGLE АУДАРҒАН АУДАРМАЛАР БОЛУЫ МҮМКІН. GOOGLE АУДАРМАЛАРҒА ҚАТЫСТЫ ТІКЕЛЕЙ НЕМЕСЕ ЖАНАМА КЕПІЛДІКТЕРДЕН, СОНЫМЕН ҚАТАР НАҚТЫЛЫҚ ПЕН СЕНІМДІЛІК КЕПІЛДІКТЕРІНЕН, САУДАҒА ЖАРАМДЫЛЫҚТЫҢ, АРНАЙЫ МАҚСАТҚА СӘЙКЕСТІК ПЕН МЕНШІК ҚҰҚЫҒЫНЫҢ БҰЗУЫЛМАУЫНА БАЙЛАНЫСТЫ КЕПІЛДІКТЕРДЕН БАС ТАРТАДЫ.",
    // Korean
    'ko': "이 서비스는 GOOGLE의 자동 번역문을 포함하고 있을 수 있습니다. GOOGLE은 모든 정확도, 신뢰도에 대한 보장, 그리고 상업 활용성, 특정 목적에 대한 적합성 및 판권 등의 비침해에 대한 모든 암묵적 보장을 포함하여 번역과 관련된 모든 명시적 또는 암묵적 보증을 부인합니다.",
    // Kirghiz/Kyrgyz
    'ky': "БУЛ КЫЗМАТ GOOGLE АРКАСЫНДАГЫ КОТОРМОЛОРДУ КАМТЫШЫ МҮМКҮН. GOOGLE КОТОРМОЛОРГО БАЙЛАНЫШКАН, МЕЙЛИ АЧЫК АЙТЫЛГАН ЖЕ МЫНДАЙ ТҮШҮНҮКТӨ БОЛСУН, АНЫН ИЧИНДЕ ТАКТЫК, ИШЕНИМДҮҮЛҮК ЖАНА БАЗАРДА ӨТҮМДҮҮЛҮККӨ, АТАЙЫН МАКСАТКА ТУУРА КЕЛГЕНИ ЖАНА БИРӨӨНҮН УКУГУН ТАЛАШУУГА КАРАШТУУ АР КАНДАЙ КЕПИЛДИКТЕР ДА БАР, БАРДЫК КЕПИЛДИКТЕРДЕН БАШ ТАРТАТ.",
    // Lithuanian
    'lt': "ŠIOJE PASLAUGOJE GALI BŪTI „POWERED BY GOOGLE“ VERTIMŲ. „GOOGLE“ NETEIKIA JOKIŲ SU VERTIMAIS SUSIJUSIŲ GARANTIJŲ, IŠREIKŠTŲ AR NUMANOMŲ, ĮSKAITANT GARANTIJAS DĖL TIKSLUMO, PATIKIMUMO IR NUMANOMAS GARANTIJAS PREKYBAI, TINKAMUMUI KONKREČIAM TIKSLUI ARBA NENUTRAUKIAMUMO.",
    // Latvian
    'lv': "ŠIS PAKALPOJUMS VAR IETVERT TULKOJUMUS, KO NODROŠINA GOOGLE. GOOGLE ATSAKĀS NO JEBKĀDĀM TIEŠĀM VAI NETIEŠĀM GARANTIJĀM SAISTĪBĀ AR TULKOJUMIEM, TOSTARP JEBKĀDĀM PRECIZITĀTES UN UZTICAMĪBAS GARANTIJĀM, KĀ ARĪ JEBKĀDĀM NETIEŠĀM GARANTIJĀM PAR PIEPRASĪJUMU, PIEMĒROTĪBU NOTEIKTAM MĒRĶIM UN TIESĪBU NEIEROBEŽOŠANU.",
    // Mongolian [Cyrillic]
    'mn': "ЭНЭ ҮЙЛЧИЛГЭЭ НЬ GOOGLE-ИЙН ТУСЛАМЖТАЙ ОРЧУУЛАГДСАН ОРЧУУЛГАТАЙ БАЙЖ МАГАДГҮЙ. GOOGLE ТОДОРХОЙ ЗОРИЛГООР, ЯМАР НЭГЭН ЗӨРЧИЛГҮЙГЭЭР ХЭРЭГЛЭЭНД НИЙЦЭЖ ТОХИРСОН, ҮНЭН ЗӨВ, НАЙДВАРТАЙ БАЙДЛЫН БАТАЛГАА ЗЭРЭГ ИЛЭРХИЙ ЭСХҮЛ ДАЛД УТГА БҮХИЙ ОРЧУУЛГАТАЙ ХОЛБООТОЙ БҮХ БАТАЛГААНД ХАРИУЦЛАГА ХҮЛЭЭХГҮЙ.",
    // Malay
    'ms': "PERKHIDMATAN INI MUNGKIN MENGANDUNGI TERJEMAHAN YANG DIKUASAKAN OLEH GOOGLE. GOOGLE MENAFIKAN SEGALA WARANTI YANG DIKAITKAN DENGAN TERJEMAHAN INI, NYATA ATAU TERSIRAT, TERMASUK SEBARANG WARANTI TENTANG KETEPATAN, KEBOLEHPERCAYAAN, DAN SEBARANG WARANTI KEBOLEHDAGANGAN YANG TERSIRAT, KESESUAIAN TERHADAP TUJUAN TERTENTU DAN KETIDAKPELANGGARAN.",
    // Dutch
    'nl': "DEZE SERVICE BEVAT MOGELIJK VERTALINGEN ONDERSTEUND DOOR GOOGLE. GOOGLE VERWERPT ALLE GARANTIE MET BETREKKING TOT DE VERTALINGEN, UITDRUKKELIJK OF GEÏMPLICEERD, MET INBEGRIP VAN GARANTIE VAN NAUWKEURIGHEID, BETROUWBAARHEID EN GEÏMPLICEERDE GARANTIE VAN VERKOOPBAARHEID, GESCHIKTHEID VOOR EEN BEPAALD DOEL EN NIET-OVERTREDING.",
    // Norwegian (Bokmål)
    // (NOTE: The true locale code ought to be nb_NO, but for legacy reasons,
    // our systems use the old no_NO locale code.)
    'no': "DENNE TJENESTEN KAN INNEHOLDE OVERSETTELSER STØTTET AV GOOGLE. GOOGLE FRASKRIVER SEG ALLE GARANTIER RELATERT TIL OVERSETTELSENE, UTTRYKKELIG ELLER UNDERFORSTÅTT, INKLUDERT ALLE GARANTIER OM NØYAKTIGHET, PÅLITELIGHET OG ALLE IMPLISERTE GARANTIER OM SALGBARHET, EGNETHET FOR EN BESTEMT HENSIKT OG SKADESLØSHET.",
    // Polish
    'pl': "USŁUGA TA MOŻE ZAWIERAĆ TŁUMACZENIA OBSŁUGIWANE PRZEZ GOOGLE. GOOGLE WYŁĄCZA WSZELKIE GWARANCJE ZWIĄZANE Z TŁUMACZENIAMI, WYRAŹNE LUB DOROZUMIANE, W TYM WSZELKIE GWARANCJE DOKŁADNOŚCI, NIEZAWODNOŚCI I DOROZUMIANYCH GWARANCJI PRZYDATNOŚCI HANDLOWEJ, PRZYDATNOŚCI DO OKREŚLONEGO CELU I NIENARUSZALNOŚCI PRAW.",
    // Portuguese
    'pt': "ESTE SERVIÇO PODE CONTER TRADUÇÕES FORNECIDAS PELA GOOGLE. A GOOGLE DECLINA TODAS AS GARANTIAS RELACIONADAS COM AS TRADUÇÕES, EXPRESSAS OU IMPLÍCITAS, INCLUINDO QUALQUER GARANTIA DE EXATIDÃO, FIABILIDADE E QUALQUER GARANTIA IMPLÍCITA DE COMÉRCIO, ADAPTAÇÃO PARA QUALQUER USO PARTICULAR E FALTA DE INFRAÇÃO.",
    // Romanian
    'ro': "ACEST SERVICIU POATE CONȚINE TRADUCERI EFECTUATE CU GOOGLE. GOOGLE DECLINĂ TOATE GARANȚIILE EXPRESE SAU IMPLICITE PRIVIND TRADUCERILE, INCLUSIV ORICE GARANȚII PRIVIND ACURATEȚEA, FIABILITATEA ȘI ORICE GARANȚII IMPLICITE DE VANDABILITATE, DE ADECVARE PENTRU UN ANUMIT SCOP ȘI DE NEÎNCĂLCARE.",
    // Russian
    'ru': "В РАМКАХ ДАННОГО СЕРВИСА МОГУТ ИСПОЛЬЗОВАТЬСЯ ПЕРЕВОДЫ, ВЫПОЛНЕННЫЕ С ПОМОЩЬЮ GOOGLE. GOOGLE НЕ ДАЕТ НИКАКИХ ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ ОТНОСИТЕЛЬНО ПРЕДОСТАВЛЯЕМЫХ ПЕРЕВОДОВ И В ЧАСТНОСТИ НЕ ГАРАНТИРУЕТ, ЧТО ОНИ ТОЧНЫ, НАДЕЖНЫ, ИМЕЮТ КОММЕРЧЕСКУЮ ЦЕННОСТЬ, ПРИГОДЫ ДЛЯ КОНКРЕТНЫХ ЦЕЛЕЙ И НЕ НАРУШАЮТ ПРАВ ИНТЕЛЛЕКТУАЛЬНОЙ СОБСТВЕННОСТИ.",
    // Slovakian
    'sk': "TÁTO SLUŽBA MÔŽE OBSAHOVAŤ PREKLADY, KTORÉ VYUŽÍVAJÚ TECHNOLÓGIU GOOGLE. SPOLOČNOSŤ GOOGLE ODMIETA VŠETKY ZÁRUKY VZŤAHUJÚCE SA NA PREKLADY, VÝSLOVNÉ ALEBO PREDPOKLADANÉ, A TO VRÁTANE AKÝCHKOĽVEK ZÁRUK TÝKAJÚCICH SA PRESNOSTI, SPOĽAHLIVOSTI A AKÝCHKOĽVEK IMPLICITNÝCH ZÁRUK TÝKAJÚCICH SA PREDAJNOSTI, VHODNOSTI NA KONKRÉTNY ÚČEL A NEOPRÁVNENÝCH ZÁSAHOV.",
    // Slovenian
    'sl': "TA STORITEV LAHKO VSEBUJE PREVODE, KI JIH PODPIRA GOOGLE. GOOGLE ZAVRAČA VSA JAMSTVA, POVEZANA S PREVODI, IZRECNA ALI IMPLICITNA, VKLJUČNO Z VSEMI JAMSTVI GLEDE NATANČNOSTI, ZANESLJIVOSTI IN VSEMI IMPLICITNIMI JAMSTVI GLEDE PRIMERNOSTI ZA TRŽENJE, USTREZNOSTI ZA DOLOČEN NAMEN IN ODSOTNOSTI KRŠITEV.",
    // Albanian
    'sq': "KY SHËRBIM MUND TË PËRMBAJË PËRKTHIME TË MUNDËSUARA NGA GOOGLE. GOOGLE MOHON ÇFARËDO GARANCIE NË LIDHJE ME PËRKTHIMET, TË SHPREHUR APO TË NËNKUPTUAR, DUKE PËRFSHIRË ÇFARËDO GARANCIE MBI SAKTËSINË, BESUESHMËRINË DHE ÇFARËDO GARANCIE TË NËNKUPTUAR TË TREGTUESHMËRISË, TË PËRSHTATSHMËRISË PËR NJË QËLLIM TË CAKTUAR DHE TË MOSSHKELJES.",
    // Serbian (not yet translated)
    'sr': "OVA USLUGA MOŽE SADRŽATI PREVODE KOJE JE ISPORUČIO GOOGLE. GOOGLE ODRIČE SVE GARANCIJE U VEZI SA PREVODIMA, IZRIČITE ILI PODRAZUMEVANE, UKLJUČUJUĆI SVE GARANCIJE O TAČNOSTI, POUZDANOSTI I SVE PODRAZUMEVANE GARANCIJE U VEZI SA PODOBNOŠĆU ZA PRODAJU, PODOBOŠĆU ZA ODREĐENU NAMENU I NEKRŠENJEM PRAVA.",
    // Swedish
    'sv': "DEN HÄR TJÄNSTEN KAN INNEHÅLLA ÖVERSÄTTNINGAR FRÅN GOOGLE. GOOGLE AVSÄGER SIG ALLA GARANTIER RELATERADE TILL ÖVERSÄTTNINGARNA, DIREKTA ELLER ANTYDDA, INKLUSIVE GARANTIER OM RIKTIGHET, PÅLITLIGHET, OCH ALLA ANTYDDA GARANTIER OM SÄLJBARHET, LÄMPLIGHET FÖR SÄRSKILT SYFTE SAMT ICKE-INTRÅNG.",
    // Thai
    'th': "บริการนี้อาจมีคำแปลที่สนับสนุนโดย Gooogle Google ขอจำกัดความรับผิดชอบการรับประกันทั้งหมดที่เกี่ยวกับคำแปลทั้งในแบบชัดแจ้งและโดยนัย รวมถึงการรับประกันใดๆ ในด้านความถูกต้อง ความน่าเชื่อถือ และการรับประกันโดยนัยใดๆ เกี่ยวกับความสามารถในการขายหรือความเหมาะสมสำหรับวัตถุประสงค์เฉพาะและรายการที่ไม่ละเมิด",
    // Turkish
    'tr': "BU HİZMET GOOGLE TARAFINDAN YAPILMIŞ ÇEVİRİLER İÇEREBİLİR. GOOGLE, ÇEVİRİLERLE İLGİLİ OLARAK HERHANGİ BİR DOĞRULUK, GÜVENİLİRLİK, TİCARETE ELVERİŞLİLİK, BELİRLİ BIR AMACA UYGUNLUK VE İHLAL ETMEME TAAHHÜTLERİ DAHİL OLMAK ÜZERE AÇIK VEYA ZIMNİ HERHANGİ BİR TAAHHÜT VERMEMEKTEDİR.",
    // Ukrainian
    'uk': "ДЕЯКІ СТОРІНКИ ЦЬОГО СЕРВІСУ МОЖУТЬ МІСТИТИ ПЕРЕКЛАДИ, СТВОРЕНІ З ВИКОРИСТАННЯМ ТЕХНОЛОГІЙ ПЕРЕКЛАДУ GOOGLE. GOOGLE ВІДМОВЛЯЄТЬСЯ ВІД БУДЬ-ЯКИХ ГАРАНТІЙ, ЯВНИХ АБО ТАКИХ, ЩО МАЮТЬСЯ НА УВАЗІ, ЩОДО ТАКИХ ПЕРЕКЛАДІВ, ВКЛЮЧАЮЧИ БУДЬ-ЯКІ ГАРАНТІЇ ТОЧНОСТІ АБО ДОСТОВІРНОСТІ ТА БУДЬ-ЯКІ ГАРАНТІЇ, ЩО МАЮТЬСЯ НА УВАЗІ, СТОСОВНО ТОВАРНОЇ ПРИДАТНОСТІ, ПРИДАТНОСТІ ДЛЯ ПЕВНОЇ ЦІЛІ ТА ВІДСУТНОСТІ ПОРУШЕНЬ ПРАВ ІНТЕЛЕКТУАЛЬНОЇ ВЛАСНОСТІ.",
    // Vietnamese
    'vi': "DỊCH VỤ NÀY CÓ THỂ CÓ BẢN DỊCH DO GOOGLE QUẢN LÝ. GOOGLE TUYÊN BỐ KHƯỚC TỪ MỌI ĐẢM BẢO LIÊN QUAN ĐẾN CÁC BẢN DỊCH, RÕ RÀNG HAY NGỤ Ý, BAO GỒM BẤT CỨ NỘI DUNG ĐẢM BẢO NÀO VỀ TÍNH CHÍNH XÁC, XÁC THỰC, VÀ BẤT CỨ ĐẢM BẢO NGỤ Ý NÀO VỀ KHẢ NĂNG BÁN ĐƯỢC, TÍNH PHÙ HỢP CHO MỘT MỤC ĐÍCH CỤ THỂ VÀ KHÔNG VI PHẠM.",
    // More locales use traditional than simplified, so it's the fallback option.
    'zh': ZH_TRADITIONAL,

    // PER-LOCALE OVERRIDES
    // ====================
    // Country-specific exceptions follow. If a specific locale has an entry
    // below, it is an exception to the language codes defined above.

    // German (Switzerland)
    'de_CH': "DIESER SERVICE KANN ÜBERSETZUNGEN ENTHALTEN, DIE VON GOOGLE BETRIEBEN WERDEN. GOOGLE SCHLIESST JEGLICHE AUSDRÜCKLICHE ODER IMPLIZIERTE HAFTUNG IN BEZUG AUF DIE ÜBERSETZUNGEN AUS, EINSCHLIESSLICH ALLER HAFTUNGEN IN BEZUG AUF GENAUIGKEIT, ZUVERLÄSSIGKEIT UND ALLER IMPLIZIERTEN GEWÄHRLEISTUNGEN DER MARKTGÄNGIGKEIT, BESTIMMTEN ZWECKEIGNUNG ODER NICHTVERLETZUNG.",
    // French (Canada)
    'fr_CA': "CE SERVICE PEUT CONTENIR DES TRADUCTIONS FOURNIES PAR GOOGLE. GOOGLE DÉCLINE TOUTE RESPONSABILITÉ EXPLICITE OU IMPLICITE CONCERNANT LES TRADUCTIONS, Y COMPRIS TOUTE GARANTIE D'EXACTITUDE ET DE FIABILITÉ, AINSI QUE TOUTE GARANTIE IMPLICITE DE QUALITÉ MARCHANDE, D'ADÉQUATION À UN USAGE PARTICULIER ET DE CONFORMITÉ.",
    // Portuguese (Brazil)
    'pt_BR': "ESTE SERVIÇO PODE CONTER TRADUÇÕES FORNECIDAS PELO GOOGLE. O GOOGLE ABDICA DE TODAS AS GARANTIAS RELACIONADAS ÀS TRADUÇÕES, EXPRESSAS OU IMPLÍCITAS, INCLUINDO TODAS AS GARANTIAS DE EXATIDÃO E CONFIANÇA, ALÉM DE TODAS AS GARANTIAS IMPLÍCITAS DE COMERCIALIZAÇÃO E ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA E NÃO VIOLAÇÃO.",
    'zh_CN': ZH_SIMPLIFIED,
    'zh_SG': "本服务可能包含 Google 提供的翻译。Google 不对翻译做任何明示或默示保证，包括对于翻译的准确性及可靠性的任何保证，以及对于翻译的适销性、对特定用途的适用性和无侵权的任何默示保证。"
  };

  function bundle (language, message) {
    return { language: language.replace('_', '-'), message: message };
  };

  return {
    mappings: DISCLAIMER_MAPPINGS,
    // Helper function. Returns both the message and its language/locale so
    // that we can annotate the disclaimer with the `lang` attribute.
    /**
     * Given a desired locale, returns the disclaimer and its language. If no
     * translation exists for the given locale, returns the English agreement
     * text as a fallback.
     *
     * @param   {String} _locale Locale (e.g., `en_US`) or language (e.g., `en`).
     * @returns {Object} Object with two keys: `language` and `message`. The
     *    `language` key is returned because the message itself isn't guaranteed
     *    to be in the language you requested. It's suitable for using as the
     *    value of an HTML `lang` attribute. The `message` key contains the
     *    disclaimer text in the language indicated by `language`.
     */
    forLocale: function forLocale (_locale) {
      var language = _locale.substring(0, 2);
      var locale = _locale.replace('-', '_');
      // Is there a message for this specific locale?
      if (DISCLAIMER_MAPPINGS[locale]) {
        return bundle(locale, DISCLAIMER_MAPPINGS[locale]);
      }
      // If not, is there a message for this locale's language?
      if (DISCLAIMER_MAPPINGS[language]) {
        return bundle(language, DISCLAIMER_MAPPINGS[language]);
      }
      // If not, fall back to the English language disclaimer.
      return bundle('en', EN_DEFAULT);
    }
  };
});

/* START_TEMPLATE */
BV.define('hbs!translationTerms',['hbs','vendor/handlebars/runtime', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-compat\"> <div id=\"bv-terms-conditions\" class=\"bv-terms-conditions\"> <div class=\"bv-terms-conditions-text bv-focusable\" tabindex=\"0\"> <p lang=\"";
  if (stack1 = helpers.translationLanguage) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.translationLanguage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (stack1 = helpers.translationText) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.translationText; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</p> </div> </div> </div> ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("submission")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('translationTerms', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/translationTerms',[
  'ENV',
  'framework/bmodel',
  'framework/bview',
  'jquery',
  'bv/util/googleTranslateDisclaimer',
  'hbs!translationTerms'
], function TranslationTerms (
  ENV,
  BModel,
  BView,
  $,
  GoogleTranslateDisclaimer,
  template
) {
  return BView.extend({
    name: 'translationTerms',
    el: '.bv-translation-terms',

    template: template,

    init: function init (config) {
      var component = this.getComponent();
      var ENVConfig = ENV.get('config');

      // Returns both the localized disclaimer and its locale/language code so
      // that we can mark up the `lang` attribute appropriately. Because we
      // fall back to English in some circumstances, the disclaimer is not
      // guaranteed to be in the same language as `ENVConfig.locale`.
      var translationMeta = GoogleTranslateDisclaimer.forLocale(ENVConfig.locale);

      this.model = new BModel({
        parent: this.parent.model,
        componentId: this.componentId,
        component: component,
        name: 'dummy',
        translationText: translationMeta.message,
        translationLanguage: translationMeta.language
      });
    }
  });
});

/**
 * @fileOverview View for a content item.
 */
BV.define('bv/c2013/view/contentItem',[
  'framework/bview',
  'jquery',
  'underscore',
  'bv/ui-core/modestbox',
  'hbs!contentItem',
  'util/viewport',
  'window',
  'mf!bv/c2013/messages/contentItem',
  'mf!bv/c2013/messages/avatar',
  'mf!bv/c2013/messages/common',
  'bv/c2013/view/translationTerms',
  'bv/util/contentType',
  'bv/util/productInfo',
  'framework/util/bvtracker',
  'util/specialKeys'
], function m (
  BView,
  $,
  _,
  ModestBox,
  template,
  viewport,
  window,
  msgPack,
  msgPackAvatar,
  msgPackCommon,
  TranslationTermsView,
  ContentType,
  ProductInfo,
  BVTracker,
  specialKeys
) {

  var ContentItemView = BView.extend({

    name: 'contentItem',

    events: {
      'click .bv-rating-stars-container': 'clickStars',
      'click .bv-content-top-question .bv-content-core-float .bv-content-title-container, .bv-content-top-question .bv-content-core-float button.bv-secondary-content-link, .bv-content-top-review .bv-secondary-content-link': 'showSecondaryContent',
      'click .bv-content-secondary-btn': 'showSecondarySubmission',
      'click .bv-media-item': 'showMedia',
      'keydown .bv-media-item': '_interpretMediaKeyPress',
      'click .bv-secondary-content-link': 'preventDefault',
      'click .bv-content-item-close': 'closeQuestion',
      'click .bv-fullprofile-popup-target': 'launchProfile',
      'click .bv-show-more-link': 'showFullContent',
      'click .bv-content-summary-translate-btn': 'translateContent',
      'click .bv-translation-disclaimer-btn': 'showTranslationTerms'
    },

    template: template,

    msgpacks: [msgPack, msgPackAvatar, msgPackCommon],

    init: function init (config) {
      var contentType = ContentType.noun(
        this.model.get('Type') || this.model.get('contentType')
      );
      this.classList.push('content-' + contentType);
      this.seoMicrodataTags();

      this.on('attach', _(this._handleBadgeVisibility).bind(this));

      this.model.on('change:translationActive', function changed (obj, newValue) {
        this.render();
      }.bind(this));

      this.model.on('change:translationFailed', function changed (obj, newValue) {
        this.render();
      }.bind(this));

      this.model.on('change:translationPending', function changed (obj, newValue) {
        if (newValue === false) {
          // Don't rerender; this will be handled by the other listeners.
          return;
        }
        this.render();
      }.bind(this));
    },

    clickStars: function clickStars (e) {
      var model = this.model;

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'Stars',
        detail2: model.get('Rating'),
        contentType: model.get('contentType'),
        contentId: model.get('Id'),
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    },

    /**
     * This function runs mostly in modestbox's beforeShow() call
     * It sets up DOM element in correct states.
     * @param data_mixin : it contains searchFor if it is called by search result.
     */
    formSetup: function formSetup (dataMixin) {
      var $contentItems;
      // highlights the search key words
      if (_(dataMixin).has('searchFor') && !_(dataMixin.searchFor).isEmpty()) {
        $contentItems = this.$viewEl.find('.bv-content-item');

        // Highlight search keyword in the text
        $contentItems.find('.bv-content-summary').bvhighlight(dataMixin);

        this.filterHighlightItems($contentItems);
      }
      else {
        this.$viewEl.find('.bv-content-item-hidden').removeClass('bv-content-item-hidden');
      }

      BView.prototype.formSetup.call(this);
    },

    /**
     * This function shows content items that are highlighted and hides the rest of
     * the content items.
     * @param $contentItems : a list of content items
     */
    filterHighlightItems: function filterHighlightItems ($contentItems) {
      var $itemsInitiallyShown = $();
      var hiddenCount = 0;

      _($contentItems).forEach(function forEachItem (el) {
        var $el = $(el);
        var isInitiallyShown = !$el.hasClass('bv-content-item-hidden');
        var hideItem;

        // After running bvhighlight(), highlighted text are wrapped with a span
        // containing the class name bv-content-highlight.
        var highlights = $el.find('.bv-content-highlight');

        // Some content items are initially shown/hidden before it reaches this part
        // of the code. We want to keep track of the items that are initially shown
        // to be used later.
        if (isInitiallyShown) {
          $itemsInitiallyShown = $itemsInitiallyShown.add($el);
        }

        // Determine whether to show/hide the content item
        hideItem = highlights.length === 0 && !$el.hasClass('bv-content-highlight');

        $el.toggleClass('bv-content-item-hidden', hideItem);

        if (hideItem) {
          hiddenCount++;
        }
      });

      // If all content items become hidden, show the initially shown items.
      if ($contentItems.length > 0 && $contentItems.length === hiddenCount) {

        // If itemsInitiallyShown is empty, just show the first content item.
        ($itemsInitiallyShown.length > 0 ?
          $itemsInitiallyShown :
          $contentItems.first()
        ).removeClass('bv-content-item-hidden');
      }
    },

    attach: function attach (elToAttach) {
      BView.prototype.attach.call(this, elToAttach);
      this.$viewEl.find('.bv-fieldset-inner textarea')
        .bind('click', _.once(this.showSecondaryContent));
      this.setMediaOrientation(this.$viewEl.find('img'));

      // If this content item is visible, un-lazyload any images inside.
      if (this.isVisible()) {
        this.$viewEl.find('img[data-src]').each(function setSrc (i, img) {
          $(img).attr('src', $(img).data('src'));
        });
      }
    },

    isVisible: function isVisible () {
      return this.$viewEl.is(':visible') && viewport.visible(this.viewEl);
    },

    /**
     * show secondary content in the modestbox
     */
    showSecondaryContent: function showSecondaryContent (e) {
      e.preventDefault();
      this._loadSecondary(true);
    },

    showSecondarySubmission: function showSecondarySubmission (e) {
      var $form;
      e.preventDefault();
      $form = this.$viewEl.next().find('form:first');
      if ($form.length > 0) {
        $form.find('textarea').focus();
        return;
      }
      this._loadSecondary();
    },

    _loadSecondary: function _loadSecondary (bypassUIAction) {
      var self = this;
      BV.require(['secondary'], function mm (app) {
        _(self).extend(app.ContentItemExt.view);
        self.showSecondaryContentExt(ContentItemView, bypassUIAction);
      });
    },

    _interpretMediaKeyPress: function _interpretMediaKeyPress (e) {
      // Space bar or Enter.
      if (e.keyCode === specialKeys.SPACE || e.keyCode === specialKeys.ENTER) {
        e.preventDefault();
        this.showMedia(e);
      }
    },

    showMedia: function showMedia (e) {
      var $container = $(e.target).closest('.bv-media-item');
      var id = $container.attr('data-bv-media-id');
      var currentMediaType = $container.attr('data-bv-mediatype');
      var currentMedia = this.model.findMediaById(id, currentMediaType);
      var categoryId;
      var mediaCollection;

      if (_.isUndefined(currentMedia)) {
        return;
      }
      categoryId = ProductInfo.getCategoryId(this);
      mediaCollection = [];

      _(this.model.get('Videos')).each(function forEachVideo (media, index) {
        mediaCollection.push({
          mediaType: 'Videos',
          mediaContent: media
        });
      });

      _(this.model.get('Photos')).each(function forEachPhoto (media, index) {
        mediaCollection.push({
          mediaType: 'Photos',
          mediaContent: media
        });
      });

      this.getTopModel().trigger('showmediaviewer', {
        media: {
          mediaType: currentMediaType,
          mediaContent: currentMedia
        },
        mediaCollection: mediaCollection,
        categoryId: categoryId,
        $container: $container
      });

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'UserSubmittedMedia',
        contentType: this.model.get('Type'),
        contentId: this.model.get('Id'),
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: categoryId
      });
    },

    closeQuestion: function closeQuestion (e) {
      e.preventDefault();
      this._remove({ view: this });
    },

    seoMicrodataTags: function seoMicrodataTags () {
      var contentType = ContentType.noun(this.model.get('Type') || this.model.get('contentType'));
      var customPath = _({ review: 'Review', question: 'Question' }).result(contentType);
      if (( customPath ) && ( contentType === 'review' )) {
        this.seoTagList.push('itemprop="' + contentType +
         '" itemscope itemtype="http://schema.org/' + customPath + '"');
      }
      else if ( customPath ) {
        this.seoTagList.push('itemscope itemtype="http://schema.org/' + customPath + '"');
      }
    },

    preventDefault: function preventDefault (e) {
      e.preventDefault();
    },

    _remove: function _remove (options) {
      var self = this;
      this.$viewEl.removeClass('bv-content-item-scale-in').addClass('bv-content-item-scale-out');
      _.delay(function later () {
        if (self.model) {
          self.model.remove(options);
        }
        else {
          self.$viewEl.remove();
        }
      }, 1000);
    },

    launchProfile: function launchProfile (e) {
      var isMobile;
      var isMostHelpfulView;
      var isQuestions;

      if (!this.hasFeature('fullProfileLink')) {
        return;
      }
      // Only trigger this event on questions, in mobile mode or for head-to-head component's profile links.
      isQuestions = this.contentType === 'Questions';
      isMobile = BV._internal.mobile ||
       navigator.userAgent.match(/(iPhone|iPod|Android|BlackBerry)/);
      isMostHelpfulView = this.viewAlias && this.viewAlias.match(/mostHelpful(Positive|Negative)/);

      if (isQuestions || isMobile || isMostHelpfulView) {
        // Use R&R component outlet to trigger full profile popup component event.
        this.getTopModel().trigger('showfullprofile', this.model.get('Author'));
      }
    },

    showFullContent: function showFullContent (e) {
      // Allow cmd + tab on mac for opening in a new tab.
      if (e.isDefaultPrevented() || e.metaKey || e.ctrlKey) {
        return;
      }

      e.preventDefault();

      this.model.publish('deeplink', {
        id: this.model.get('Id'),
        contentType: this.model.get('Type')
      });
    },

    translateContent: function translateContent (event) {
      var languageDetail;
      var model = this.model;
      event.preventDefault();
      if (model.get('translationPending')) { return; }

      // If we're toggling _toward_ the machine translation, send out the
      // analytics event.
      if (!model.get('translationActive')) {
        languageDetail = model.get('translationLanguageCode')
          .replace('-x-mtfrom-', '-from-');

        BVTracker.feature({
          type: 'Used',
          name: 'Click',
          detail1: 'Translation',
          // Contains a string like `en-from-fr` that indicates the native
          // language and target language of this translation. (In this
          // example, the review was originally in french, but we're
          // translating it into English for display.)
          detail2: languageDetail,
          contentType: model.get('contentType'),
          contentId: model.get('Id'),
          bvProduct: ProductInfo.getType(this),
          productId: ProductInfo.getId(this),
          categoryId: ProductInfo.getCategoryId(this)
        });
      }

      this.model.translateContent();
    },

    showTranslationTerms: function showTranslationTerms (event) {
      var model = this.model;
      var mbConfig;
      var tcBox;
      var termsView = new TranslationTermsView({
        parent: this,
        componentId: model.get('componentId')
      });

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'TranslationTerms',
        detail2: null,
        contentType: model.get('contentType'),
        contentId: model.get('Id'),
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });

      mbConfig = {
        title: msgPack.contentItem_translationTermsTitle(),
        view: termsView,
        inline: false,
        // Changed to 'true' according to CCS-16210. With out role="dialog" screen
        // readers don't start to read opened T&C box automatically
        ariaDialog: true,
        overlay: false
      };

      tcBox = ModestBox.get('translation-terms-and-conditions');
      tcBox.open(mbConfig);
    },

    impression: function _impression () {
      var contentId = this.model.get('Id');
      var impression;

      // Ignore placeholder content.
      if (!contentId) {
        return;
      }

      impression = {
        contentId: contentId,
        contentType: ContentType.Noun(this.model.get('contentType')),
        subjectType: ContentType.Noun(this.model.get('subjectType')),
        subjectId: this.model.get('ReferenceId'),
        visible: this.isVisible(),
        syndicated: !!this.model.get('IsSyndicated'),
        bvProduct: this.model.get('Type') === 'review' ? 'RatingsAndReviews' : 'AskAndAnswer'
      };

      if (this.model.get('IsSyndicated')) {
        impression.syndicationSource = this.model.get('SyndicationSource').Name;
      }

      return impression;
    },

    _handleBadgeVisibility: function _handleBadgeVisibility () {
      var $badges = this.$viewEl.find('.bv-badge-summary');

      // The first badge AND the first three badges need distinct classes
      // because we show only them at narrow screen widths.
      $badges.first().addClass('bv-badge-first');
      $badges.slice(0, 3).addClass('bv-badge-top-three');
    },

    /**
     * This method determines the orientation of the media and adds an
     * appropriate class name.
     * @param $media : a list of media items
     */
    setMediaOrientation: function setMediaOrientation ($media) {
      // Add classes to crop each image based on their orientation
      // as soon as the images load.
      $media.each(function forEachMediaItem (index, img) {
        $(img).on('load', function onMediaImgLoad () {
          var $mediaContainer = $(this).closest('.bv-media-item');
          var h = this.naturalHeight;
          var w = this.naturalWidth;
          var tempImage;
          var landscape;

          // IE8 doesn't support naturalWidth and naturalHeight so create
          // a temporary image to get those values.
          if (!w || !h) {
            tempImage = new window.Image();

            tempImage.src = this.src;
            w = tempImage.width;
            h = tempImage.height;

            // We already got the width and height, so we do not need
            // the temporary image anymore.
            tempImage = null;
          }

          landscape = h < w;

          // Remove spinner and show image with corresponding icon.
          $mediaContainer.addClass('bv-media-item-show');

          if (landscape) {
            if (1 - (h / w) <= 0.25) {
              $mediaContainer.addClass('bv-media-item-square');
            }
            else {
              $mediaContainer.addClass('bv-media-item-landscape');
            }
          }
          else {
            if (1 - (w / h) <= 0.25) {
              $mediaContainer.addClass('bv-media-item-square');
            }
            else {
              $mediaContainer.addClass('bv-media-item-portrait');
            }
          }
        });
      });
    }
  });

  return ContentItemView;
});


/**
 * @fileOverview Implementation for stubRemainderContentItem model
 */
BV.define('bv/c2013/model/stubRemainderContentItem',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/api'
], function (ENV, BModel, _, api) {

  return BModel.extend({
    name: 'stubRemainderContentItem',

    init: function () {
      if (!this.get('type')) {
        this.set('type', api.noun(this.get('contentType')));
      }

      // Pretend to be a `contentItem` so that we can use `contentItem`'s
      // feature list in our template. (This doesn't have implications beyond
      // features.)
      this.set('refName', 'contentItem');
    },

    setupDataProcessing: function () {
      // no-op
    },

    processData: function (data) {
      // no-op
    }
  });

});

/* START_TEMPLATE */
BV.define('hbs!stubRemainderContentItem',['hbs','vendor/handlebars/runtime','hbs!contentAvatar', 'template/helpers/view', 'template/helpers/unlessHasFeature', 'template/helpers/ifHasFeature', 'template/helpers/renderIcon', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " "
    + " "
    + " ";
  stack1 = helpers.each.call(depth0, depth0.remainders, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0, depth1)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-content-item bv-stub-content-item bv-focusable\" tabindex=\"0\"> "
    + " ";
  stack1 = self.invokePartial(partials.contentAvatar, 'contentAvatar', depth1, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " "
    + " <div class=\"bv-content-container\"> <div class=\"bv-content-core\"> "
    + " <div class=\"bv-content-header\"> "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth1)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "inlineProfile", depth2, options) : helperMissing.call(depth0, "unlessHasFeature", "inlineProfile", depth2, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " <div class=\"bv-content-data-summary\"> <div class=\"bv-content-title-container\"> <h4 class=\"bv-content-title\" itemprop=\"headline\"> ";
  options = {hash:{
    'prefix': (depth0.prefix)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentListCount", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentListCount", depth1.msgpack, depth0, options)))
    + " </h4> </div> "
    + " </div> "
    + " </div> "
    + " "
    + " </div> "
    + " </div> "
    + " </div> "
    + " </div> "
    + " ";
  return buffer;
  }
function program3(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "socialAvatar", depth2, options) : helperMissing.call(depth0, "ifHasFeature", "socialAvatar", depth2, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-author-avatar\"> "
    + " "
    + " <span class=\"bv-author-no-avatar bv-author-gender-Male\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-author-Multiple", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-author-Multiple", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </div> "
    + " ";
  return buffer;
  }
function program5(depth0,data) {
  
  
  return "&#x260D;";
  }

  options = {hash:{
    'tag': ("li")
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('stubRemainderContentItem', t);
t.deps = ["contentAvatar"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/stubContentItem',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"ratingsOnly_contentListCount" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "count";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["count"];
r += " Ratings-Only Review";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["count"];
r += " Ratings-Only Reviews";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `ratingsOnly_contentListCount`: ' + e.toString() ) ] ); return ""; } },"otherLocales_contentListCount" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "count";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["count"];
r += " Review in Another Language";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["count"];
r += " Reviews in Other Languages";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `otherLocales_contentListCount`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('mf!bv/c2013/messages/ugcCount',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"content_type_display" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "type";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Review";
return r;
},
"other" : function(d){
var r = "";
r += "Reviews";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"question" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Question";
return r;
},
"other" : function(d){
var r = "";
r += "Questions";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"answer" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Answer";
return r;
},
"other" : function(d){
var r = "";
r += "Answers";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"product" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Product";
return r;
},
"other" : function(d){
var r = "";
r += "Products";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Content";
return r;
},
"other" : function(d){
var r = "";
r += "Content";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_type_display`: ' + e.toString() ) ] ); return ""; } },"contentListPageInfoSimple" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "orphanEnd";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"true" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["lastPageSize"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["lastPageSize"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["pageSize"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["pageSize"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentListPageInfoSimple`: ' + e.toString() ) ] ); return ""; } },"contentListPageInfo" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "orphanEnd";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"true" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["start"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["start"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["start"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["start"];
r += "&ndash;";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["end"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentListPageInfo`: ' + e.toString() ) ] ); return ""; } },"contentListPageInfoSearch" : function (x) { try { return (function(d){
var r = "";
r += "Showing ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "orphanEnd";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"true" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["end"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["end"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "total";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["total"];
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["start"];
r += "&ndash;";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["end"];
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentListPageInfoSearch`: ' + e.toString() ) ] ); return ""; } },"offscreen_ugc_arrow" : function (x) { try { return (function(d){
var r = "";
r += "Menu, press enter to show options";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_ugc_arrow`: ' + e.toString() ) ] ); return ""; } }
};
});


/**
 *  @fileOverview A content item for displaying at the end of a paginated list
 *  explaining why certain parts of the result set aren't available to be
 *  shown.
 */
BV.define('bv/c2013/view/stubRemainderContentItem',[
  'framework/bview',
  'hbs!stubRemainderContentItem',
  'mf!bv/c2013/messages/stubContentItem',
  'mf!bv/c2013/messages/ugcCount',
  'underscore'
], function (BView, template, stubContentItemPack, ugcCountPack, _) {

  return BView.extend({
    name: 'stubRemainderContentItem',

    template: template,

    msgpacks: [stubContentItemPack, ugcCountPack],

    init: function (config) {
      // no-op
    }
  });

});

/* START_TEMPLATE */
BV.define('hbs!submissionMessage',['hbs','vendor/handlebars/runtime', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <hgroup class=\"bv-submission-message\"> <h1 class=\"bv-submission-icon\" aria-hidden=\"true\">";
  if (stack1 = helpers.icon) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.icon; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</h1> <h2 id=\"bv-mbox-label-text\" class=\"bv-submission-text\"> ";
  if (stack1 = helpers.message) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.message; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " ";
  stack1 = helpers['if'].call(depth0, depth0.offScreenText, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </h2> </hgroup> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span class=\"bv-off-screen\">";
  if (stack1 = helpers.offScreenText) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.offScreenText; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("submission submission-message-container bv-focusable"),
    'tabindex': ("0")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('submissionMessage', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/submissionMessage',[
  'ENV',
  'framework/bmodel',
  'framework/bview',
  'hbs!submissionMessage'
], function (ENV, BModel, BView, template) {
  return BView.extend({
    name: 'SubmissionMessage',

    template: template,

    init: function (config) {
      var component = this.getComponent();

      this.model = new BModel({
        name: 'SubmissionMessage',
        message: config.message,
        offScreenText: config.offScreenText,
        icon: config.icon,
        componentId: this.componentId,
        component: component,
        contentType: component.contentType
      });
    }
  });
});

/*!
 * jQuery replaceText - v1.1 - 11/21/2009
 * http://benalman.com/projects/jquery-replacetext-plugin/
 *
 * Copyright (c) 2009 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

BV.define('vendor/jquery/replacetext',['jquery', 'underscore'], function (jQuery, _) {

  (function($){

    $.fn.replaceText = function( search, replace, text_only ) {
      return this.each(function(){
        var node = this.firstChild;
        var val;
        var new_val;
        // Elements to be removed at the end.
        var remove = [];

        // Only continue if firstChild exists.
        if ( node ) {
          // Loop over all childNodes.
          do {
            // Only process text nodes.
            if ( node.nodeType === 3 ) {
              // The original node value.
              // We need to escape HTML characters since nodeValue un-escapes them.
              val = _.escape(node.nodeValue);
              // The new value.
              new_val = val.replace( search, replace );
              // Only replace text if the new value is actually different!
              if ( new_val !== val ) {
                if ( !text_only && /</.test( new_val ) ) {
                  // The new value contains HTML, set it in a slower but far more
                  // robust way.
                  $(node).before( new_val );
                  // Don't remove the node yet, or the loop will lose its place.
                  remove.push( node );
                } else {
                  // The new value contains no HTML, so it can be set in this
                  // very fast, simple way.
                  // ... except that we have escaped preexisting HTML, so we need to undo that.
                  node.nodeValue = _.unescape(new_val);
                }
              }
            }
            node = node.nextSibling;
          } while ( node );
        }

        // Time to remove those elements!
        if (remove.length) {
          $(remove).remove();
        }
      });
    };

  })(jQuery);

  return jQuery;

});

BV.define('bv/util/jquery/highlight',['vendor/jquery/replacetext', 'underscore'], function ($, _) {

  var BVHighlight = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.bvhighlight.defaults, options);
    this.highlightSearches();
  };

  BVHighlight.prototype = {
    constructor: BVHighlight,

    highlightSearches: function (options) {
      var self = this;
      var searchFor = _(this.options.searchFor).isArray() ? this.options.searchFor : [this.options.searchFor];
      _(searchFor).forEach(function (search) {
        var searchRegex;
        if (_(search).isString()) {
          searchRegex = new RegExp(search.replace(/[.*+?|()\[\]{}\\$\^]/g, '\\$&'), 'ig');
        }
        self.$element.find('*').addBack().replaceText(searchRegex, '<span class="bv-content-highlight">$&</span>');
      });
    }
  };

  $.fn.bvhighlight = function (options) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bvhighlight');
      options = options || {};

      if (!data) {
        $this.data('bvhighlight', (data = new BVHighlight(this, options)));
      }
      if (_.isString(options)) {
        data[options]();
      }
    });
  };

  $.fn.bvhighlight.defaults = {
    searchFor: []
  };

  return $;

});

BV.define('bv/c2013/view/contentItemCollection',[
  'framework/bview',
  'hbs!contentItemCollection',
  'bv/c2013/view/contentItem',
  'bv/c2013/model/stubRemainderContentItem',
  'bv/c2013/view/stubRemainderContentItem',
  'bv/c2013/view/submissionMessage',
  'bv/util/productInfo',
  'underscore',
  'bv/util/jquery/highlight',
  'bv/util/contentType',
  'bv/util/focusManager',
  'bv/ui-core/focusableview',
  'framework/util/bvtracker',
  'bv/util/ariaStatus',
  'bv/util/bvLocal'
], function contentItemCollection (BView, template, ContentItemView, StubRemainderContentItemModel,
  StubRemainderContentItemView, SubmissionMessageView, ProductInfo, _, $, ContentType,
  FocusManager, FocusableView, BVTracker, ariaStatus, bvLocal) {

  var View = BView.extend(FocusableView);
  return View.extend({
    name: 'contentItemCollection',

    template: template,

    init: function _init (config) {
      this.resetDfd = new $.Deferred();
      // Add toLowerCase() to bring all the names of the classes to one look.
      this.classList.push('content-list-' + this.contentType.toLowerCase());

      // We do some special things for review collections.
      this._isReviews = (ContentType.noun(this.contentType) === 'review');
      this._isQuestions = (ContentType.noun(this.contentType) === 'question');

      // Remove non-interactive 'ol' elements from tab order. See UIA-8756.
      // Add focus to Review and Question collections for PRS functionality as well as
      // user experience when tabbing to the review content list.
      // if (this._isReviews || this._isQuestions) {
      //   this.classList.push('focusable');
      // }
    },

    modelDataReady: function _modelDataReady () {
      BView.prototype.modelDataReady.call(this);
      this.initContentViews();

      // After the model's initial data is ready, listen for changes.
      this.listenTo(this.model, {
        reset: this.contentChanged,
        loadmore: this.loadMore,
        add: this.addContent
      });

      if (this.resetDfd) {
        this.resetDfd.resolve(this);
      }

      // CCS-3262: Bandaid. This fix, which should be removed in the future,
      // is a patch to force re-rendering of this view after it's data is ready.
      // It is only necessary because the lifecycle on async clients is fubar.
      // After the follow-up ticket is resolved, this should not be necessary:
      //   https://bits.bazaarvoice.com/jira/browse/UIA-7359
      if (bvLocal.isBVLocal()) {
        this.render();
      }
    },

    initContentViews: function _initContentViews () {
      var self = this;
      this.views = [];
      this.model.forEach(function _initializeAndTrack (contentItemModel, index) {
        self.initContentView(contentItemModel, index);
        self._trackImpression(contentItemModel, true);
      });
    },

    initContentView: function _initContentView (contentItemModel, index) {
      var view;
      var item = contentItemModel;
      var contentType = item.get('Type') || item.contentType || item.get('contentType');
      var componentId = item.componentId || item.get('componentId');

      if (contentItemModel.hasFeature('inlineSubmission')) {
        this.model.fakeSubmissionSchemaExt(contentItemModel);
      }

      view = new ContentItemView({
        model: item,
        config: item,
        componentId: componentId,
        index: index,
        classList: ['content-top-' + ContentType.noun(contentType)],
        parent: this
      });

      this.views.push(view);
      return view;
    },

    contentChanged: function _contentChanged (newContent) {
      var self = this;

      this.resetDfd.done(function _recreateViews () {
        // Destroy old content views and recreate new ones.
        self.initContentViews();
        self.render();
        self.rescanFocusLayer();
      });

      this.publish('loadmedia');
    },

    _trackImpression: function __trackImpression (contentItemModel, isInitialContent) {
      var impressionConfig = {
        type: 'UGC',
        initialContent: !!isInitialContent,
        contentType: contentItemModel.get('Type'),
        contentId: contentItemModel.get('Id'),
        bvProduct: ProductInfo.getType({ model: contentItemModel }),
        categoryId: ProductInfo.getCategoryId(this)
      };
      var parentReview;

      // "clientresponse" content doesn't inherently have a "bvProduct" nor
      // a "contentId". As such we need to set the bvProduct manually and
      // use the contentId from the parent review.
      if (contentItemModel.get('Type') === 'clientresponse') {
        parentReview = contentItemModel.get('parentContentItem');

        _.extend(impressionConfig, {
          bvProduct: 'RatingsAndReviews',
          contentId: parentReview.get('Id')
        });
      }

      BVTracker.impression(impressionConfig, contentItemModel);
    },

    loadMore: function _loadMore (collection, loadedContent, fromIndex) {
      var self = this;
      var index = fromIndex;
      var html = '';
      var views = [];
      var stubView;
      var firstElement;

      // Build up the html for the new content, then add/attach it all at once.
      _(loadedContent).forEach(function _buildHtml (contentItemModel) {
        var view = self.initContentView(contentItemModel, index);
        self._trackImpression(contentItemModel);
        index++;
        html += view.toHTML();
        views.push(view);
      });

      stubView = this._manageStubView();
      if (stubView) {
        html += stubView.toHTML();
        views.push(stubView);
      }

      self.$viewEl.append(html);

      _(views).forEach(function _attachViewElement (view) {
        view.attach(self.viewEl);
      });

      // Focus on the first element of the newly loaded content.
      firstElement = views[0].$viewEl.find('.bv-focusable')[0];
      firstElement.focus();
      // We set a timeout of 0 to delay this until after the new content loads
      setTimeout(function _refocus () {
        FocusManager.rescanFocusLayer();
        // Force focus to be the currently focussed element
        FocusManager.moveFocus($(firstElement));
      }, 0);
    },

    _manageStubView: function __manageStubView () {
      var stubContentItemIndices = [];
      var currentPage = this.model.componentGet('currentPage');
      var totalPages = this.model.componentGet('numPages');
      var stats = this.model.stats || {};
      var stubCounts = [];

      // Remove any old stub views.
      _(this.views).each(function _findOldStubViews (view, index) {
        if (view.name === 'stubRemainderContentItem') {
          stubContentItemIndices.push(index);
        }
      });
      _(stubContentItemIndices).each(function _removeOldStubViews (index) {
        this.views.splice(index, 1);
      }, this);

      // Before we serialize to HTML, we need to figure out if we're
      // including a new stub content item.
      if (currentPage !== totalPages) {
        // We're not on the last page. We should not create a stub view.
        return;
      }

      // The number of non-ratings-only reviews in this locale with all
      // filters applied.
      stats.localCount = stats.localCount || 0;

      // The number of ratings-only reviews across all locales with all
      // (non-locale-related) filters applied.
      stats.globalRatingsOnlyCount = stats.globalRatingsOnlyCount || 0;

      // The number of non-ratings-only reviews across all locales with all
      // (non-locale-related) filters applied.
      stats.globalCount = stats.globalCount || 0;

      // The number of reviews in locales other than this one, excluding
      // ratings-only reviews.
      stats.otherLocaleCount = stats.otherLocaleCount || 0;

      if (stats.globalRatingsOnlyCount > 0) {
        // There should be a stub content item for ratings-only reviews.
        stubCounts.push({
          prefix: 'ratingsOnly_',
          count: stats.globalRatingsOnlyCount
        });
      }

      if (stats.otherLocaleCount > 0) {
        // There should be a stub content item for reviews from other locales.
        stubCounts.push({
          prefix: 'otherLocales_',
          count: stats.otherLocaleCount
        });
      }

      if (stubCounts.length > 0) {
        return this._createStubView(stubCounts);
      }

      return null;
    },

    serializeSubviews: function _serializeSubviews () {
      var stubView;
      if (this._isReviews) {
        stubView = this._manageStubView();
        if (stubView) {
          this.views.push(stubView);
        }
      }
      return View.prototype.serializeSubviews.apply(this, arguments);
    },

    _createStubView: function __createStubView (stubCounts) {
      var view;
      var component = this.getComponent();
      var total = _(stubCounts).reduce(function _countStubs (sum, item) {
        return sum + item.count;
      }, 0);

      var attributes = {
        totalResults: this.model.componentGet('totalResults'),
        startResult: this.model.componentGet('startResult'),
        pageItemCount: this.model.componentGet('pageItemCount'),
        remainders: stubCounts,
        remainderCount: total
      };

      var model = new StubRemainderContentItemModel({
        component: component,
        parent: this.model,
        contentType: this.contentType
      });
      model.set(attributes);

      view = new StubRemainderContentItemView({
        model: model,
        component: component,
        parent: this
      });

      return view;
    },

    addContent: function _addContent (contentItemModel, collection, options) {
      var contentType = contentItemModel.contentType || contentItemModel.get('contentType');
      var messageText;
      var newView;
      var ariaMessage;
      var messageView;

      if (contentItemModel.hasFeature('inlineSubmission')) {
        this.model.fakeSubmissionSchemaExt(contentItemModel);
      }

      newView = new ContentItemView({
        model: contentItemModel,
        config: contentItemModel,
        componentId: contentItemModel.componentId || contentItemModel.get('componentId'),
        classList: ['content-item', 'content-' + ContentType.noun(contentType)],
        parent: this
      });

      // Add the rendered preview to the top of the content and give it at
      // class so we can style it all special like.
      if (this.$viewEl) {
        var _self = this;
        if (options.isPreview) {
          // Add the rendered preview to the top of the content and give it at
          // class so we can style it all special like.
          this.$viewEl
            .prepend(newView.toHTML())
            .find('li:first')
            .addClass('bv-content-preview');

          // Clone preview message text to aria status so screen readers can see it
          messageText = this.$viewEl.find('.bv-content-preview-message').text();
          ariaMessage = ariaStatus.add(messageText);
          _.delay(function _removeAriaMessage () {
            ariaMessage.remove();
          }, 1000);

          // Scroll the window to the new review.
          this.publish('scrolltocontent');

          // set the focus on a submission button, once Thank You Page button is closed.
          // This is needed to comply with accessibility (see CCS-33218 for details)
          _.delay( function() {
            var focusFlag = sessionStorage.getItem('bvSubmissionTriggerElemenet');
            var elemToFocusOn = _self._isReviews ? '.bv-write-review' : '.bv-ask-question';
            var searchElemQuery;

            switch(focusFlag) {
              case 'bvSummary':
                searchElemQuery = $('#BVRRSummaryContainer ' + elemToFocusOn);
                break;
              case 'bvContentList':
                searchElemQuery = $('.bv-content-list-container ' + elemToFocusOn);
                break;
              default:
                break;
            }

            FocusManager.moveFocus(searchElemQuery);

            },
            500
          );

        }
        else {
          // Use render to make sure all the events are delegated correctly.
          if (!options.message) {
            options.view.model = contentItemModel;
            options.view.hasSubmissionView = false;
            options.view.classList.push('content-item-scale-out');
            options.view.render();

            _.delay(function _showView () {
              options.view.$viewEl.removeClass('bv-content-item-scale-out')
                .addClass('bv-content-item-scale-in');
            }, 500);
          }
          else {
            messageView = new SubmissionMessageView({
              componentId: options.view.componentId,
              message: options.message,
              classList: ['thankyou'],
              icon: '&#x2714;'
            });

            $(options.view.$viewEl[0]).find('div').remove();
            $(options.view.$viewEl[0]).parent().find('div.bv-thankyou').remove();
            $(options.view.$viewEl[0]).parent().prepend(messageView.toHTML());

            _.delay(function _moveView () {
              options.view.$viewEl.removeClass('bv-content-item-scale-out')
                .addClass('bv-content-item-scale-in');
              options.view.model = null;
              newView.classList.push('content-item-scale-out');

              // Azel wants to try show question in a diff place.
              newView.setElement(options.view.$viewEl.parent());
              $(options.view.$viewEl[0]).after(newView.toHTML());
              newView.attach();
            }, 500);

            _.delay(function _showNewView () {
              newView.$viewEl.removeClass('bv-content-item-scale-out')
                .addClass('bv-content-item-scale-in');
            }, 1500);
          }
        }
      }
    }

  });
});

BV.define('bv/c2013/model/ugcCount',[
  'framework/bmodel',
  'underscore',
  'bv/c2013/model/contentList',
  'bv/util/productInfo',
  'framework/util/bvtracker'
], function (BModel, _, ContentList, ProductInfo, BVTracker) {
  return BModel.extend({
    name: 'ugcCount',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);

      // Set flag for displaying a different label on search results (i.e. 'Showing 1-10' instead of '1-4 of 368 reviews')
      var parent = this.get('parent');
      this.set('searchPagination', parent.name === 'searchContentList');

      if (parent.get('parentContentType') && parent.get('parentContentId')) {
        this.set({
          parentContentType: parent.get('parentContentType'),
          parentContentId: parent.get('parentContentId')
        });
      }

      var listModel = this.getClosestAncestor({ modelType: ContentList });
      if (listModel) {
        this.listenTo(listModel, 'pageinfo', this.updatePageInfo);
      }
      else if (this.getComponent().type === 'genericSubmission') {
        this.subscribe('pageinfo', this.updatePageInfo);
      }
    },

    updatePageInfo: function (newPagingValues, infoSrc) {
      if (this.hasFeature('instanceNameScope') && infoSrc) {
        if (infoSrc.instanceName !== this.getInstanceName()) {
          return;
        }
      }
      if (!newPagingValues.message) {
        this.unset('message');
      }
      if (!newPagingValues.inlineMessage) {
        this.unset('inlineMessage');
      }
      if (newPagingValues.parentContentId) {
        if (this.get('parentContentType') === newPagingValues.parentContentType &&
            this.get('parentContentId') === newPagingValues.parentContentId) {
          this.set(newPagingValues);
          this.trigger('datachanged');
        }
      }
      else {
        this.set(newPagingValues);
        this.trigger('datachanged');
      }
    },

    /**
     * Page to a specific page number and send an event to notify
     * listeners that the page has been changed
     * @param pageNum  The page number to change to
     * @param pageData The page data object.  Expects key/value for
     *                 srcControl, bvProduct, productId
     */
    pageTo: function (pageNum, pageData) {
      if (pageNum < 1 || pageNum > this.get('numPages')) {
        // Ignore invalid paging.
        return;
      }

      this.publish('pageto', pageNum);

      if (pageData.srcControl) {
        BVTracker.feature({
          type: 'Used',
          name: 'Paginate',
          detail1: pageData.srcControl,
          detail2: pageNum,
          bvProduct: pageData.bvProduct,
          productId: pageData.productId,
          categoryId: ProductInfo.getCategoryId(this)
        });
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!ugcCountSummary',['hbs','vendor/handlebars/runtime', 'template/helpers/compare', 'template/helpers/extmsg', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.searchPagination, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentListPageInfoSearch", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentListPageInfoSearch", depth0.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.simpleMode, {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentListPageInfoSimple", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentListPageInfoSimple", depth0.msgpack, depth0, options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "content_type_display", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "content_type_display", depth0.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentListPageInfo", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentListPageInfo", depth0.msgpack, depth0, options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "content_type_display", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "content_type_display", depth0.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.message, {hash:{},inverse:self.noop,fn:self.program(10, program10, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.message) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.message; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " ";
  return buffer;
  }

  buffer += "<div class=\"bv-content-pagination-pages-current bv-focusable\" tabindex=\"-1\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.compare),stack1 ? stack1.call(depth0, depth0.total, "gt", 1, options) : helperMissing.call(depth0, "compare", depth0.total, "gt", 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.total, 0, options) : helperMissing.call(depth0, "equals", depth0.total, 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " ";
  if (stack2 = helpers.inlineMessage) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.inlineMessage; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "&nbsp;</div> ";
  return buffer;
  });
Handlebars.registerPartial('ugcCountSummary', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!ugcCount',['hbs','vendor/handlebars/runtime','hbs!ugcCountSummary', 'template/helpers/view', 'template/helpers/exists'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.total, options) : helperMissing.call(depth0, "exists", depth0.total, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.ugcCountSummary, 'ugcCountSummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("control-bar-count"),
    'alwaysRender': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('ugcCount', t);
t.deps = ["ugcCountSummary"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/ugcCount',[
  'framework/bview',
  'hbs!ugcCount',
  'mf!bv/c2013/messages/ugcCount',
  'bv/util/productInfo',
  'jquery'
], function (BView, template, msgPack, ProductInfo, $) {
  return BView.extend({
    name: 'ugcCount',

    template: template,

    msgpacks: [msgPack],

    modelDataReady: function () {
      BView.prototype.modelDataReady.call(this);
      // After the model's initial data is ready, listen for changes.
      this.listenTo(this.model, 'datachanged', this.updatePageInfo);
    },

    firstPage: function () {
      var pageData = {
        srcControl: 'First',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this)
      };
      this.model.pageTo(1, pageData);
    },

    lastPage: function (a) {
      var pageData = {
        srcControl: 'Last',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this)
      };
      this.model.pageTo(this.model.get('numPages'), pageData);
    },

    updatePageInfo: function () {
      // if we haven't rendered before, do nothing.
      if (this.$viewEl && this.$viewEl.length) {
        this.render();
      }
    }

  });
});

/*global unescape:false */
/**
 *  @fileOverview Used to parse and validate a `bvstate` URL parameter.
 *
 *  Crash course on `bvstate`:
 *
 *  1. It can appear as a URL param or as part of the URL fragment, whether
 *     in the fragment itself or in the _escaped_fragment_ equivalent URL
 *     param used by Google.
 *
 *  2. It can specify page number, content type, subject type, and product
 *     ID. Currently, for our purposes, all we're concerned with is the page
 *     number and the content type, since that's all the information we need
 *     to tell a particular component to go to a particular page.
 *
 *  3. Its main purpose is to permalink paginated content so that GoogleBot
 *     can scrape it.
 *
 *  Examples of valid `bvstate` parameters:
 *
 *  - http://example.com/?bvstate=pg2/ctr/stp/id91419
 *  - http://example.com/?foo=bar#!bvstate=pg2/ctr/stp/id91419
 *  - http://example.com/?foo=bar&_escaped_fragment_=pg2%2Fctr%2Fstp%2Fid91419
 *
 *  For more information, see:
 *  https://bits.bazaarvoice.com/confluence/display/PM/Spec+for+SEO+Links+-+bvpage
 */
BV.define('bv/util/bvstate',[
  'underscore',
  'util/url',
  'window'
], function (_, URL, window) {

  // Like String.prototype.split, except it divides the string into exactly
  // two parts at the _first_ occurrence of the given string. Otherwise
  // things like http://example.com?foo=bar=baz&baz=thud won't get parsed
  // correctly.
  function divideAt (str, divider) {
    var index = str.indexOf(divider);
    var left = str.substring(0, index);
    var right = str.substring(index + 1);
    return [left, right];
  }

  var contentTypes = {
    q: 'question',
    r: 'review',
    a: 'answer',
    c: 'comment',
    s: 'story',
    u: 'universal'
  };

  var subjectTypes = {
    p: 'product',
    c: 'category',
    d: 'detail',
    e: 'entry'
  };

  var VALIDATORS = {
    // PAGE
    // Must be a string that represents an integer.
    pg: function (value) {
      if (value.length === 0) {
        return false;
      }
      var num = Number(value);
      return !isNaN(num) && Math.round(num) === num;
    },

    // CONTENT TYPE
    // Must be a recognized type.
    ct: function (value) {
      return (value in contentTypes);
    },

    // SUBJECT TYPE
    // Must be a recognized type.
    st: function (value) {
      return (value in subjectTypes);
    },

    // SUBJECT ID
    // Any string without spaces.
    id: function (value) {
      return !(/\s/.test(value));
    }
  };

  // Convert raw values to parsed values.
  var TRANSFORMERS = {
    ct: function (value) {
      return contentTypes[value];
    },

    st: function (value) {
      return subjectTypes[value];
    },

    pg: function (value) {
      return Number(value);
    }
  };


  // Convert parsed values back to unparsed values.
  var UNTRANSFORMERS = {
    // For safety's sake, the untransformers should gracefully handle values
    // that are already untransformed.
    ct: function (value) {
      value = value.toLowerCase();
      var longNames = _(contentTypes).values();
      if (!VALIDATORS.ct(value) && !_(longNames).contains(value)) {
        // This is neither a valid short name nor a valid long name for a
        // contentType. Return something that will fail validation.
        return null;
      }

      if (value.length === 1) {
        // It must be a short name, and must be a valid one or else it
        // would've failed the check above.
        return value;
      }

      // It must be a long name. Find its corresponding short name.
      // (This is guaranteed to return something because invalid long names
      // got filtered out above.)
      for (var key in contentTypes) {
        if (value === contentTypes[key]) {
          return key;
        }
      }
    },

    st: function (value) {
      value = value.toLowerCase();
      var longNames = _(subjectTypes).values();
      if (!VALIDATORS.st(value) && !_(longNames).contains(value)) {
        // This is neither a valid short name nor a valid long name for a
        // subjectType. Return something that will fail validation.
        return null;
      }

      if (value.length === 1) {
        // It must be a short name, and must be a valid one or else it
        // would've failed the check above.
        return value;
      }

      // It must be a long name. Find its corresponding short name.
      // (This is guaranteed to return something because invalid long names
      // got filtered out above.)
      for (var key in subjectTypes) {
        if (value === subjectTypes[key]) {
          return key;
        }
      }
    }
  };

  function validate (value, key) {
    if (!(key in VALIDATORS)) {
      return false;
    }
    return VALIDATORS[key](value);
  }

  function transform (value, key) {
    if (!(key in TRANSFORMERS)) {
      return value;
    }
    return TRANSFORMERS[key](value);
  }

  function untransform (value, key) {
    if (!(key in UNTRANSFORMERS)) {
      return value;
    }
    return UNTRANSFORMERS[key](value);
  }

  /**
   *  Parse a `bvstate` value string by itself.
   *
   *  Accepts either (e.g.) "ct:r/pg:2" or "bvstate=ct:r/pg:2" as input.
   *
   *  @param {String} value The value to parse, without any surrounding
   *    string.
   *  @return {Object} The metadata for that input. Can have keys `pg`
   *    (page), `ct` (content type), `st` (subject type), and `id` (subject
   *    ID), though keys will only be included if a _valid_ value is found
   *    for that key. If no valid keys are found, returns an empty object.
   */
  function parse (value) {
    if ((/^bvstate=/).test(value)) {
      value = value.replace(/^bvstate=/, '');
    }
    var parts = value.split('/');
    var result = {};

    _(parts).each(function (p) {
      if (p.indexOf(':') === -1) {
        // Invalid.
        return;
      }
      var pair = divideAt(p, ':');
      var key = pair[0];
      var value = pair[1];

      // If this isn't a recognized key, or if it fails validation, pretend
      // it doesn't exist.
      if (!validate(value, key)) {
        return;
      }
      // Run it through transformation.
      value = transform(value, key);
      result[key] = value;
    });

    return result;
  }

  /**
   *  Parse a full URL, extracting the `bvstate` metadata if present.
   *
   *  Note that a full URL can specify `bvstate` metadata in more than one
   *  way. If this happens, all sources will be used, with later sources able
   *  to override specific aspects of earlier sources' data. Sources are
   *  handled in this order, with later sources winning out:
   *
   *  1. An actual URL parameter, as in http://example.com/foo?bvstate=pg4
   *  2. An `_escaped_fragment_` URL parameter (Google's equivalent to the
   *     URL fragment for SEO purposes), as in
   *     http://example.com/foo?_escaped_fragment_=bvstate=pg4
   *  3. Within the URL fragment, as in http://example.com/foo#!bvstate=pg4
   *
   *  @param {String} url The URL to parse
   *  @return {Object} The metadata for that input. Can have keys `pg`
   *    (page), `ct` (content type), `st` (subject type), and `id` (subject
   *    ID), though keys will only be included if a _valid_ value is found
   *    for that key. If no valid keys are found, returns an empty object.
   */
  function parseURL (url) {
    var paramValue = URL.getParam(url, 'bvstate');
    var escapedFragment = URL.getParam(url, '_escaped_fragment_');
    var hash = URL.hash(url);
    var hashParams;
    var result = {};

    function consumePair (value, key, i) {
      if ((/bvstate/i).test(key)) {
        _.extend(result, parse(value));
      }
    }

    // These three sources are specifically handled in this order. Later
    // sources win out over earlier sources.
    if (paramValue) {
      _.extend(result, parse(paramValue));
    }

    if (escapedFragment) {
      var escapedFragmentParams = URL.toQueryParams(escapedFragment);
      _.each(escapedFragmentParams, consumePair);
    }

    if (hash) {
      // Strip initial # or #! from the hash.
      hash = hash.replace(/^#!?/, '');
      hash = unescape(hash);
      try {
        hashParams = URL.toQueryParams(hash);
      }
      catch (e) {
        // This is a rare case where an empty `catch` block is likely the
        // right thing to do.
        //
        // There's no standard for how to decode a URL fragment into
        // key/value pairs. We've got to unescape the hash or else we could
        // miss some encoded &s and =s. But `URL.toQueryParams` will do its
        // own URL decoding on each value in the pair, so we end up
        // double-decoding, which will throw an error with some input.
        //
        // Two possible solutions to this are (a) allow `URL.toQueryParams`
        // to accept an option that can skip its internal decoding; or (b)
        // catch and ignore such an error. Ordinarily A would seem like the
        // better option, but `URL.toQueryParams` is an exact copy of the
        // version in underscore.strings.js, and it seems wrong to diverge
        // from that. More importantly, any input that would throw an error
        // is input we're not expecting, and serves as a signal that we
        // should stop trying to parse the URL fragment altogether.
      }
      if (hashParams) {
        _.each(hashParams, consumePair);
      }
    }

    return result;
  }

  /**
   *  The opposite of parsing; given a `bvstate`-like object, find a string
   *  that will `parse` to that object.
   *
   *  In other words, `parse( serialize(foo) )` should be an equivalent
   *  object to `foo`.
   *
   *  @param {Object} bvstate  The bvstate object to be serialized.
   *  @returns {String}
   */
  function serialize (bvstate) {
    var result = [];
    var value;
    var str;
    for (var name in bvstate) {
      value = bvstate[name];

      // If we're dealing with an object we got from `parse`, some of the
      // parts will have been transformed, and we should un-transform them
      // before we validate or serialize.
      value = untransform(value, name);

      // Skip the param if it doesn't pass validation.
      if (!validate(value, name)) {
        continue;
      }

      result.push(name + ':' + value);
    }

    return result.join('/');
  }

  /**
   *  Given a URL, remove its bvstate attribute.
   *
   *  @param {String} url The URL.
   *  @return {String}
  **/
  function removeFromURL (url) {
    return URL.splice(url, 'bvstate');
  }

  /**
   *  Given a URL and a bvstate object, generates a new URL with the new
   *  bvstate data while otherwise leaving the URL intact.
   *
   *  If the URL previously had a `bvstate` parameter of some sort, the
   *  information in that parameter will be used as a base.
   *
   *  @param {String} url          The URL.
   *  @param {Object} newStateValue The new `bvstate` information to encode.
   */
  function updateURL (url, newStateValue) {
    var bvstate = parseURL(url);

    // Clone the new object so we don't overwrite any of its info.
    newStateValue = _.clone(newStateValue);

    var escapedFragment = URL.getParam(url, '_escaped_fragment_');
    var hash = URL.hash(url);

    var matchesHash = hash && hash.indexOf('bvstate') !== -1;
    var matchesEscapedFragment = escapedFragment && escapedFragment.indexOf('bvstate') !== -1;

    // For sanity's sake, we will assume for now that if the `bvstate` param
    // is present in the hash, or in the escaped fragment, we are the _only
    // ones_ using the fragment and can therefore remove it when generating
    // the next page URL.
    //
    // That said, if the escaped fragment or the hash is present but _does
    // not_ contain a `bvstate` param, we should leave it alone.
    if (matchesHash) {
      url = URL.withoutHash(url);
    }

    if (matchesEscapedFragment) {
      url = URL.splice(url, '_escaped_fragment_');
    }

    url = URL.splice(url, 'bvstate');

    // We don't want to extend these new values onto the old ones without
    // checking them for validity, or else an invalid value might overwrite a
    // valid one. So we run `newStateValue` through a serialize/parse cycle.
    // Anything that was valid will still be present; anything that was
    // invalid won't.
    newStateValue = parse(serialize(newStateValue));

    // Extend onto the existing info.
    _.extend(bvstate, newStateValue);

    // Since we validated the state info, we know that the new value of the
    // `bvstate` param contains no characters that have special meanings to
    // URL parsers in the context of a URL parameter's value. Hence we choose
    // not to escape the value so it will look prettier in someone's address
    // bar. Yes, clients care about this.
    url = URL.push(url, 'bvstate', serialize(bvstate), { encode: false });

    return url;
  }

  return {
    parse: parse,
    parseURL: parseURL,
    updateURL: updateURL,
    removeFromURL: removeFromURL,
    serialize: serialize
  };
});

/**
 * This file is used to manage *short-lived* experiments. To add an experiment,
 * add a string to the validExperiments array below, along with an explanation
 * of the experiment, your name, when we should remove the experiment, and any
 * other useful information, such as a ticket number.
 *
 * Experiments can be enabled per implementation under Technical Setup >
 * Site Profile > Experimental Flags. The value of this field should be a comma-
 * separated list of strings. (Presently, this field is only available to BV
 * employees)
 */
BV.define('framework/util/experiments',[
  'ENV',
  'underscore',
  'framework/util/bvreporter',
  'bv/util/bvLocal'
], function (ENV, _, BVReporter, bvLocal) {
  var validExperiments = [
    // Experiment: Asynchronous rendering
    //
    // The goal is to increase main thread availablility and decrease the
    // amount of time we block other scripts and UI. Should be removed when
    // we implement a more permanent configuration option. (See UIA-5159.)
    //
    // Breaks up template serialization into jobs, yielding in between.
    'asyncRender',

    // Experiment: Asynchronous data processing
    //
    // The goal is to increase main thread availablility and decrease the
    // amount of time we block other scripts and UI. Should be removed when
    // we implement a more permanent configuration option. (See UIA-5159.)
    //
    // Breaks up the recursive `processData` call on models, yielding in
    // between.
    'asyncDataProcessing',

    // Experiment: Asynchronous component rendering
    //
    // This experiment treats a component's entire rendering task as a
    // discrete chunk and yields in between each one, instead of rendering
    // each component in turn synchronously. If async render is disabled,
    // this should have some benefit in perceived responsiveness, no matter
    // how tiny. If async render is enabled, this won't do much, but won't
    // hurt either.
    'asyncComponentRender'
  ];

  var configuredExperiments = ENV.get('config').experiments || {};
  var experiments = {};

  _(validExperiments).each(function (exp) {
    if (configuredExperiments[exp]) {
      BVReporter.info('Experiment', exp, 'enabled');
      experiments[exp] = configuredExperiments[exp];
    }
  });

  /**
   * In UIA-5586, we made it so that Firebird won't render for disabled
   * BV Local nodes. This decision -- whether to render or not -- happens
   * asynchronously, so we need to force render to happen asynchronously
   * as well. This accomplishes that.
   */
  if (bvLocal.isBVLocal()) {
    experiments.asyncRender = true;
    BVReporter.info('Experiment asyncRender enabled for BV Local');
  }

  return experiments;
});

/**
 *  @fileOverview Pagination model
 */
BV.define('bv/c2013/model/pagination',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'window',
  'bv/util/pageInfo',
  'bv/util/bvstate',
  'bv/util/contentType',
  'bv/util/productInfo',
  'framework/util/bvtracker',
  'framework/util/experiments'
], function (ENV, BModel, _, window, pageInfo, BVState, ContentType, ProductInfo, BVTracker, experiments) {
  return BModel.extend({
    name: 'pagination',

    defaults: {
      start: 0,
      end: 0,
      total: 0,
      currentPage: 1,
      numPages: 0,
      allowNext: true,
      allowBack: false,
      activeRequests: 0
    },

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
      var parent = this.get('parent');

      var initData = this.componentGet('initData') || parent.get('initData');
      if (initData) {
        this.processData();
      }

      if (parent.name === 'genericSubmission') {
        this.subscribe('pageinfo', this.updatePageInfo, this);
      }

      else {
        this.listenTo(parent, 'pageinfo', this.updatePageInfo);
      }

      if (parent.name === 'secondaryContentList') {
        var contentItem = parent.get('parent');
        if (contentItem) {
          this.set({
            parentContentType: contentItem.get('contentType'),
            parentContentId: contentItem.get('Id')
          });
        }
      }
    },

    processData: function (data) {
      var parent = this.get('parent');
      var initData = this.componentGet('initData') || parent.get('initData');

      if (initData) {
        var currentPage = parent.get('current') || this.componentGet('currentPage');
        var list = initData.List;
        var myPageInfo = pageInfo(
          ContentType.noun(this.get('contentType')),
          currentPage,
          list ? list.length : 0,
          initData.LocalResults || 0
        );

        // We change this after the fact because we want pageInfo to make
        // decisions based on how many reviews we're going to _show_.
        //
        // If we have 100 global results, but 60 of them are ratings-only
        // reviews and another 30 are in locales not configured for display,
        // and we're showing 5 reviews per page, then we want pagination to
        // show 2 pages of reviews, not 20. But we still want the pagination
        // bar to say "1-5 of 200 Reviews."

        // Keep a reference to the true number of displayed reviews. (If it's
        // 0, for instance, we still want to omit the control bar.)
        myPageInfo.localTotal = myPageInfo.total;
        if (initData.TotalResults) {
          myPageInfo.total = initData.TotalResults;
        }
        this.set(myPageInfo);
      }
      this.updateButtonState();
      this.dataReady(data);
    },

    _getNextPageUrl: function () {
      var current = this.get('currentPage');
      var total = this.get('numPages');

      if (current === total) {
        return null;
      }
      return this._getPageUrl(current + 1);
    },

    _getPrevPageUrl: function () {
      var current = this.get('currentPage');
      if (current === 1) {
        return null;
      }
      return this._getPageUrl(current - 1);
    },

    _getPageUrl: function (page) {
      var url = window.location.toString();

      if (page === 1) {
        // We never want to put a bvstate attribute on the URL for showing
        // page 1, since that'll cause it to get indexed as a different page.
        // Ordinarily it'd be rude to remove the `bvstate` attribute, since
        // other apps could theoretically rely on it, but if we get this far
        // it's because we're reacting to a `bvstate` value that was clearly
        // intended for us.
        return BVState.removeFromURL(url);
      }

      var bvstate = { pg: page, ct: ContentType.noun(this.get('contentType')) };
      var newUrl = BVState.updateURL(url, bvstate);
      return newUrl;
    },

    updatePageInfo: function (newValues, options) {
      options = options || {};
      // If this has instanceNameScope and it's not this instance return.
      if (this.hasFeature('instanceNameScope') && options.instanceName !== this.getInstanceName()) {
        return;
      }
      // If we have a parentContentId and the parentContentId is not the
      // newValue's parentContentType OR this model's parentContentId, return
      // immediately.
      if (newValues.parentContentId && (this.get('parentContentType') !== newValues.parentContentType || this.get('parentContentId') !== newValues.parentContentId)) {
        return;
      }

      this.set(newValues);

      // What follows is a bit of a mess to get pagination working
      // correctly for search results.
      //
      // pagination.hbs uses the value of localTotal to determine whether
      // or not it should show pagination arrows.  Normally this value is set in
      // the processData method, but for some reason that doesn't execute for
      // a searchContentList the way it does for other modules.  To that end,
      // we set the value explicitly here.  We use values from the pagination model.
      //
      // To fix a bug in which the model would think it had more results to display
      // than it did (due to the 'total' number of results reflecting those across
      // all locales) we call pageInfo with an updated number of results retrieved
      // from this model's parent, the searchContentList model.

      var parent = this.get('parent');
      var correctedResults = parent.get('fetchResults');
      if (correctedResults) {
        var currentPage = parent.get('current') || this.componentGet('currentPage');
        var correctedNumResults = correctedResults.length;
        var correctedPageInfo = pageInfo(ContentType.noun(this.get('contentType')),
          currentPage,
          correctedNumResults,
          correctedNumResults
        );
        this.set(correctedPageInfo);
      }
      this.set('localTotal', this.get('total'));

      // Figure out the URLs for the next/previous pages, if they exist.
      var component = this.getComponent();
      // Only include pagination links for review/question content lists.
      if (component.get('subjectType') === 'Products') {
        // For this experiment, we should generate URLs that Google can use
        // to crawl the other pages of this content.
        var nextPage = this._getNextPageUrl();
        this.set('seoNextPageUrl', nextPage);

        var prevPage = this._getPrevPageUrl();
        this.set('seoPrevPageUrl', prevPage);
      }

      // If we are not loadMore or sort (i.e., we're prev/next) we need
      // to scroll to the top of the container.
      var scrollPage = !(this.get('loadMore') || options.doNotScroll);

      // Either way, we need to update the button state. Pagination buttons
      // need to know whether to enable/disable themselves, and loadMore
      // needs to know whether it should be shown at all.
      this.updateButtonState();

      // Should scroll to the top on prev/next only
      this.trigger('pagingstatechanged', scrollPage);
    },

    /**
     * Page to a specific page number and send an event to notify
     * listeners that the page has been changed
     * @param pageNum  The page number to change to
     * @param pageData The page data object.  Expects key/value for
     *                 srcControl, loadMore, bvProduct, productId
     */
    pageTo: function (pageNum, pageData) {
      if (pageNum < 1 || pageNum > this.get('numPages')) {
        // ignore invalid paging
        return;
      }
      this.set('currentPage', pageNum);

      var paginationControl = {
        loadMore: pageData.loadMore,
        parentContentType: this.get('parentContentType'),
        parentContentId: this.get('parentContentId'),
        instanceName: this.getInstanceName()
      };

      this.publish('pageto', pageNum, false, paginationControl);

      if (pageData.srcControl) {
        BVTracker.feature({
          type: 'Used',
          name: 'Paginate',
          detail1: pageData.srcControl,
          detail2: pageNum,
          bvProduct: pageData.bvProduct,
          productId: pageData.productId,
          categoryId: ProductInfo.getCategoryId({ model: this })
        });
      }
    },

    updateButtonState: function () {
      var pageNum = this.get('currentPage');
      var allowNext = (pageNum < this.get('numPages'));
      var allowBack = (pageNum > 1);
      this.set({
        allowNext: allowNext,
        allowBack: allowBack
      });
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!pagination',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/mountView', 'template/helpers/extmsg', 'template/helpers/renderIcon'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.showPages, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-pagination")
  },inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--begin-pagination--> <div class=\"bv-content-pagination-container\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount", depth0, options) : helperMissing.call(depth0, "mountView", "ugcCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <ul class=\"bv-content-pagination-buttons\" role=\"presentation\"> "
    + " <li class=\"bv-content-pagination-buttons-item bv-content-pagination-buttons-item-previous\" role=\"presentation\"> ";
  stack2 = helpers['if'].call(depth0, depth0.seoPrevPageUrl, {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> "
    + " <li class=\"bv-content-pagination-buttons-item bv-content-pagination-buttons-item-next\" role=\"presentation\"> ";
  stack2 = helpers['if'].call(depth0, depth0.seoNextPageUrl, {hash:{},inverse:self.program(21, program21, data),fn:self.program(18, program18, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> </ul> </div> "
    + " <!--end-pagination--> ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <a href=\"";
  if (stack1 = helpers.seoPrevPageUrl) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.seoPrevPageUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role=\"button\" class=\"bv-content-btn bv-content-btn-pages bv-content-btn-pages-first bv-focusable bv-content-btn-pages-active\"> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "paginationPrevious", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "paginationPrevious", depth0.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </span> <span class=\"bv-content-btn-pages-prev\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-left-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-left-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </a> ";
  return buffer;
  }
function program5(depth0,data) {
  
  
  return " &#x25C4; ";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <button type=\"button\" class=\"bv-content-btn bv-content-btn-pages bv-content-btn-pages-first bv-focusable bv-content-btn-pages-";
  stack1 = helpers['if'].call(depth0, depth0.allowBack, {hash:{},inverse:self.program(10, program10, data),fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers.unless.call(depth0, depth0.allowBack, {hash:{},inverse:self.noop,fn:self.program(12, program12, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "paginationPrevious", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "paginationPrevious", depth0.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </span> <span class=\"bv-content-btn-pages-prev\" aria-hidden=\"true\"> ";
  stack2 = helpers['if'].call(depth0, depth0.allowBack, {hash:{},inverse:self.program(16, program16, data),fn:self.program(14, program14, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </button> ";
  return buffer;
  }
function program8(depth0,data) {
  
  
  return "active";
  }

function program10(depth0,data) {
  
  
  return "inactive";
  }

function program12(depth0,data) {
  
  
  return "disabled";
  }

function program14(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-left-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-left-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-left-arrow-light", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-left-arrow-light", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <a href=\"";
  if (stack1 = helpers.seoNextPageUrl) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.seoNextPageUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role=\"button\" class=\"bv-content-btn bv-content-btn-pages bv-content-btn-pages-last bv-focusable bv-content-btn-pages-active\"> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "paginationNext", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "paginationNext", depth0.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </span> <span class=\"bv-content-btn-pages-next\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-right-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-right-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </a> ";
  return buffer;
  }
function program19(depth0,data) {
  
  
  return " &#x25BA; ";
  }

function program21(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <button type=\"button\" class=\"bv-content-btn bv-content-btn-pages bv-content-btn-pages-last bv-focusable bv-content-btn-pages-";
  stack1 = helpers['if'].call(depth0, depth0.allowNext, {hash:{},inverse:self.program(10, program10, data),fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers.unless.call(depth0, depth0.allowNext, {hash:{},inverse:self.noop,fn:self.program(12, program12, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "paginationNext", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "paginationNext", depth0.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </span> <span class=\"bv-content-btn-pages-next\" aria-hidden=\"true\"> ";
  stack2 = helpers['if'].call(depth0, depth0.allowNext, {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </button> ";
  return buffer;
  }
function program22(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-right-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-right-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-right-arrow-light", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-right-arrow-light", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.localTotal, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('pagination', t);
t.deps = [];
t.tplMountedViews = ['ugcCount'];
return t;
});
/* END_TEMPLATE */
;
/**
 *  @fileOverview Initiates/reacts to page changes related to the `bvstate` parameter.
 */
BV.define('bv/util/bvstateManager',[
  'ENV',
  'underscore',
  'util/url',
  'window',
  'jquery',
  'bv/util/bvstate',
  'framework/util/bvreporter'
], function (ENV, _, URL, window, $, BVState, BVReporter) {
  // Keep a unique ID around so that subscribers can be identified
  // unambiguously.
  var UID = 1;

  // If the page has a <link rel="canonical"> tag, and they've enabled a
  // setting in Config Hub, we should make sure that canonical URL has our
  // pagination data.
  function validateCanonicalLink (bvstate) {
    // We need a page number _and_ a content type to use it on.
    if (!bvstate.pg || !bvstate.ct) { return; }

    // Check if there's a LINK tag.
    var $link = $('link[rel=canonical]');
    if ($link.length === 0) { return; }

    // If so, grab its href, parse it with BVState, and check for equivalence.
    var href = $link.attr('href');

    var newHref = null;
    var canonicalBvState;

    // But before we check for equivalence, we need to handle one special
    // case: if the page number is 1 and it's a Firebird content type, we
    // want to remove `bvstate` from the URL entirely. We don't want to index
    // identical content at two different URLs.
    if (bvstate.pg === 1 && (/[qr]/).exec(bvstate.ct)) {
      newHref = BVState.removeFromURL(href);
    }
    else {
      // Otherwise, we should make sure the canonical URL includes current
      // `bvstate` info, and update it if it doesn't.
      canonicalBvState = BVState.parseURL(href);
      if (!_.isEqual(bvstate, canonicalBvState)) {
        newHref = BVState.updateURL(href, bvstate);
      }
    }

    // If we didn't assign `newHref`, there's no change to be made.
    if (!newHref) { return; }

    BVReporter.info('Changing page\'s canonical URL from:', href, 'to:', newHref);
    $link.attr('href', newHref);
  }

  function callBundle (bundle, state) {
    bundle.handler.call(bundle.scope, state);
  }

  return {
    state: null,

    _handlers: {},
    /**
     *  Initialize the BVStateManager.
     *
     *  @param {Object} initialState An object representing the manager's
     *                  initial state. Optional. If missing, the manager will
     *                  try to determine the initial state from the page URL.
     */
    start: function (initialState) {
      var state;
      if (initialState) {
        state = _.clone(initialState);
      }
      else {
        state = BVState.parseURL(window.location.toString());
      }

      this._change(state);
      var ENVConfig = ENV.get('config');

      // If a `bvstate` parameter is present, _and_ this page has a
      // `link[rel=canonical]` tag, we should make sure that tag's HREF
      // includes the information in the `bvstate` parameter. Otherwise, for
      // instance, each separate page of reviews will get indexed by
      // Googlebot as all pointing to the same PDP URL.
      //
      // This feature is enabled by default in Config Hub.
      if (ENVConfig.queryRouter && ENVConfig.queryRouter.editCanonicalTags) {
        validateCanonicalLink(this.state);
      }
    },

    /**
     *  Subscribe to changes in `bvstate`.
     *
     *  @return {Number} The ID of this subscription. Keep this around if you
     *                   need to unsubscribe later.
     */
    subscribe: function (handler, scope) {
      var subscriptionId = UID++;
      if (_.isUndefined(scope)) {
        scope = null;
      }
      var bundle = { handler: handler, scope: scope };

      this._handlers[subscriptionId] = bundle;

      if (this.state !== null) {
        callBundle(bundle, this.state);
      }

      return subscriptionId;
    },

    /**
     *  Unsubscribe from changes in `bvstate`.
     *
     *  @param {Number} subscriptionId The ID received on the call to
     *                  `subscribe`.
     */
    unsubscribe: function (subscriptionId) {
      BVReporter.assert(_.isNumber(subscriptionId), 'argument must be number');
      var bundle = this._handlers[subscriptionId];
      if (!bundle) { return; }

      delete this._handlers[subscriptionId];
    },

    /**
     *  Change the `bvstate`.
     */
    update: function (newState) {
      if (_.isEqual(newState, this.state)) { return; }
      // TODO: Update the URL in browsers that support history.pushState.
      // When this is implemented, make sure you change the URL _before_ you
      // trigger the handlers.
      this._change(newState);
    },

    _change: function (state) {
      this.state = state;
      _(this._handlers).each(function (bundle, key) {
        callBundle(bundle, state);
      });
    }
  };


});

BV.define('mf!bv/c2013/messages/pagination',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"paginationPrevious" : function (x) { try { return (function(d){
var r = "";
r += "Previous";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `paginationPrevious`: ' + e.toString() ) ] ); return ""; } },"paginationNext" : function (x) { try { return (function(d){
var r = "";
r += "Next";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `paginationNext`: ' + e.toString() ) ] ); return ""; } }
};
});

/**
 * @fileOverview View for a content list's pagination.
 */
BV.define('bv/c2013/view/pagination',[
  'ENV',
  'framework/bview',
  'jquery',
  'hbs!pagination',
  'bv/util/contentType',
  'bv/util/productInfo',
  'bv/util/loadingOverlay',
  'bv/util/bvstateManager',
  'util/url',
  'mf!bv/c2013/messages/pagination',
  'mf!bv/c2013/messages/common'
], function (ENV, BView, $, template, ContentType, ProductInfo, LoadingOverlay, BVStateManager, url, msgPackPagination, msgPackCommon) {
  return BView.extend({
    name: 'pagination',
    events: {
      'click .bv-content-btn-pages-first': 'prevPageClicked',
      'click .bv-content-btn-pages-last': 'nextPageClicked',
      'click button.bv-content-pagination-pages-arrow': 'pagesArrowClicked'
    },
    template: template,
    msgpacks: [msgPackPagination, msgPackCommon],
    handlerAdded: false,

    init: function () {
      this.on('attach', function (self) {
        if (!self.handlerAdded) {
          self.listenTo(self.model, 'pagingstatechanged', self.stateChanged);
          self.handlerAdded = true;
        }
        if (!self.viewEl) { return; }
        self.$('ul.bv-content-pagination-pages').hover(
          function () {
            $(self).addClass('bv-content-pagination-pages-active');
          },
          function () {
            $(self).removeClass('bv-content-pagination-pages-active');
          }
        );
      });
    },

    stateChanged: function (scrollPage) {
      LoadingOverlay.hide();
      if (this.$viewEl) {
        this.render();
        if (scrollPage) {
          this.scrollPage();
        }
      }
    },

    scrollPage: function (e) {
      this.model.publish('scrolltocontent');
    },

    pageTo: function (e, direction) {
      var toPage;
      var increment = 1;

      e.preventDefault();
      if ($(e.target).hasClass('bv-content-btn-pages-inactive')) {
        return;
      }
      if (direction === 'Prev') {
        increment = -1;
      }
      toPage = this.model.get('currentPage') + increment;
      var pageData = {
        srcControl: direction,
        loadMore: false,
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this)
      };

      // We're changing pages. Update the `bvstate` info.
      BVStateManager.update({
        ct: this.model.get('contentType'),
        pg: toPage
      });

      LoadingOverlay.show();
      this.model.pageTo(toPage, pageData);
    },

    // Event handler for the "back" pagination button
    prevPageClicked: function (e) {
      e.preventDefault();
      this.pageTo(e, 'Prev');
    },

    // Event handler for the "next" pagination button
    nextPageClicked: function (e) {
      e.preventDefault();
      this.pageTo(e, 'Next');
    },

    pagesArrowClicked: function (e) {
      this.$('ul.bv-content-pagination-pages').toggleClass('bv-content-pagination-pages-active');
    }
  });
});

BV.define('bv/c2013/model/secondaryContentItem',[
  'ENV',
  'bv/c2013/model/contentItem',
  'underscore'
], function (ENV, BContentItemModel, _) {
  return BContentItemModel.extend({
    options: {},
    name: 'secondaryContentItem',

    init: function (config, options) {
      // Make sure this.get('Author') is formatted
      // properly using the available data
      this._cleanAuthorData();

      // Mixin options
      _.extend(this.options, options);
      var parent = this.get('parent');
      if (parent) {
        this.set({
          parentContentItem: parent.parentContentItem
        });
      }
    }
  });
});

BV.define('bv/c2013/collection/secondaryContentItemCollection',[
  'bv/c2013/collection/contentItemCollection',
  'underscore',
  'bv/c2013/model/secondaryContentItem',
  'ENV',
  'bv/api'
],
function (BContentCollection, _, ContentItem, ENV, api) {
  return BContentCollection.extend({
    model: ContentItem,
    name: 'secondaryContentItemCollection',

    init: function (models, options) {
      var parent = this.options.parent;
      // This collection's data is ready, when its parent's data is ready
      if (parent) {
        this.parentContentItem = parent.get('parent');
      }
    },

    fetchPage: function (page, clientAPIConfig, filters, paginationControl) {
      if (!this.parentContentItem) {
        throw new Error('SecondaryContentItemCollection is missing its parentContentItem.');
      }

      var self = this;
      var requestType = api.nouns(this.contentType);
      var parentType = this.parentContentItem.get('contentType');
      var config = ENV.get('config');
      var pageConfig = config.page.details[api.noun(requestType)] || config.page;
      var pageSize = pageConfig.size;
      var pageSize2n = pageConfig.size2n;
      var limit = page > 1 ? pageSize2n : pageSize;
      var offset = page > 1 ? pageSize + (pageSize2n * (page - 2)) : 0;


      if (requestType === 'comments') {
        requestType = api.noun(parentType) + requestType;
      }

      var contentRequest = api.get(requestType)
        .include(['Authors', api.Nouns(parentType)])
        .withStatsOn(this.getStatsTypes())
        .limit(limit)
        .offset(offset);

      if (!_(paginationControl).isUndefined() && !_(paginationControl.parentContentId).isUndefined()) {
        var filterContentType = api.noun(paginationControl.parentContentType);
        contentRequest = contentRequest.filterBy(filterContentType + 'id', paginationControl.parentContentId);
      }

      var batchContent = api.get('batch', null, [contentRequest]);
      try {
        batchContent.fetch('pageSecondary').done(function (dataArray) {
          var contentData = dataArray[0];

          var list = contentData.data.Results;

          if (paginationControl && paginationControl.loadMore) {
            self.loadMore(list);
          }
          else {
            self.reset(list);
          }
        });
      }
      catch (e) {

      }
    }


  });
});

BV.define('bv/c2013/model/secondaryContentList',[
  'ENV',
  'framework/bmodel',
  'bv/c2013/model/contentList',
  'bv/c2013/collection/secondaryContentItemCollection',
  'bv/util/pageInfo',
  'underscore',
  'bv/util/contentType'
], function (ENV, BModel, ContentListModel, contentItemCollection, pageInfo, _, ContentType) {
  return ContentListModel.extend({
    name: 'secondaryContentList',
    collectionFeatureName: 'secondaryContentItemCollection',

    defaults: {
      TotalResults: 0,
      numPages: 0
    },

    init: function (config, options) {
      _.extend(this.options, options);

      var parent = this.get('parent');
      if (parent) {
        var contentType = parent.get('secondaryContentType');
        if (_.isEmpty(contentType)) {
          return {};
        }

        // get initial data stub for secondary content-type
        var initData = parent.get(ContentType.Nouns(contentType));

        // mount the normalized TotalContent from devApi into our initData stub
        // Used by pagination component during processData event (matches Reviews/Questions)
        if (typeof (initData) !== 'undefined') {
          initData.TotalResults = parent.get('TotalSecondaryContentCount');
        }

        this.set({
          componentId: parent.isCollection ? parent.componentId : parent.get('componentId'),
          contentType: contentType,
          subject: parent,
          TotalResults: parent.get('TotalSecondaryContentCount'),
          current: 0,
          initData: initData
        });
        this.unset('secondaryContentType');
      }

      // listen for paging requests.
      this.subscribe('pageto', this.fetchPage);
    },

    setupDataProcessing: function () {
      var parent = this.get('parent');

      if (!parent) {
        return;
      }

      // When our parent's data is processed, we can initialize our own state.
      parent.onDataReady(this.processData, this);
    },

    processData: function (data) {
      var self = this;
      var parent = this.get('parent');

      var contentCollection = this.getContent();
      if (!contentCollection) {
        return;
      }

      _(contentCollection).forEach(function (collection, type) {
        var newContent = parent.get(type);
        if (!_.isEmpty(newContent)) {
          newContent = newContent.List || newContent;

          // Move all the Review Response to the top
          if (type === 'ClientResponses') {
            newContent = _(newContent).sortBy(function (resp) {
              return resp.ResponseSource === 'Review Response';
            });
          }

          collection.reset(newContent);

          self.listenTo(collection, {
            reset: self.contentChanged,
            loadmore: self.moreContentLoaded
          });

          if (type === parent.get('secondaryContentType')) {
            self.updatePageInfo(newContent);
          }
        }
      });

      // Resolve data first to trigger the pagination subscript "pageinfo" event.
      this.dataReady(data);
    },

    getSubject: function () {
      // TODO: Eventually need to make this handle other types?
      return {
        type: 'product',
        id: this.get('clientAPIConfig').productId,
        contentType: this.get('secondaryContentType')
      };
    },

    getContent: function () {
      return this._getContent();
    },

    previewContent: function (response) {
      var contentCollection = this.getContent();
      var responseContentType = ContentType.Nouns(response._contentType);

      if (contentCollection && contentCollection[responseContentType]) {
        var collection = contentCollection[responseContentType];
        var previewContent = collection.createContentItem(response);
        collection.add(previewContent, { isPreview: true });
      }
    },

    /**
     * Create pageInfo based on 'TotalResult', 'currentPage', and newContent length
     *
     * @param newContent : content array reset the contentItemCollection.
     */
    updatePageInfo: function (newContent) {
      var parent = this.get('parent');
      var currentPage;
      var myPageInfo;

      if (newContent) {
        currentPage = this.get('current') || 1;

        // Update pagination values to align with the new content.
        myPageInfo = pageInfo(
          ContentType.noun(this.get('contentType')),
          currentPage,
          newContent.length,
          parent.get('TotalSecondaryContentCount')
        );

        this.set({
          TotalResults: this.get('TotalResults'),
          numPages: myPageInfo.numPages,
          startResult: myPageInfo.start,
          current: currentPage
        }, { silent: true });

        myPageInfo.parentContentType = parent.get('contentType');
        myPageInfo.parentContentId = parent.get('Id');
      }

      return myPageInfo;
    },

    toJSON: function () {
      return BModel.prototype.toJSON.call(this);
    },

    moreContentLoaded: function (collection, contentLoaded) {
      var parent = this.get('parent');
      var newPaginationValues;
      var currentPage = this.get('current');

      if (parent) {
        newPaginationValues = pageInfo(
          ContentType.noun(this.get('contentType')),
          currentPage,
          contentLoaded.length,
          this.get('TotalResults')
        );

        // Change the page info to always have the initial start value for
        // "Load More".
        newPaginationValues.start = this.get('startResult');
        newPaginationValues.loadMore = true;
        newPaginationValues.parentContentType = parent.get('contentType');
        newPaginationValues.parentContentId = parent.get('Id');
        this.trigger('pageinfo', newPaginationValues);
      }
    },

    fetchPage: function (pageNum, force, paginationControl) {
      var parent = this.get('parent');
      if (parent) {
        if (parent.get('contentType') === paginationControl.parentContentType &&
            parent.get('Id') === paginationControl.parentContentId) {

          if (_(pageNum).isObject() && (_(pageNum.pageNum).isNumber() || _(pageNum.pageNum).isString())) {
            pageNum = parseInt(pageNum.pageNum, 10);
          }

          var contentCollection = this.getContent()[this.get('contentType')];

          if (!force && (pageNum < 1 || pageNum > this.get('numPages'))) {
            return;
          }

          this.set('current', pageNum);

          // If we haven't processed data, but there is initial data, there is no
          // reason to fetch data again.
          if (this.dataReadyPromise().state() !== 'resolved') {
            return;
          }

          contentCollection.fetchPage(pageNum, this.get('clientAPIConfig'), null, paginationControl);
        }
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!secondaryContentList',['hbs','vendor/handlebars/runtime','hbs!inlineFormContainer', 'template/helpers/view', 'template/helpers/ifHasFeature', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "inlineSubmission", options) : helperMissing.call(depth0, "ifHasFeature", "inlineSubmission", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.inlineFormContainer, 'inlineFormContainer', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("secondary-content-list")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('secondaryContentList', t);
t.deps = ["inlineFormContainer"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/secondaryContentList',[
  'framework/bview',
  'jquery',
  'hbs!secondaryContentList'
], function (BView, $, template) {
  return BView.extend({
    name: 'secondaryContentList',

    template: template

  });
});

/* START_TEMPLATE */
BV.define('hbs!secondaryContentItem',['hbs','vendor/handlebars/runtime','hbs!contentAvatar', 'hbs!content', 'hbs!previewMessage', 'hbs!contentActions', 'template/helpers/view', 'template/helpers/mountView', 'template/helpers/subviews', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "inlineProfile", depth0, options) : helperMissing.call(depth0, "mountView", "inlineProfile", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentAvatar, 'contentAvatar', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.content, 'content', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.previewMessage, 'previewMessage', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.contentActions, 'contentActions', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "inlineSubmission", options) : helperMissing.call(depth0, "ifHasFeature", "inlineSubmission", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return " <div class=\"bv-secondary-submission\"> <div class=\"bv-submission bv-fake-submission bv-fake-inline\"> </div> </div> ";
  }

  buffer += " ";
  options = {hash:{
    'tag': ("li"),
    'classList': ("content-item"),
    'dataContentId': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('secondaryContentItem', t);
t.deps = ["contentAvatar","content","previewMessage","contentActions"];
t.tplMountedViews = ['inlineProfile'];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/secondaryContentItem',[
  'bv/c2013/view/contentItem',
  'jquery',
  'underscore',
  'hbs!secondaryContentItem',
  'util/viewport',
  'window',
  'mf!bv/c2013/messages/contentItem',
  'bv/util/contentType'
], function (BContentItemView, $, _, template, viewport, window, msgPack, ContentType) {
  return BContentItemView.extend({
    name: 'secondaryContentItem',
    el: '.bv-content-list',
    template: template,
    msgpacks: [msgPack],

    init: function (items) {
      this.seoMicrodataTags();
      this.classList.push('secondary-content-item');
      if (!items.showItem) {
        this.classList.push('content-item-hidden');
      }

      this.on('attach', _(this._handleBadgeVisibility).bind(this));
    },

    seoMicrodataTags: function () {
      var contentType = ContentType.noun(this.model.get('Type') || this.model.get('contentType'));
      var customPath = _({ answer: 'Answer', comment: 'Comment' }).result(contentType);
      if (( customPath ) && ( contentType === 'answer' )) {
        this.seoTagList.push('itemprop="suggestedAnswer" itemscope itemtype="http://schema.org/' + customPath + '"');
      }
      else if ( customPath ) {
        this.seoTagList.push('itemprop="' + contentType + '" itemscope itemtype="http://schema.org/' + customPath + '"');
      }
    }

  });
});

BV.define('bv/c2013/view/secondaryContentItemCollection',[
  'framework/bview',
  'bv/c2013/view/contentItemCollection',
  'hbs!contentItemCollection',
  'bv/c2013/view/secondaryContentItem',
  'bv/util/contentType',
  'underscore'
], function (BView, BContentCollectionView, template, ContentItemView, ContentType, _) {
  return BContentCollectionView.extend({
    name: 'secondaryContentItemCollection',
    // templateName is needed here.
    // in hbs.js, mountView auto assume that each subview has a template matches its name.
    // since 'secondaryContentItemCollection' share the same template as 'contentItemCollection'
    // we need to speicificlly use templateName to overwrite the name.
    templateName: 'contentItemCollection',

    template: template,

    getShowView: function () {
      var showItem = {
        comments: true,
        clientresponses: true,
        answers: function (index) { return index === 0; }
      };
      return showItem[ContentType.nouns(this.contentType)];
    },

    initContentView: function (contentItemModel, index) {
      var v;
      var contentType = contentItemModel.get('Type') || contentItemModel.contentType || contentItemModel.get('contentType');
      var componentId = contentItemModel.get('componentId') || contentItemModel.componentId;
      var config = BView.config;
      var pageConfig = config.page.details[ContentType.noun(contentType)] || config.page;
      var pageSize = pageConfig.size;
      var showItem = this.getShowView();

      v = new ContentItemView({
        model: contentItemModel,
        config: contentItemModel,
        componentId: componentId,
        contentType: contentType,
        index: index,
        classList: ['secondary-content-' + ContentType.noun(contentType)],
        parent: this,
        showItem: _(showItem).isFunction() ? showItem(index) : showItem
      });

      this.views.push(v);

      return v;
    },

    addContent: function (contentItemModel, collection, options) {
      var contentType = contentItemModel.contentType || contentItemModel.get('contentType');
      var newView = new ContentItemView({
        model: contentItemModel,
        config: contentItemModel,
        componentId: contentItemModel.componentId || contentItemModel.get('componentId'),
        contentType: contentType,
        secondaryContentType: contentItemModel.secondaryContentType || contentItemModel.get('secondaryContentType'),
        classList: ['content-item', 'content-' + ContentType.noun(contentType)]
      });

      // Prepend new secondaryContentItem to current secondaryContentItemCollection
      if (this.$viewEl) {
        if (options.isPreview) {
          // Add the rendered preview to the top of the content and give it at
          // class so we can style it all special like.
          this.$viewEl
            .prepend(newView.toHTML())
            .find('li:first')
            .removeClass('bv-content-item-hidden')
            .addClass('bv-content-preview');

          // Scroll the window to the new comment preview.
        }
        else {
          // use render to make sure all the events are delegated correctly
          newView.setElement(this.$viewEl);
          newView.render();
        }
      }
    }

  });
});

BV.define('bv/c2013/model/loadMore',[
  'ENV',
  'bv/c2013/model/pagination',
  'underscore'
], function (ENV, PaginationModel, _) {

  return PaginationModel.extend({
    name: 'loadMore',

    defaults: _.extend({}, PaginationModel.defaults, { loadMore: true }),

    init: function (config, options) {
      PaginationModel.prototype.init.call(this, config, options);

      // It's possible that clients can run $BV.container without running
      // $BV.configure first. In this event, clientAPIConfig won't be defined.
      var clientAPIConfig = this.get('clientAPIConfig') || {};
      var infiniteScroll = !clientAPIConfig.suppressScrollMore && this.hasFeature('infiniteScroll');

      this.set('infiniteScroll', infiniteScroll);
    }
  });
});

/* START GENERATED MESSAGE */
BV.define('_i18n_paginationLoadMore', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function paginationLoadMore( data ) {
try { return (function(d){
var r = "";
r += "Load More";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `paginationLoadMore`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_paginationLoadMore', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return paginationLoadMore(data);
});
return paginationLoadMore;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!loadMore',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/unlessHasFeature', '_i18n_paginationLoadMore'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.total, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.showPages, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <div class=\"bv-content-pagination-container\"> ";
  options = {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "infiniteScroll", options) : helperMissing.call(depth0, "unlessHasFeature", "infiniteScroll", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.allowNext, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <button type=\"button\" class=\"bv-content-btn bv-content-btn-pages bv-content-btn-pages-load-more bv-focusable\"> <span class=\"bv-content-btn-pages-load-more-text\"> "
    + " ";
  if (stack1 = helpers._i18n_paginationLoadMore) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_paginationLoadMore; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> </button> ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.allowNext, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.infiniteScroll, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  
  return " <div class=\"bv-load-more-spinner\"/> ";
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("content-pagination"),
    'alwaysRender': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('loadMore', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/loadMore',[
  'bv/c2013/view/pagination',
  'bv/util/productInfo',
  'bv/util/loadingOverlay',
  'framework/bview',
  'jquery',
  'underscore',
  'hbs!loadMore'
], function (PaginationView, ProductInfo, LoadingOverlay, BView, $, _, template) {

  return PaginationView.extend({

    name: 'loadMore',

    events: {
      'click .bv-content-btn-pages-load-more': 'morePageClicked'
    },

    template: template,

    modelDataReady: function (config) {
      this.throttledPageTo = _(this.pageTo).throttle(100);

      if (this.model.get('infiniteScroll')) {
        // Set up infinite scrolling
        this.scrollEventName = 'scroll.bv-' + this.name + ':' + this.uniq;
        this.registerScrollEvent();
        this.subscribe('bv-component-show', this.registerScrollEvent, this);
        this.subscribe('bv-component-hide', this.unregisterScrollEvent, this);
      }
    },

    stateChanged: function (scrollPage) {
      PaginationView.prototype.stateChanged.call(this, scrollPage);
      this.scrollMore();
    },

    morePageClicked: function (e) {
      if (this.parent.name === 'secondaryContentList') {
        var $hiddenItems = this.parent.$viewEl.find('.bv-content-item-hidden');
        if ($hiddenItems.length > 0) {
          $hiddenItems.removeClass('bv-content-item-hidden');
          return;
        }
      }
      var toPage = this.model.get('currentPage') + 1;
      this.pageTo(toPage);
    },

    pageTo: function (pageNum) {
      var pageData = {
        srcControl: (this.parent.name === 'genericSubmission') ? 'GWAR' : 'Next',
        loadMore: true,
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this)
      };
      LoadingOverlay.show();
      this.model.pageTo(pageNum, pageData);
    },

    stopListening: function (e) {
      this.unregisterScrollEvent();
      BView.prototype.stopListening.apply(this, arguments);
    },

    attach: function (elToAttach) {
      var result = PaginationView.prototype.attach.call(this, elToAttach);
      // Once rendered, do an initial test to see if we should immediately load more.
      this.scrollMore();
      return result;
    },

    scrollMore: function () {
      // We don't want to load more content if we are not infinite scrolling
      // or if we have no view element or if there is no more content to load
      if (!this.model.get('infiniteScroll') || !this.$viewEl || !this.model.get('allowNext')) {
        return;
      }
      var windowHeight = $(window).height();
      var scrollHeight = $(window).scrollTop();
      var viewHeight = this.$viewEl.offset().top;
      var scrollToBottomRatio = (scrollHeight + windowHeight) / viewHeight;
      if (scrollToBottomRatio >= 0.80) {
        var toPage = this.model.get('currentPage') + 1;
        this.throttledPageTo(toPage);
      }
    },

    registerScrollEvent: function () {
      if (!this.scrollEventRegistered) {
        $(window).on(this.scrollEventName, _(_(this.scrollMore).debounce(200)).bind(this));
        this.scrollEventRegistered = true;
      }
    },

    unregisterScrollEvent: function () {
      $(window).off(this.scrollEventName);
      this.scrollEventRegistered = false;
    }

  });

});

BV.define('bv/c2013/model/mediaViewer',[
  'framework/bmodel',
  'underscore'
], function (BModel, _) {
  return BModel.extend({
    options: {},
    name: 'mediaViewer',

    init: function (config, options) {
      _.extend(this.options, options);
    }
  });
});

BV.define('mf!bv/c2013/messages/mediaViewer',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"media_dialog_label" : function (x) { try { return (function(d){
var r = "";
r += "Media Viewer";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `media_dialog_label`: ' + e.toString() ) ] ); return ""; } },"previous_media" : function (x) { try { return (function(d){
var r = "";
r += "Previous";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `previous_media`: ' + e.toString() ) ] ); return ""; } },"next_media" : function (x) { try { return (function(d){
var r = "";
r += "Next";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `next_media`: ' + e.toString() ) ] ); return ""; } }
};
});

/* START_TEMPLATE */
BV.define('hbs!mediaViewer',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/notEqual', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <div class=\"bv-media-viewer-stack\"> <div class=\"bv-media-viewer-inner\"> <table class=\"bv-media-viewer-table\" role=\"presentation\"> <tr> <td> <div class=\"bv-media-viewer-canvas\"> "
    + " </div> </td> </tr> </table> </div> <div class=\"bv-media-viewer-ribbon bv-hidden\"> "
    + " </div> </div> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.mediaCollection),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.mediaCollection),stack1 == null || stack1 === false ? stack1 : stack1.length), 1, options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.mediaCollection),stack1 == null || stack1 === false ? stack1 : stack1.length), 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div role=\"button\" class=\"bv-media-arrow bv-media-prev bv-focusable\" tabindex=\"0\" aria-labelledby=\"bv-previous-media-label\"> <span aria-hidden=\"true\">◄</span> <span id=\"bv-previous-media-label\" class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "previous_media", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "previous_media", depth0.msgpack, depth0, options)))
    + "</span> </div> <div role=\"button\" class=\"bv-media-arrow bv-media-next bv-focusable\" tabindex=\"0\" aria-labelledby=\"bv-next-media-label\"> <span aria-hidden=\"true\">►</span> <span id=\"bv-next-media-label\" class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "next_media", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "next_media", depth0.msgpack, depth0, options)))
    + "</span> </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("compat media-viewer")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('mediaViewer', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!mediaViewerImage',['hbs','vendor/handlebars/runtime', 'template/helpers/ensureProtocolRelative'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";


  buffer += "<div class=\"bv-media-viewer-image\"> <img src=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, depth0.url, options) : helperMissing.call(depth0, "ensureProtocolRelative", depth0.url, options)))
    + "\" alt=\"";
  if (stack2 = helpers.caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" tabindex=\"0\" class=\"bv-focusable bv-media-focus-target\" /> </div> <div class=\"bv-media-viewer-caption\" aria-hidden=\"true\"> ";
  if (stack2 = helpers.caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </div> ";
  return buffer;
  });
Handlebars.registerPartial('mediaViewerImage', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!mediaViewerEmbed',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"bv-media-viewer-embedded\"> <div class=\"bv-media-viewer-dummy\"></div> <iframe class=\"bv-media-viewer-ytmedia bv-media-focus-target bv-focusable\" aria-labelledby=\"bv-media-viewer-title\" type=\"text/html\" src=\"//www.youtube.com/embed/";
  if (stack1 = helpers.videoId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.videoId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "?rel=0\" /> </div> <div id=\"bv-media-viewer-title\" class=\"bv-media-viewer-caption\"> ";
  if (stack1 = helpers.caption) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.caption; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " </div> ";
  return buffer;
  });
Handlebars.registerPartial('mediaViewerEmbed', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_mediaViewerCollectionSummary', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function mediaViewerCollectionSummary( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["currentItem"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["totalItems"];
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `mediaViewerCollectionSummary`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_mediaViewerCollectionSummary', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return mediaViewerCollectionSummary(data);
});
return mediaViewerCollectionSummary;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!mediaViewerRibbonSummary',['hbs','vendor/handlebars/runtime', '_i18n_mediaViewerCollectionSummary'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing;


  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_mediaViewerCollectionSummary),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_mediaViewerCollectionSummary", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('mediaViewerRibbonSummary', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!mediaViewerRibbon',['hbs','vendor/handlebars/runtime','hbs!mediaViewerRibbonSummary', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <p class=\"bv-media-viewer-ribbon-summary\"> ";
  stack1 = self.invokePartial(partials.mediaViewerRibbonSummary, 'mediaViewerRibbonSummary', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </p> <ul class=\"bv-media-viewer-ribbon-inner\"> ";
  stack1 = helpers.each.call(depth0, depth0.mediaCollection, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </ul> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <li class=\"bv-media-viewer-ribbon-item ";
  stack1 = helpers['if'].call(depth0, depth0.current, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-bv-mediatype=\"";
  if (stack1 = helpers.mediaType) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.mediaType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" data-bv-index=\"";
  if (stack1 = helpers.index) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.index; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">&nbsp;</li> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return "bv-media-viewer-ribbon-item-active";
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('mediaViewerRibbon', t);
t.deps = ["mediaViewerRibbonSummary"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview A view for displaying media in review content.
 */
BV.define('bv/c2013/view/mediaViewer',[
  'framework/bmodel',
  'framework/bview',
  'bv/ui-core/focusableview',
  'mf!bv/c2013/messages/mediaViewer',
  'hbs!mediaViewer',
  'hbs!mediaViewerImage',
  'hbs!mediaViewerEmbed',
  'hbs!mediaViewerRibbon',
  'hbs!mediaViewerRibbonSummary',
  'underscore',
  'jquery',
  'bv/api',
  'BV',
  'bv/util/productInfo',
  'framework/util/bvtracker',
  'util/specialKeys',
  'bv/ui-core/modestbox'
], function (BModel, BView, FocusableView, msgpack, template, imageTemplate, embedVideoTemplate, ribbonTemplate, ribbonSummaryTemplate, _, $, api, BV, ProductInfo, BVTracker, specialKeys, ModestBox) {

  // The ribbon is complicated enough that it gets its own private view and model
  // components.
  //
  // TODO: Add logic for what happens when the media collection is way too
  // big to show all at once in the navigation. We don't have this problem
  // yet because a review can have a maximum of 6 images.
  var RibbonModel = BModel.extend({
    toJSON: function () {
      var currentIndex = this.get('index');
      var mediaCollection = this.get('mediaCollection');

      var data = {
        mediaCollection: _(mediaCollection).map(function (media, index) {
          var datum = {
            mediaType: media.mediaType,
            index: index
          };
          if (index === currentIndex) {
            datum.current = true;
          }
          return datum;
        }),
        totalItems: mediaCollection.length,
        currentItem: currentIndex + 1
      };

      return data;
    }
  });

  var RibbonView = BView.extend({
    name: 'mediauploadribbonview',

    events: {
      'click .bv-media-viewer-ribbon-item': '_thumbnailClick'
    },

    template: ribbonTemplate,

    init: function (config) {
      this.summaryTemplate = ribbonSummaryTemplate;
      this.parent = config.parent;
      this.listenTo(this.model, 'change:index', this.onChangeIndex);
    },

    _thumbnailClick: function (e) {
      var index = $(e.currentTarget).data('bv-index');
      this.model.set('index', index);
      this.parent.setIndex(index);
    },

    onChangeIndex: function (model, index) {
      // Re-render the summary ("1 of 3").
      var $summaryContainer = this.$el.find('.bv-media-viewer-ribbon-summary');
      var $thumb;
      var activeClass;

      $summaryContainer.html(this.summaryTemplate(this.model.toJSON()));
      // Mark the new active node in the ribbon.
      activeClass = 'bv-media-viewer-ribbon-item-active';
      this.$el.find('.' + activeClass).removeClass(activeClass);
      $thumb = this.$el.find('[data-bv-index="' + index + '"]');
      $thumb.addClass(activeClass);
    }
  });

  return BView.extend({
    name: 'mediaViewer',

    template: template,

    msgpacks: [msgpack],

    init: function (config) {
      var self = this;
      self.imageTemplate = imageTemplate;
      self.embedVideoTemplate = embedVideoTemplate;

      self.multiple = false;

      self.subscribe('open', this.open);
      this.listenTo(this.model, 'change:media', this.onChangeMedia);
    },

    events: {
      'click .bv-media-prev': '_prev',
      'click .bv-media-next': '_next',
      'keydown .bv-media-arrow': '_interpretKeydown'
    },

    /**
     * Open up a lightbox to display the media front and center.
     */
    open: function (config) {
      var self = this;
      var mb;

      if (config.media) {
        self.model.set('media', config.media);
      }

      if (config.mediaCollection) {
        self.model.set('mediaCollection', config.mediaCollection);
        self.ribbonModel = new RibbonModel({
          name: 'mediauploadribbon',
          mediaCollection: config.mediaCollection,
          index: 0,
          component: self.model.getComponent()
        });
        self.ribbonView = new RibbonView({
          model: self.ribbonModel,
          mediaCollection: config.mediaCollection,
          parent: this,
          component: self.model.getComponent()
        });

        self.multiple = config.mediaCollection.length > 1;
      }

      mb = ModestBox.get('lightbox');
      mb.pushOrOpen({
        view: self,
        targetClass: 'bv-mbox-media-box',
        title: msgpack.media_dialog_label(),
        // Set focus to close button.
        autoFocus: true,
        beforeShow: function (layer) {
          // The modestbox makes us choose between `bv-mbox-narrow` and
          // `bv-mbox-wide` classes. We want neither one. Swap it out with
          // our preferred class before we show the box.
          var $box = layer.box.$container.find('.bv-mbox-narrow');
          $box.removeClass('bv-mbox-narrow').addClass('bv-mbox-media');

          self.onRender();
        },

        afterHide: function () {
          // Set the `bv-mbox-narrow` class back. See UIA-9263.
          var $box = this.box.$container.find('.bv-mbox-media');
          $box.removeClass('bv-mbox-media').addClass('bv-mbox-narrow');
          FocusableView.moveFocus(config.$container);

          BVTracker.feature({
            type: 'Used',
            name: 'Close',
            detail1: 'UserSubmittedMedia',
            detail2: 'Lightbox',
            bvProduct: ProductInfo.RATINGSANDREVIEWS,
            productId: ProductInfo.getId(self),
            categoryId: config.categoryId
          });
        }
      });

    },

    _indexOfMediaWithId: function (id, mediaCollection) {
      var i;
      var currentMedia;
      var length;

      mediaCollection = mediaCollection || this.model.get('mediaCollection');
      for (i = 0, currentMedia, length = mediaCollection.length; i < length; i++) {
        currentMedia = mediaCollection[i].mediaContent;
        if (currentMedia.Id === id || currentMedia.VideoId === id) {
          return i;
        }
      }
      return -1;
    },

    setIndex: function (index) {
      var mediaCollection = this.model.get('mediaCollection');
      var lastIndex = mediaCollection.length - 1;
      var media;

      if (index < 0) {
        index = 0;
      }

      if (index > lastIndex) {
        index = lastIndex;
      }

      media = mediaCollection[index];
      this.setMedia(media);
    },

    _interpretKeydown: function (e) {
      var $el;

      if (e.keyCode !== specialKeys.SPACE && e.keyCode !== specialKeys.ENTER) {
        return;
      }

      e.preventDefault();
      $el = $(e.target);

      if ($el.hasClass('bv-media-prev')) {
        this._prev();
      }
      else {
        this._next();
      }
    },

    _prev: function () {
      this.move(-1);
    },

    _next: function () {
      this.move(1);
    },

    _keydown: function (e) {
      // Intercept left and right arrow keys for navigating between mediaCollection.
      switch (e.keyCode) {
        case specialKeys.LEFT:
          e.preventDefault();
          this.move(-1);
          break;
        case specialKeys.RIGHT:
          e.preventDefault();
          this.move(1);
          break;
      }
    },

    // `delta` should be either 1 or -1.
    move: function (delta) {
      var mediaCollection = this.model.get('mediaCollection');
      var currentIndex = this.currentIndex;
      var lastIndex = mediaCollection.length - 1;
      var newIndex;

      if (currentIndex === lastIndex && delta === 1) {
        // Wrap around from the last media to the first.
        newIndex = 0;
      }
      else if (currentIndex === 0 && delta === -1) {
        // Wrap around from the first media to the last.
        newIndex = lastIndex;
      }
      else {
        newIndex = currentIndex + delta;
      }

      this.setIndex(newIndex);
    },

    onRender: function () {
      var $container = this.$el.find('.bv-media-viewer');

      this._adjustContainerHeight();
      this._registerResize(true);

      if (this.multiple) {
        // If we're showing more than one image, set up the arrow keys to
        // navigate between mediaCollection.
        this._registerKeyDown(true);

        // Add a class name to a container element so we can style the box
        // differently based on whether we're viewing just one media or a
        // series.
        $container.addClass('bv-media-viewer-multiple');

        // Show and render the ribbon.
        this.$el.find('.bv-media-viewer-ribbon').removeClass('bv-hidden');
        this.renderRibbon();
      }
      this.onChangeMedia();
    },

    renderRibbon: function () {
      var $el = this.$el.find('.bv-media-viewer-ribbon');
      this.ribbonView.setElement($el);
      this.ribbonView.render();
    },

    setMedia: function (media) {
      this.model.set('media', media);
      // Triggers onChangeMedia
    },

    onChangeMedia: function () {
      var self = this;
      var media = self.model.get('media');
      var mediaType = media.mediaType;
      var mediaContent = media.mediaContent;
      var showFunc;
      var newIndex;

      if (!this.$el.length) {
        // We haven't rendered yet, so don't worry about it. The view will
        // set the media before it's shown in the modestbox.
        return;
      }

      showFunc = {
        Photos: this.showPhoto,
        Videos: this.showVideo
      };

      (showFunc[mediaType] || function () {})(mediaContent, self);

      FocusableView.rescanFocusLayer();
      _.delay(function () {
        FocusableView.moveFocus(self.$el.find('.bv-media-focus-target'));
      }, 0);

      if (this.multiple) {
        newIndex = this._indexOfMediaWithId(mediaContent.Id || mediaContent.VideoId);
        this.currentIndex = newIndex;
        this.ribbonModel.set('index', newIndex);
      }
    },

    showVideo: function (video, self) {
      var data = {
        caption: video.Caption,
        videoId: video.VideoId
      };
      self.$el.find('.bv-media-viewer-canvas').html(self.embedVideoTemplate(data));
    },

    showPhoto: function (photo, self) {
      var $img;
      var image;
      var data = {
        caption: photo.Caption,
        url: photo.Sizes.normal.Url
      };

      self.$el.find('.bv-media-viewer-canvas').html(self.imageTemplate(data));
      $img = self.$el.find('.bv-media-viewer-image img');

      // Load the image off-screen to capture its natural dimensions, then
      // adjust the table cell to accommodate those dimensions (if possible).
      image = new Image();
      image.onload = function () {
        self._captureImageDimensions($img, image.height, image.width);
        self._adjustTableCell();
      };

      image.src = data.url;
    },

    // Record the image's natural dimensions. We'll need them later when
    // we're doing the container resize.
    _captureImageDimensions: function ($img, height, width) {
      $img.attr({
        'data-height': height,
        'data-width': width
      });
    },

    // The modestbox is absolutely positioned, but we want it to try to
    // constrain its dimensions to fit within the viewport. So we listen for
    // window resize (throttled) and adjust the height of the modestbox to
    // fit within the viewport (until it hits min-height).
    _adjustContainerHeight: function () {
      // jQuery's height is sensitive to doctype. In case doctype is not specified it returns the height of the document
      var vHeightJQ = $(window).innerHeight();
      // cross-browser viewport height
      var vHeightJS = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      // in quirks mode vHeightJQ returns 0
      var vHeight = (!vHeightJQ || (vHeightJS && (vHeightJS < vHeightJQ))) ? vHeightJS : vHeightJQ;
      var $container = this.$el.find('.bv-media-viewer');

      $container.css('height', vHeight * 0.8);
      this._adjustTableCell();
    },

    // We put some content in a table cell so it can be vertically-aligned.
    // But this means that we have to adjust the height of the table cell
    // manually when the height of its container changes.
    //
    // This gets triggered on window resize and when a media is first
    // displayed.
    _adjustTableCell: function () {
      var self = this;
      var $inner;
      var h;
      var captionHeight;
      var imageHeight;
      var newWrapperHeight;

      if (!this.$el) {
        return;
      }

      $inner = this.$el.find('.bv-media-viewer-inner');
      h = $inner.height();

      // IE isn't always ready right away.
      if (h) {
        $inner.find('td').css('height', h);

        // We have to do more work. Firefox and IE don't seem to be able to
        // adjust the size of the image's wrapper DIV dynamically the way
        // that Safari/Chrome can. So we take the table cell's height,
        // subtract the height of the caption (to make room for it), and
        // manually set that height on the wrapper DIV so that the image
        // scales down properly.
        //
        // Ideally, we'd set this as a `max-height`, because we don't
        // actually want it to be this tall when the image is smaller. But in
        // FF/IE, the image's own `max-height: 100%`  isn't relative to its
        // container unless its container's height is _explicitly set_, not
        // just `auto`. So we have to compare our would-be height to the
        // image's natural height and set the wrapper's height to the smaller
        // of the two values.
        //
        // TODO: We're going really far down the rabbit hole here. Maybe it's
        // not worth it and we should figure out another way to do all of
        // this. -APD
        captionHeight = $inner.find('.bv-media-viewer-caption').outerHeight();
        imageHeight = Number($inner.find('.bv-media-viewer-image > img').attr('data-height'));
        newWrapperHeight = Math.min(imageHeight, h - captionHeight);

        $inner.find('.bv-media-viewer-image').css('height', newWrapperHeight);
        self._innerHeightCount = 0;
      }
      else {
        self._innerHeightCount = self._innerHeightCount ? self._innerHeightCount : 0;
        if (self._innerHeightCount < 10) {
          setTimeout(function () {
            self._adjustTableCell.call(this);
          }, 50);
        }
        self._innerHeightCount++;
      }
    },

    _registerResize: function (bool) {
      var self = this;
      var throttled;

      if (bool) {
        throttled = _.throttle(function () { self._adjustContainerHeight(); }, 500);
        $(window).bind('resize.bvmediaviewerresize', throttled);
      }
      else {
        $(window).unbind('.bvmediaviewerresize');
      }
    },

    // While the modestbox is visible, we listen for keydown on the document
    // so the user can control the gallery navigation with arrow keys.
    _registerKeyDown: function (bool) {
      var self = this;
      if (bool) {
        $(document).bind('keydown.bvthumbnail', function (e) {
          self._keydown(e);
        });
      }
      else {
        $(document).unbind('.bvthumbnail');
      }
    },

    // TODO: See if this can make a supercall to BView#remove.
    remove: function () {
      this._registerResize(false);
      this._registerKeyDown(false);
      this.$el.remove();
      // Null this out so that it has to create a new one next time the
      // modestbox is shown.
      this.$viewEl = this.viewEl = null;
      return this;
    }

  });

});

BV.define('mf!bv/c2013/messages/submission',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"submit_review" : function (x) { try { return (function(d){
var r = "";
r += "Post Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submit_review`: ' + e.toString() ) ] ); return ""; } },"submit_comment" : function (x) { try { return (function(d){
var r = "";
r += "Post Comment";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submit_comment`: ' + e.toString() ) ] ); return ""; } },"submit_question" : function (x) { try { return (function(d){
var r = "";
r += "Post Question";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submit_question`: ' + e.toString() ) ] ); return ""; } },"submit_answer" : function (x) { try { return (function(d){
var r = "";
r += "Post Answer";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submit_answer`: ' + e.toString() ) ] ); return ""; } },"add_file" : function (x) { try { return (function(d){
var r = "";
r += "Add File";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_file`: ' + e.toString() ) ] ); return ""; } },"add_photo" : function (x) { try { return (function(d){
var r = "";
r += "Add Photo";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_photo`: ' + e.toString() ) ] ); return ""; } },"add_photo_dialog" : function (x) { try { return (function(d){
var r = "";
r += "Add Photo. dialog.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_photo_dialog`: ' + e.toString() ) ] ); return ""; } },"add_facebookphoto" : function (x) { try { return (function(d){
var r = "";
r += "Add Photo";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_facebookphoto`: ' + e.toString() ) ] ); return ""; } },"add_facebookphoto_1" : function (x) { try { return (function(d){
var r = "";
r += "Facebook";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_facebookphoto_1`: ' + e.toString() ) ] ); return ""; } },"display_photourl_1" : function (x) { try { return (function(d){
var r = "";
r += "Choose File";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_photourl_1`: ' + e.toString() ) ] ); return ""; } },"helpertext_photourl_1" : function (x) { try { return (function(d){
var r = "";
r += "<div>  Photo guidelines</div> <div>  When submitting images, please follow these guidelines:</div> <ul>  <li>   Images must be in BMP, PNG, GIF or JPEG format.</li>  <li>   File size must be 5 MB or less.</li>  <li>   Image must be at least 60 pixels tall.</li>  <li>   Image must be at least 60 pixels wide.</li>  <li>   If you are not the copyright holder, you may not submit copyrighted images.</li>  <li>   Objectionable images will be rejected.</li>  <li>   Uploaded images become the property of the Company.</li> </ul>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpertext_photourl_1`: ' + e.toString() ) ] ); return ""; } },"header_review" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "productNameAvailable";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"true" : function(d){
var r = "";
r += "My Review for ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["productName"];
return r;
},
"false" : function(d){
var r = "";
r += "My Review";
return r;
},
"other" : function(d){
var r = "";
r += "My Review";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `header_review`: ' + e.toString() ) ] ); return ""; } },"remove_photo" : function (x) { try { return (function(d){
var r = "";
r += "Remove Photo";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `remove_photo`: ' + e.toString() ) ] ); return ""; } },"remove_confirm_photo" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Are you sure you want to remove this photo?";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `remove_confirm_photo`: ' + e.toString() ) ] ); return ""; } },"add_video" : function (x) { try { return (function(d){
var r = "";
r += "Add Video";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_video`: ' + e.toString() ) ] ); return ""; } },"add_video_dialog" : function (x) { try { return (function(d){
var r = "";
r += "Add Video. dialog.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `add_video_dialog`: ' + e.toString() ) ] ); return ""; } },"display_videourl_1" : function (x) { try { return (function(d){
var r = "";
r += "Link to YouTube Video";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_videourl_1`: ' + e.toString() ) ] ); return ""; } },"offscreen_videourl_1" : function (x) { try { return (function(d){
var r = "";
r += "Enter the URL of the video to add";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_videourl_1`: ' + e.toString() ) ] ); return ""; } },"helpertext_videourl_1" : function (x) { try { return (function(d){
var r = "";
r += "<h2>  Video guidelines</h2> <p>  When submitting videos, please follow these guidelines:</p> <ul>  <li>   Make sure your video is related to the product.</li>  <li>   Try to submit videos of you using the product.</li>  <li>   Inappropriate videos will be rejected along with your review.</li>  <li>   If you are not the copyright holder, you may not submit copyrighted videos.</li> </ul>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpertext_videourl_1`: ' + e.toString() ) ] ); return ""; } },"error_message_invalid_url_video" : function (x) { try { return (function(d){
var r = "";
r += "Invalid YouTube URL";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_message_invalid_url_video`: ' + e.toString() ) ] ); return ""; } },"error_message_require_url_video" : function (x) { try { return (function(d){
var r = "";
r += "YouTube URL is required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_message_require_url_video`: ' + e.toString() ) ] ); return ""; } },"remove_video" : function (x) { try { return (function(d){
var r = "";
r += "Remove Video";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `remove_video`: ' + e.toString() ) ] ); return ""; } },"remove_confirm_video" : function (x) { try { return (function(d){
var r = "";
r += "Are you sure you want to remove this video?";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `remove_confirm_video`: ' + e.toString() ) ] ); return ""; } },"display_rating" : function (x) { try { return (function(d){
var r = "";
r += "Overall Rating";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_rating`: ' + e.toString() ) ] ); return ""; } },"placeholder_rating" : function (x) { try { return (function(d){
var r = "";
r += "Rate from 1 to 5 where 1 is poor and 5 is excellent.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_rating`: ' + e.toString() ) ] ); return ""; } },"helper_rating_1" : function (x) { try { return (function(d){
var r = "";
r += "Clique para classificar!";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helper_rating_1`: ' + e.toString() ) ] ); return ""; } },"title_rating_1" : function (x) { try { return (function(d){
var r = "";
r += "Poor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `title_rating_1`: ' + e.toString() ) ] ); return ""; } },"title_rating_2" : function (x) { try { return (function(d){
var r = "";
r += "Fair";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `title_rating_2`: ' + e.toString() ) ] ); return ""; } },"title_rating_3" : function (x) { try { return (function(d){
var r = "";
r += "Average";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `title_rating_3`: ' + e.toString() ) ] ); return ""; } },"title_rating_4" : function (x) { try { return (function(d){
var r = "";
r += "Good";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `title_rating_4`: ' + e.toString() ) ] ); return ""; } },"title_rating_5" : function (x) { try { return (function(d){
var r = "";
r += "Excellent";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `title_rating_5`: ' + e.toString() ) ] ); return ""; } },"display_title" : function (x) { try { return (function(d){
var r = "";
r += "Review Title";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_title`: ' + e.toString() ) ] ); return ""; } },"placeholder_title" : function (x) { try { return (function(d){
var r = "";
r += "Example: Great features!";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_title`: ' + e.toString() ) ] ); return ""; } },"display_reviewtext" : function (x) { try { return (function(d){
var r = "";
r += "Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_reviewtext`: ' + e.toString() ) ] ); return ""; } },"placeholder_reviewtext" : function (x) { try { return (function(d){
var r = "";
r += "Example: I bought this a month ago and am so happy that I did...";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_reviewtext`: ' + e.toString() ) ] ); return ""; } },"helpertext_reviewtext" : function (x) { try { return (function(d){
var r = "";
r += "<h2>  Writing guidelines</h2> <p>  We want to publish your review, so please:</p> <ul>  <li>   Keep your review focused on the product.</li>  <li>   Avoid writing about customer service, contact us instead if you have issues requiring immediate attention.</li>  <li>   Refrain from mentioning competitors or the specific price you paid for the product.</li>  <li>   Do not include any personally identifiable information, such as full names.</li> </ul>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpertext_reviewtext`: ' + e.toString() ) ] ); return ""; } },"display_photocaption_1" : function (x) { try { return (function(d){
var r = "";
r += "Caption";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_photocaption_1`: ' + e.toString() ) ] ); return ""; } },"placeholder_photocaption_1" : function (x) { try { return (function(d){
var r = "";
r += "Example: My new shirt";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_photocaption_1`: ' + e.toString() ) ] ); return ""; } },"display_videocaption_1" : function (x) { try { return (function(d){
var r = "";
r += "Caption";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_videocaption_1`: ' + e.toString() ) ] ); return ""; } },"placeholder_videocaption_1" : function (x) { try { return (function(d){
var r = "";
r += "Example: How to Install";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_videocaption_1`: ' + e.toString() ) ] ); return ""; } },"display_usernickname" : function (x) { try { return (function(d){
var r = "";
r += "Nickname";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_usernickname`: ' + e.toString() ) ] ); return ""; } },"placeholder_usernickname" : function (x) { try { return (function(d){
var r = "";
r += "Example: jackie27";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_usernickname`: ' + e.toString() ) ] ); return ""; } },"display_userlocation" : function (x) { try { return (function(d){
var r = "";
r += "Location";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_userlocation`: ' + e.toString() ) ] ); return ""; } },"placeholder_userlocation" : function (x) { try { return (function(d){
var r = "";
r += "Example: New York, NY";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_userlocation`: ' + e.toString() ) ] ); return ""; } },"display_isrecommended" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Would you recommend this product to a friend?";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_isrecommended`: ' + e.toString() ) ] ); return ""; } },"display_netpromoterscore" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "Would you recommend ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["clientName"];
r += " to a friend?";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_netpromoterscore`: ' + e.toString() ) ] ); return ""; } },"placeholder_netpromoterscore" : function (x) { try { return (function(d){
var r = "";
r += "Rate from 0 to 10 where 0 is never and 10 is definitely.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_netpromoterscore`: ' + e.toString() ) ] ); return ""; } },"helper_netpromoterscore_1" : function (x) { try { return (function(d){
var r = "";
r += "Never";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helper_netpromoterscore_1`: ' + e.toString() ) ] ); return ""; } },"helper_netpromoterscore_2" : function (x) { try { return (function(d){
var r = "";
r += "Definitely";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helper_netpromoterscore_2`: ' + e.toString() ) ] ); return ""; } },"display_netpromotercomment" : function (x) { try { return (function(d){
var r = "";
r += "Please tell us why <em>(will not appear on our site)</em>";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_netpromotercomment`: ' + e.toString() ) ] ); return ""; } },"display_useremail" : function (x) { try { return (function(d){
var r = "";
r += "Email";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_useremail`: ' + e.toString() ) ] ); return ""; } },"placeholder_useremail" : function (x) { try { return (function(d){
var r = "";
r += "Example: yourname@example.com";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_useremail`: ' + e.toString() ) ] ); return ""; } },"display_hostedauthentication_authenticationemail" : function (x) { try { return (function(d){
var r = "";
r += "Email";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_hostedauthentication_authenticationemail`: ' + e.toString() ) ] ); return ""; } },"placeholder_hostedauthentication_authenticationemail" : function (x) { try { return (function(d){
var r = "";
r += "Example: youremail@example.com";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_hostedauthentication_authenticationemail`: ' + e.toString() ) ] ); return ""; } },"display_rememberemail" : function (x) { try { return (function(d){
var r = "";
r += "Remember me";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_rememberemail`: ' + e.toString() ) ] ); return ""; } },"display_casltext" : function (x) { try { return (function(d){
var r = "";
r += "You may receive emails regarding this submission. Any emails will include the ability to opt-out of future communications.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_casltext`: ' + e.toString() ) ] ); return ""; } },"header_comment" : function (x) { try { return (function(d){
var r = "";
r += "My Comment";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `header_comment`: ' + e.toString() ) ] ); return ""; } },"display_commenttext" : function (x) { try { return (function(d){
var r = "";
r += "Comment";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_commenttext`: ' + e.toString() ) ] ); return ""; } },"placeholder_commenttext" : function (x) { try { return (function(d){
var r = "";
r += "Write a comment...";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_commenttext`: ' + e.toString() ) ] ); return ""; } },"header_question" : function (x) { try { return (function(d){
var r = "";
r += "Ask a Question";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `header_question`: ' + e.toString() ) ] ); return ""; } },"display_questionsummary" : function (x) { try { return (function(d){
var r = "";
r += "Question";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_questionsummary`: ' + e.toString() ) ] ); return ""; } },"display_required_text" : function (x) { try { return (function(d){
var r = "";
r += "Required fields are marked with *";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `display_required_text`: ' + e.toString() ) ] ); return ""; } },"placeholder_questionsummary" : function (x) { try { return (function(d){
var r = "";
r += "Ask a question...";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `placeholder_questionsummary`: ' + e.toString() ) ] ); return ""; } },"header_answer" : function (x) { try { return (function(d){
var r = "";
r += "My Answer";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `header_answer`: ' + e.toString() ) ] ); return ""; } },"error_AN_ERROR_OCCURRED" : function (x) { try { return (function(d){
var r = "";
r += "An error occurred. Please try again.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_AN_ERROR_OCCURRED`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_DUPLICATE" : function (x) { try { return (function(d){
var r = "";
r += "nickname already used";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_DUPLICATE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_DUPLICATE_NICKNAME" : function (x) { try { return (function(d){
var r = "";
r += "nickname already used";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_DUPLICATE_NICKNAME`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_DUPLICATE_SUBMISSION" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
r += "You already submitted a review. Thanks!";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_DUPLICATE_SUBMISSION`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_FILE_PARSE" : function (x) { try { return (function(d){
var r = "";
r += "error";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_FILE_PARSE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_FILE_TOO_LARGE" : function (x) { try { return (function(d){
var r = "";
r += "file too large";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_FILE_TOO_LARGE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_IMAGE_HEIGHT_TOO_SMALL" : function (x) { try { return (function(d){
var r = "";
r += "image too short";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_IMAGE_HEIGHT_TOO_SMALL`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_IMAGE_PARSE" : function (x) { try { return (function(d){
var r = "";
r += "invalid image";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_IMAGE_PARSE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_IMAGE_TOO_LARGE" : function (x) { try { return (function(d){
var r = "";
r += "image too large";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_IMAGE_TOO_LARGE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_IMAGE_WIDTH_TOO_SMALL" : function (x) { try { return (function(d){
var r = "";
r += "image too narrow";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_IMAGE_WIDTH_TOO_SMALL`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_INVALID_EMAILADDRESS" : function (x) { try { return (function(d){
var r = "";
r += "invalid email";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_INVALID_EMAILADDRESS`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_INVALID_IPADDRESS" : function (x) { try { return (function(d){
var r = "";
r += "invalid IP";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_INVALID_IPADDRESS`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_INVALID_OPTION" : function (x) { try { return (function(d){
var r = "";
r += "invalid value";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_INVALID_OPTION`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_PATTERN_MISMATCH" : function (x) { try { return (function(d){
var r = "";
r += "only use letters and numbers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_PATTERN_MISMATCH`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_PROFANITY" : function (x) { try { return (function(d){
var r = "";
r += "profanity";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_PROFANITY`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_HEADER" : function (x) { try { return (function(d){
var r = "";
r += "Your review cannot be approved at this time because it:";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_HEADER`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_SENTENCE" : function (x) { try { return (function(d){
var r = "";
r += "This field ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["errorCodeMessage"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_SENTENCE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_CR" : function (x) { try { return (function(d){
var r = "";
r += "mentions a competitor";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_CR`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_DBA" : function (x) { try { return (function(d){
var r = "";
r += "directs business away";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_DBA`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_MSR" : function (x) { try { return (function(d){
var r = "";
r += "has star rating that does not match review text";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_MSR`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_PII" : function (x) { try { return (function(d){
var r = "";
r += "includes personally identifiable information";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_PII`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_SI" : function (x) { try { return (function(d){
var r = "";
r += "shipping or fulfillment focused";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_SI`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_IMG" : function (x) { try { return (function(d){
var r = "";
r += "includes inappropriate media";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_IMG`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_URL" : function (x) { try { return (function(d){
var r = "";
r += "contains a URL";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_URL`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_VAC" : function (x) { try { return (function(d){
var r = "";
r += "is vague or needs more detail";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_VAC`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_PRF" : function (x) { try { return (function(d){
var r = "";
r += "includes profanity";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_PRF`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_VID" : function (x) { try { return (function(d){
var r = "";
r += "includes inappropriate media";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_VID`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_PRI" : function (x) { try { return (function(d){
var r = "";
r += "mentions the specific price";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_PRI`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_CS" : function (x) { try { return (function(d){
var r = "";
r += "customer service focused";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_CS`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_LI" : function (x) { try { return (function(d){
var r = "";
r += "contains legally sensitive content";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_LI`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_FL" : function (x) { try { return (function(d){
var r = "";
r += "does not match the site's language";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_FL`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_SPM" : function (x) { try { return (function(d){
var r = "";
r += "looks like duplicate content";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_SPM`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_GIU" : function (x) { try { return (function(d){
var r = "";
r += "contains inappropriate content";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_GIU`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_WP" : function (x) { try { return (function(d){
var r = "";
r += "applies to a different product";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_WP`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_UA" : function (x) { try { return (function(d){
var r = "";
r += "was written by a reviewer younger than 13";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_UA`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED_PUX" : function (x) { try { return (function(d){
var r = "";
r += "was written lacking personal experience";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED_PUX`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REJECTED" : function (x) { try { return (function(d){
var r = "";
r += "Does not meet moderation guidelines";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REJECTED`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REQUIRED" : function (x) { try { return (function(d){
var r = "";
r += "required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REQUIRED`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REQUIRED_EITHER" : function (x) { try { return (function(d){
var r = "";
r += "required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REQUIRED_EITHER`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REQUIRED_FAKE" : function (x) { try { return (function(d){
var r = "";
r += "required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REQUIRED_FAKE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REQUIRED_NICKNAME" : function (x) { try { return (function(d){
var r = "";
r += "required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REQUIRED_NICKNAME`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_REQUIRES_TRUE" : function (x) { try { return (function(d){
var r = "";
r += "required";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_REQUIRES_TRUE`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_RESTRICTED" : function (x) { try { return (function(d){
var r = "";
r += "too young";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_RESTRICTED`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_STORAGE_PROVIDER_FAILED" : function (x) { try { return (function(d){
var r = "";
r += "upload failed";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_STORAGE_PROVIDER_FAILED`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_SUBMITTED_NICKNAME" : function (x) { try { return (function(d){
var r = "";
r += "nickname already used";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_SUBMITTED_NICKNAME`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_TOO_FEW" : function (x) { try { return (function(d){
var r = "";
r += "too few";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_TOO_FEW`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_TOO_HIGH" : function (x) { try { return (function(d){
var r = "";
r += "too high";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_TOO_HIGH`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_TOO_LONG" : function (x) { try { return (function(d){
var r = "";
r += "too long";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_TOO_LONG`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_TOO_LOW" : function (x) { try { return (function(d){
var r = "";
r += "too low";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_TOO_LOW`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_TOO_SHORT" : function (x) { try { return (function(d){
var r = "";
r += "too short";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_TOO_SHORT`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_FORM_UPLOAD_IO" : function (x) { try { return (function(d){
var r = "";
r += "upload failed";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_FORM_UPLOAD_IO`: ' + e.toString() ) ] ); return ""; } },"error_ERROR_PRIVATE_BROWSING_MODE" : function (x) { try { return (function(d){
var r = "";
r += "Sorry, writing reviews is disabled in private browsing mode. Please disable private browsing mode and try again.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_ERROR_PRIVATE_BROWSING_MODE`: ' + e.toString() ) ] ); return ""; } },"error_FAILED_TO_LOAD_FINGERPRINT_BEFORE" : function (x) { try { return (function(d){
var r = "";
r += "Please disable any ad blockers, which can prevent successful review submission.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_FAILED_TO_LOAD_FINGERPRINT_BEFORE`: ' + e.toString() ) ] ); return ""; } },"error_FAILED_TO_LOAD_FINGERPRINT_AFTER" : function (x) { try { return (function(d){
var r = "";
r += "Ad blockers prevented your review submission. Please disable ad blockers from this page, then resubmit your review.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_FAILED_TO_LOAD_FINGERPRINT_AFTER`: ' + e.toString() ) ] ); return ""; } },"error_unknown" : function (x) { try { return (function(d){
var r = "";
r += "error";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `error_unknown`: ' + e.toString() ) ] ); return ""; } },"selectOne" : function (x) { try { return (function(d){
var r = "";
r += "Select";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `selectOne`: ' + e.toString() ) ] ); return ""; } },"submission_yes" : function (x) { try { return (function(d){
var r = "";
r += "Yes";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submission_yes`: ' + e.toString() ) ] ); return ""; } },"submission_no" : function (x) { try { return (function(d){
var r = "";
r += "No";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submission_no`: ' + e.toString() ) ] ); return ""; } },"field_required" : function (x) { try { return (function(d){
var r = "";
r += "Required field";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `field_required`: ' + e.toString() ) ] ); return ""; } },"max_length_message" : function (x) { try { return (function(d){
var r = "";
r += "Maximum of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["maxlength"];
r += " characters.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `max_length_message`: ' + e.toString() ) ] ); return ""; } },"max_length_reached_message" : function (x) { try { return (function(d){
var r = "";
r += "Reached maximum of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["maxlength"];
r += " characters.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `max_length_reached_message`: ' + e.toString() ) ] ); return ""; } },"photo_upload_success" : function (x) { try { return (function(d){
var r = "";
r += "The photo was uploaded successfully.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `photo_upload_success`: ' + e.toString() ) ] ); return ""; } },"photo_upload_preview" : function (x) { try { return (function(d){
var r = "";
r += "This is a preview of the photo that was uploaded.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `photo_upload_preview`: ' + e.toString() ) ] ); return ""; } },"photo_upload_preview_placeholder" : function (x) { try { return (function(d){
var r = "";
r += "Uploading photo.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `photo_upload_preview_placeholder`: ' + e.toString() ) ] ); return ""; } },"video_upload_success" : function (x) { try { return (function(d){
var r = "";
r += "The video was successfully linked.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `video_upload_success`: ' + e.toString() ) ] ); return ""; } },"video_upload_preview" : function (x) { try { return (function(d){
var r = "";
r += "This is a preview of the video that was linked.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `video_upload_preview`: ' + e.toString() ) ] ); return ""; } },"video_upload_preview_placeholder" : function (x) { try { return (function(d){
var r = "";
r += "Loading video.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `video_upload_preview_placeholder`: ' + e.toString() ) ] ); return ""; } },"submission_photo_added" : function (x) { try { return (function(d){
var r = "";
r += "The photo was successfully added.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submission_photo_added`: ' + e.toString() ) ] ); return ""; } },"submission_video_added" : function (x) { try { return (function(d){
var r = "";
r += "The video was successfully added.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `submission_video_added`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/model/guidelines',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/util/contentType',
  'framework/util/bvtracker',
  'mf!bv/c2013/messages/submission'
], function (ENV, BModel, _, ContentType, BVTracker, msgPack) {
  return BModel.extend({
    name: 'guidelines',

    init: function (config) {
      this.set({
        icon: '&#x2714;',
        contentType: ContentType.noun(this.get('contentType')),
        guidelinesText: msgPack.helpertext_reviewtext
      });
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!guidelines',['hbs','vendor/handlebars/runtime', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-compat\"> <div class=\"bv-submission-guidelines\"> ";
  if (stack1 = helpers.guidelinesText) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.guidelinesText; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> <!-- <div class=\"bv-guidelines-footer\"> <a class=\"bv-resubmit\">Link to resubmit</a> </div> --> </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("guidelines")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('guidelines', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/guidelines',[
  'framework/bmodel',
  'framework/bview',
  'jquery',
  'hbs!guidelines',
  'bv/util/contentType',
  'mf!bv/c2013/messages/submission',
  'bv/ui-core/modestbox',
  'bv/util/productInfo',
  'framework/util/bvtracker'
], function (BModel, BView, $, template, ContentType, msgPack, ModestBox, ProductInfo, BVTracker) {
  return BView.extend({
    name: 'guidelines',
    el: '.bv-submission-guidelines',

    template: template,

    init: function (config) {
      var component = this.getComponent();

      var mbConfig = {
        title: '',
        view: this,
        inline: false,
        ariaDialog: true
      };

      var guidelinesBox = ModestBox.get('lightbox');
      guidelinesBox.open(mbConfig);

      BVTracker.feature({
        type: 'Used',
        name: 'Guidelines',
        detail1: 'GuidelinesForRejection',
        bvProduct: ProductInfo.RATINGSANDREVIEWS
      });

      this.model = new BModel({
        componentId: this.componentId,
        component: component
      });
    }

  });
});

BV.define('mf!bv/c2013/messages/genericSubmission',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"product_picker_title" : function (x) { try { return (function(d){
var r = "";
r += "Select a Product to Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `product_picker_title`: ' + e.toString() ) ] ); return ""; } },"allCategories" : function (x) { try { return (function(d){
var r = "";
r += "All Categories";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `allCategories`: ' + e.toString() ) ] ); return ""; } },"goBackCategory" : function (x) { try { return (function(d){
var r = "";
r += "Back to ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["lastCategoryName"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `goBackCategory`: ' + e.toString() ) ] ); return ""; } },"selectCategory" : function (x) { try { return (function(d){
var r = "";
r += "More Categories";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `selectCategory`: ' + e.toString() ) ] ); return ""; } },"offscreen_category_select_arrow" : function (x) { try { return (function(d){
var r = "";
r += "Menu, press enter to show options";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_category_select_arrow`: ' + e.toString() ) ] ); return ""; } }
};
});

/* eslint-disable no-unused-vars */
BV.define('bv/c2013/model/genericSubmission',[
  'framework/bmodel',
  'underscore',
  'bv/api/fetch',
  'framework/util/bvtracker',
  'bv/util/productInfo',
  'template/helpers/extmsg',
  'mf!bv/c2013/messages/genericSubmission'
], function (BModel, _, api, BVTracker, ProductInfo, extmsg, msgPack) {
  return BModel.extend({
    name: 'genericSubmission',

    init: function (config) {
      var clientAPIConfig = config.clientAPIConfig || {};
      var familyProductId = clientAPIConfig.familyProductId;

      // Because search can be continuous, we should wait until the user has
      // stopped typing for a couple seconds before we send out a Magpie event.
      var searchAnalyticsHandler = _.debounce(function (searchText) {
        BVTracker.feature({
          type: 'Used',
          name: 'Search',
          detail1: 'GenericReviewSubmission',
          detail2: searchText,
          bvProduct: ProductInfo.RATINGSANDREVIEWS
        });
      }, 2000);

      var component = this.getComponent();

      // If it's rendering inline, we'll assume that it shouldn't scroll
      // automatically to bring the product picker into view. This can be
      // overridden, though.
      var inline = !!clientAPIConfig.inline;
      var silentMode = ('silentMode' in clientAPIConfig) ? !!clientAPIConfig.silentMode : inline;
      var containerId;

      this.set({
        categoryId: clientAPIConfig.categoryId || null,
        familyProductId: familyProductId,
        categoryHistory: [],
        rootCategoryId: -1,
        preventClose: !!clientAPIConfig.preventClose,
        inline: inline,
        silentMode: silentMode
      });

      if (inline) {
        // By default, the container ID is the one specified by the component
        // config (BVGRSContainer)...
        containerId = component.container;
        // ...but the client can override this in the $BV.ui call, in which
        // case we need to tell the component that it should render elsewhere.
        if (clientAPIConfig.containerId) {
          containerId = clientAPIConfig.containerId;
          component.container = containerId;
        }
      }
      else {
        // We're in lightbox mode, so we don't want a containerId. And we
        // need to tell the component that it shouldn't look for a container
        // on the page.
        component.container = containerId = null;
      }

      this.set('containerId', containerId);

      if (!familyProductId) {
        this.subscribe({
          pageto: this.fetchData,
          productItemSelected: this.launchSubmissionForProduct,
          searchcontent: function (pageNum, searchText) {
            searchAnalyticsHandler(searchText);
          },
          searchcleared: function () {
            var rootCategory = this.get('rootCategoryId');
            var currentCategory = this.get('categoryId');
          }
        });
      }
      else {
        this.subscribe('productItemSelected', this.launchSubmissionForProduct);
        this.subscribeOnce('pageto', function () {
          this.dataReady();
        });
      }

      this.on('change:categoryId', this.fetchData, this);
      this.on('change:categoryName', this.updateChildrenWithName, this);
    },

    setupDataProcessing: function () {
      var self = this;
      this.searchModel = _(this.subModels).find(function (m) {
        return m.name === 'searchBar';
      });
      this.subscribe('pageinfo', function (newPageInfo, infoSrc) {
        if (infoSrc.instanceName === 'unfiltered') {
          this.set('moreResultsEnabled', !!(newPageInfo.total));
        }
      }, this);
      this.on('categoryDataReady', function (data) {
        var resultData = data.subcatData;
        if (this.get('categoryHistory').length) {
          resultData = [{ Id: 'bv_back_category', Name: msgPack.goBackCategory(self.toJSON()) }].concat(resultData);
        }
        this.set('subCategories', resultData);
        if (this.get('categoryId') === null) {
          this.set('categoryName', msgPack.allCategories());
        }
        else {
          this.set('categoryName', data.catData.Name);
        }
      });
      this.once('categoryDataReady', function (data) {
        this.dataReady({
          categoryName: this.get('categoryName'),
          subCategories: this.get('subCategories')
        });
      });
    },

    fetchData: function () {
      var self = this;
      var categoryId = this.get('categoryId');
      var subcatRequest = api.get('categories')
        .filterBy('parentid', '=', String(categoryId))
        .filterBy('isActive')
        .sortBy('asc', 'Name')
        .limit(100);
      var catRequest = api.get('categories')
        .filterBy('id', '=', categoryId)
        .filterBy('isActive');
      var batchRequest = api.get('batch', null, [catRequest, subcatRequest]);
      this.unsubscribe('pageto', this.fetchData);
      batchRequest.fetch(this.name).done(function (dataArray) {
        var catData = dataArray[0];
        var subcatData = dataArray[1];
        self.trigger('categoryDataReady', {
          catData: catData.data.Results[0],
          subcatData: subcatData.data.Results
        });
      });
    },

    setCategory: function (category, categoryName, remember) {
      var rootCategory = this.get('rootCategoryId');
      var toCat;
      if (!categoryName) {
        toCat = _(this.get('subCategories')).find(function (cat) {
          return cat.Id === category.toString();
        });
        categoryName = toCat ? toCat.Name : null;
      }
      // Remember where we came from
      if (remember) {
        this.get('categoryHistory').push({
          categoryId: this.get('categoryId'),
          categoryName: this.get('categoryName'),
          lastCategoryName: this.get('lastCategoryName')
        });
        this.set('lastCategoryName', this.get('categoryName'));
      }
      // Careful! Order matters here. Once categoryId changes, it will trigger a re-render.
      this.set('categoryName', categoryName);
      this.set('categoryId', category);
      this.publish('change:categoryId', category);
    },

    backCategory: function () {
      var history = this.get('categoryHistory').pop();
      this.set('lastCategoryName', history.lastCategoryName);
      this.setCategory(history.categoryId, history.categoryName, false);
    },

    breadcrumbCategory: function (categoryId) {
      var history;
      if (categoryId !== undefined) {
        do {
          history = this.get('categoryHistory').pop();
        }
        while (history.categoryId !== null && history.categoryId !== categoryId);
        this.set('lastCategoryName', history.lastCategoryName);
        this.setCategory(history.categoryId, history.categoryName, false);
      }
    },

    launchSubmissionForProduct: function (productId) {
      this.trigger('launchSubmissionForProduct', productId);
    },

    updateChildrenWithName: function (parent, categoryName) {
      this.searchModel.set('categoryName', categoryName);
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!genericSubmission',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/mountView', 'template/helpers/foreach'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; data = data || {};
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.familyProductId, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <div class=\"bv-product-picker\"> ";
  stack1 = helpers.unless.call(depth0, depth0.familyProductId, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "productItemCollection:filtered", options) : helperMissing.call(depth0, "mountView", "productItemCollection:filtered", options)))
    + " ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "loadMore:filtered", options) : helperMissing.call(depth0, "mountView", "loadMore:filtered", options)))
    + " ";
  stack2 = helpers.unless.call(depth0, depth0.familyProductId, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.dimsumConfig),stack1 == null || stack1 === false ? stack1 : stack1.grsSearchEnabled), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "searchBar", options) : helperMissing.call(depth0, "mountView", "searchBar", options)))
    + " ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-control-bar\"> ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount:filtered", options) : helperMissing.call(depth0, "mountView", "ugcCount:filtered", options)))
    + " <div class=\"bv-category-breadcrumb\" role=\"menu\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data};
  stack2 = ((stack1 = helpers.foreach),stack1 ? stack1.call(depth0, depth0.categoryHistory, options) : helperMissing.call(depth0, "foreach", depth0.categoryHistory, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "categorySelect", options) : helperMissing.call(depth0, "mountView", "categorySelect", options)))
    + " </div> </div> ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, data.last, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-back-category-link\"> <a class=\"bv-text-link bv-category-breadcrumb-link\" data-bv-category-breadcrumb=\"";
  if (stack1 = helpers.categoryId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.categoryId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" href=\"#\">";
  if (stack1 = helpers.categoryName) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.categoryName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " &raquo;&nbsp;</a> </div> ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-control-bar bv-more-results bv-hidden\"> ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount:unfiltered", options) : helperMissing.call(depth0, "mountView", "ugcCount:unfiltered", options)))
    + " </div> ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "productItemCollection:unfiltered", options) : helperMissing.call(depth0, "mountView", "productItemCollection:unfiltered", options)))
    + " ";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "loadMore:unfiltered", options) : helperMissing.call(depth0, "mountView", "loadMore:unfiltered", options)))
    + " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("submission generic-submission")
  },inverse:self.noop,fn:self.program(1, program1, data),data:data};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('genericSubmission', t);
t.deps = [];
t.tplMountedViews = ['searchBar','ugcCount:filtered','categorySelect','productItemCollection:filtered','loadMore:filtered','ugcCount:unfiltered','productItemCollection:unfiltered','loadMore:unfiltered'];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/contentSearch',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"content_follow_button" : function (x) { try { return (function(d){
var r = "";
r += "Follow";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_follow_button`: ' + e.toString() ) ] ); return ""; } },"content_share_button" : function (x) { try { return (function(d){
var r = "";
r += "Share";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_share_button`: ' + e.toString() ) ] ); return ""; } },"content_search_button" : function (x) { try { return (function(d){
var r = "";
r += "Search";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_search_button`: ' + e.toString() ) ] ); return ""; } },"content_search_placeholder" : function (x) { try { return (function(d){
var r = "";
r += "Search topics and reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_search_placeholder`: ' + e.toString() ) ] ); return ""; } },"content_search_placeholder_reviewGenericSubmission1" : function (x) { try { return (function(d){
var r = "";
r += "Search ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["categoryName"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_search_placeholder_reviewGenericSubmission1`: ' + e.toString() ) ] ); return ""; } },"content_search_no_results" : function (x) { try { return (function(d){
var r = "";
r += "Your search returned no results.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_search_no_results`: ' + e.toString() ) ] ); return ""; } }
};
});

/* START GENERATED MESSAGE */
BV.define('_i18n_acceptTCButton', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function acceptTCButton( data ) {
try { return (function(d){
var r = "";
r += "Accept";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `acceptTCButton`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_acceptTCButton', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return acceptTCButton(data);
});
return acceptTCButton;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!termsConditions',['hbs','vendor/handlebars/runtime', 'template/helpers/view', '_i18n_acceptTCButton'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-compat bv-submit-step\"> <div id=\"bv-terms-conditions\" class=\"bv-terms-conditions\"> <div class=\"bv-terms-conditions-text bv-focusable\" tabindex=\"0\"> ";
  if (stack1 = helpers.hostedText) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.hostedText; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> </div> <div class=\"bv-tc-footer\"> <button type=\"button\" class=\"bv-button bv-accept-tc-button bv-focusable\"> "
    + " ";
  if (stack1 = helpers._i18n_acceptTCButton) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_acceptTCButton; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </button> </div> </div> ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("submission")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('termsConditions', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/termsConditions',[
  'framework/bmodel',
  'framework/bview',
  'jquery',
  'hbs!termsConditions',
  'bv/util/contentType'
], function (BModel, BView, $, template, ContentType) {
  return BView.extend({
    name: 'termsConditions',
    el: '.bv-terms-conditions',

    events: {
      'click .bv-accept-tc-button': 'acceptAgreements'
    },

    template: template,

    init: function (config) {
      var component = this.getComponent();
      var parent = this.parent;

      // Map from contentType to the message the template needs
      var termsConditionsTypes = {
        answer: 'agreementsQuestions',
        review: 'agreementsReviews',
        question: 'agreementsQuestions'
      };

      this.model = new BModel({
        componentId: this.componentId,
        component: component,
        hostedText: config.fields.hostedText,
        name: 'dummy',
        termsConditionsType: termsConditionsTypes[this.parent.model.get('contentType')]
      });

      this.on('acceptAgreements', function acceptAgrCallback () {
        var prefix = ContentType.nouns(parent.model.get('contentType')) + '_';
        var cb;
        if (prefix === 'answers_') {
          prefix = 'questions_';
        }
        cb = parent.$('[name="agreements_' + prefix + config.fields.id + '"]');

        if (!cb.prop('checked')) {
          // change the checkbox directly and
          // manually re-trigger the validator. from CCS-1819.
          cb.prop('checked', true);
          parent.validator.check(cb);
        }
      }, this);
    },

    acceptAgreements: function (e) {
      this.trigger('acceptAgreements');
      this.trigger('close');
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!uploadPreviewPlaceholder',['hbs','vendor/handlebars/runtime', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " <span aria-hidden=\"true\" class=\"bv-media-preview-icon bv-photo-preview-icon\">&#9688;</span> ";
  }

function program3(depth0,data) {
  
  
  return " <span aria-hidden=\"true\" class=\"bv-media-preview-icon bv-video-preview-icon\">&#9689;</span> ";
  }

  buffer += "<div id=\"bv-media-preview-placeholder-label\" class=\"bv-off-screen\"></div> <div class=\"bv-media-preview-placeholder bv-";
  if (stack1 = helpers.mediaType) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.mediaType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-preview-placeholder\" aria-labelledby=\"bv-media-preview-placeholder-label\" role=\"presentation\"> <div class=\"bv-media-preview-dummy\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "photo", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "photo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "video", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "video", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> "
    + " <div class=\"bv-upload-spinner-container\"> <div class=\"bv-upload-spinner\"></div> </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('uploadPreviewPlaceholder', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionHelper',['hbs','vendor/handlebars/runtime', 'template/helpers/equals', 'template/helpers/renderIcon'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " role=\"status\" aria-live=\"polite\" ";
  }

function program3(depth0,data) {
  
  
  return " &#x2714; ";
  }

function program5(depth0,data) {
  
  
  return " &#x2718; ";
  }

  buffer += "<span class=\"bv-helper\"> <span class=\"bv-helper-label\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "usernickname", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "usernickname", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ></span> <span class=\"bv-helper-icon\" aria-hidden=\"true\"> <span class=\"bv-helper-icon-positive\">";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-helper-icon-positive", options) : helperMissing.call(depth0, "renderIcon", "bv-helper-icon-positive", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</span> <span class=\"bv-helper-icon-negative\">";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-helper-icon-negative", options) : helperMissing.call(depth0, "renderIcon", "bv-helper-icon-negative", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</span> </span> </span> ";
  return buffer;
  });
Handlebars.registerPartial('submissionHelper', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionLabel',['hbs','vendor/handlebars/runtime','hbs!submissionHelper', 'template/helpers/extmsg', 'template/helpers/notEqual', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  
  return "*";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.maxlength), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "max_length_message", depth0.msgpack, depth0.validation, options) : helperMissing.call(depth0, "extmsg", "max_length_message", depth0.msgpack, depth0.validation, options)))
    + "</span> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-sublabel\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "max_length_message", depth0.msgpack, depth0.validation, options) : helperMissing.call(depth0, "extmsg", "max_length_message", depth0.msgpack, depth0.validation, options)))
    + " </span> ";
  return buffer;
  }

  buffer += "<label for=\"bv-";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-fieldset-label-wrapper\"> <span class=\"bv-fieldset-label\"> <span class=\"bv-fieldset-label-text\"> ";
  options = {hash:{
    'prefix': ("display_"),
    'defaultDisplay': (((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Label))
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)));
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.required), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> "
    + " <span aria-hidden=\"false\" class=\"bv-off-screen bv-field-aria-validation\"></span> </span> "
    + " "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "photourl_1", options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "photourl_1", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </label> "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "questionsummary", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "questionsummary", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.submissionHelper, 'submissionHelper', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('submissionLabel', t);
t.deps = ["submissionHelper"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
* msgExists - This is a handlebars template helper that checks to see if a message exists in a
* specified msgPack and then fills the handlebars expression with the message.
*/
BV.define('template/helpers/msgExists',['vendor/handlebars/runtime', 'underscore', 'template/helpers/extmsg'], function (Handlebars, _, extmsg) {
  function msgExists (key, msgpack, data, options) {
    var message = extmsg(key, msgpack, data, options);

    if (message && !_(message.string).isEmpty()) {
      return options.fn({ text: message.string });
    }
    else {
      return options.inverse(this);
    }
  }

  Handlebars.registerHelper('msgExists', msgExists);
  return msgExists;
});

/* START_TEMPLATE */
BV.define('hbs!submissionInputRadio',['hbs','vendor/handlebars/runtime', 'template/helpers/equals', 'template/helpers/loop', 'template/helpers/percentage', 'template/helpers/extmsg', 'template/helpers/msgExists', 'template/helpers/notEqual'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  
  return " bv-fieldset-slider-group";
  }

function program3(depth0,data) {
  
  var buffer = "";
  return buffer;
  }

function program5(depth0,data) {
  
  
  return " notranslate";
  }

function program7(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-radio-";
  if (stack1 = helpers.groupId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.groupId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " bv-radio-";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-group-";
  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " bv-radio-container-li bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, 1, depth0.total, 2, options) : helperMissing.call(depth0, "percentage", 1, depth0.total, 2, options)))
    + "\"";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program8, data, depth0)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "> <input type=\"radio\" id=\"bv-radio-"
    + escapeExpression(((stack1 = ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" name=\"";
  if (stack2 = helpers.id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-radio-input bv-"
    + escapeExpression(((stack1 = ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-input "
    + escapeExpression(((stack1 = depth1.inputClasses),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" value=\"";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" ";
  stack2 = helpers['if'].call(depth0, depth0.label, {hash:{},inverse:self.noop,fn:self.program(12, program12, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{
    'prefix': ("title_"),
    'defaultDisplay': (depth0.label)
  },inverse:self.noop,fn:self.programWithDepth(program14, data, depth1)};
  stack2 = ((stack1 = helpers.msgExists),stack1 ? stack1.call(depth0, depth0.msgpackId, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "msgExists", depth0.msgpackId, depth1.msgpack, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program17, data, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program20, data, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "netpromoterscore", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "netpromoterscore", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program22, data, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " aria-checked=\"false\"/> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program24, data, depth0, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth1.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </li> ";
  return buffer;
  }
function program8(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " data-bv-dropdown-inmbox data-bv-dropdown-style=\"sliderTextOverflow\" data-bv-dropdown-text=\"";
  options = {hash:{
    'defaultDisplay': (depth0.value)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.msgpackId, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.msgpackId, depth1.msgpack, depth0, options)))
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  
  return "bv-focusable";
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "data-label=\"";
  if (stack1 = helpers.label) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.label; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program14(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(15, program15, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "title=\"";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program17(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2;
  buffer += "aria-labelledby=\"bv-fieldset-label-text-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-off-screen-text-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2);
  stack2 = helpers['if'].call(depth0, ((stack1 = depth2.validation),stack1 == null || stack1 === false ? stack1 : stack1.required), {hash:{},inverse:self.noop,fn:self.program(18, program18, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"";
  return buffer;
  }
function program18(depth0,data) {
  
  
  return " bv-required-text-reader";
  }

function program20(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2;
  buffer += "aria-labelledby=\"bv-fieldset-label-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-radio-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-label\"";
  return buffer;
  }

function program22(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2;
  buffer += "aria-labelledby=\"bv-fieldset-label-text-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-radio-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-label bv-field-aria-validation-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"";
  return buffer;
  }

function program24(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-off-screen\" id=\"bv-off-screen-text-"
    + escapeExpression(((stack1 = ((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\">";
  if (stack2 = helpers.value) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.value; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-";
  options = {hash:{
    'defaultDisplay': (depth0.value)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.msgpackId, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.msgpackId, depth1.msgpack, depth0, options)))
    + ".</span> ";
  return buffer;
  }

  buffer += "<span class=\"bv-fieldset-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-group bv-radio-group";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  options = {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "isrecommended", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> <ul> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program7, data, depth0)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, ((stack1 = depth0.ui),stack1 == null || stack1 === false ? stack1 : stack1.radioEl), depth0, options) : helperMissing.call(depth0, "loop", ((stack1 = depth0.ui),stack1 == null || stack1 === false ? stack1 : stack1.radioEl), depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> </span> ";
  return buffer;
  });
Handlebars.registerPartial('submissionInputRadio', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionInputCheckbox',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<!-- checkbox --> <div class=\"bv-checkbox-container\"> <input id=\"bv-checkbox-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-checkbox bv-focusable ";
  if (stack2 = helpers.inputClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.inputClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" type=\"checkbox\" value=\"true\"/> <label class=\"bv-fieldset-label-checkbox\" for=\"bv-checkbox-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> <span class=\"bv-fieldset-label-text\">";
  options = {hash:{
    'prefix': ("display_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "</span> "
    + " <span aria-hidden=\"false\" class=\"bv-off-screen bv-field-aria-validation\"></span> </label> </div> ";
  return buffer;
  });
Handlebars.registerPartial('submissionInputCheckbox', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionInputSelect',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2;
  buffer += " "
    + " "
    + " <option value=\""
    + escapeExpression(((stack1 = depth0.Value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" ";
  stack2 = helpers['if'].call(depth0, depth0.Selected, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + escapeExpression(((stack1 = depth0.Label),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "> ";
  stack2 = helpers['if'].call(depth0, depth0.Label, {hash:{},inverse:self.programWithDepth(program6, data, depth1),fn:self.programWithDepth(program4, data, depth1)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </option> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "selected=\"selected\"";
  }

function program4(depth0,data,depth2) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{
    'prefixNum': (2),
    'prefix': (((stack1 = depth2.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),
    'prefix1': ("_"),
    'defaultDisplay': (depth0.Label)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Value, depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Value, depth2.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

function program6(depth0,data,depth2) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "selectOne", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "selectOne", depth2.msgpack, depth0, options)))
    + " ";
  return buffer;
  }

  buffer += "<select id=\"bv-select-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-select-cleanslate bv-select bv-focusable bv-fastclick-ignore\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> ";
  stack2 = helpers.each.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Options), {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </select> <button type=\"button\" class=\"bv-dropdown-arrow\" aria-hidden=\"true\" onclick=\"return false;\">▼</button> ";
  return buffer;
  });
Handlebars.registerPartial('submissionInputSelect', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionInput',['hbs','vendor/handlebars/runtime','hbs!submissionInputRadio', 'hbs!submissionInputCheckbox', 'hbs!submissionInputSelect', 'template/helpers/extmsg', 'template/helpers/ifHasFeature', 'template/helpers/msgExists', 'template/helpers/equals', 'template/helpers/loop'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <input id=\"bv-hidden-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" type=\"hidden\" class=\"bv-noremember\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Value)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.text, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.email, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.textarea, {hash:{},inverse:self.noop,fn:self.program(8, program8, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.radio, {hash:{},inverse:self.noop,fn:self.program(14, program14, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.checkbox, {hash:{},inverse:self.noop,fn:self.program(27, program27, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.select, {hash:{},inverse:self.noop,fn:self.program(29, program29, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <input id=\"bv-text-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-text bv-focusable ";
  if (stack2 = helpers.inputClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.inputClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" type=\"text\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" maxlength=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.maxlength)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" placeholder=\"";
  options = {hash:{
    'prefix': ("placeholder_"),
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Value)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <input id=\"bv-email-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-text bv-focusable ";
  if (stack2 = helpers.inputClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.inputClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" type=\"email\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" maxlength=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.maxlength)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" placeholder=\"";
  options = {hash:{
    'prefix': ("placeholder_"),
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Value)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <textarea id=\"bv-textarea-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" ";
  stack2 = helpers['if'].call(depth0, depth0.requiredWarning, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " class=\"bv-text bv-focusable ";
  if (stack2 = helpers.inputClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.inputClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" maxlength=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.maxlength)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" placeholder=\"";
  options = {hash:{
    'prefix': ("placeholder_"),
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "\" ";
  options = {hash:{
    '_schemaId': (((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id))
  },inverse:self.noop,fn:self.program(11, program11, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "reviewHelperText", depth0.rawData, options) : helperMissing.call(depth0, "ifHasFeature", "reviewHelperText", depth0.rawData, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += ">"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Value)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</textarea> ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "aria-describedby=\"";
  if (stack1 = helpers.requiredWarning) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.requiredWarning; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program11(depth0,data) {
  
  var stack1, stack2, options;
  options = {hash:{
    'prefix': ("helpertext_")
  },inverse:self.noop,fn:self.program(12, program12, data)};
  stack2 = ((stack1 = helpers.msgExists),stack1 ? stack1.call(depth0, depth0._schemaId, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "msgExists", depth0._schemaId, depth0.msgpack, depth0, options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  }
function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " data-bv-dropdown-inmbox data-bv-dropdown-style=\"helperTextOverflow\" data-bv-dropdown-always-show=\"false\" data-bv-dropdown-text=\"";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <span class=\"bv-fieldset-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-wrapper bv-fieldset-radio-wrapper\" role=\"radiogroup\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(15, program15, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "rating", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), "rating", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  options = {hash:{},inverse:self.program(19, program19, data),fn:self.program(17, program17, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "> ";
  stack2 = self.invokePartial(partials.submissionInputRadio, 'submissionInputRadio', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.dimsumField),stack1 == null || stack1 === false ? stack1 : stack1.type), "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "aria-labelledby=\"";
  if (stack1 = helpers.requiredWarning) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.requiredWarning; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program17(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "aria-labelledby=\"bv-fieldset-label-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"";
  return buffer;
  }

function program19(depth0,data) {
  
  var stack1, stack2;
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.validation),stack1 == null || stack1 === false ? stack1 : stack1.required), {hash:{},inverse:self.noop,fn:self.program(20, program20, data)});
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  }
function program20(depth0,data) {
  
  
  return "aria-labelledby=\"bv-required-text-reader\"";
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-sliderscore-helper-1\" aria-hidden=\"true\">";
  options = {hash:{
    'prefix': ("slider_dimension_1_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "</span> <span class=\"bv-sliderscore-helper-2\" aria-hidden=\"true\">";
  options = {hash:{
    'prefix': ("slider_dimension_2_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program25, data, depth0)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, ((stack1 = depth0.ui),stack1 == null || stack1 === false ? stack1 : stack1.numHelpers), depth0, options) : helperMissing.call(depth0, "loop", ((stack1 = depth0.ui),stack1 == null || stack1 === false ? stack1 : stack1.numHelpers), depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program25(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-rating-helper bv-";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-helper-";
  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" aria-hidden=\"true\">";
  options = {hash:{
    'prefix': ("helper_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.msgpackId, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.msgpackId, depth1.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  stack1 = self.invokePartial(partials.submissionInputCheckbox, 'submissionInputCheckbox', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program29(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " <span class=\"bv-fieldset-select-wrapper\"> ";
  stack1 = self.invokePartial(partials.submissionInputSelect, 'submissionInputSelect', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </span> ";
  return buffer;
  }

  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.hidden, {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('submissionInput', t);
t.deps = ["submissionInputRadio","submissionInputCheckbox","submissionInputSelect"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!submissionField',['hbs','vendor/handlebars/runtime','hbs!submissionInput', 'hbs!submissionLabel'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <fieldset class=\"bv-hidden-field bv-fieldset-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">";
  stack2 = self.invokePartial(partials.submissionInput, 'submissionInput', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</fieldset> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <fieldset class=\"bv-fieldset bv-fieldset-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-";
  if (stack2 = helpers.type) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.type; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-field ";
  if (stack2 = helpers.fieldsetClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.fieldsetClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <div class=\"bv-fieldset-arrowicon\"></div> <div class=\"bv-fieldset-inner\"> ";
  stack2 = self.invokePartial(partials.submissionLabel, 'submissionLabel', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.submissionInput, 'submissionInput', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </fieldset> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.hidden, {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('submissionField', t);
t.deps = ["submissionInput","submissionLabel"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/submissionField',[
  'vendor/handlebars/runtime',
  'underscore',
  'mf!bv/c2013/messages/submission'
], function (Handlebars, _, msgPack) {

  function submissionField (fieldName, context, topContext) {
    var args = [].slice.call(arguments);
    var options = args[args.length - 1];
    var data = context[fieldName];
    var inputs;

    var ui = {};

    var result = !Handlebars.Utils.isEmpty(data);

    if (!result || !data.enabled) {
      return options.inverse(data);
    }
    if (!_(data.schema).isObject()) {
      data.schema = {
        Id: fieldName
      };
    }
    data.rawData = topContext;
    data.clientName = topContext.clientName;
    data.msgpack = topContext.msgpack;

    inputs = {
      TextInput: function (uiInputs) {
        uiInputs.type = 'text';
        return uiInputs;
      },
      TextAreaInput: function (uiInputs) {
        uiInputs.type = 'textarea';
        return uiInputs;
      },
      BooleanInput: function (uiInputs) {
        uiInputs.type = 'radio';
        uiInputs.radioEl = {
          values: ['true', 'false'],
          labels: [msgPack.submission_yes(), msgPack.submission_no()]
        };
        return uiInputs;
      },
      IntegerInput: function (uiInputs) {
        uiInputs.type = 'radio';
        uiInputs.radioEl = {
          range: data.range
        };
        return uiInputs;
      },
      SelectInput: function (uiInputs) {
        uiInputs.type = 'select';
        return uiInputs;
      },
      HiddenInput: function (uiInputs) {
        uiInputs.type = 'hidden';
        uiInputs.hidden = true;
        return uiInputs;
      }
    };

    // Input type
    if (!_(data.schema.Type).isEmpty()) {
      ui = inputs[data.hidden ? 'HiddenInput' : data.schema.Type](ui);

      if (data.schema.Id.indexOf('rating_') > -1) {
        ui = inputs.IntegerInput(ui);
      }
    }

    // override the input type
    if (!_(options.hash.inputType).isUndefined()) {
      ui.type = options.hash.inputType;
    }

    // override the input type
    if (!_(options.hash.numHelpers).isUndefined()) {
      ui.numHelpers = options.hash.numHelpers;
    }

    if (!_(ui.type).isEmpty()) {
      data.type = ui.type;
      data.ui = ui;
      data[ui.type] = true;
    }

    // fieldsetClasses
    if (!_(options.hash.fieldsetClasses).isUndefined()) {
      data.fieldsetClasses = options.hash.fieldsetClasses;
    }
    if (!_(options.hash.inputClasses).isUndefined()) {
      data.inputClasses = options.hash.inputClasses;
    }
    // checking whether the required message should be announced
    if (!_(options.hash.requiredWarning).isUndefined()) {
      data.requiredWarning = options.hash.requiredWarning;
    }

    return options.fn(data);
  }

  Handlebars.registerHelper('submissionField', submissionField);
  return submissionField;
});

/* START_TEMPLATE */
BV.define('hbs!upload',['hbs','vendor/handlebars/runtime','hbs!uploadPreviewPlaceholder', 'hbs!submissionLabel', 'hbs!submissionField', 'template/helpers/view', 'template/helpers/submissionField', 'template/helpers/equals', 'template/helpers/extmsg', 'template/helpers/msgExists'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-compat bv-media-uploader bv-";
  if (stack1 = helpers.mediaType) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.mediaType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-uploader bv-submit-step\"> <form id=\"bv-";
  if (stack1 = helpers.mediaType) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.mediaType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-upload-form-";
  if (stack1 = helpers.channelId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.channelId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" enctype=\"multipart/form-data\" target=\"bv-submission-target-";
  if (stack1 = helpers.channelId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.channelId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" action=\"https:"
    + escapeExpression(((stack1 = ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.baseUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "upload";
  if (stack2 = helpers.mediaType) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.mediaType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + ".json?\" accept-charset=\"utf-8\" method=\"POST\" class=\"bv-form\"> <input type=\"hidden\" name=\"contenttype\" value=\"";
  if (stack2 = helpers.contentType) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.contentType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-noremember\" /> <input type=\"hidden\" name=\"passkey\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.passkey)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-noremember\" /> <input type=\"hidden\" name=\"apiversion\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.apiversion)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-noremember\" /> <input type=\"hidden\" name=\"callback\" value=\"";
  if (stack2 = helpers.postCallback) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.postCallback; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-noremember\" /> <input type=\"hidden\" name=\"forceutf8\" value=\"&#9760;\" class=\"bv-noremember\" /> <input type=\"hidden\" name=\"locale\" value=\"";
  if (stack2 = helpers.locale) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.locale; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-noremember\" /> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.virtualEnvironment), {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.displaycode), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-submission-section\"> <div class=\"bv-media-upload bv-";
  if (stack2 = helpers.mediaType) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.mediaType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-upload\"> <ul class=\"bv-fieldsets\"> ";
  options = {hash:{
    'fieldsetClasses': ("bv-media-upload-placeholder")
  },inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.submissionField),stack1 ? stack1.call(depth0, depth0.urlFieldName, depth0.formFields, depth0, options) : helperMissing.call(depth0, "submissionField", depth0.urlFieldName, depth0.formFields, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.program(21, program21, data),fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> <ul class=\"bv-fieldsets bv-fieldsets-actions bv-media-upload-actions";
  options = {hash:{},inverse:self.noop,fn:self.program(23, program23, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "photo", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "photo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.name, "facebookphotoupload", options) : helperMissing.call(depth0, "equals", depth0.name, "facebookphotoupload", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> <li class=\"bv-form-actions bv-fieldset\"> <div class=\"bv-fieldset-arrowicon\"></div> <div class=\"bv-fieldset-inner\"> <button type=\"button\" type=\"submit\" class=\"bv-form-actions-submit bv-submit bv-photo-submit bv-focusable bv-submission-button-submit\" aria-labelledby=\"";
  options = {hash:{},inverse:self.noop,fn:self.program(25, program25, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "video", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "video", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " bv-add-media-button-label\">";
  options = {hash:{
    'prefix': ("add_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.mediaType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.mediaType, depth0.msgpack, depth0, options)))
    + "</button> <span id=\"bv-add-media-button-label\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("add_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.mediaType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.mediaType, depth0.msgpack, depth0, options)))
    + "</span> <button type=\"button\" class=\"bv-form-action bv-cancel bv-submission-button-submit\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "cancel", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "cancel", depth0.msgpack, depth0, options)))
    + " </button> </div> </li> </ul> </div> "
    + " </div> "
    + " </form> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <input type=\"hidden\" name=\"ve\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.virtualEnvironment)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-noremember\" /> ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <input type=\"hidden\" name=\"displaycode\" value=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.apiConfig),stack1 == null || stack1 === false ? stack1 : stack1.displaycode)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-noremember\" /> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-fieldset bv-fieldset-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " bv-";
  if (stack2 = helpers.type) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.type; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-field ";
  if (stack2 = helpers.fieldsetClasses) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.fieldsetClasses; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\"> <div class=\"bv-fieldset-arrowicon\"></div> <div class=\"bv-fieldset-inner bv-fieldset-media-upload\"> <div class=\"bv-media-display bv-"
    + escapeExpression(((stack1 = ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-display\"> "
    + " <div id=\"bv-";
  if (stack2 = helpers.type) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.type; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-media-display-container-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-media-preview-container bv-"
    + escapeExpression(((stack1 = ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-preview-container";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> ";
  stack2 = self.invokePartial(partials.uploadPreviewPlaceholder, 'uploadPreviewPlaceholder', depth0.rawData, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> <div class=\"bv-media-picker-container\"> ";
  stack2 = self.invokePartial(partials.submissionLabel, 'submissionLabel', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <button type=\"button\" class=\"bv-content-btn bv-hidden bv-media-preview-clear bv-focusable\" tabindex=\"0\">";
  options = {hash:{
    'prefix': ("remove_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.msgpack), depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.msgpack), depth0, options)))
    + "</button> "
    + " ";
  options = {hash:{},inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), "photo", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), "photo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(15, program15, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), "video", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType), "video", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> "
    + " </div> </li> ";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return " bv-hidden bv-hidden-facebook";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "photoupload", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "photoupload", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(13, program13, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options) : helperMissing.call(depth0, "equals", ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.name), "facebookphotoupload", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-media-toggle-controls\"> <input type=\"file\" accept=\"image/*\" name=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.rawData),stack1 == null || stack1 === false ? stack1 : stack1.mediaType)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-noremember bv-form-ignore bv-focusable\" ";
  options = {hash:{
    'prefix': ("helpertext_")
  },inverse:self.noop,fn:self.programWithDepth(program11, data, depth0)};
  stack2 = ((stack1 = helpers.msgExists),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "msgExists", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " aria-labelledby=\"bv-guidelines-label bv-media-guidelines-ul bv-choose-file-label\"/> <span id=\"bv-choose-file-label\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("display_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "</span> </div> ";
  return buffer;
  }
function program11(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " data-bv-dropdown-inmbox data-bv-dropdown-style=\"helperTextOverflow\" data-bv-dropdown-text=\"";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" data-bv-dropdown-position-target=\"bv-"
    + escapeExpression(((stack1 = depth1.type),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-media-display-container-"
    + escapeExpression(((stack1 = ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" data-bv-dropdown-disable-events ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return " <div class=\"bv-facebook-photo-outer-container\"> <div class=\"bv-mbox-spinner\">loading...</div> </div> <input type=\"hidden\" name=\"photourl\" class=\"bv-noremember\" /> ";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <input type=\"text\" name=\"videourl\" id=\"bv-";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-field-"
    + escapeExpression(((stack1 = ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-text bv-focusable bv-noremember\" aria-label=\"";
  options = {hash:{
    'prefix': ("offscreen_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options)))
    + "\" placeholder=\"Ex: http://youtube.com\" ";
  options = {hash:{
    'prefix': ("helpertext_")
  },inverse:self.noop,fn:self.programWithDepth(program16, data, depth0)};
  stack2 = ((stack1 = helpers.msgExists),stack1 ? stack1.call(depth0, ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options) : helperMissing.call(depth0, "msgExists", ((stack1 = depth0.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id), depth0.msgpack, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " /> ";
  return buffer;
  }
function program16(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " data-bv-dropdown-inmbox data-bv-dropdown-style=\"helperTextOverflow\" data-bv-dropdown-text=\"";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" data-bv-dropdown-position-target=\"bv-"
    + escapeExpression(((stack1 = depth1.type),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-media-display-container-"
    + escapeExpression(((stack1 = ((stack1 = depth1.schema),stack1 == null || stack1 === false ? stack1 : stack1.Id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" data-bv-dropdown-disable-events=\"true\" ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'fieldsetClasses': ("bv-media-upload-caption")
  },inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.submissionField),stack1 ? stack1.call(depth0, depth0.captionFieldName, depth0.formFields, depth0, options) : helperMissing.call(depth0, "submissionField", depth0.captionFieldName, depth0.formFields, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <li class=\"bv-fieldset-wrapper\"> ";
  stack1 = self.invokePartial(partials.submissionField, 'submissionField', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </li> ";
  return buffer;
  }

function program21(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'fieldsetClasses': ("bv-media-upload-caption bv-hidden bv-hidden-facebook")
  },inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.submissionField),stack1 ? stack1.call(depth0, depth0.captionFieldName, depth0.formFields, depth0, options) : helperMissing.call(depth0, "submissionField", depth0.captionFieldName, depth0.formFields, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program23(depth0,data) {
  
  
  return " bv-hidden";
  }

function program25(depth0,data) {
  
  
  return "bv-guidelines-label bv-media-guidelines-ul";
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("submission submission-noimage")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('upload', t);
t.deps = ["uploadPreviewPlaceholder","submissionLabel","submissionField"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!uploadPreview',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/equals', 'template/helpers/ensureProtocolRelative'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-media-preview-dummy\"></div> <iframe id=\"bv-media-viewer-ytmedia\" class=\"bv-media-viewer-ytmedia\" type=\"text/html\" src=\"//www.youtube.com/embed/";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" aria-labelledby=\"bv-media-viewer-ytmedia\"/> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <img data-src=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, depth0.url, options) : helperMissing.call(depth0, "ensureProtocolRelative", depth0.url, options)))
    + "\" aria-labelledby=\"bv-media-preview-label\"/> ";
  return buffer;
  }

  buffer += "<div id=\"bv-media-preview-label\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': (depth0.mediaType)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "_upload_preview", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "_upload_preview", depth0.msgpack, depth0, options)))
    + "</div> <div class=\"bv-media-preview bv-";
  if (stack2 = helpers.mediaType) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.mediaType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-preview bv-focusable\" tabindex=\"0\" aria-labelledby=\"bv-media-preview-label\" role=\"presentation\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "video", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "video", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.mediaType, "photo", options) : helperMissing.call(depth0, "equals", depth0.mediaType, "photo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('uploadPreview', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/ui-core/buploadview',[
  'ENV',
  'framework/bmodel',
  'framework/bview',
  'hbs!upload',
  'underscore',
  'jquery',
  'bv/api',
  'mf!bv/c2013/messages/submission',
  'hbs!uploadPreview',
  'hbs!uploadPreviewPlaceholder',
  'bv/util/focusManager'
], function (ENV, BModel, BView, template, _, $, api, msgPack, uploadPreview, uploadPreviewPlaceholder, focusManager) {
  return BView.extend({
    name: 'mediaupload',
    mediaType: 'media',

    label: '.bv-media-picker-container .bv-helper-label',
    offscreenError: '.bv-media-picker-container .bv-field-aria-validation',
    input: '.bv-media-picker-container input',
    preview: '.bv-media-preview-container',
    controls: '.bv-media-toggle-controls',
    uploadActions: '.bv-media-upload-actions',
    clear: '.bv-media-preview-clear',
    fieldset: '.bv-media-upload-placeholder',
    caption: '.bv-media-upload-caption',

    events: {
      'click .bv-cancel': 'cancelUpload',
      'click .bv-submit': 'submitUpload',
      'click .bv-media-preview-clear': '_removeMedia'
    },

    init: function (config) {
      // var parent = config.parent || this.parent;
      this.template = template;

      // Did the parent view pass in a photo? If so, we're editing, not
      // uploading. Store the photo in the model and it'll be seen when the
      // view renders.
      if (!_(config.media).isUndefined()) {
        this.model.set(this.mediaType, config.media);
      }
    },

    submitUpload: function (e) {
      var media;
      var originalFileName;
      e.preventDefault();
      media = this.model.get(this.mediaType);
      // If there's no media, do nothing.
      if (!media) {
        return;
      }
      this._updateMedia(media);

      if (!media.caption && !media.fileName) {
        originalFileName = this.$el.find(this.input)[0].value;
        originalFileName = originalFileName.slice(originalFileName.lastIndexOf('\\') + 1);
        media.fileName = _.escape(originalFileName);
      }

      this.model.set(this.mediaType, media);

      // Fire an event on the parent.
      this.parent.trigger('addmedia', this.mediaType, media);
    },

    _updateMedia: function (media) {
      var mediaCaption = this.model.get('captionFieldName');
      var caption = this.$el.find('input[name="' + mediaCaption + '"]').val();
      media.caption = caption;
    },

    showError: function (message) {
      var $previewContainer;
      var $li;
      var $label;
      var $errorMessage;
      var $input;

      this._currentError = message;

      $previewContainer = this.$el.find(this.preview);
      $previewContainer.removeClass('bv-media-uploading');

      // Show upload controls
      this.$el.find(this.controls).css('display', 'block');

      $li = this.$el.find(this.fieldset);
      $li.addClass('bv-error');

      $label = $li.find(this.label);
      $label.text(message).show();

      // Give the input an error label for screenreaders
      $errorMessage = $li.find(this.offscreenError);
      $errorMessage.text(message);

      // Mark aria-invalid
      $input = $li.find(this.input);
      $input.attr('aria-invalid', true);

      // Move focus back to the input
      focusManager.moveFocus($input);
    },

    clearError: function () {
      var $li;
      var $errorMessage;
      var $input;
      var $label;
      // var $button;

      this._currentError = null;
      $li = this.$el.find(this.fieldset);
      $li.removeClass('bv-error');

      // Clear the error message
      $errorMessage = $li.find(this.offscreenError);
      $errorMessage.empty();

      // Make sure to remove the error label
      $input = $li.find(this.input);
      $input.removeAttr('aria-invalid');

      $label = $li.find(this.label);
      $label.empty().hide();

      // $button = this.$el.find('.bv-submit');
    },

    displayMedia: function (img, fromUpload) {
      // img is an optional parameter for preloaded photo image

      var self = this;
      var media = this.model.get(this.mediaType);
      var url = (media.thumbnail && media.thumbnail[2]) ? media.thumbnail[2].url : media.url;
      var $previewContainer;
      var $caption;

      // Clear any error that may have been shown prior to this successful
      // video upload.
      this.clearError();

      // Hide the spinner stuff and show the preview, removeMedia and submit buttons.
      this.$el.find(this.preview).removeClass('bv-media-uploading');
      this.$el.find(this.controls).css('display', 'none');
      this.$el.find(this.clear).removeClass('bv-hidden');
      this.$el.find(this.uploadActions).removeClass('bv-hidden');

      $previewContainer = this.$el.find(this.preview);
      $previewContainer.html(uploadPreview({
        mediaType: this.mediaType,
        id: media.id,
        url: url,
        msgpack: msgPack
      }));

      if (img) {
        $(img).addClass('bv-photo-preview-img');
        $(img).attr('aria-labelledby', 'bv-media-preview-label');
        self.$el.find('.bv-media-preview').html(img);
        setTimeout(function () {
          $(img).addClass('bv-photo-preview-img-show');
        }, 0);
      }

      if (this.mediaType === 'video') {
        this.$el.find('input[name="videourl"]').val(media.url);
      }

      if (fromUpload) {
        // After upload, move focus to the add photo/video preview (wait a tick for modest box resizing).
        // In addition, we want the screen reader to announce that the photo was uploaded successfully.
        // In order to accomplish both of these things simultaneously, we swap out the preview label text for 2 seconds
        // to contain an offscreen message about upload success, then swap back in the normal text. For context,
        // adding an aria alert to the DOM or adding a status using ariaStatus always fails for VO in this case,
        // and sometimes fails in JAWS. The solution below was the only thing that consistently worked in both. I
        // suspect the inconsitency stems from the screenreader being in forms mode.
        setTimeout(function () {
          var $mediaPreview;
          var $mediaPreviewLabel;
          var originalText;

          focusManager.rescanFocusLayer();
          $mediaPreview = $('.bv-media-preview');
          $mediaPreviewLabel = $('#bv-media-preview-label');
          originalText = $mediaPreviewLabel.html();
          $mediaPreviewLabel.html(msgPack[self.mediaType + '_upload_success']() + ' ' + originalText);
          focusManager.moveFocus($mediaPreview);
          setTimeout(function () {
            $mediaPreviewLabel.html(originalText);
          }, 2000);
        }, 0);
      }

      // Now that we have media, we can show the caption field and the
      // buttons.
      $caption = this.$el.find(this.caption);
      $caption.removeClass('bv-hidden');
      // Set caption text to the value of the media's caption. It will be empty if it's a new upload.
      $caption.find('input[type="text"]').val(media.caption);
    },

    _removeMedia: function (e) {
      // This is the event handler for removeMedia
      this.removeMedia(true);
    },

    removeMedia: function (clearTextField) {
      var isIE = /Trident|MSIE/.test(navigator.userAgent);
      var media;
      var $previewContainer;
      var html;
      var fieldName;

      if (_.isUndefined(clearTextField)) {
        clearTextField = true;
      }

      media = this.model.get(this.mediaType);
      if (media) {
        // Fire an event on the parent.
        this.parent.trigger('removemedia', media.id, this.mediaType);
        this.model.set(this.mediaType, null);
      }

      // Show the upload controls.
      this.$el.find(this.controls).css('display', 'block');
      if (this.mediaType === 'photo') {
        this.$el.find(this.uploadActions).addClass('bv-hidden');
      }

      // Remove the preview and restore the placeholder to original size.
      $previewContainer = this.$el.find(this.preview);

      html = uploadPreviewPlaceholder({
        mediaType: this.mediaType,
        msgpack: msgPack
      });
      $previewContainer.html(html)
        .css({ height: '', width: '' })
        .addClass('bv-' + this.mediaType + '-preview-container');

      // Commenting for now until Azel and I can look at it together - Oliver
      // $previewContainer.closest('.bv-media-display').css('height', '');

      this.$el.find(this.clear).addClass('bv-hidden');
      this.$el.find(this.caption).addClass('bv-hidden');

      // Reset the form input unless we've been told not to.
      if (clearTextField) {
        fieldName = this.mediaType === 'video' ? 'videourl' : this.mediaType;
        this.$el.find('input[name="' + fieldName + '"]').val('');
        if (isIE) {
          this.$el.find(this.preview).removeClass('bv-media-uploading');
          this.$el.find(this.controls).css('display', 'block');
        }
      }
      this.trigger('scroll');
    },

    cancelUpload: function () {
      this.trigger('close');
    },

    remove: function () {
      BView.prototype.remove.apply(this, arguments);
    },

    setupView: function () {
      // If we were initialized with media, display it immediately for
      // editing.
      var media = this.model.get(this.mediaType);
      if (media) {
        this.displayMedia();
      }
    },

    // This little utility function is used to populate the placeholder container with screenreader text relevant
    // to what is getting loaded.
    updatePlaceholderText: function () {
      var self = this;
      // Wait a second to start updating text so the screenreader doesn't get confused.
      setTimeout(function () {
        var $placeHolder = self.$el.find('.bv-media-preview-placeholder');
        var $placeHolderLabel = self.$el.find('#bv-media-preview-placeholder-label');

        // Ensure that the placeholder is now focusable
        $placeHolder.addClass('bv-focusable');
        $placeHolder.attr('tabindex', '0');

        // Insert offscreen progress message for screen reader
        $placeHolderLabel.html(msgPack[self.mediaType + '_upload_preview_placeholder']());

        focusManager.rescanFocusLayer();

        // Move focus to the preview placeholder
        focusManager.moveFocus($placeHolder);

        setTimeout(function () {
          $placeHolderLabel.empty();
        }, 2000);
      }, 1000);
    }

  });
});

/**
 * easyXDM
 * http://easyxdm.net/
 * Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.

 */
BV.define('vendor/easyXDM',['vendor/json2'], function (JSON){
(function (window, document, location, setTimeout, decodeURIComponent, encodeURIComponent) {
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global JSON, XMLHttpRequest, window, escape, unescape, ActiveXObject */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

var global = window;
var channelId = Math.floor(Math.random() * 10000); // randomize the initial id in case of multiple closures loaded
var emptyFn = Function.prototype;
var reURI = /^((http.?:)\/\/([^:\/\s]+)(:\d+)*)/; // returns groups for protocol (2), domain (3) and port (4)
var reParent = /[\-\w]+\/\.\.\//; // matches a foo/../ expression
var reDoubleSlash = /([^:])\/\//g; // matches // anywhere but in the protocol
var namespace = ""; // stores namespace under which easyXDM object is stored on the page (empty if object is global)
var easyXDM = {};
var _easyXDM = window.easyXDM; // map over global easyXDM in case of overwrite
var IFRAME_PREFIX = "easyXDM_";
var HAS_NAME_PROPERTY_BUG;
var useHash = false; // whether to use the hash over the query
var flashVersion; // will be set if using flash
var HAS_FLASH_THROTTLED_BUG;


// http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
function isHostMethod(object, property){
    var t = typeof object[property];
    return t == 'function' ||
    (!!(t == 'object' && object[property])) ||
    t == 'unknown';
}

function isHostObject(object, property){
    return !!(typeof(object[property]) == 'object' && object[property]);
}

// end

// http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
function isArray(o){
    return Object.prototype.toString.call(o) === '[object Array]';
}

// end
function hasFlash(){
    var name = "Shockwave Flash", mimeType = "application/x-shockwave-flash";

    if (!undef(navigator.plugins) && typeof navigator.plugins[name] == "object") {
        // adapted from the swfobject code
        var description = navigator.plugins[name].description;
        if (description && !undef(navigator.mimeTypes) && navigator.mimeTypes[mimeType] && navigator.mimeTypes[mimeType].enabledPlugin) {
            flashVersion = description.match(/\d+/g);
        }
    }
    if (!flashVersion) {
        var flash;
        try {
            flash = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
            flashVersion = Array.prototype.slice.call(flash.GetVariable("$version").match(/(\d+),(\d+),(\d+),(\d+)/), 1);
            flash = null;
        }
        catch (notSupportedException) {
        }
    }
    if (!flashVersion) {
        return false;
    }
    var major = parseInt(flashVersion[0], 10), minor = parseInt(flashVersion[1], 10);
    HAS_FLASH_THROTTLED_BUG = major > 9 && minor > 0;
    return true;
}

/*
 * Cross Browser implementation for adding and removing event listeners.
 */
var on, un;
if (isHostMethod(window, "addEventListener")) {
    on = function(target, type, listener){
        target.addEventListener(type, listener, false);
    };
    un = function(target, type, listener){
        target.removeEventListener(type, listener, false);
    };
}
else if (isHostMethod(window, "attachEvent")) {
    on = function(object, sEvent, fpNotify){
        object.attachEvent("on" + sEvent, fpNotify);
    };
    un = function(object, sEvent, fpNotify){
        object.detachEvent("on" + sEvent, fpNotify);
    };
}
else {
    throw new Error("Browser not supported");
}

/*
 * Cross Browser implementation of DOMContentLoaded.
 */
var domIsReady = false, domReadyQueue = [], readyState;
if ("readyState" in document) {
    // If browser is WebKit-powered, check for both 'loaded' (legacy browsers) and
    // 'interactive' (HTML5 specs, recent WebKit builds) states.
    // https://bugs.webkit.org/show_bug.cgi?id=45119
    readyState = document.readyState;
    domIsReady = readyState == "complete" || (~ navigator.userAgent.indexOf('AppleWebKit/') && (readyState == "loaded" || readyState == "interactive"));
}
else {
    // If readyState is not supported in the browser, then in order to be able to fire whenReady functions apropriately
    // when added dynamically _after_ DOM load, we have to deduce wether the DOM is ready or not.
    // We only need a body to add elements to, so the existence of document.body is enough for us.
    domIsReady = !!document.body;
}

function dom_onReady(){
    if (domIsReady) {
        return;
    }
    domIsReady = true;
    for (var i = 0; i < domReadyQueue.length; i++) {
        domReadyQueue[i]();
    }
    domReadyQueue.length = 0;
}


if (!domIsReady) {
    if (isHostMethod(window, "addEventListener")) {
        on(document, "DOMContentLoaded", dom_onReady);
    }
    else {
        on(document, "readystatechange", function(){
            if (document.readyState == "complete") {
                dom_onReady();
            }
        });
        if (document.documentElement.doScroll && window === top) {
            var doScrollCheck = function(){
                if (domIsReady) {
                    return;
                }
                // http://javascript.nwbox.com/IEContentLoaded/
                try {
                    document.documentElement.doScroll("left");
                }
                catch (e) {
                    setTimeout(doScrollCheck, 1);
                    return;
                }
                dom_onReady();
            };
            doScrollCheck();
        }
    }

    // A fallback to window.onload, that will always work
    on(window, "load", dom_onReady);
}
/**
 * This will add a function to the queue of functions to be run once the DOM reaches a ready state.
 * If functions are added after this event then they will be executed immediately.
 * @param {function} fn The function to add
 * @param {Object} scope An optional scope for the function to be called with.
 */
function whenReady(fn, scope){
    if (domIsReady) {
        fn.call(scope);
        return;
    }
    domReadyQueue.push(function(){
        fn.call(scope);
    });
}

/**
 * Returns an instance of easyXDM from the parent window with
 * respect to the namespace.
 *
 * @return An instance of easyXDM (in the parent window)
 */
function getParentObject(){
    var obj = parent;
    if (namespace !== "") {
        for (var i = 0, ii = namespace.split("."); i < ii.length; i++) {
            obj = obj[ii[i]];
        }
    }
    return obj.easyXDM;
}

/**
 * Removes easyXDM variable from the global scope. It also returns control
 * of the easyXDM variable to whatever code used it before.
 *
 * @param {String} ns A string representation of an object that will hold
 *                    an instance of easyXDM.
 * @return An instance of easyXDM
 */
function noConflict(ns){

    window.easyXDM = _easyXDM;
    namespace = ns;
    if (namespace) {
        IFRAME_PREFIX = "easyXDM_" + namespace.replace(".", "_") + "_";
    }
    return easyXDM;
}

/*
 * Methods for working with URLs
 */
/**
 * Get the domain name from a url.
 * @param {String} url The url to extract the domain from.
 * @return The domain part of the url.
 * @type {String}
 */
function getDomainName(url){
    return url.match(reURI)[3];
}

/**
 * Get the port for a given URL, or "" if none
 * @param {String} url The url to extract the port from.
 * @return The port part of the url.
 * @type {String}
 */
function getPort(url){
    return url.match(reURI)[4] || "";
}

/**
 * Returns  a string containing the schema, domain and if present the port
 * @param {String} url The url to extract the location from
 * @return {String} The location part of the url
 */
function getLocation(url){
    var m = url.toLowerCase().match(reURI);
    var proto = m[2], domain = m[3], port = m[4] || "";
    if ((proto == "http:" && port == ":80") || (proto == "https:" && port == ":443")) {
        port = "";
    }
    return proto + "//" + domain + port;
}

/**
 * Resolves a relative url into an absolute one.
 * @param {String} url The path to resolve.
 * @return {String} The resolved url.
 */
function resolveUrl(url){

    // replace all // except the one in proto with /
    url = url.replace(reDoubleSlash, "$1/");

    // If the url is a valid url we do nothing
    if (!url.match(/^(http||https):\/\//)) {
        // If this is a relative path
        var path = (url.substring(0, 1) === "/") ? "" : location.pathname;
        if (path.substring(path.length - 1) !== "/") {
            path = path.substring(0, path.lastIndexOf("/") + 1);
        }

        url = location.protocol + "//" + location.host + path + url;
    }

    // reduce all 'xyz/../' to just ''
    while (reParent.test(url)) {
        url = url.replace(reParent, "");
    }

    return url;
}

/**
 * Appends the parameters to the given url.<br/>
 * The base url can contain existing query parameters.
 * @param {String} url The base url.
 * @param {Object} parameters The parameters to add.
 * @return {String} A new valid url with the parameters appended.
 */
function appendQueryParameters(url, parameters){

    var hash = "", indexOf = url.indexOf("#");
    if (indexOf !== -1) {
        hash = url.substring(indexOf);
        url = url.substring(0, indexOf);
    }
    var q = [];
    for (var key in parameters) {
        if (parameters.hasOwnProperty(key)) {
            q.push(key + "=" + encodeURIComponent(parameters[key]));
        }
    }
    return url + (useHash ? "#" : (url.indexOf("?") == -1 ? "?" : "&")) + q.join("&") + hash;
}


// build the query object either from location.query, if it contains the xdm_e argument, or from location.hash
var query = (function(input){
    input = input.substring(1).split("&");
    var data = {}, pair, i = input.length;
    while (i--) {
        pair = input[i].split("=");
        data[pair[0]] = decodeURIComponent(pair[1]);
    }
    return data;
}(/xdm_e=/.test(location.search) ? location.search : location.hash));

/*
 * Helper methods
 */
/**
 * Helper for checking if a variable/property is undefined
 * @param {Object} v The variable to test
 * @return {Boolean} True if the passed variable is undefined
 */
function undef(v){
    return typeof v === "undefined";
}

/**
 * A safe implementation of HTML5 JSON. Feature testing is used to make sure the implementation works.
 * @return {JSON} A valid JSON conforming object, or null if not found.
 */
var getJSON = function(){
    var cached = {};
    var obj = {
        a: [1, 2, 3]
    }, json = "{\"a\":[1,2,3]}";

    if (typeof JSON != "undefined" && typeof JSON.stringify === "function" && JSON.stringify(obj).replace((/\s/g), "") === json) {
        // this is a working JSON instance
        return JSON;
    }
    if (Object.toJSON) {
        if (Object.toJSON(obj).replace((/\s/g), "") === json) {
            // this is a working stringify method
            cached.stringify = Object.toJSON;
        }
    }

    if (typeof String.prototype.evalJSON === "function") {
        obj = json.evalJSON();
        if (obj.a && obj.a.length === 3 && obj.a[2] === 3) {
            // this is a working parse method
            cached.parse = function(str){
                return str.evalJSON();
            };
        }
    }

    if (cached.stringify && cached.parse) {
        // Only memoize the result if we have valid instance
        getJSON = function(){
            return cached;
        };
        return cached;
    }
    return null;
};

/**
 * Applies properties from the source object to the target object.<br/>
 * @param {Object} target The target of the properties.
 * @param {Object} source The source of the properties.
 * @param {Boolean} noOverwrite Set to True to only set non-existing properties.
 */
function apply(destination, source, noOverwrite){
    var member;
    for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
            if (prop in destination) {
                member = source[prop];
                if (typeof member === "object") {
                    apply(destination[prop], member, noOverwrite);
                }
                else if (!noOverwrite) {
                    destination[prop] = source[prop];
                }
            }
            else {
                destination[prop] = source[prop];
            }
        }
    }
    return destination;
}

// This tests for the bug in IE where setting the [name] property using javascript causes the value to be redirected into [submitName].
function testForNamePropertyBug(){
    var form = document.body.appendChild(document.createElement("form")), input = form.appendChild(document.createElement("input"));
    input.name = IFRAME_PREFIX + "TEST" + channelId; // append channelId in order to avoid caching issues
    HAS_NAME_PROPERTY_BUG = input !== form.elements[input.name];
    document.body.removeChild(form);
}

/**
 * Creates a frame and appends it to the DOM.
 * @param config {object} This object can have the following properties
 * <ul>
 * <li> {object} prop The properties that should be set on the frame. This should include the 'src' property.</li>
 * <li> {object} attr The attributes that should be set on the frame.</li>
 * <li> {DOMElement} container Its parent element (Optional).</li>
 * <li> {function} onLoad A method that should be called with the frames contentWindow as argument when the frame is fully loaded. (Optional)</li>
 * </ul>
 * @return The frames DOMElement
 * @type DOMElement
 */
function createFrame(config){
    if (undef(HAS_NAME_PROPERTY_BUG)) {
        testForNamePropertyBug();
    }
    var frame;
    // This is to work around the problems in IE6/7 with setting the name property.
    // Internally this is set as 'submitName' instead when using 'iframe.name = ...'
    // This is not required by easyXDM itself, but is to facilitate other use cases
    if (HAS_NAME_PROPERTY_BUG) {
        frame = document.createElement("<iframe name=\"" + config.props.name + "\"/>");
    }
    else {
        frame = document.createElement("IFRAME");
        frame.name = config.props.name;
    }

    frame.id = frame.name = config.props.name;
    delete config.props.name;

    if (typeof config.container == "string") {
        config.container = document.getElementById(config.container);
    }

    if (!config.container) {
        // This needs to be hidden like this, simply setting display:none and the like will cause failures in some browsers.
        frame.setAttribute('class', 'easyXDMStyle');
        config.container = document.body;
    }

    var src = config.props.src;

    // transfer properties to the frame
    apply(frame, config.props);

    frame.border = frame.frameBorder = 0;
    frame.allowTransparency = true;
    config.container.appendChild(frame);

    if (config.onLoad) {
        on(frame, "load", config.onLoad);
    }

    // set the frame URL to the proper value
    if(config.usePost) {
        var form = config.container.appendChild(document.createElement('form')), input;
        form.target = frame.name;
        form.action = src;
        form.method = 'POST';
        if (typeof(config.usePost) === 'object') {
            for (var i in config.usePost) {
                if (config.usePost.hasOwnProperty(i)) {
                    if (HAS_NAME_PROPERTY_BUG) {
                        input = document.createElement('<input name="' + i + '"/>');
                    } else {
                        input = document.createElement("INPUT");
                        input.name = i;
                    }
                    input.value = config.usePost[i];
                    form.appendChild(input);
                }
            }
        }
        form.submit();
        form.parentNode.removeChild(form);
    } else {
        frame.src = src;
    }

    return frame;
}

/**
 * Check whether a domain is allowed using an Access Control List.
 * The ACL can contain * and ? as wildcards, or can be regular expressions.
 * If regular expressions they need to begin with ^ and end with $.
 * @param {Array/String} acl The list of allowed domains
 * @param {String} domain The domain to test.
 * @return {Boolean} True if the domain is allowed, false if not.
 */
function checkAcl(acl, domain){
    // normalize into an array
    if (typeof acl == "string") {
        acl = [acl];
    }
    var re, i = acl.length;
    while (i--) {
        re = acl[i];
        re = new RegExp(re.substr(0, 1) == "^" ? re : ("^" + re.replace(/(\*)/g, ".$1").replace(/\?/g, ".") + "$"));
        if (re.test(domain)) {
            return true;
        }
    }
    return false;
}

/*
 * Functions related to stacks
 */
/**
 * Prepares an array of stack-elements suitable for the current configuration
 * @param {Object} config The Transports configuration. See easyXDM.Socket for more.
 * @return {Array} An array of stack-elements with the TransportElement at index 0.
 */
function prepareTransportStack(config){
    var protocol = config.protocol, stackEls;
    config.isHost = config.isHost || undef(query.xdm_p);
    useHash = config.hash || false;

    if (!config.props) {
        config.props = {};
    }
    if (!config.isHost) {
        config.channel = query.xdm_c.replace(/["'<>\\]/g, "");
        config.secret = query.xdm_s;
        config.remote = query.xdm_e.replace(/["'<>\\]/g, "");
        ;
        protocol = query.xdm_p;
        if (config.acl && !checkAcl(config.acl, config.remote)) {
            throw new Error("Access denied for " + config.remote);
        }
    }
    else {
        config.remote = resolveUrl(config.remote);
        config.channel = config.channel || "default" + channelId++;
        config.secret = Math.random().toString(16).substring(2);
        if (undef(protocol)) {
            if (getLocation(location.href) == getLocation(config.remote)) {
                /*
                 * Both documents has the same origin, lets use direct access.
                 */
                protocol = "4";
            }
            else if (isHostMethod(window, "postMessage") || isHostMethod(document, "postMessage")) {
                /*
                 * This is supported in IE8+, Firefox 3+, Opera 9+, Chrome 2+ and Safari 4+
                 */
                protocol = "1";
            }
            else if (config.swf && isHostMethod(window, "ActiveXObject") && hasFlash()) {
                /*
                 * The Flash transport superseedes the NixTransport as the NixTransport has been blocked by MS
                 */
                protocol = "6";
            }
            else if (navigator.product === "Gecko" && "frameElement" in window && navigator.userAgent.indexOf('WebKit') == -1) {
                /*
                 * This is supported in Gecko (Firefox 1+)
                 */
                protocol = "5";
            }
            else if (config.remoteHelper) {
                /*
                 * This is supported in all browsers that retains the value of window.name when
                 * navigating from one domain to another, and where parent.frames[foo] can be used
                 * to get access to a frame from the same domain
                 */
                protocol = "2";
            }
            else {
                /*
                 * This is supported in all browsers where [window].location is writable for all
                 * The resize event will be used if resize is supported and the iframe is not put
                 * into a container, else polling will be used.
                 */
                protocol = "0";
            }
        }
    }
    config.protocol = protocol; // for conditional branching
    switch (protocol) {
        case "0":// 0 = HashTransport
            apply(config, {
                interval: 100,
                delay: 2000,
                useResize: true,
                useParent: false,
                usePolling: false
            }, true);
            if (config.isHost) {
                if (!config.local) {
                    // If no local is set then we need to find an image hosted on the current domain
                    var domain = location.protocol + "//" + location.host, images = document.body.getElementsByTagName("img"), image;
                    var i = images.length;
                    while (i--) {
                        image = images[i];
                        if (image.src.substring(0, domain.length) === domain) {
                            config.local = image.src;
                            break;
                        }
                    }
                    if (!config.local) {
                        // If no local was set, and we are unable to find a suitable file, then we resort to using the current window
                        config.local = window;
                    }
                }

                var parameters = {
                    xdm_c: config.channel,
                    xdm_p: 0
                };

                if (config.local === window) {
                    // We are using the current window to listen to
                    config.usePolling = true;
                    config.useParent = true;
                    config.local = location.protocol + "//" + location.host + location.pathname + location.search;
                    parameters.xdm_e = config.local;
                    parameters.xdm_pa = 1; // use parent
                }
                else {
                    parameters.xdm_e = resolveUrl(config.local);
                }

                if (config.container) {
                    config.useResize = false;
                    parameters.xdm_po = 1; // use polling
                }
                config.remote = appendQueryParameters(config.remote, parameters);
            }
            else {
                apply(config, {
                    channel: query.xdm_c,
                    remote: query.xdm_e,
                    useParent: !undef(query.xdm_pa),
                    usePolling: !undef(query.xdm_po),
                    useResize: config.useParent ? false : config.useResize
                });
            }
            stackEls = [new easyXDM.stack.HashTransport(config), new easyXDM.stack.ReliableBehavior({}), new easyXDM.stack.QueueBehavior({
                encode: true,
                maxLength: 4000 - config.remote.length
            }), new easyXDM.stack.VerifyBehavior({
                initiate: config.isHost
            })];
            break;
        case "1":
            stackEls = [new easyXDM.stack.PostMessageTransport(config)];
            break;
        case "2":
            if (config.isHost) {
                config.remoteHelper = resolveUrl(config.remoteHelper);
            }
            stackEls = [new easyXDM.stack.NameTransport(config), new easyXDM.stack.QueueBehavior(), new easyXDM.stack.VerifyBehavior({
                initiate: config.isHost
            })];
            break;
        case "3":
            stackEls = [new easyXDM.stack.NixTransport(config)];
            break;
        case "4":
            stackEls = [new easyXDM.stack.SameOriginTransport(config)];
            break;
        case "5":
            stackEls = [new easyXDM.stack.FrameElementTransport(config)];
            break;
        case "6":
            if (!flashVersion) {
                hasFlash();
            }
            stackEls = [new easyXDM.stack.FlashTransport(config)];
            break;
    }
    // this behavior is responsible for buffering outgoing messages, and for performing lazy initialization
    stackEls.push(new easyXDM.stack.QueueBehavior({
        lazy: config.lazy,
        remove: true
    }));
    return stackEls;
}

/**
 * Chains all the separate stack elements into a single usable stack.<br/>
 * If an element is missing a necessary method then it will have a pass-through method applied.
 * @param {Array} stackElements An array of stack elements to be linked.
 * @return {easyXDM.stack.StackElement} The last element in the chain.
 */
function chainStack(stackElements){
    var stackEl, defaults = {
        incoming: function(message, origin){
            this.up.incoming(message, origin);
        },
        outgoing: function(message, recipient){
            this.down.outgoing(message, recipient);
        },
        callback: function(success){
            this.up.callback(success);
        },
        init: function(){
            this.down.init();
        },
        destroy: function(){
            this.down.destroy();
        }
    };
    for (var i = 0, len = stackElements.length; i < len; i++) {
        stackEl = stackElements[i];
        apply(stackEl, defaults, true);
        if (i !== 0) {
            stackEl.down = stackElements[i - 1];
        }
        if (i !== len - 1) {
            stackEl.up = stackElements[i + 1];
        }
    }
    return stackEl;
}

/**
 * This will remove a stackelement from its stack while leaving the stack functional.
 * @param {Object} element The elment to remove from the stack.
 */
function removeFromStack(element){
    element.up.down = element.down;
    element.down.up = element.up;
    element.up = element.down = null;
}

/*
 * Export the main object and any other methods applicable
 */
/**
 * @class easyXDM
 * A javascript library providing cross-browser, cross-domain messaging/RPC.
 * @version 2.4.19.3
 * @singleton
 */
apply(easyXDM, {
    /**
     * The version of the library
     * @type {string}
     */
    version: "2.4.19.3",
    /**
     * This is a map containing all the query parameters passed to the document.
     * All the values has been decoded using decodeURIComponent.
     * @type {object}
     */
    query: query,
    /**
     * @private
     */
    stack: {},
    /**
     * Applies properties from the source object to the target object.<br/>
     * @param {object} target The target of the properties.
     * @param {object} source The source of the properties.
     * @param {boolean} noOverwrite Set to True to only set non-existing properties.
     */
    apply: apply,

    /**
     * A safe implementation of HTML5 JSON. Feature testing is used to make sure the implementation works.
     * @return {JSON} A valid JSON conforming object, or null if not found.
     */
    getJSONObject: getJSON,
    /**
     * This will add a function to the queue of functions to be run once the DOM reaches a ready state.
     * If functions are added after this event then they will be executed immediately.
     * @param {function} fn The function to add
     * @param {object} scope An optional scope for the function to be called with.
     */
    whenReady: whenReady,
    /**
     * Removes easyXDM variable from the global scope. It also returns control
     * of the easyXDM variable to whatever code used it before.
     *
     * @param {String} ns A string representation of an object that will hold
     *                    an instance of easyXDM.
     * @return An instance of easyXDM
     */
    noConflict: noConflict
});

/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global console, _FirebugCommandLine,  easyXDM, window, escape, unescape, isHostObject, undef, _trace, domIsReady, emptyFn, namespace */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, isHostObject, isHostMethod, un, on, createFrame, debug */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.DomHelper
 * Contains methods for dealing with the DOM
 * @singleton
 */
easyXDM.DomHelper = {
    /**
     * Provides a consistent interface for adding eventhandlers
     * @param {Object} target The target to add the event to
     * @param {String} type The name of the event
     * @param {Function} listener The listener
     */
    on: on,
    /**
     * Provides a consistent interface for removing eventhandlers
     * @param {Object} target The target to remove the event from
     * @param {String} type The name of the event
     * @param {Function} listener The listener
     */
    un: un,
    /**
     * Checks for the presence of the JSON object.
     * If it is not present it will use the supplied path to load the JSON2 library.
     * This should be called in the documents head right after the easyXDM script tag.
     * http://json.org/json2.js
     * @param {String} path A valid path to json2.js
     */
    requiresJSON: function(path){
        if (!isHostObject(window, "JSON")) {
            // we need to encode the < in order to avoid an illegal token error
            // when the script is inlined in a document.
            document.write('<' + 'script type="text/javascript" src="' + path + '"><' + '/script>');
        }
    }
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, debug */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

(function(){
    // The map containing the stored functions
    var _map = {};

    /**
     * @class easyXDM.Fn
     * This contains methods related to function handling, such as storing callbacks.
     * @singleton
     * @namespace easyXDM
     */
    easyXDM.Fn = {
        /**
         * Stores a function using the given name for reference
         * @param {String} name The name that the function should be referred by
         * @param {Function} fn The function to store
         * @namespace easyXDM.fn
         */
        set: function(name, fn){
            _map[name] = fn;
        },
        /**
         * Retrieves the function referred to by the given name
         * @param {String} name The name of the function to retrieve
         * @param {Boolean} del If the function should be deleted after retrieval
         * @return {Function} The stored function
         * @namespace easyXDM.fn
         */
        get: function(name, del){
            if (!_map.hasOwnProperty(name)) {
                return;
            }
            var fn = _map[name];

            if (del) {
                delete _map[name];
            }
            return fn;
        }
    };

}());
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, chainStack, prepareTransportStack, getLocation, debug */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.Socket
 * This class creates a transport channel between two domains that is usable for sending and receiving string-based messages.<br/>
 * The channel is reliable, supports queueing, and ensures that the message originates from the expected domain.<br/>
 * Internally different stacks will be used depending on the browsers features and the available parameters.
 * <h2>How to set up</h2>
 * Setting up the provider:
 * <pre><code>
 * var socket = new easyXDM.Socket({
 * &nbsp; local: "name.html",
 * &nbsp; onReady: function(){
 * &nbsp; &nbsp; &#47;&#47; you need to wait for the onReady callback before using the socket
 * &nbsp; &nbsp; socket.postMessage("foo-message");
 * &nbsp; },
 * &nbsp; onMessage: function(message, origin) {
 * &nbsp;&nbsp; alert("received " + message + " from " + origin);
 * &nbsp; }
 * });
 * </code></pre>
 * Setting up the consumer:
 * <pre><code>
 * var socket = new easyXDM.Socket({
 * &nbsp; remote: "http:&#47;&#47;remotedomain/page.html",
 * &nbsp; remoteHelper: "http:&#47;&#47;remotedomain/name.html",
 * &nbsp; onReady: function(){
 * &nbsp; &nbsp; &#47;&#47; you need to wait for the onReady callback before using the socket
 * &nbsp; &nbsp; socket.postMessage("foo-message");
 * &nbsp; },
 * &nbsp; onMessage: function(message, origin) {
 * &nbsp;&nbsp; alert("received " + message + " from " + origin);
 * &nbsp; }
 * });
 * </code></pre>
 * If you are unable to upload the <code>name.html</code> file to the consumers domain then remove the <code>remoteHelper</code> property
 * and easyXDM will fall back to using the HashTransport instead of the NameTransport when not able to use any of the primary transports.
 * @namespace easyXDM
 * @constructor
 * @cfg {String/Window} local The url to the local name.html document, a local static file, or a reference to the local window.
 * @cfg {Boolean} lazy (Consumer only) Set this to true if you want easyXDM to defer creating the transport until really needed.
 * @cfg {String} remote (Consumer only) The url to the providers document.
 * @cfg {String} remoteHelper (Consumer only) The url to the remote name.html file. This is to support NameTransport as a fallback. Optional.
 * @cfg {Number} delay The number of milliseconds easyXDM should try to get a reference to the local window.  Optional, defaults to 2000.
 * @cfg {Number} interval The interval used when polling for messages. Optional, defaults to 300.
 * @cfg {String} channel (Consumer only) The name of the channel to use. Can be used to set consistent iframe names. Must be unique. Optional.
 * @cfg {Function} onMessage The method that should handle incoming messages.<br/> This method should accept two arguments, the message as a string, and the origin as a string. Optional.
 * @cfg {Function} onReady A method that should be called when the transport is ready. Optional.
 * @cfg {DOMElement|String} container (Consumer only) The element, or the id of the element that the primary iframe should be inserted into. If not set then the iframe will be positioned off-screen. Optional.
 * @cfg {Array/String} acl (Provider only) Here you can specify which '[protocol]://[domain]' patterns that should be allowed to act as the consumer towards this provider.<br/>
 * This can contain the wildcards ? and *.  Examples are 'http://example.com', '*.foo.com' and '*dom?.com'. If you want to use reqular expressions then you pattern needs to start with ^ and end with $.
 * If none of the patterns match an Error will be thrown.
 * @cfg {Object} props (Consumer only) Additional properties that should be applied to the iframe. This can also contain nested objects e.g: <code>{style:{width:"100px", height:"100px"}}</code>.
 * Properties such as 'name' and 'src' will be overrided. Optional.
 */
easyXDM.Socket = function(config){

    // create the stack
    var stack = chainStack(prepareTransportStack(config).concat([{
        incoming: function(message, origin){
            config.onMessage(message, origin);
        },
        callback: function(success){
            if (config.onReady) {
                config.onReady(success);
            }
        }
    }])), recipient = getLocation(config.remote);

    // set the origin
    this.origin = getLocation(config.remote);

    /**
     * Initiates the destruction of the stack.
     */
    this.destroy = function(){
        stack.destroy();
    };

    /**
     * Posts a message to the remote end of the channel
     * @param {String} message The message to send
     */
    this.postMessage = function(message){
        stack.outgoing(message, recipient);
    };

    stack.init();
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, undef,, chainStack, prepareTransportStack, debug, getLocation */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.Rpc
 * Creates a proxy object that can be used to call methods implemented on the remote end of the channel, and also to provide the implementation
 * of methods to be called from the remote end.<br/>
 * The instantiated object will have methods matching those specified in <code>config.remote</code>.<br/>
 * This requires the JSON object present in the document, either natively, using json.org's json2 or as a wrapper around library spesific methods.
 * <h2>How to set up</h2>
 * <pre><code>
 * var rpc = new easyXDM.Rpc({
 * &nbsp; &#47;&#47; this configuration is equal to that used by the Socket.
 * &nbsp; remote: "http:&#47;&#47;remotedomain/...",
 * &nbsp; onReady: function(){
 * &nbsp; &nbsp; &#47;&#47; you need to wait for the onReady callback before using the proxy
 * &nbsp; &nbsp; rpc.foo(...
 * &nbsp; }
 * },{
 * &nbsp; local: {..},
 * &nbsp; remote: {..}
 * });
 * </code></pre>
 *
 * <h2>Exposing functions (procedures)</h2>
 * <pre><code>
 * var rpc = new easyXDM.Rpc({
 * &nbsp; ...
 * },{
 * &nbsp; local: {
 * &nbsp; &nbsp; nameOfMethod: {
 * &nbsp; &nbsp; &nbsp; method: function(arg1, arg2, success, error){
 * &nbsp; &nbsp; &nbsp; &nbsp; ...
 * &nbsp; &nbsp; &nbsp; }
 * &nbsp; &nbsp; },
 * &nbsp; &nbsp; &#47;&#47; with shorthand notation
 * &nbsp; &nbsp; nameOfAnotherMethod:  function(arg1, arg2, success, error){
 * &nbsp; &nbsp; }
 * &nbsp; },
 * &nbsp; remote: {...}
 * });
 * </code></pre>

 * The function referenced by  [method] will receive the passed arguments followed by the callback functions <code>success</code> and <code>error</code>.<br/>
 * To send a successfull result back you can use
 *     <pre><code>
 *     return foo;
 *     </pre></code>
 * or
 *     <pre><code>
 *     success(foo);
 *     </pre></code>
 *  To return an error you can use
 *     <pre><code>
 *     throw new Error("foo error");
 *     </code></pre>
 * or
 *     <pre><code>
 *     error("foo error");
 *     </code></pre>
 *
 * <h2>Defining remotely exposed methods (procedures/notifications)</h2>
 * The definition of the remote end is quite similar:
 * <pre><code>
 * var rpc = new easyXDM.Rpc({
 * &nbsp; ...
 * },{
 * &nbsp; local: {...},
 * &nbsp; remote: {
 * &nbsp; &nbsp; nameOfMethod: {}
 * &nbsp; }
 * });
 * </code></pre>
 * To call a remote method use
 * <pre><code>
 * rpc.nameOfMethod("arg1", "arg2", function(value) {
 * &nbsp; alert("success: " + value);
 * }, function(message) {
 * &nbsp; alert("error: " + message + );
 * });
 * </code></pre>
 * Both the <code>success</code> and <code>errror</code> callbacks are optional.<br/>
 * When called with no callback a JSON-RPC 2.0 notification will be executed.
 * Be aware that you will not be notified of any errors with this method.
 * <br/>
 * <h2>Specifying a custom serializer</h2>
 * If you do not want to use the JSON2 library for non-native JSON support, but instead capabilities provided by some other library
 * then you can specify a custom serializer using <code>serializer: foo</code>
 * <pre><code>
 * var rpc = new easyXDM.Rpc({
 * &nbsp; ...
 * },{
 * &nbsp; local: {...},
 * &nbsp; remote: {...},
 * &nbsp; serializer : {
 * &nbsp; &nbsp; parse: function(string){ ... },
 * &nbsp; &nbsp; stringify: function(object) {...}
 * &nbsp; }
 * });
 * </code></pre>
 * If <code>serializer</code> is set then the class will not attempt to use the native implementation.
 * @namespace easyXDM
 * @constructor
 * @param {Object} config The underlying transports configuration. See easyXDM.Socket for available parameters.
 * @param {Object} jsonRpcConfig The description of the interface to implement.
 */
easyXDM.Rpc = function(config, jsonRpcConfig){

    // expand shorthand notation
    if (jsonRpcConfig.local) {
        for (var method in jsonRpcConfig.local) {
            if (jsonRpcConfig.local.hasOwnProperty(method)) {
                var member = jsonRpcConfig.local[method];
                if (typeof member === "function") {
                    jsonRpcConfig.local[method] = {
                        method: member
                    };
                }
            }
        }
    }

    // create the stack
    var stack = chainStack(prepareTransportStack(config).concat([new easyXDM.stack.RpcBehavior(this, jsonRpcConfig), {
        callback: function(success){
            if (config.onReady) {
                config.onReady(success);
            }
        }
    }]));

    // set the origin
    this.origin = getLocation(config.remote);
    this.channel = config.channel;

    /**
     * Initiates the destruction of the stack.
     */
    this.destroy = function(){
        stack.destroy();
    };

    stack.init();
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, getLocation, appendQueryParameters, createFrame, debug, un, on, apply, whenReady, getParentObject, IFRAME_PREFIX*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.SameOriginTransport
 * SameOriginTransport is a transport class that can be used when both domains have the same origin.<br/>
 * This can be useful for testing and for when the main application supports both internal and external sources.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String} remote The remote document to communicate with.
 */
easyXDM.stack.SameOriginTransport = function(config){
    var pub, frame, send, targetOrigin;

    return (pub = {
        outgoing: function(message, domain, fn){
            send(message);
            if (fn) {
                fn();
            }
        },
        destroy: function(){
            if (frame) {
                frame.parentNode.removeChild(frame);
                frame = null;
            }
        },
        onDOMReady: function(){
            targetOrigin = getLocation(config.remote);

            if (config.isHost) {
                // set up the iframe
                apply(config.props, {
                    src: appendQueryParameters(config.remote, {
                        xdm_e: location.protocol + "//" + location.host + location.pathname,
                        xdm_c: config.channel,
                        xdm_p: 4 // 4 = SameOriginTransport
                    }),
                    name: IFRAME_PREFIX + config.channel + "_provider"
                });
                frame = createFrame(config);
                easyXDM.Fn.set(config.channel, function(sendFn){
                    send = sendFn;
                    setTimeout(function(){
                        pub.up.callback(true);
                    }, 0);
                    return function(msg){
                        pub.up.incoming(msg, targetOrigin);
                    };
                });
            }
            else {
                send = getParentObject().Fn.get(config.channel, true)(function(msg){
                    pub.up.incoming(msg, targetOrigin);
                });
                setTimeout(function(){
                    pub.up.callback(true);
                }, 0);
            }
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global global, easyXDM, window, getLocation, appendQueryParameters, createFrame, debug, apply, whenReady, IFRAME_PREFIX, namespace, resolveUrl, getDomainName, HAS_FLASH_THROTTLED_BUG, getPort, query*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.FlashTransport
 * FlashTransport is a transport class that uses an SWF with LocalConnection to pass messages back and forth.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String} remote The remote domain to communicate with.
 * @cfg {String} secret the pre-shared secret used to secure the communication.
 * @cfg {String} swf The path to the swf file
 * @cfg {Boolean} swfNoThrottle Set this to true if you want to take steps to avoid beeing throttled when hidden.
 * @cfg {String || DOMElement} swfContainer Set this if you want to control where the swf is placed
 */
easyXDM.stack.FlashTransport = function(config){
    var pub, // the public interface
 frame, send, targetOrigin, swf, swfContainer;

    function onMessage(message, origin){
        setTimeout(function(){
            pub.up.incoming(message, targetOrigin);
        }, 0);
    }

    /**
     * This method adds the SWF to the DOM and prepares the initialization of the channel
     */
    function addSwf(domain){
        // the differentiating query argument is needed in Flash9 to avoid a caching issue where LocalConnection would throw an error.
        var url = config.swf + "?host=" + config.isHost;
        var id = "easyXDM_swf_" + Math.floor(Math.random() * 10000);

        // prepare the init function that will fire once the swf is ready
        easyXDM.Fn.set("flash_loaded" + domain.replace(/[\-.]/g, "_"), function(){
            easyXDM.stack.FlashTransport[domain].swf = swf = swfContainer.firstChild;
            var queue = easyXDM.stack.FlashTransport[domain].queue;
            for (var i = 0; i < queue.length; i++) {
                queue[i]();
            }
            queue.length = 0;
        });

        if (config.swfContainer) {
            swfContainer = (typeof config.swfContainer == "string") ? document.getElementById(config.swfContainer) : config.swfContainer;
        }
        else {
            // create the container that will hold the swf
            swfContainer = document.createElement('div');

            // http://bugs.adobe.com/jira/browse/FP-4796
            // http://tech.groups.yahoo.com/group/flexcoders/message/162365
            // https://groups.google.com/forum/#!topic/easyxdm/mJZJhWagoLc
            apply(swfContainer.style, HAS_FLASH_THROTTLED_BUG && config.swfNoThrottle ? {
                height: "20px",
                width: "20px",
                position: "fixed",
                right: 0,
                top: 0
            } : {
                height: "1px",
                width: "1px",
                position: "absolute",
                overflow: "hidden",
                right: 0,
                top: 0
            });
            document.body.appendChild(swfContainer);
        }

        // create the object/embed
        var flashVars = "callback=flash_loaded" + encodeURIComponent(domain.replace(/[\-.]/g, "_"))
            + "&proto=" + global.location.protocol
            + "&domain=" + encodeURIComponent(getDomainName(global.location.href))
            + "&port=" + encodeURIComponent(getPort(global.location.href))
            + "&ns=" + encodeURIComponent(namespace);
        swfContainer.innerHTML = "<object height='20' width='20' type='application/x-shockwave-flash' id='" + id + "' data='" + url + "'>" +
        "<param name='allowScriptAccess' value='always'></param>" +
        "<param name='wmode' value='transparent'>" +
        "<param name='movie' value='" +
        url +
        "'></param>" +
        "<param name='flashvars' value='" +
        flashVars +
        "'></param>" +
        "<embed type='application/x-shockwave-flash' FlashVars='" +
        flashVars +
        "' allowScriptAccess='always' wmode='transparent' src='" +
        url +
        "' height='1' width='1'></embed>" +
        "</object>";
    }

    return (pub = {
        outgoing: function(message, domain, fn){
            swf.postMessage(config.channel, message.toString());
            if (fn) {
                fn();
            }
        },
        destroy: function(){
            try {
                swf.destroyChannel(config.channel);
            }
            catch (e) {
            }
            swf = null;
            if (frame) {
                frame.parentNode.removeChild(frame);
                frame = null;
            }
        },
        onDOMReady: function(){

            targetOrigin = config.remote;

            // Prepare the code that will be run after the swf has been intialized
            easyXDM.Fn.set("flash_" + config.channel + "_init", function(){
                setTimeout(function(){
                    pub.up.callback(true);
                });
            });

            // set up the omMessage handler
            easyXDM.Fn.set("flash_" + config.channel + "_onMessage", onMessage);

            config.swf = resolveUrl(config.swf); // reports have been made of requests gone rogue when using relative paths
            var swfdomain = getDomainName(config.swf);
            var fn = function(){
                // set init to true in case the fn was called was invoked from a separate instance
                easyXDM.stack.FlashTransport[swfdomain].init = true;
                swf = easyXDM.stack.FlashTransport[swfdomain].swf;
                // create the channel
                swf.createChannel(config.channel, config.secret, getLocation(config.remote), config.isHost);

                if (config.isHost) {
                    // if Flash is going to be throttled and we want to avoid this
                    if (HAS_FLASH_THROTTLED_BUG && config.swfNoThrottle) {
                        apply(config.props, {
                            position: "fixed",
                            right: 0,
                            top: 0,
                            height: "20px",
                            width: "20px"
                        });
                    }
                    // set up the iframe
                    apply(config.props, {
                        src: appendQueryParameters(config.remote, {
                            xdm_e: getLocation(location.href),
                            xdm_c: config.channel,
                            xdm_p: 6, // 6 = FlashTransport
                            xdm_s: config.secret
                        }),
                        name: IFRAME_PREFIX + config.channel + "_provider"
                    });
                    frame = createFrame(config);
                }
            };

            if (easyXDM.stack.FlashTransport[swfdomain] && easyXDM.stack.FlashTransport[swfdomain].init) {
                // if the swf is in place and we are the consumer
                fn();
            }
            else {
                // if the swf does not yet exist
                if (!easyXDM.stack.FlashTransport[swfdomain]) {
                    // add the queue to hold the init fn's
                    easyXDM.stack.FlashTransport[swfdomain] = {
                        queue: [fn]
                    };
                    addSwf(swfdomain);
                }
                else {
                    easyXDM.stack.FlashTransport[swfdomain].queue.push(fn);
                }
            }
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, getLocation, appendQueryParameters, createFrame, debug, un, on, apply, whenReady, IFRAME_PREFIX*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.PostMessageTransport
 * PostMessageTransport is a transport class that uses HTML5 postMessage for communication.<br/>
 * <a href="http://msdn.microsoft.com/en-us/library/ms644944(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms644944(VS.85).aspx</a><br/>
 * <a href="https://developer.mozilla.org/en/DOM/window.postMessage">https://developer.mozilla.org/en/DOM/window.postMessage</a>
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String} remote The remote domain to communicate with.
 */
easyXDM.stack.PostMessageTransport = function(config){
    var pub, // the public interface
 frame, // the remote frame, if any
 callerWindow, // the window that we will call with
 targetOrigin; // the domain to communicate with
    /**
     * Resolves the origin from the event object
     * @private
     * @param {Object} event The messageevent
     * @return {String} The scheme, host and port of the origin
     */
    function _getOrigin(event){
        if (event.origin) {
            // This is the HTML5 property
            return getLocation(event.origin);
        }
        if (event.uri) {
            // From earlier implementations
            return getLocation(event.uri);
        }
        if (event.domain) {
            // This is the last option and will fail if the
            // origin is not using the same schema as we are
            return location.protocol + "//" + event.domain;
        }
        throw "Unable to retrieve the origin of the event";
    }

    /**
     * This is the main implementation for the onMessage event.<br/>
     * It checks the validity of the origin and passes the message on if appropriate.
     * @private
     * @param {Object} event The messageevent
     */
    function _window_onMessage(event){
        var origin = _getOrigin(event);
        if (origin == targetOrigin && event.data.substring(0, config.channel.length + 1) == config.channel + " ") {
            pub.up.incoming(event.data.substring(config.channel.length + 1), origin);
        }
    }

    return (pub = {
        outgoing: function(message, domain, fn){
            callerWindow.postMessage(config.channel + " " + message, domain || targetOrigin);
            if (fn) {
                fn();
            }
        },
        destroy: function(){
            un(window, "message", _window_onMessage);
            if (frame) {
                callerWindow = null;
                frame.parentNode.removeChild(frame);
                frame = null;
            }
        },
        onDOMReady: function(){
            targetOrigin = getLocation(config.remote);
            if (config.isHost) {
                // add the event handler for listening
                var waitForReady = function(event){
                    if (event.data == config.channel + "-ready") {
                        // replace the eventlistener
                        callerWindow = ("postMessage" in frame.contentWindow) ? frame.contentWindow : frame.contentWindow.document;
                        un(window, "message", waitForReady);
                        on(window, "message", _window_onMessage);
                        setTimeout(function(){
                            pub.up.callback(true);
                        }, 0);
                    }
                };
                on(window, "message", waitForReady);

                // set up the iframe
                apply(config.props, {
                    src: appendQueryParameters(config.remote, {
                        xdm_e: getLocation(location.href),
                        xdm_c: config.channel,
                        xdm_p: 1 // 1 = PostMessage
                    }),
                    name: IFRAME_PREFIX + config.channel + "_provider"
                });
                frame = createFrame(config);
            }
            else {
                // add the event handler for listening
                on(window, "message", _window_onMessage);
                callerWindow = ("postMessage" in window.parent) ? window.parent : window.parent.document;
                callerWindow.postMessage(config.channel + "-ready", targetOrigin);

                setTimeout(function(){
                    pub.up.callback(true);
                }, 0);
            }
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, getLocation, appendQueryParameters, createFrame, debug, apply, query, whenReady, IFRAME_PREFIX*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.FrameElementTransport
 * FrameElementTransport is a transport class that can be used with Gecko-browser as these allow passing variables using the frameElement property.<br/>
 * Security is maintained as Gecho uses Lexical Authorization to determine under which scope a function is running.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String} remote The remote document to communicate with.
 */
easyXDM.stack.FrameElementTransport = function(config){
    var pub, frame, send, targetOrigin;

    return (pub = {
        outgoing: function(message, domain, fn){
            send.call(this, message);
            if (fn) {
                fn();
            }
        },
        destroy: function(){
            if (frame) {
                frame.parentNode.removeChild(frame);
                frame = null;
            }
        },
        onDOMReady: function(){
            targetOrigin = getLocation(config.remote);

            if (config.isHost) {
                // set up the iframe
                apply(config.props, {
                    src: appendQueryParameters(config.remote, {
                        xdm_e: getLocation(location.href),
                        xdm_c: config.channel,
                        xdm_p: 5 // 5 = FrameElementTransport
                    }),
                    name: IFRAME_PREFIX + config.channel + "_provider"
                });
                frame = createFrame(config);
                frame.fn = function(sendFn){
                    delete frame.fn;
                    send = sendFn;
                    setTimeout(function(){
                        pub.up.callback(true);
                    }, 0);
                    // remove the function so that it cannot be used to overwrite the send function later on
                    return function(msg){
                        pub.up.incoming(msg, targetOrigin);
                    };
                };
            }
            else {
                // This is to mitigate origin-spoofing
                if (document.referrer && getLocation(document.referrer) != query.xdm_e) {
                    window.top.location = query.xdm_e;
                }
                send = window.frameElement.fn(function(msg){
                    pub.up.incoming(msg, targetOrigin);
                });
                pub.up.callback(true);
            }
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, undef, getLocation, appendQueryParameters, resolveUrl, createFrame, debug, un, apply, whenReady, IFRAME_PREFIX*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.NameTransport
 * NameTransport uses the window.name property to relay data.
 * The <code>local</code> parameter needs to be set on both the consumer and provider,<br/>
 * and the <code>remoteHelper</code> parameter needs to be set on the consumer.
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String} remoteHelper The url to the remote instance of hash.html - this is only needed for the host.
 * @namespace easyXDM.stack
 */
easyXDM.stack.NameTransport = function(config){

    var pub; // the public interface
    var isHost, callerWindow, remoteWindow, readyCount, callback, remoteOrigin, remoteUrl;

    function _sendMessage(message){
        var url = config.remoteHelper + (isHost ? "#_3" : "#_2") + config.channel;
        callerWindow.contentWindow.sendMessage(message, url);
    }

    function _onReady(){
        if (isHost) {
            if (++readyCount === 2 || !isHost) {
                pub.up.callback(true);
            }
        }
        else {
            _sendMessage("ready");
            pub.up.callback(true);
        }
    }

    function _onMessage(message){
        pub.up.incoming(message, remoteOrigin);
    }

    function _onLoad(){
        if (callback) {
            setTimeout(function(){
                callback(true);
            }, 0);
        }
    }

    return (pub = {
        outgoing: function(message, domain, fn){
            callback = fn;
            _sendMessage(message);
        },
        destroy: function(){
            callerWindow.parentNode.removeChild(callerWindow);
            callerWindow = null;
            if (isHost) {
                remoteWindow.parentNode.removeChild(remoteWindow);
                remoteWindow = null;
            }
        },
        onDOMReady: function(){
            isHost = config.isHost;
            readyCount = 0;
            remoteOrigin = getLocation(config.remote);
            config.local = resolveUrl(config.local);

            if (isHost) {
                // Register the callback
                easyXDM.Fn.set(config.channel, function(message){
                    if (isHost && message === "ready") {
                        // Replace the handler
                        easyXDM.Fn.set(config.channel, _onMessage);
                        _onReady();
                    }
                });

                // Set up the frame that points to the remote instance
                remoteUrl = appendQueryParameters(config.remote, {
                    xdm_e: config.local,
                    xdm_c: config.channel,
                    xdm_p: 2
                });
                apply(config.props, {
                    src: remoteUrl + '#' + config.channel,
                    name: IFRAME_PREFIX + config.channel + "_provider"
                });
                remoteWindow = createFrame(config);
            }
            else {
                config.remoteHelper = config.remote;
                easyXDM.Fn.set(config.channel, _onMessage);
            }

            // Set up the iframe that will be used for the transport
            var onLoad = function(){
                // Remove the handler
                var w = callerWindow || this;
                un(w, "load", onLoad);
                easyXDM.Fn.set(config.channel + "_load", _onLoad);
                (function test(){
                    if (typeof w.contentWindow.sendMessage == "function") {
                        _onReady();
                    }
                    else {
                        setTimeout(test, 50);
                    }
                }());
            };

            callerWindow = createFrame({
                props: {
                    src: config.local + "#_4" + config.channel
                },
                onLoad: onLoad
            });
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, getLocation, createFrame, debug, un, on, apply, whenReady, IFRAME_PREFIX*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.HashTransport
 * HashTransport is a transport class that uses the IFrame URL Technique for communication.<br/>
 * <a href="http://msdn.microsoft.com/en-us/library/bb735305.aspx">http://msdn.microsoft.com/en-us/library/bb735305.aspx</a><br/>
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The transports configuration.
 * @cfg {String/Window} local The url to the local file used for proxying messages, or the local window.
 * @cfg {Number} delay The number of milliseconds easyXDM should try to get a reference to the local window.
 * @cfg {Number} interval The interval used when polling for messages.
 */
easyXDM.stack.HashTransport = function(config){
    var pub;
    var me = this, isHost, _timer, pollInterval, _lastMsg, _msgNr, _listenerWindow, _callerWindow;
    var useParent, _remoteOrigin;

    function _sendMessage(message){
        if (!_callerWindow) {
            return;
        }
        var url = config.remote + "#" + (_msgNr++) + "_" + message;
        ((isHost || !useParent) ? _callerWindow.contentWindow : _callerWindow).location = url;
    }

    function _handleHash(hash){
        _lastMsg = hash;
        pub.up.incoming(_lastMsg.substring(_lastMsg.indexOf("_") + 1), _remoteOrigin);
    }

    /**
     * Checks location.hash for a new message and relays this to the receiver.
     * @private
     */
    function _pollHash(){
        if (!_listenerWindow) {
            return;
        }
        var href = _listenerWindow.location.href, hash = "", indexOf = href.indexOf("#");
        if (indexOf != -1) {
            hash = href.substring(indexOf);
        }
        if (hash && hash != _lastMsg) {
            _handleHash(hash);
        }
    }

    function _attachListeners(){
        _timer = setInterval(_pollHash, pollInterval);
    }

    return (pub = {
        outgoing: function(message, domain){
            _sendMessage(message);
        },
        destroy: function(){
            window.clearInterval(_timer);
            if (isHost || !useParent) {
                _callerWindow.parentNode.removeChild(_callerWindow);
            }
            _callerWindow = null;
        },
        onDOMReady: function(){
            isHost = config.isHost;
            pollInterval = config.interval;
            _lastMsg = "#" + config.channel;
            _msgNr = 0;
            useParent = config.useParent;
            _remoteOrigin = getLocation(config.remote);
            if (isHost) {
                apply(config.props, {
                    src: config.remote,
                    name: IFRAME_PREFIX + config.channel + "_provider"
                });
                if (useParent) {
                    config.onLoad = function(){
                        _listenerWindow = window;
                        _attachListeners();
                        pub.up.callback(true);
                    };
                }
                else {
                    var tries = 0, max = config.delay / 50;
                    (function getRef(){
                        if (++tries > max) {
                            throw new Error("Unable to reference listenerwindow");
                        }
                        try {
                            _listenerWindow = _callerWindow.contentWindow.frames[IFRAME_PREFIX + config.channel + "_consumer"];
                        }
                        catch (ex) {
                        }
                        if (_listenerWindow) {
                            _attachListeners();
                            pub.up.callback(true);
                        }
                        else {
                            setTimeout(getRef, 50);
                        }
                    }());
                }
                _callerWindow = createFrame(config);
            }
            else {
                _listenerWindow = window;
                _attachListeners();
                if (useParent) {
                    _callerWindow = parent;
                    pub.up.callback(true);
                }
                else {
                    apply(config, {
                        props: {
                            src: config.remote + "#" + config.channel + new Date(),
                            name: IFRAME_PREFIX + config.channel + "_consumer"
                        },
                        onLoad: function(){
                            pub.up.callback(true);
                        }
                    });
                    _callerWindow = createFrame(config);
                }
            }
        },
        init: function(){
            whenReady(pub.onDOMReady, pub);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, debug */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.ReliableBehavior
 * This is a behavior that tries to make the underlying transport reliable by using acknowledgements.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The behaviors configuration.
 */
easyXDM.stack.ReliableBehavior = function(config){
    var pub, // the public interface
 callback; // the callback to execute when we have a confirmed success/failure
    var idOut = 0, idIn = 0, currentMessage = "";

    return (pub = {
        incoming: function(message, origin){
            var indexOf = message.indexOf("_"), ack = message.substring(0, indexOf).split(",");
            message = message.substring(indexOf + 1);

            if (ack[0] == idOut) {
                currentMessage = "";
                if (callback) {
                    callback(true);
                }
            }
            if (message.length > 0) {
                pub.down.outgoing(ack[1] + "," + idOut + "_" + currentMessage, origin);
                if (idIn != ack[1]) {
                    idIn = ack[1];
                    pub.up.incoming(message, origin);
                }
            }

        },
        outgoing: function(message, origin, fn){
            currentMessage = message;
            callback = fn;
            pub.down.outgoing(idIn + "," + (++idOut) + "_" + message, origin);
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, debug, undef, removeFromStack*/
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.QueueBehavior
 * This is a behavior that enables queueing of messages. <br/>
 * It will buffer incoming messages and dispach these as fast as the underlying transport allows.
 * This will also fragment/defragment messages so that the outgoing message is never bigger than the
 * set length.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The behaviors configuration. Optional.
 * @cfg {Number} maxLength The maximum length of each outgoing message. Set this to enable fragmentation.
 */
easyXDM.stack.QueueBehavior = function(config){
    var pub, queue = [], waiting = true, incoming = "", destroying, maxLength = 0, lazy = false, doFragment = false;

    function dispatch(){
        if (config.remove && queue.length === 0) {
            removeFromStack(pub);
            return;
        }
        if (waiting || queue.length === 0 || destroying) {
            return;
        }
        waiting = true;
        var message = queue.shift();

        pub.down.outgoing(message.data, message.origin, function(success){
            waiting = false;
            if (message.callback) {
                setTimeout(function(){
                    message.callback(success);
                }, 0);
            }
            dispatch();
        });
    }
    return (pub = {
        init: function(){
            if (undef(config)) {
                config = {};
            }
            if (config.maxLength) {
                maxLength = config.maxLength;
                doFragment = true;
            }
            if (config.lazy) {
                lazy = true;
            }
            else {
                pub.down.init();
            }
        },
        callback: function(success){
            waiting = false;
            var up = pub.up; // in case dispatch calls removeFromStack
            dispatch();
            up.callback(success);
        },
        incoming: function(message, origin){
            if (doFragment) {
                var indexOf = message.indexOf("_"), seq = parseInt(message.substring(0, indexOf), 10);
                incoming += message.substring(indexOf + 1);
                if (seq === 0) {
                    if (config.encode) {
                        incoming = decodeURIComponent(incoming);
                    }
                    pub.up.incoming(incoming, origin);
                    incoming = "";
                }
            }
            else {
                pub.up.incoming(message, origin);
            }
        },
        outgoing: function(message, origin, fn){
            if (config.encode) {
                message = encodeURIComponent(message);
            }
            var fragments = [], fragment;
            if (doFragment) {
                // fragment into chunks
                while (message.length !== 0) {
                    fragment = message.substring(0, maxLength);
                    message = message.substring(fragment.length);
                    fragments.push(fragment);
                }
                // enqueue the chunks
                while ((fragment = fragments.shift())) {
                    queue.push({
                        data: fragments.length + "_" + fragment,
                        origin: origin,
                        callback: fragments.length === 0 ? fn : null
                    });
                }
            }
            else {
                queue.push({
                    data: message,
                    origin: origin,
                    callback: fn
                });
            }
            if (lazy) {
                pub.down.init();
            }
            else {
                dispatch();
            }
        },
        destroy: function(){
            destroying = true;
            pub.down.destroy();
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, undef, debug */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.VerifyBehavior
 * This behavior will verify that communication with the remote end is possible, and will also sign all outgoing,
 * and verify all incoming messages. This removes the risk of someone hijacking the iframe to send malicious messages.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} config The behaviors configuration.
 * @cfg {Boolean} initiate If the verification should be initiated from this end.
 */
easyXDM.stack.VerifyBehavior = function(config){
    var pub, mySecret, theirSecret, verified = false;

    function startVerification(){
        mySecret = Math.random().toString(16).substring(2);
        pub.down.outgoing(mySecret);
    }

    return (pub = {
        incoming: function(message, origin){
            var indexOf = message.indexOf("_");
            if (indexOf === -1) {
                if (message === mySecret) {
                    pub.up.callback(true);
                }
                else if (!theirSecret) {
                    theirSecret = message;
                    if (!config.initiate) {
                        startVerification();
                    }
                    pub.down.outgoing(message);
                }
            }
            else {
                if (message.substring(0, indexOf) === theirSecret) {
                    pub.up.incoming(message.substring(indexOf + 1), origin);
                }
            }
        },
        outgoing: function(message, origin, fn){
            pub.down.outgoing(mySecret + "_" + message, origin, fn);
        },
        callback: function(success){
            if (config.initiate) {
                startVerification();
            }
        }
    });
};
/*jslint evil: true, browser: true, immed: true, passfail: true, undef: true, newcap: true*/
/*global easyXDM, window, escape, unescape, undef, getJSON, debug, emptyFn, isArray */
//
// easyXDM
// http://easyxdm.net/
// Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

/**
 * @class easyXDM.stack.RpcBehavior
 * This uses JSON-RPC 2.0 to expose local methods and to invoke remote methods and have responses returned over the the string based transport stack.<br/>
 * Exposed methods can return values synchronous, asyncronous, or bet set up to not return anything.
 * @namespace easyXDM.stack
 * @constructor
 * @param {Object} proxy The object to apply the methods to.
 * @param {Object} config The definition of the local and remote interface to implement.
 * @cfg {Object} local The local interface to expose.
 * @cfg {Object} remote The remote methods to expose through the proxy.
 * @cfg {Object} serializer The serializer to use for serializing and deserializing the JSON. Should be compatible with the HTML5 JSON object. Optional, will default to JSON.
 */
easyXDM.stack.RpcBehavior = function(proxy, config){
    var pub, serializer = config.serializer || getJSON();
    var _callbackCounter = 0, _callbacks = {};

    /**
     * Serializes and sends the message
     * @private
     * @param {Object} data The JSON-RPC message to be sent. The jsonrpc property will be added.
     */
    function _send(data){
        data.jsonrpc = "2.0";
        pub.down.outgoing(serializer.stringify(data));
    }

    /**
     * Creates a method that implements the given definition
     * @private
     * @param {Object} The method configuration
     * @param {String} method The name of the method
     * @return {Function} A stub capable of proxying the requested method call
     */
    function _createMethod(definition, method){
        var slice = Array.prototype.slice;

        return function(){
            var l = arguments.length, callback, message = {
                method: method
            };

            if (l > 0 && typeof arguments[l - 1] === "function") {
                //with callback, procedure
                if (l > 1 && typeof arguments[l - 2] === "function") {
                    // two callbacks, success and error
                    callback = {
                        success: arguments[l - 2],
                        error: arguments[l - 1]
                    };
                    message.params = slice.call(arguments, 0, l - 2);
                }
                else {
                    // single callback, success
                    callback = {
                        success: arguments[l - 1]
                    };
                    message.params = slice.call(arguments, 0, l - 1);
                }
                _callbacks["" + (++_callbackCounter)] = callback;
                message.id = _callbackCounter;
            }
            else {
                // no callbacks, a notification
                message.params = slice.call(arguments, 0);
            }
            if (definition.namedParams && message.params.length === 1) {
                message.params = message.params[0];
            }
            // Send the method request
            _send(message);
        };
    }

    /**
     * Executes the exposed method
     * @private
     * @param {String} method The name of the method
     * @param {Number} id The callback id to use
     * @param {Function} method The exposed implementation
     * @param {Array} params The parameters supplied by the remote end
     */
    function _executeMethod(method, id, fn, params){
        if (!fn) {
            if (id) {
                _send({
                    id: id,
                    error: {
                        code: -32601,
                        message: "Procedure not found."
                    }
                });
            }
            return;
        }

        var success, error;
        if (id) {
            success = function(result){
                success = emptyFn;
                _send({
                    id: id,
                    result: result
                });
            };
            error = function(message, data){
                error = emptyFn;
                var msg = {
                    id: id,
                    error: {
                        code: -32099,
                        message: message
                    }
                };
                if (data) {
                    msg.error.data = data;
                }
                _send(msg);
            };
        }
        else {
            success = error = emptyFn;
        }
        // Call local method
        if (!isArray(params)) {
            params = [params];
        }
        try {
            var result = fn.method.apply(fn.scope, params.concat([success, error]));
            if (!undef(result)) {
                success(result);
            }
        }
        catch (ex1) {
            error(ex1.message);
        }
    }

    return (pub = {
        incoming: function(message, origin){
            var data = serializer.parse(message);
            if (data.method) {
                // A method call from the remote end
                if (config.handle) {
                    config.handle(data, _send);
                }
                else {
                    _executeMethod(data.method, data.id, config.local[data.method], data.params);
                }
            }
            else {
                // A method response from the other end
                var callback = _callbacks[data.id];
                if (data.error) {
                    if (callback.error) {
                        callback.error(data.error);
                    }
                }
                else if (callback.success) {
                    callback.success(data.result);
                }
                delete _callbacks[data.id];
            }
        },
        init: function(){
            if (config.remote) {
                // Implement the remote sides exposed methods
                for (var method in config.remote) {
                    if (config.remote.hasOwnProperty(method)) {
                        proxy[method] = _createMethod(config.remote[method], method);
                    }
                }
            }
            pub.down.init();
        },
        destroy: function(){
            for (var method in config.remote) {
                if (config.remote.hasOwnProperty(method) && proxy.hasOwnProperty(method)) {
                    delete proxy[method];
                }
            }
            pub.down.destroy();
        }
    });
};
global.easyXDM = easyXDM;
})(window, document, location, window.setTimeout, decodeURIComponent, encodeURIComponent);


// put this on the global bv object if it exists, create it if it doesn't
window.BV || (window.BV ={});

return (window.BV.easyXDM = easyXDM.noConflict('BV'));
});

BV.define('bv/util/withRPC',[
  'ENV',
  'underscore',
  'bv/api',
  'bv/strings',
  'util/url',
  'window',
  'framework/util/bvtracker',
  'vendor/easyXDM'
], function (ENV, _, api, str, url, window, BVTracker, easyXDM) {

  function withRPC (rpcReady, handler, timeout) {
    var rpcTimeoutMs;
    var rpcFailure;
    var rpcUrl;
    var rpcConfig;
    var rpcFunctions;

    rpcTimeoutMs = 25000;
    // If a numeric timeout was passed, replace RPC_TIMEOUT with that value
    if (timeout && _.isNumber(timeout)) {
      rpcTimeoutMs = timeout;
    }

    // wait some time for rpc to get setup, if it hasn't by then, it probably failed
    rpcFailure = _.delay(function () {
      if (rpcReady.state() !== 'resolved') {
        BVTracker.error({
          name: str.errors.TIMEOUT,
          detail1: 'RPC',
          detail2: rpcConfig.remote
        });
        rpcReady.reject();
      }
    }, rpcTimeoutMs);

    rpcUrl = 'https:' + ENV.get('config').apiconfig.baseUrl + 'rpcfile?apiversion=' +
      encodeURIComponent(api._config.apiversion) + '&passkey=' +
      encodeURIComponent(ENV.get('config').apiconfig.passkey) +
      '&ve=' + encodeURIComponent(api._config.virtualEnvironment || '') +
      '&displaycode=' + encodeURIComponent(api._config.displaycode || '');

    rpcConfig = {
      isHost: true,
      hash: true,
      swf: 'https:' + ENV.get('config').utilPath + 'easyxdm.swf',
      remote: rpcUrl,
      onReady: function () {
        window.clearTimeout(rpcFailure);
        rpcReady.resolve();
      },
      props: {
        role: 'presentation',
        tabindex: '-1',
        title: 'empty'
      }
    };

    rpcFunctions = {
      local: {}
    };
    // This callback handles the response back from the API. See
    // VJB-145, we maintain the callback name in a string because
    // the callback name is now hard-coded in the API code.
    rpcFunctions.local[str.rpc.localCallback] = handler;

    return new BV.easyXDM.Rpc(rpcConfig, rpcFunctions);
  }

  return withRPC;
});

/**
  * @fileOverview The view for choosing a photo and adding a caption (for attaching to,
  * e.g., a review).
  *
  * A parent view should listen to the 'addphoto' event to be notified when
  * the process is done.
  *
  * TODO: One day this should be augmented to support drag/drop.
 */
BV.define('bv/c2013/view/photoupload',[
  'bv/ui-core/buploadview',
  'underscore',
  'jquery',
  'bv/util/withRPC',
  'mf!bv/c2013/messages/submission',
  'bv/util/focusManager',
  'bv/strings',
  'framework/util/bvtracker'
], function (BUploadView, _, $, withRPC, msgPack, focusManager, str, BVTracker) {

  var RPC_TIMEOUT_MS = 60000;
  var UPLOAD_TIMEOUT_MS = 60000;

  return BUploadView.extend({
    name: 'photoupload',
    mediaType: 'photo',
    preview: '.bv-media-preview-container',
    timedOut: false,
    rpcReady: null,
    uploadTimeout: null,
    events: _.extend({}, BUploadView.prototype.events, {
      'change input[name="photo"]': 'mediaSelected'
    }),

    init: function (config) {
      BUploadView.prototype.init.call(this, config);
      this.initRpc();
    },

    /**
     * Prepare the RPC channel for upload.
     */
    initRpc: function () {
      var self = this;
      this.rpcReady = $.Deferred();

      this.rpc = withRPC(this.rpcReady, function (response) {
        self.processUpload(response);
      }, RPC_TIMEOUT_MS);

      this.model.set('channelId', this.rpc.channel);
    },

    /**
     * Display loading animation and then, if rpcReady is:
     *  - resolved, submit the photo for upload
     *  - rejected, re-initialize the rpc and display an error.
     */
    mediaSelected: function () {
      var self = this;
      var imageSize;

      // check image size before upload starts
      var imageInput = this.$el.find(this.input);
      if (
        imageInput &&
        imageInput[0] &&
        imageInput[0].files &&
        imageInput[0].files.length > 0
       ) {
        imageSize = imageInput[0].files[0].size;
        // image should be less than 5 mb; 1024 * 1024 * 5 === 5242880
        if (imageSize > 5242880) {
          self._showError('ERROR_FORM_IMAGE_TOO_LARGE');
          return;
        }
      }

      // Show indeterminate progress state here. Remove when the file upload
      // finishes.
      this.$el.find(this.preview).addClass('bv-media-uploading');
      // Hide controls during uploading
      this.$el.find(this.controls).css('display', 'none');

      this.updatePlaceholderText();

      this.rpcReady
        .done(function () {
          // If the rpcReady is resolved, it's ok to try submitting.
          $('#bv-photo-upload-form-' + self.model.get('channelId')).submit();

          self.timedOut = false;

          // UIA-6903: If we time out after selecting media, it indicates a problem in
          // withRPC, or a connection issue. Either way, we want to stop the
          // upload and allow the user to try again or exit.
          window.clearTimeout(self.uploadTimeout);
          self.uploadTimeout = setTimeout(function () {
            self.timedOut = true;
            self._showError();
            self._removeMedia();

            BVTracker.error({
              name: str.errors.TIMEOUT,
              detail1: 'Photo Upload'
            });
          }, UPLOAD_TIMEOUT_MS);
        })
        .fail(function () {
          // If rpc setup failed after the timeout,
          // show an error and try re-initializing.
          self._showError();
          self._removeMedia();
          self.initRpc();
        });
    },

    resizePreview: function (url, fromUpload) {
      // Get maximum width and height of image preview from the CSS properties.
      var $previewContainer = this.$el.find(this.preview);
      var maxHeight = parseInt($previewContainer.css('max-height'), 10);
      // var maxWidth = parseInt($previewContainer.css('max-width'), 10);

      // HACK: For now, the container's CSS max-width is set to 100%. So
      // instead of reading that value, measure its parent's inner width.
      // If that CSS changes in the future, we'll need to change this too.
      // -APD
      var maxWidth = $previewContainer.parent().innerWidth();
      var self = this;

      // Load the image and resize the preview container to match the image
      // dimensions.
      var img = new Image();
      img.onload = function () {
        var config = {
          height: {
            original: this.height,
            max: maxHeight
          },
          width: {
            original: this.width,
            max: maxWidth
          }
        };

        self.setDimensions($previewContainer, config);
        self.displayMedia(img, fromUpload);
      };

      img.onerror = function () {
        self._showError();
      };

      img.src = url;
    },

    // Sets the dimensions of the preview container to fit the chosen image.
    setDimensions: function ($container, config) {
      var width = config.width, height = config.height;
      var dimensions;
      var factor;
      var scaleFactors;
      // HACK: In IE8 innerWidth will return 0 some of the time. In the case
      // where we do not have a max width, just use the regular width so we
      // can finish processing without scaling width and height to 0. -JBL
      width.max = width.max || width.original;

      scaleFactors = {
        width: width.max / width.original,
        height: height.max / height.original
      };

      // We need to scale the image down by the smaller of these two
      // ratios to be sure it'll fit in the container.
      factor = Math.min(scaleFactors.width, scaleFactors.height);

      if (factor < 1) {
        // Image needs scaling down.
        dimensions = { width: width.original * factor, height: height.original * factor };
      }
      else {
        // Image will fit at its native size.
        dimensions = { width: width.original, height: height.original };
      }

      $container.width(dimensions.width).height(dimensions.height);
    },

    processUpload: function (response) {
      var photo, data;
      var errorCode;

      // If the timeout flag is set and we get here, it means we are way behind
      // just drop out to avoid conflicts.
      if (this.timedOut) {
        return;
      }

      // If we haven't timed out yet, make sure we don't timeout now.
      window.clearTimeout(this.uploadTimeout);

      if (!response || response.HasErrors) {

        errorCode = response &&
                        response.FormErrors &&
                        response.FormErrors.FieldErrors &&
                        response.FormErrors.FieldErrors.photo &&
                        response.FormErrors.FieldErrors.photo.Code;

        this._showError(errorCode);
      }

      photo = response.Photo;
      data = {
        id: photo.Id,
        url: photo.Sizes.normal.Url,
        thumbUrl: photo.Sizes.thumbnail.Url,
        caption: ''
      };

      this.model.set(this.mediaType, data);
      this.resizePreview(response.Photo.Sizes.normal.Url, true);
    },

    /**
     * Handles a11y work for showing errors, then makes a call to
     * buploadview's showError method
     *
     * @param  {String} errorCode Optional error code to determine which
     *                            error message to show
     */
    _showError: function (errorCode) {
      // Generic message that will be replaced with something more specific
      // in the code below. Defined here just in case.
      var inputSelect;
      var message = msgPack.error_AN_ERROR_OCCURRED();
      var messageKey;
      var self;

      if (errorCode) {
        // If errorCode is not null, there was likely an error with the photo
        // itself. Attempt to load the error message associated with the error
        // code. Wrapped in a try with an empty catch in case there is a
        // problem getting the error message, e.g., it doesn't exist, hasn't
        // been translated, probably a third scenario of some sort, etc.
        try {
          messageKey = 'error_' + errorCode;
          message = msgPack[messageKey]();
        }
        catch (e) {}
      }

      this.showError(message);

      // Since we're hiding the input element while focus is on it,
      // we hit undefined behavior. To remedy that, we wait for the
      // input to be shown again (which happens in showError), then
      // move focus back to the input. This not only keeps users
      // from getting lost, but also forces screenreaders to read
      // the error label.
      // The delay is so that the screen reader doesn't get
      // confused.
      inputSelect = this.fieldset + ' ' + this.input;
      self = this;
      setTimeout(function () {
        var $input = self.$el.find(inputSelect);
        focusManager.rescanFocusLayer();
        focusManager.moveFocus($input);
      }, 1000);

      return;
    },

    setupView: function () {
      // If we were initialized with media, display it immediately for
      // editing.
      var media = this.model.get(this.mediaType);
      if (media) {
        this.resizePreview(media.url);
      }
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!facebookAlbumPickerMenu',['hbs','vendor/handlebars/runtime', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " <button type=\"button\" class=\" bv-submission-button bv-facebook-button bv-facebook-album-list-back\">Back to Albums</button> ";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <button type=\"button\" class=\"bv-submission-button bv-facebook-button bv-facebook-";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-prev\" data-bv-url=\"";
  if (stack1 = helpers.prevpage) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.prevpage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">Previous</button> ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <button type=\"button\" class=\"bv-submission-button bv-facebook-button bv-facebook-";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-next\" data-bv-url=\"";
  if (stack1 = helpers.nextpage) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.nextpage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">Next</button> ";
  return buffer;
  }

  buffer += "<div class=\"bv-facebook-album-list-menu\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.type, "photo", options) : helperMissing.call(depth0, "equals", depth0.type, "photo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.prevpage, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.nextpage, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('facebookAlbumPickerMenu', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/largestFbPhoto',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {

  function largestFbPhoto (photo, options) {
    if (photo.images && photo.images.length) {
      var max = 0;
      var result;
      _(photo.images).forEach(function (image) {
        if (image.height + image.width > max) {
          max = image.height + image.width;
          result = image;
        }
      });
      return result.source;
    }
    return photo.source;
  }

  Handlebars.registerHelper('largestFbPhoto', largestFbPhoto);
  return largestFbPhoto;
});

/* START_TEMPLATE */
BV.define('hbs!facebookAlbumPicker',['hbs','vendor/handlebars/runtime','hbs!facebookAlbumPickerMenu', 'template/helpers/equals', 'template/helpers/largestFbPhoto'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  
  return " Choose from your Facebook albums ";
  }

function program3(depth0,data) {
  
  
  return " Choose a picture from this album ";
  }

function program5(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-media-item bv-media-item-photo\"> <div class=\"bv-media-item-wrapper\"> <img src=\"https://graph.facebook.com/";
  options = {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, "album", depth1.type, options) : helperMissing.call(depth0, "equals", "album", depth1.type, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "/picture?access_token="
    + escapeExpression(((stack1 = depth1.access_token),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "&amp;type=normal\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, "photo", depth1.type, options) : helperMissing.call(depth0, "equals", "photo", depth1.type, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " title=\"";
  if (stack2 = helpers.name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" data-bv-fb"
    + escapeExpression(((stack1 = depth1.type),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "id=\"";
  if (stack2 = helpers.id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </div> <span class=\"bv-media-item-border\" data-bv-fb"
    + escapeExpression(((stack1 = depth1.type),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "id=\"";
  if (stack2 = helpers.id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, "photo", depth1.type, options) : helperMissing.call(depth0, "equals", "photo", depth1.type, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ></span> </li> ";
  return buffer;
  }
function program6(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.cover_photo) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.cover_photo; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program8(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " data-bv-fbsource=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.largestFbPhoto),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "largestFbPhoto", depth0, options)))
    + "\" ";
  return buffer;
  }

  buffer += "<div class=\"bv-facebook-album-selector\"> <div class=\"bv-facebook-album-header\"> ";
  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.type, "album", options) : helperMissing.call(depth0, "equals", depth0.type, "album", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> <div class=\"bv-facebook-album-list-container\"> ";
  stack2 = self.invokePartial(partials.facebookAlbumPickerMenu, 'facebookAlbumPickerMenu', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <ul class=\"bv-facebook-";
  if (stack2 = helpers.type) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.type; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "-list bv-content-media-container\" role=\"presentation\"> ";
  stack2 = helpers.each.call(depth0, depth0.photos, {hash:{},inverse:self.noop,fn:self.programWithDepth(program5, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> ";
  stack2 = self.invokePartial(partials.facebookAlbumPickerMenu, 'facebookAlbumPickerMenu', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  });
Handlebars.registerPartial('facebookAlbumPicker', t);
t.deps = ["facebookAlbumPickerMenu"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/*global alert:false */
BV.define('bv/c2013/view/facebookphotoupload',[
  'ENV',
  'bv/ui-core/buploadview',
  'bv/c2013/view/photoupload',
  'bv/util/loadingOverlay',
  'bv/strings',
  'underscore',
  'jquery',
  'bv/api',
  'bv/util/withRPC',
  'hbs!facebookAlbumPicker',
  'framework/util/bvtracker'
], function (ENV, BUploadView, PhotoUploadView, LoadingOverlay, str, _, $, api, withRPC, fbAlbumPickerTemplate, BVTracker) {

  // The view for choosing a photo and adding a caption (for attaching to,
  // e.g., a review).
  //
  // A parent view should listen to the 'addphoto' event to be notified when
  // the process is done.
  //
  // One day this should be augmented to support drag/drop.
  //
  return PhotoUploadView.extend({
    name: 'facebookphotoupload',
    label: '.bv-facebookphoto-label',

    events: _.extend({}, BUploadView.prototype.events, {
      'click .bv-facebook-album-list li': 'selectAlbum',
      'click .bv-facebook-photo-list li': 'selectPhoto',
      'click .bv-facebook-album-list-back': 'backToAlbums',
      'click .bv-facebook-album-prev': 'showPrevAlbum',
      'click .bv-facebook-album-next': 'showNextAlbum',
      'click .bv-facebook-photo-prev': 'showPrevPhotos',
      'click .bv-facebook-photo-next': 'showNextPhotos'
    }),

    init: function (config) {
      BUploadView.prototype.init.call(this, config);
      var self = this;

      this.rpcReady = $.Deferred();
      this.rpc = withRPC(this.rpcReady, function (response) {
        self.processUpload(response);
      });

      this.model.set('channelId', this.rpc.channel);
      this.model.set('token', config.token);
    },

    mediaSelected: function () {
      this.$('.bv-hidden-facebook').removeClass('bv-hidden');
      var $form = $('#bv-photo-upload-form-' + this.model.get('channelId'));
      $form.find('input[name="photourl"]').val(this.selectedPhoto.url);
      $form.submit();

      this.$('.bv-facebook-album-selector').addClass('bv-hidden');

      // TODO: Show indeterminate progress state here, to be replaced when
      // the file upload finishes. -APD

      // Show indeterminate progress state here. Remove when the file upload
      // finishes.
      this.$el.find(this.preview).addClass('bv-media-uploading');
    },

    _removeMedia: function () {
      this.$('.bv-hidden-facebook').addClass('bv-hidden');
      this.$('.bv-facebook-album-selector').removeClass('bv-hidden');
      return BUploadView.prototype._removeMedia.apply(this, arguments);
    },

    getAccessToken: function (cb) {
      var token = this.model.get('token');
      if (token) {
        cb(token);
      }
      else {
        cb(null, new Error('No access token'));
      }
    },

    getNextPage: function (nexturl, cb) {
      return $.getJSON(nexturl, cb);
    },

    getAlbums: function (cb, _forceUrl) {
      var self = this;
      var req = {
        dataType: 'jsonp',
        success: cb
      };

      if (!_forceUrl) {
        _(req).extend({
          url: 'https://graph.facebook.com/me/albums',
          data: {
            access_token: self.token
          }
        });
      }
      else {
        req.url = _forceUrl;
      }

      LoadingOverlay.show();
      return $.ajax(req);
    },

    showAlbums: function (data) {
      var self = this;
      data = data || {};
      LoadingOverlay.hide();
      if (!data.data) {
        alert('No albums found');
        self.trigger('close');
        BVTracker.error({
          name: str.errors.THIRD_PARTY,
          detail1: 'Facebook',
          detail2: 'showFacebookAlbums: No data returned'
        });
        return;
      }

      var albumlist = data.data;
      data.paging = data.paging || {};
      this.model.set({
        'albumNextPage': data.paging.next,
        'albumPrevPage': data.paging.previous
      });

      this.$('.bv-facebook-photo-outer-container').html(fbAlbumPickerTemplate({
        type: 'album',
        photos: albumlist,
        access_token: self.token,
        nextpage: data.paging.next,
        prevpage: data.paging.previous
      }));
      this.trigger('scroll');
    },

    showAlbumPhotos: function (data) {
      var self = this;
      data = data || {};
      LoadingOverlay.hide();
      if (!data.data) {
        alert('No albums found');
        self.trigger('close');
        BVTracker.error({
          name: str.errors.THIRD_PARTY,
          detail1: 'Facebook',
          detail2: 'showFacebookAlbumPhotos: No data returned'
        });
        return;
      }

      var albumlist = data.data;
      data.paging = data.paging || {};
      this.model.set({
        'photosNextPage': data.paging.next,
        'photosPrevPage': data.paging.previous
      });

      var area = this.$('.bv-facebook-photo-outer-container');
      area.html(fbAlbumPickerTemplate({
        type: 'photo',
        photos: albumlist,
        access_token: self.token,
        nextpage: data.paging.next,
        prevpage: data.paging.previous
      }));
      this.trigger('scroll');
    },

    getAlbumPhotos: function (albumid, cb, _forceUrl) {
      var self = this;
      var reqData = {
        dataType: 'jsonp',
        success: cb
      };

      if (_forceUrl) {
        reqData.url = _forceUrl;
      }
      else {
        _(reqData).extend({
          url: 'https://graph.facebook.com/' + albumid + '/photos',
          data: {
            access_token: self.token
          }
        });
      }

      LoadingOverlay.show();
      return $.ajax(reqData);
    },

    selectAlbum: function (e) {
      var self = this;
      var albumid = $(e.target).data('bv-fbalbumid');
      this.getAlbumPhotos(albumid).done(function (data) {
        self.showAlbumPhotos(data);
      });
    },

    selectPhoto: function (e) {
      var self = this;
      var $el = $(e.target);
      var photoid = $el.data('bv-fbphotoid');
      var photourl = $el.data('bv-fbsource');
      this.selectedPhoto = {
        id: photoid,
        url: photourl
      };
      this.$('.bv-media-item-border-selected').removeClass('bv-media-item-border-selected');
      $el.addClass('bv-media-item-border-selected');
      this.mediaSelected();
      this.trigger('scroll');
    },

    choosefacebookphoto: function () {
      var self = this;
      this.getAccessToken(function (token, err) {
        if (err) {
          alert('The correct permissions were not granted or the attempt failed.');
          self.trigger('close');
          BVTracker.error({
            name: str.errors.THIRD_PARTY,
            detail1: 'Facebook',
            detail2: 'choosefacebookphoto: ' + err
          });
          return;
        }
        self.token = token;

        self.getAlbums().done(function (albums) {
          self.showAlbums(albums);
        });
      });
    },

    backToAlbums: function () {
      var self = this;
      self.getAlbums().done(function (albums) {
        self.showAlbums(albums);
      });
    },

    showPrevAlbum: function (e) {
      return this.showNextAlbum.call(this, e);
    },
    showNextAlbum: function (e) {
      var self = this;
      var $el = $(e.target);
      var nextUrl = $el.data('bv-url');
      this.getAlbums(null, nextUrl).done(function (albums) {
        var errmsg;
        if (!albums) {
          errmsg = 'Could not retrieve the next page.';
          alert(errmsg);
          BVTracker.error({
            name: str.errors.THIRD_PARTY,
            detail1: 'Facebook',
            detail2: 'showNextFacebookAlbum: ' + errmsg
          });
          return;
        }
        self.showAlbums(albums);
      });
    },
    showPrevPhotos: function (e) {
      return this.showNextPhotos.call(this, e);
    },
    showNextPhotos: function (e) {
      var self = this;
      var $el = $(e.target);
      var nextUrl = $el.data('bv-url');
      this.getAlbumPhotos(null, null, nextUrl).done(function (photos) {
        var errmsg;
        if (!photos) {
          errmsg = 'Could not retrieve the next page.';
          alert(errmsg);
          BVTracker.error({
            name: str.errors.THIRD_PARTY,
            detail1: 'Facebook',
            detail2: 'showNextFacebookAlbumPhoto: ' + errmsg
          });
          return;
        }
        self.showAlbumPhotos(photos);
      });
    },

    render: function () {
      this.choosefacebookphoto();
      return BUploadView.prototype.render.apply(this, arguments);
    }

  });
});

/**
 * @fileOverview A view that "pops up" positioned relative to an arbitrary view.
 */
BV.define('bv/ui-core/bpopupview',[
  'ENV',
  'framework/bview',
  'underscore',
  'jquery',
  'document',
  'window',
  'vendor/fastclick',
  'bv/ui-core/focusableview',
  'util/specialKeys',
  'body'
], function (ENV, BView, _, $, document, window, FastClick, FocusableView, specialKeys, body) {
  var popupClass = 'popup-container';
  var View = BView.extend(FocusableView);
  return View.extend({

    classList: ['shared', popupClass],

    // Because a popup is appended to BODY, it doesn't have its top view as a
    // DOM ancestor, and so it can't rely on that top view to delegate
    // events. Act as an event manager.
    isEventManager: true,

    options: {
      delay: 250,
      animDelay: 20,
      containerClass: 'bv-absolute-top-container',
      focusableClass: 'bv-focusable',
      cleanslateClass: 'bv-cleanslate bv-cv2-cleanslate',
      popupInClass: 'bv-popup-in',
      popupOutClass: 'bv-popup-out',
      popupClass: popupClass,
      popupInEvent: 'mouseenter',
      popupOutEvent: 'mouseleave',
      popupPositionMargin: 10,
      startDelay: 180,
      arrowWidth: 20,
      arrowHeight: 10,
      alignArrow: true
    },

    init: function (config) {
      _(this.options).extend(config.options);

      this.popupId = 'bv-popup-' + Math.floor(Math.random() * 1e10);
    },

    createFeatureViews: function (features, modelName, mappings) {
      // since popups have no direct model, we must initialize any feature models here
      // derive subviews from environment feature definitions
      var views = [];
      var self = this;
      _(features[modelName]).forEach(function (name) {
        var feature;
        var FeatureView;
        var featureModel;

        name = name.replace('has:', '');
        feature = mappings[name];

        if (feature.model) {
          featureModel = new feature.model({
            parent: self.model
          });
        }
        else if (feature.collection) {
          featureModel = new feature.collection(undefined, { parent: self.model });
          featureModel.parent = self.model;
          // featureModel.componentId = componentId;
        }
        if (feature.view) {
          FeatureView = feature.view;
          if (!featureModel) {
            views.push(new FeatureView({
              parent: self
            }));
          }
          else {
            views.push(new FeatureView({
              parent: self,
              model: featureModel
            }));
          }
        }
      });
      return views;
    },

    enter: function (e) {
      // Stop any pending detach timeouts
      clearTimeout(this.keyEventId);
    },

    leave: function (e) {
      var self = this;

      if (this.parent.triggerElement) {
        $(this.parent.triggerElement).attr('aria-expanded', 'false');
      }
      else {
        this.parent.$targetEl.attr('aria-expanded', 'false');
      }

      // If we still have a focus layer, remove it
      this.removeFocusLayer();

      // Keep the view around for speed,
      // but get it out of the dom after a
      // grace period
      clearTimeout(this.keyEventId);
      self.keyEventId = setTimeout(function () {
        self.detach();
      }, self.options.delay);
    },

    // These are to encourage placement overrides
    topPositionModifier: function (pos) {
      return pos;
    },

    leftPositionModifier: function (pos) {
      return pos;
    },

    /**
     *  Position the popup.
     */
    _position: function () {
      var self = this;
      var $window = $(window);
      var outerWidth = $window.outerWidth();
      var popupPosition;

      // Calculate the position of the link element on the page.
      var parentOffset = self.parent.$targetEl.offset();

      function calculatePopupPosition () {
        var leftPosition;
        var leftPositionBounded;
        var popupMargin = self.options.popupPositionMargin;

        var position = {
          width: '100%',
          height: self.height,

          // If popup width is wider than window width, then make popup width smaller.
          maxWidth: self.width + popupMargin > outerWidth ? outerWidth - popupMargin * 2 : self.width + 2 // add +2 for border
        };

        // TODO :: Build z-index management system. zims.
        // The outer-most element gets most of the positioning.
        if (self.parent.options.positionPopupRelativeToLink) {

          // Position popup relative to it.
          // Left position equals (target left position) - (half popup width) + (half target width)
          leftPosition = self.leftPositionModifier(parentOffset.left) - ((self.width + 1) / 2) + self.parent.$targetEl.outerWidth(false) / 2;

          // Recalculate popup position to align with window left when
          // 1) previous calculated popup position goes too far to the left making popup look cutoff
          // 2) popup width is wider than the window width
          if (leftPosition < 0 || (self.width + popupMargin > outerWidth)) {
            leftPositionBounded = popupMargin;
          }
          // Recalculate popup position to align with window right when popup goes too far to the right
          else if ((self.width + leftPosition) > outerWidth) {
            leftPositionBounded = outerWidth - self.width - popupMargin;
          }
          else {
            leftPositionBounded = leftPosition;
          }

          position = _.extend(position, {
            top: (self.topPositionModifier(parentOffset.top) + self.parent.$targetEl.outerHeight(false) + self.options.arrowHeight),
            left: leftPositionBounded
          });
        }
        else {
          // Center popup in window.
          // Assume no offsets for arrow height since we're in
          // positionPopupRelativeToLink=false mode.
          position = _.extend(position, {
            top: $window.scrollTop() + (($window.height() - self.height) / 2),
            left: (outerWidth / 2) - ((self.width + 1) / 2)
          });
        }

        return position;
      }

      function calculateArrowPosition (popUpPosition) {
        var minArrowLeft = self.options.arrowWidth;

        // Since we are setting the popup to have a max-width of self.width,
        // we use the minimum between window width and max-width of the popup to
        // calculate maxArrowLeft.
        var maxArrowLeft = Math.min(outerWidth, self.width) - self.options.arrowWidth;

        // Determine left position of arrow
        // Left arrow position equals (target left position) + (half target width) - (popup left position)
        // We subtract the popup's left position because the arrow is positioned relative to the popup
        // We use quarter of arrow width since the CSS already defines a negative margin for half arrow width
        var leftArrowPosition = self.leftPositionModifier(parentOffset.left) + (self.parent.$targetEl.outerWidth(false) / 2) - popUpPosition.left;

        if (leftArrowPosition < minArrowLeft) {
          leftArrowPosition = minArrowLeft;
        }
        else if (leftArrowPosition > maxArrowLeft) {
          leftArrowPosition = maxArrowLeft;
        }

        return leftArrowPosition;
      }

      popupPosition = calculatePopupPosition();

      // Positions popup
      self.$el.css(popupPosition);

      // Positions popup arrow
      if (self.options.alignArrow) {
        // saving arrow position here to use after render (see UIA-9380)
        self.arrowPosition = calculateArrowPosition(popupPosition);
      }
    },

    /**
     *  Render the popup.
     */
    render: function (data) {
      var self = this;

      clearTimeout(self.detachKey);

      // Make sure there is an element
      if (!self.$el || !self.$el.length) {
        self.$el = $('<div/>')
          .addClass(self.options.cleanslateClass)
          .addClass(self.options.containerClass)
          .addClass(self.options.popupOutClass);
      }

      if (self.options.aboveModestBox) {
        self.$el.addClass('bv-above-mbox');
      }

      // Add id
      self.$el.attr('id', self.popupId);

      // Render this
      self.$el.html(self.toHTML(_.extend({}, data, {
        version: ENV.get('config').version
      })));

      // Get some events, yo
      self.attach();

      new FastClick(self.$el.get(0));

      // Set some love on the actual render stuff
      self.$el.find('.bv-' + popupClass).css({
        position: 'relative'
      });

      self._position();

      // Reposition the view when orientation changes.
      self._positionHandler = function () {
        self._position();
      };

      // Detach so we can be sure that only one of these handlers is attached
      // at a time.
      $(document).off('orientationchange.bpopupview');
      $(document).on('orientationchange.bpopupview', self._positionHandler);

      if (!self.rendered) {
        // For CSS animations and stuff.
        // Remove this if it's been here before.
        self.$el.removeClass(self.options.popupInClass);

        // Inject it.
        self.startKey = setTimeout(function () {
          self.$el.appendTo(body());

          // Wait a tiny bit and add the 'in' class.
          setTimeout(function () {
            self.$el.addClass(self.options.popupInClass).removeClass(self.options.popupOutClass);
            self.model.trigger('dropdownRendered');
            // setting inline style for CSP complianace (see UIA-9380)
            $('.bv-tm-popup-arrow').css('left', (self.arrowPosition) + 'px', 'important');
          }, self.options.animDelay);

          // Save the state.
          self.rendered = true;

        }, self.options.startDelay);
      }
    },

    needDetach: function (target) {
      var $popupArea = this.$viewEl;
      var offset = $popupArea.offset();
      var width = $popupArea.outerWidth();
      var height = $popupArea.outerHeight();

      var result =
        (target.clientX < offset.left ||
          target.clientX > (offset.left + width) ||
          target.clientY < offset.top ||
          target.clientX > (offset.top + height)) && this.rendered;
      return result;
    },

    /**
     *  Detach the popup.
     */
    detach: function (immediate) {
      var self = this;

      BView.prototype.detach.call(this);

      $(document).off('orientationchange.bpopupview');

      if (!self.rendered) {
        return;
      }

      // Make sure any focus layer is cleared here
      this.removeFocusLayer();

      function detachFn () {
        $(document).off('click.sharing');
        self.getEventManager().undelegateSubviewEvents(self);
        self.$el.detach();

        // Save some more state.
        self.rendered = false;

      }

      // If we're detached no elements should be focusable.
      this.$focusables = $([]);

      // Remove the fade in class.
      self.$el.addClass(self.options.popupOutClass);

      if (immediate) {
        detachFn();
      }
      else {
        self.detachKey = setTimeout(detachFn, self.options.delay);
      }
    },

    attach: function () {
      var self = this;
      // Call the normal bview attach
      var res = BView.prototype.attach.apply(this, arguments);

      // Use jQuery to do mouseenter and mouseleave, because they're best.
      // But proxy the functions so everything is always in a View Instance scope
      var $popupArea = this.$el.find('.bv-' + this.options.popupClass)
        .off(this.options.popupOutEvent).on(this.options.popupOutEvent, $.proxy(this.leave, this))
        .off(this.options.popupInEvent).on(this.options.popupInEvent, $.proxy(this.enter, this));

      if (this.parent.options && this.parent.options.toggleable) {
        $popupArea.off(this.options.popupOutEvent);

        $(document).off('click.sharing').on('click.sharing', function (e) {
          if (!$(e.currentTarget).is(this.linkEl) && self.needDetach(e)) {
            self.detach(true);
          }
        });
      }

      // Identify focusables in the popup
      this.$focusables = this.$el.find('.' + this.options.focusableClass);

      // Cache these
      this.$first = this.$focusables.first();
      this.$last = this.$focusables.last();

      if (!this.focusLayer) {
        this.focusLayer = this.registerFocusableLayer(this.$el, '.' + this.options.focusableClass);
      }
      this.listenTo(ENV, 'focusLayerRemoved', this.focusLayerRemoved);

      // More event handling specifically for keyboard nav
      this.setupKeyboardNavigation();

      // Return whatever the super function returned before
      return res;
    },

    setupKeyboardNavigation: function () {
      var self = this;

      self.$focusables.off('focus.bpopupview').on('focus.bpopupview', function () {
        clearTimeout(self.keyEventId);
      });

      self.$focusables.off('keydown.bpopupview').on('keydown.bpopupview', function (e) {
        if (e.keyCode === specialKeys.ESCAPE) {
          e.preventDefault();
          e.stopPropagation();
          self.deregisterFocusableLayerById(self.focusLayer);
        }
      });
    },

    focusLayerRemoved: function (e) {
      if (e.focusLayer.$layerRoot === this.$el) {
        delete this.focusLayer;
        this.leave();
      }
    },

    removeFocusLayer: function () {
      // If we have a focus layer property, that means that we still have a
      // registered focus layer, so we'll remove the key, stop listening for
      // subsequent removal, and deregister our layer.
      if (this.focusLayer) {
        this.stopListening(ENV, 'focusLayerRemoved');
        this.deregisterFocusableLayerById(this.focusLayer, false, this.parent.options && this.parent.options.preserveFocus);
        delete this.focusLayer;
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!photouploadPopup',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-popup bv-popup-photoupload\"> <ul class=\"bv-fieldsets\" role=\"presentation\"> <li class=\"bv-fieldset bv-photoupload-action\"> <button type=\"button\" class=\"bv-upload-btn bv-focusable\" data-bv-upload-type=\"upload\"> ";
  options = {hash:{
    'prefix': ("add_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "file", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "file", depth0.msgpack, depth0, options)))
    + " </button> </li> ";
  stack2 = helpers['if'].call(depth0, depth0.janrain_configured, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> </div> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "addSocialPhoto", options) : helperMissing.call(depth0, "ifHasFeature", "addSocialPhoto", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <li class=\"bv-fieldset bv-photoupload-action\"> <button type=\"button\" class=\"bv-upload-btn bv-focusable\" data-bv-upload-type=\"facebook\"> ";
  options = {hash:{
    'prefix': ("add_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "facebookphoto_1", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "facebookphoto_1", depth0.msgpack, depth0, options)))
    + " </button> </li> ";
  return buffer;
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('photouploadPopup', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/photouploadPopup',[
  'framework/bview',
  'bv/ui-core/bpopupview',
  'hbs!photouploadPopup',
  'jquery',
  'underscore',
  'mf!bv/c2013/messages/submission'
], function (BView, BPopupView, template, $, _, msgPack) {
  return BPopupView.extend({

    name: 'photouploadDropdown',

    options: _.extend({}, BPopupView.prototype.options, {
      popupInClass: 'bv-dropdown-in',
      popupOutClass: 'bv-dropdown-out'
    }),

    width: 160,

    height: 400,

    events: {
      'click .bv-upload-btn': 'uploadPhoto'
    },

    template: template,

    msgpacks: [msgPack],

    uploadPhoto: function (e) {
      this.detach();

      var $el = $(e.target);
      var type = $el.data('bv-upload-type');

      if (type === 'upload' && this.parent.photoUpload) {
        return this.parent.photoUpload(e);
      }
      else if (type === 'facebook' && this.parent.facebookPhotoUpload) {
        return this.parent.facebookPhotoUpload(e);
      }

      // TODO :: do something here?
    },

    topPositionModifier: function (pos) {
      return pos - 20;
    },

    init: function (opts) {
      // Are we configured for social
      var vendorConfig = BView.config.vendorConfig || {};
      this.model.set('janrain_configured', vendorConfig.janrain);
    }

  });
});


/**
 * @file Abstract class to interact with video apis
 */
BV.define('framework/video/abstractVideo',[
  'jquery',
  'underscore',
  'framework/util/bvreporter'
], function (
  $,
  _,
  BVReporter
) {

  /**
   * AbstractVideo constuctor
   *
   * Assigns the videoUrl and videoId memebers.
   * Checks if a video id can be parsed from the url.
   * If so, begins fetching the video data.
   *
   * @param {String} videoUrl - The url of the video we need to load
   *
   * @constructor
   */
  function AbstractVideo (videoUrl) {
    BVReporter.assert(
      this.constructor !== AbstractVideo,
      'AbstractVideo is an abstract class'
    );

    BVReporter.assert(
      _(videoUrl).isString(),
      'Video objects require a video url'
    );

    this.videoUrl = videoUrl;

    // Attempt to parse a video id from the url.
    try {
      this.videoId = this._getVideoIdFromUrl(videoUrl);
    }
    catch (error) {
      // We couldn't parse an id from the url. We don't really need to know
      // about the error, we just need to set the invalid flag and bail.
      this.invalid = true;
      return;
    }

    // Begin fetching the data. Anything that needs to happen after this data
    // is fetched should use this promise.
    this._fetchingVideoData = this._fetchVideoDataFromAPI();
  }

  // --- Abstract Methods ---
  // These methods don't need to be touched by child classes.

  /**
   * Fetches the video data from the child class' api.
   * Returns a promise.
   *
   * If an ajax request is not the proper way to fetch the video data for a
   * child class, then this method should be overridden. It should still return
   * a promise.
   *
   * @return {Promise} - This promise will be resolved with normalized
   *  video data once the video api returns.
   *
   * @protected
   */
  AbstractVideo.prototype._fetchVideoDataFromAPI = function () {
    var self = this;
    var videoDataDeferred = $.Deferred();
    var ajaxRequest = self._myAjaxConfig();

    $.ajax(ajaxRequest).done(function (response) {
      var normalizedResponse = self._normalizeVideoData(response);

      if (normalizedResponse.error) {
        // If we had an error, reject the promise.
        videoDataDeferred.reject(normalizedResponse);
      }
      else {
        // Otherwise, resolve away.
        videoDataDeferred.resolve(normalizedResponse);
      }

      // Hang on to the the video data for easier debugging.
      self.videoData = normalizedResponse;
    });

    return videoDataDeferred.promise();
  };

  /**
   * A public endpoint to return the video data.
   *
   * This method returns a promise that will be resolved with the video data
   * once it has been returned from the api.
   *
   * It's set up so that it will only make the request once, and will return
   * the same data whenever it's called.
   *
   * @return {Promise} - A promise that will be resolved with the normalzied
   *   video data once it returns from the api.
   */
  AbstractVideo.prototype.getVideoData = function () {
    BVReporter.assert(
      !this.invalid,
      'Cannot get data on an invalid video.'
    );

    return this._fetchingVideoData;
  };

  // --- "pure virtual" methods ---
  // There isn't a legit way to make a method pure virtual in javascript,
  // so these just assert false to force you to overwrite them.

  /**
   * Attempts to parse a video id out from a video url.
   * Should return the video id as a string.
   *
   * TODO should this be a "pure virtual" method ? I went back and forth on
   *   it in my head. On one hand, we can handle everything here in the parent
   *   class as long as each child defines a regex, like the youtube child. On
   *   the other hand, that would require each child class have a regex, which
   *   is kinda lame.
   *
   * @protected
   */
  AbstractVideo.prototype._getVideoIdFromUrl = function () {
    BVReporter.assert(
      false,
      '_getVideoIdFromUrl is "pure virtual" and should be overwritten.'
    );
  };

  /**
   * Returns an object to be used as a configuration for an ajax call.
   * This should be set up to make an ajax request to the child class' api.
   *
   * @return {Object} A configuration for an ajax request.
   *
   * @protected
   */
  AbstractVideo.prototype._myAjaxConfig = function () {
    BVReporter.assert(
      false,
      '_myAjaxConfig is "pure virtual" and should be overwritten.'
    );
  };

  /**
   * Normalizes the response from the api into a generic form we can
   * use agnostically throughout our app.
   *
   * The returned object should fit these criteria:
   *
   * - If there was an error in the api response, the video data should have
   *   an error property. This error property can be anything truthy, though
   *   for dev convenience should have some data on the error.
   *
   * - If there was no error in the api response, the video data should have
   *   three properties: id, url, and thumbUrl. The id should be the video id
   *   as parsed from the url, the url should be the url to show the video, and
   *   the thumbUrl should be the url of thumbnail image representing the
   *   video.
   *
   * @param  {Object} response - The raw response from the child class' api.
   *
   * @return {Object} - The normalized response data.
   *
   * @protected
   */
  AbstractVideo.prototype._normalizeVideoData = function (response) {
    BVReporter.assert(
      false,
      '_normalizeVideoData is "pure virtual" and should be overwritten.'
    );
  };

  return AbstractVideo;
});

/**
 * @file This creates a shim for Object.create because IE8 doesn't have it
 *
 * The sooner we can stop supporting IE8, the sooner we can stop doing this.
 *
 * Based on an answer here:
 * http://stackoverflow.com/questions/18020265/object-create-not-supported-in-ie8
 */
BV.define('util/objectCreateShim',[],function () {
  if (Object.create) {
    return Object.create;
  }
  else {
    return function (proto, props) {
      if (typeof props !== 'undefined') {
          throw 'The multiple-argument version of Object.create is not provided by this browser and cannot be shimmed.';
      }
      function ctor() { }
      ctor.prototype = proto;
      return new ctor();
    };
  }
});

/**
 * @file A method to descendFrom a parent class.
 */
BV.define('util/descendFrom',[
  'util/objectCreateShim'
], function (
  ObjectCreate
) {

  /**
   * Descends from the parent class with the child class.
   *
   * @param  {Class} ParentClass - The parent class to descend from
   * @param  {Class} ChildClass - The child class that descends from the parent
   */
  function descendFrom (ParentClass, ChildClass) {
    // We have to use Object.create in case the parent class is "abstract",
    // meaning that the constructor ensures it isn't instanced.
    ChildClass.prototype = ObjectCreate(ParentClass.prototype);
    ChildClass.prototype.constructor = ChildClass;
  }

  return descendFrom;
});

/**
 * @file Class to handle Youtube Videos
 */
BV.define('framework/video/youtubeVideo',[
  'jquery',
  'underscore',
  'framework/util/bvreporter',
  'framework/video/abstractVideo',
  'util/descendFrom'
], function (
  $,
  _,
  BVReporter,
  AbstractVideo,
  descendFrom
) {

  // A regex we can use to ensure a video is a youtube video.
  var YOUTUBE_URL_PATTERN = /(?:https?:\/\/)?(?:[0-9A-Z\-]+\.)?(?:youtu\.be\/|youtube\.com\S*[^\w\-\s])([\w\-]{11})(?=[^\w\-]|$)(?![?=&+%\w]*(?:['"][^<>]*>|<\/a>))[?=&+%\w\-]*/ig;

  // We're not that worried about the api keys being in the repo, as they don't
  // cover anything sensitive.
  var YOUTUBE_API_KEY = 'AIzaSyD1aZoYVpIKzD79SPOp9QLX_X_118xcLUE';

  /**
   * Youtube video contstuctor.
   *
   * @param videoUrl - The Url to load the video from.
   *
   * @constructor
   * @extends {AbstractVideo}
   */
  function YoutubeVideo (videoUrl) {
    AbstractVideo.apply(this, arguments);
  }
  descendFrom(AbstractVideo, YoutubeVideo);

  /**
   * Attempts to parse a video id out from a video url.
   *
   * @param  {String} videoUrl - The url to load the video from.
   *
   * @return {String} - The video id
   *
   * @throws Will throw an error if it can't parse an id from the url.
   *   This error should be caught by the caller.
   *
   * @override
   * @protected
   */
  YoutubeVideo.prototype._getVideoIdFromUrl = function (videoUrl) {

    // This is an odd way to parse the video id from the url.
    // If this is a valid youtube url, id will be parsed out.
    // Otherwise, id will be set equal to url.
    var id = videoUrl.replace(YOUTUBE_URL_PATTERN, '$1');

    // If we failed to find a video id, id will be equal to the url.
    // Then we can throw an error.
    if (videoUrl === id) {
      throw new Error('The given url was not a valid youtube url');
    }

    // If we didn't throw an error, we can just return an id.
    return id;
  };

  /**
   * Returns an object to be used as a configuration for an ajax call.
   * This is set up to call the youtube api and fetch the required video
   * data.
   *
   * First, we need to hit the videos endpoint:
   * 'https://www.googleapis.com/youtube/v3/videos'
   *
   * We need to return a configuration for the ajax call that will get the
   * appropriate data.
   * - dataType - jsonp so that we get appropriate https response codes
   * - type - GET, because we're getting data
   * - url - The base url for the youtube v3 videos endpoint
   * - id - The id of the video we're looking up
   * - part - snippet, as this contains the thumbnail url we need
   * - fields - we filter out everything besides the default thumbnail image
   * - key - our youtube api key
   *
   * @return {Object} A configuration for an ajax request to the youtube api
   *
   * @override
   * @protected
   */
  YoutubeVideo.prototype._myAjaxConfig = function () {
    return {
      dataType: 'jsonp',
      type: 'GET',

      // This is the youtube endpoint for getting video data.
      url: 'https://www.googleapis.com/youtube/v3/videos',
      data: {

        // Passing the id parameter tells the youtube api that we're only
        // interested in a single video, and not a list of videos. It also
        // tells youtube which video we're interested in. Convenient.
        id: this.videoId,

        // We need the snippet part for the thumbnail.
        part: 'snippet',

        // We can filter out the stuff we don't need, which can speed up the
        // request a little and reduce our api quota cost.
        fields: 'items/snippet/thumbnails/default',

        // Pick an api key to use.
        key: YOUTUBE_API_KEY
      }
    };
  };

  /**
   * Normalizes the response from the youtube api into a generic form we can
   * use agnostically throughout our app.
   *
   * @param  {Object} response - The raw response from the youtube api.
   *
   * @return {Object} - The normalized response data.
   *
   * @override
   * @protected
   */
  YoutubeVideo.prototype._normalizeVideoData = function (response) {
    var normalizedVideoData;

    if (response.error) {
      normalizedVideoData = {
        error: response.error
      };
    }
    else if (_(response.items).isEmpty()) {
      normalizedVideoData = {
        error: 'Youtube returned 0 results'
      };
    }
    else {
      normalizedVideoData = {
        id: this.videoId,
        url: this.videoUrl,
        thumbUrl: response.items[0].snippet.thumbnails['default'].url
      };
    }

    return normalizedVideoData;
  };

  return YoutubeVideo;
});

/**
 * @file A view where users can provide a video url for their submission.
 */
BV.define('bv/c2013/view/videoupload',[
  'bv/ui-core/buploadview',
  'underscore',
  'jquery',
  'mf!bv/c2013/messages/submission',
  'framework/util/bvreporter',
  'framework/video/youtubeVideo',
  'util/specialKeys'
], function (
  BUploadView,
  _,
  $,
  msgPack,
  BVReporter,
  YoutubeVideo,
  specialKeys
) {

  return BUploadView.extend({
    name: 'videoupload',
    mediaType: 'video',

    label: '.bv-media-picker-container .bv-helper-label',
    preview: '.bv-media-preview-container',
    controls: '.bv-media-toggle-controls',
    field: 'input[name="videourl"]',

    events: _.extend({}, BUploadView.prototype.events, {
      'click .bv-photo-submit': 'validateVideo',
      'keydown input[name="videourl"]': 'handleKeydown',
      'blur input[name="videourl"]': 'checkInput'
    }),

    /**
     * The init function for the video upload view.
     *
     * @param {Object} config - The configuration for this view
     */
    init: function (config) {
      BUploadView.prototype.init.call(this, config);

      // Init with this blank url so that we can have myVideo defined as
      // a precondition. The videoUrl should be empty to match the initial
      // input value.
      this.myVideo = {
        videoUrl: ''
      };
    },

    /**
     * Handles a keydown event on the input field.
     * When the user presses enter, we catch that event and process the
     * value of the url field.
     *
     * @param  {event} e - The event that triggered this callback.
     */
    handleKeydown: function (e) {
      if (e.type === 'keydown' && e.keyCode === specialKeys.ENTER) {
        e.stopPropagation();
        e.preventDefault();
        this.checkInput();
      }
    },

    /**
     * Reads the current value from the url input and compares it to the
     * current video url. If the current value is different, updates the
     * media data.
     */
    checkInput: function () {
      var currentUrl = this._getVideoUrlFromView();

      if (this.myVideo.videoUrl !== currentUrl) {
        this.updateMedia(currentUrl);
      }
    },

    /**
     * Gets the data on the video in the url.
     */
    updateMedia: function (videoUrl) {

      // URL field has changed so clear the preview.
      this.removeMedia(false);

      // Bail if the URL field is empty or blank.
      if (!videoUrl) { return; }

      // Create a new video instance.
      this.myVideo = new YoutubeVideo(videoUrl);

      // If the new video is invalid, bail.
      if (this.myVideo.invalid) {
        return;
      }

      // Let the user know we're getting their video data.
      this.$el.find(this.preview).addClass('bv-media-uploading');
      this.updatePlaceholderText();

      // We need to hang on to this context for these callbacks.
      var self = this;

      // Set up some callbacks when the video data comes in.
      this.myVideo.getVideoData().done(function (videoData) {
        self._videoError = false;
        self.processUpload(videoData);
      }).fail(function (error) {
        self._videoError = true;
        self.showError(msgPack.error_message_invalid_url_video());
      });
    },

    /**
     * Get the current value of the url field.
     *
     * @return {String} - The value of the url field.
     */
    _getVideoUrlFromView: function () {
      return this.$el.find(this.field).val();
    },

    /**
     * Callback handler for when the remove media button is clicked.
     * Make sure to clear out the video data, then clear out everything else.
     */
    _removeMedia: function () {
      this.myVideo = {};
      this.removeMedia(true);
    },

    /**
     * Display the video and set the data to the model.
     *
     * @param  {Object} videoData - The video data
     */
    processUpload: function (videoData) {
      this.model.set('video', videoData);
      this.displayMedia(null, true);
    },

    /**
     * Errors triggered by API responses get shown immediately
     * because they should be resolved ASAP, but other validation errors
     * shouldn't show up until the field is blurred or the submit button
     * is clicked. Otherwise it'd be annoying as hell to have a message
     * keep saying "invalid URL" or "field cannot be blank" with every
     * keystroke you type.
     */
    validateVideo: function () {
      if (this._videoError) {
        // Errors given to us by the API trump any other errors.
        // Don't do any other validation until those errors are fixed.
        return;
      }

      var videoUrl = this._getVideoUrlFromView();

      if (!videoUrl) {
        // Field is blank.
        this.showError(msgPack.error_message_require_url_video());
      }
      else if (this.myVideo.invalid) {
        // Field is not blank, but doesn't look like a valid video
        this.showError(msgPack.error_message_invalid_url_video());
      }
      else {
        // If we get here, there shouldn't be a visible error in the first
        // place, but call this just to be safe.
        this.clearError();
      }
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!submissionSidebar',['hbs','vendor/handlebars/runtime','hbs!subjectInfo', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-subject-info-section\"> ";
  stack1 = helpers['if'].call(depth0, depth0.subject, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.subjectInfo, 'subjectInfo', depth0.subject, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("submission-sidebar")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { return stack2; }
  else { return ''; }
  });
Handlebars.registerPartial('submissionSidebar', t);
t.deps = ["subjectInfo"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/submissionSidebar',[
  'ENV',
  'framework/bview',
  'underscore',
  'hbs!submissionSidebar',
  'jquery'
], function (ENV, BView, _, template, $) {
  return BView.extend({
    name: 'submissionSidebar',
    classList: ['submission-side'],

    events: {
    },

    template: template,

    // This view shares a model with the main submission view. But we don't
    // want it to actually think it's the main submission view and create an
    // extra set of subviews. Easiest way to do that is to override the
    // _setupSubviews method.
    //
    // TODO: When UIA-7731 is fixed, we should be able to do this another
    // way, or at least make this a true no-op. The `_setupSubviews` method
    // should be truly optional; the `uniq` property should be set elsewhere.
    _setupSubviews: function () {
      this.uniq = ++this.getComponent().viewUniq;
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!thumbnail',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/renderIcon'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.each.call(depth0, depth0.media, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div data-bv-";
  if (stack1 = helpers.mediaType) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.mediaType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"";
  stack1 = helpers.each.call(depth0, depth0.classList, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"> ";
  stack1 = helpers['if'].call(depth0, depth0.caption, {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " <a title=\"";
  options = {hash:{
    'prefix': ("remove_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.mediaType, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.mediaType, depth1.msgpack, depth0, options)))
    + "\" class=\"bv-thumbnail-close bv-focusable\" tabindex=\"0\" href=\"#\"> ";
  options = {hash:{
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-close", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-close", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.caption, {hash:{},inverse:self.programWithDepth(program13, data, depth0),fn:self.programWithDepth(program11, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </a> <input type=\"hidden\" name=\"";
  if (stack2 = helpers.urlFieldName) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.urlFieldName; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" value=\"";
  if (stack2 = helpers.url) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.url; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> <input type=\"hidden\" name=\"";
  if (stack2 = helpers.captionFieldName) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.captionFieldName; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" value=\"";
  if (stack2 = helpers.caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "";
  buffer += escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + " ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <a class=\"bv-image-wrapper bv-focusable\" tabindex=\"0\" href=\"#\"> <img src=\"";
  if (stack1 = helpers.thumbUrl) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.thumbUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" aria-label=\"";
  if (stack1 = helpers.caption) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.caption; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (stack1 = helpers.caption) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.caption; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\"";
  if (stack1 = helpers.caption) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.caption; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"/> <span class=\"bv-off-screen\">. ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options)))
    + "</span> </a> ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <a class=\"bv-image-wrapper bv-focusable\" tabindex=\"0\" href=\"#\"> <img src=\"";
  if (stack1 = helpers.thumbUrl) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.thumbUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" aria-label=\"";
  if (stack1 = helpers.fileName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.fileName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (stack1 = helpers.fileName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.fileName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" alt=\"";
  if (stack1 = helpers.fileName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.fileName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"/> <span class=\"bv-off-screen\">. ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_writeReviewModalNotice", depth0.msgpack, depth0, options)))
    + "</span> </a> ";
  return buffer;
  }

function program9(depth0,data) {
  
  
  return " &#x2718; ";
  }

function program11(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("remove_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.mediaType, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.mediaType, depth1.msgpack, depth0, options)))
    + " ";
  if (stack2 = helpers.caption) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.caption; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> ";
  return buffer;
  }

function program13(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("remove_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.mediaType, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.mediaType, depth1.msgpack, depth0, options)))
    + " ";
  if (stack2 = helpers.fileName) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.fileName; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('thumbnail', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* global confirm:false */
BV.define('bv/c2013/view/thumbnail',[
  'framework/bmodel',
  'framework/bview',
  'underscore',
  'hbs!thumbnail',
  'mf!bv/c2013/messages/submission',
  'bv/util/contentType',
  'jquery',
  'bv/util/focusManager',
  'util/specialKeys'
], function ThumbnailView (BModel, BView, _, template, msgPack, ContentType, $, focusManager, specialKeys) {

  var mediaFieldsPattern = /(photo|video)(caption|url)_(\d+)/;

  return BView.extend({
    name: 'thumbnail',
    el: '.bv-media-thumbnail-strip',

    events: {
      'click .bv-thumbnail-close': 'removeMedia',
      'click .bv-thumbnail-container .bv-image-wrapper': 'editMedia',
      'keydown .bv-thumbnail-container .bv-image-wrapper': 'processKeyboard'
    },

    template: template,

    msgpacks: [msgPack],

    init: function init (config) {
      this.parent = config.parent;
      this.mediaType = config.mediaType || 'media';
      this.classList = [this.mediaType + '-thumbnail-strip'];
      this.setElement(this.parent.$el.find('.bv-thumbnail-strip'));
      this.mediaErrors = this._getMediaErrors();
      this._createModel();
    },

    /**
     * Returns the errors that are present in the parent.
     * If this returns nothing, then there won't be any errors present
     * on the thumbnail.
     *
     * If you want to add errors through future renders, you will
     * need to invoke this function again after updating formErrors.
     * Or you could just push the error field (ie photocaption_4) directly
     * to the `mediaErrors` array.
     */
    _getMediaErrors: function _getMediaErrors () {
      var mediaErrors = [];
      var formErrors = this.parent.model.get('formErrors');

      if (formErrors && formErrors.FieldErrors) {
        _.each(formErrors.FieldErrors, function (error, key) {
          if (key.match(mediaFieldsPattern)) {
            mediaErrors.push(key);
          }
        });
      }
      return mediaErrors;
    },

    _createModel: function _createModel () {
      // var self = this;
      var parent = this.parent.model;
      var media = parent.get(ContentType.nouns(this.mediaType));
      // Build data for the handlebars template.
      this.model = new BModel({
        media: this._generateData(media),
        parent: parent
      });
    },

    _generateData: function _generateData (media) {
      var self = this;
      var data = _(media).map(function generateData (item, index) {
        var hasErrors = false;
        var identifiers = item.id.match(mediaFieldsPattern);
        var searchId;
        var thumbnailClassList;
        var ordinal;
        if (identifiers) {
          // If we matched the pattern, we have existing fields that were added by the API
          // So determine whether there is an error associated to it.
          searchId = identifiers[1] + 'caption_' + identifiers[3];
          hasErrors = _(self.mediaErrors).contains(searchId);
        }

        thumbnailClassList = hasErrors ? ['bv-thumbnail-container', 'bv-error'] : ['bv-thumbnail-container'];

        // The field names (e.g., 'photourl_1') start at 1, not 0.
        ordinal = index + 1;
        return {
          id: item.id,
          caption: item.caption,
          url: item.url,
          thumbUrl: item.thumbUrl,
          fileName: item.fileName,
          mediaType: self.mediaType,
          urlFieldName: self.mediaType + 'url_' + ordinal,
          captionFieldName: self.mediaType + 'caption_' + ordinal,
          classList: thumbnailClassList
        };
      });
      return data;
    },

    processKeyboard: function processKeyboard (e) {
      if (e.keyCode === specialKeys.ENTER || e.keyCode === specialKeys.SPACE ) {
        e.preventDefault();
        this.editMedia(e);
      }
    },

    editMedia: function editMedia (e) {
      var $container = $(e.target).closest('.bv-thumbnail-container');
      var id = $container.attr('data-bv-' + this.mediaType + '-id');
      var media = this.model.get('parent').getMediaById(id, this.mediaType);
      this.parent.trigger('showupload', this.mediaType, media, null, null, '[data-bv-photo-id=' + id + ']');
    },

    // Moved out of removemedia to make unit testing more feasible.
    _confirmRemoval: function _confirmRemoval () {
      return confirm(msgPack['remove_confirm_' + this.mediaType]());
    },

    /**
     *  confirm the action, find the closest image to the click event, remove it from the model, and rerender
     */
    removeMedia: function removeMedia (e) {
      var sure;
      var $container;
      var idQuery;
      var $focusContainer;
      var nextId;
      var id;
      var allMedia;
      e.preventDefault();
      sure = this._confirmRemoval();
      if (!sure) {
        return;
      }

      $container = $(e.target).closest('.bv-thumbnail-container');
      idQuery = 'data-bv-' + this.mediaType + '-id';

      // If we have a thumbnail 'after' the target, grab the id
      $focusContainer = $container.next();
      if ($focusContainer.length) {
        nextId = $focusContainer.attr(idQuery);
      }

      id = $container.attr(idQuery);
      allMedia = this.model.get('media');
      allMedia = _(allMedia).filter(function (m) {
        return m.id !== id;
      });
      this.model.set('media', allMedia);
      this.model.get('parent').removeMedia(id, this.mediaType);
      this.render();
      this._removeDefereds(nextId, idQuery);
    },

    // moved out of removemedia to make unit testing more feasible
    _removeDefereds: function _removeDefereds (nextId, idQuery) {
      _.defer(function () {
        var $nextContainer;
        var $nextTarget;
        // If a 'next' thumbnail exists, rescan _then_ moveFocus
        // If there is no 'next' thumbnail, focusNext _then_ rescan
        if (nextId) {
          // We have to find the new object based on the id
          $nextContainer = $('[' + idQuery + '=\'' + nextId + '\']');
          $nextTarget = $nextContainer.find('.bv-focusable');
          focusManager.rescanFocusLayer();
          focusManager.moveFocus($nextTarget);
        }
        else {
          focusManager.focusNext();
          focusManager.rescanFocusLayer();
        }
      });
    },

    update: function update () {
      var parentMedia = this.model.get('parent').get(ContentType.nouns(this.mediaType));
      var currentMedia = this.model.get('media');
      if (currentMedia.length !== parentMedia) {
        this.model.set('media', this._generateData(parentMedia));
      }
    },

    render: function render (elToAttach) {
      var maxCount;
      var remaindingCount;
      this.update();
      BView.prototype.render.call(this, elToAttach);
      maxCount = this.model.get('parent').getMaxNumByMediaType(this.mediaType);
      // var currentCount = this.model.get('parent');
      remaindingCount = maxCount - this.model.get('media').length;
      this.parent.trigger('updateupload', this.mediaType, remaindingCount);
    }

  });
});

BV.define('bv/util/submissionSubviews',[
  'ENV',
  'underscore',
  'bv/c2013/view/termsConditions',
  'bv/c2013/view/submissionMessage',
  'bv/c2013/view/photoupload',
  'bv/c2013/view/facebookphotoupload',
  'bv/c2013/view/photouploadPopup',
  'bv/c2013/view/videoupload',
  'bv/c2013/view/submissionSidebar',
  'bv/c2013/view/thumbnail'
], function (ENV, _, TermsConditionsView, SubmissionMessageView, PhotoUploadView, FacebookPhotoUploadView, PhotoUploadPopupView, VideoUploadView, SidebarView, ThumbnailView) {
  var SubmissionSubviews = {
    TermsConditionsView: TermsConditionsView,
    SubmissionMessageView: SubmissionMessageView,
    PhotoUploadView: PhotoUploadView,
    FacebookPhotoUploadView: FacebookPhotoUploadView,
    PhotoUploadPopupView: PhotoUploadPopupView,
    VideoUploadView: VideoUploadView,
    SidebarView: SidebarView,
    ThumbnailView: ThumbnailView
  };
  return SubmissionSubviews;
});

/**
 * @fileOverview Generic Review Submission view
 */
BV.define('bv/c2013/view/genericSubmission',[
  'ENV',
  'framework/bview',
  'underscore',
  'jquery',
  'hbs!genericSubmission',
  'mf!bv/c2013/messages/genericSubmission',
  'mf!bv/c2013/messages/contentSearch',
  'mf!bv/c2013/messages/submission',
  'bv/ui-core/modestbox',
  'framework/util/bvtracker',
  'bv/util/productInfo',
  'bv/util/cssLoadCheck',
  'client!bv/util/submissionSubviews',
  'window'
], function (ENV, BView, _, $, template, msgPack, searchMsgPack, submissionMsgPack, ModestBox, BVTracker, ProductInfo, cssLoadCheck, SubmissionSubviews, window) {
  return BView.extend({
    name: 'genericSubmission',
    template: template,
    msgpacks: [msgPack, searchMsgPack, submissionMsgPack],
    sb: null,
    rendered: false,

    events: {
      'click .bv-category-breadcrumb-link': 'breadcrumbCategory',
      'click .bv-root-category-item': 'categoryItem'
    },

    init: function (config) {
      this.model.on('launchSubmissionForProduct', this.launchSubmissionForProduct, this);
      this.model.on('change:moreResultsEnabled', function (model, enabled) {
        this.$('.bv-more-results').toggleClass('bv-hidden', !enabled);
      }, this);
      this.model.on('categorySelected', this.categoryChange, this);
    },

    /**
     * This is the overriden _render method for this view.
     * It will be called using the renderAsync or async methods from the BView
     * prototype. The initial render will be performed asynchronously if the
     * isAsync parameter is truthy, and will be performed synchronously
     * otherwise. Any subsequent renders will always be performed synchronously,
     * as problems arise if they are performed asynchronouly.
     *
     * Calls the _render method from the BView prototype.
     *
     * @override
     *
     * @param {Boolean} isAsync True to perform the initial render
     * asynchronously. False to perform the initial render synchronously.
     *
     * @return {promise} Returns a  promise which will be resolved once this
     * view has finished rendering.
     */
    _render: function (isAsync) {
      var sb = this.sb;
      var self = this;
      var containerId;
      var inline;
      var lightboxOptions;
      var config;

      // All paths through this method must return this promise.
      // It will be resolved after the initial render.
      var dfd = $.Deferred();
      var promise = dfd.promise();

      if (!sb) {
        // create a lightbox to contain the view, then render the view into the lightbox
        lightboxOptions = {};
        containerId = this.model.get('containerId');
        containerId = containerId ? '#' + containerId : null;
        inline = this.model.get('inline');

        // If generic submission is being rendered inline (inline preview), empty out the container to clear
        // out any config-hub generated markup.
        if (inline && containerId) {
          $(containerId).empty();
        }

        this.sb = sb = ModestBox.get('lightbox');
        config = _.extend({}, lightboxOptions, {
          view: this,
          title: msgPack.product_picker_title(this.model.toJSON()),
          preventClose: this.model.get('preventClose'),
          inline: inline,
          silentMode: this.model.get('silentMode'),
          container: containerId,
          beforeHide: _(function () { this.publish('bv-component-hide'); }).bind(this),
          afterShow: _(function () { this.publish('bv-component-show'); }).bind(this)
        });

        sb.once('afterClose', self.afterClose.bind(self));
        sb.replaceOrOpen(config);

        // Send out an event for opening up GWAR.
        BVTracker.feature({
          type: 'Used',
          name: 'Click',
          detail1: 'GenericReviewSubmission',
          bvProduct: ProductInfo.RATINGSANDREVIEWS
        });

        // We need to bail here.
        // When we opened the lightbox above, this view's render method was
        // called, which then called this _render method a second time. That
        // call to _render will get past here and eventually assign a listener
        // for the change:subCategories event that causes a re-render. The
        // execution then makes its way back here. If we continue executing,
        // we end up assigning that listener twice, causing each subcategory
        // change to render the view twice. So we bail here, returning the
        // promise.
        if (self.rendered) {
          dfd.resolve();
        }
        else {
          dfd.reject();
        }
        return promise;
      }

      if (this.rendered) {
        dfd.resolve();
        return promise;
      }

      cssLoadCheck.done(function () {
        var model = self.model;

        // ModestBox will immediately call _render. Ignore subsequent render
        // requests from other sources.
        BView.prototype._render.call(self, isAsync);
        self.rendered = true;
        dfd.resolve();

        // Re-render the html when the category changes
        // The isAsync argument needs to be false, as the subviews don't render
        // correctly in async when the GRS is two categories deep. As in,
        // when looking at `Books and Audio > Children's`, there should be one
        // book, but it doesn't render correctly in async.
        model.on('change:subCategories', function () {
          BView.prototype._render.call(self, false);
          self.$viewEl.find('.bv-text-field-search').val('');
        }, self);

        model.on('change:showProducts', function () {
          self.$viewEl.find('.bv-product-picker, .bv-root-category-picker').toggleClass('bv-hidden');
        }, self);
      });

      return promise;
    },

    categoryChange: function (newCategory) {
      if (newCategory === 'bv_back_category') {
        return this.model.backCategory();
      }
      this.model.setCategory(newCategory, null, true);
    },

    breadcrumbCategory: function (e) {
      var categoryId = $(e.currentTarget).attr('data-bv-category-breadcrumb');
      e.preventDefault();
      this.model.breadcrumbCategory(categoryId);
    },

    afterClose: function () {
      if (this.model) {
        this.model.destroy();
      }
    },
    // Add _.debounce function to prevent opening
    // more than one submission form. See CCS-31297
    launchSubmissionForProduct: _.debounce(function (productId) {
      var campaignId = this.model.get('clientAPIConfig').campaignId;
      window.$BV.ui('rr', 'submit_review', {
        productId: productId,
        campaignId: campaignId,
        push: true,
        breadcrumbs: false,
        // After submission, we show a message in a new ModestBox layer. The
        // layer has a close button. Ordinarily, we want that close button to
        // close the whole ModestBox when clicked. But when `preventClose` is
        // true, we don't want the box to close under any circumstances.
        closeAllPostSubmission: !this.model.get('preventClose'),
        isGenericSubmission: true
      });

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'GenericReviewSubmission',
        productId: productId
      });
    }, 1000, true),

    categoryItem: function (e) {
      var newCategory = $(e.currentTarget).attr('data-bv-categoryId');
      this.model.setCategory(newCategory, null, true);
    }

  });
});

BV.define('bv/c2013/model/searchBar',[
  'ENV',
  'framework/bmodel'
], function (ENV, BModel) {
  return BModel.extend({
    name: 'searchBar',
    processData: function (data) {
      if (!data) {
        this.set('lightboxSearch', true);
      }
      this.set(data);
      BModel.prototype.processData.call(this, data);
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!searchBar',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/ifHasFeature', 'template/helpers/extmsg', 'template/helpers/renderIcon', 'template/helpers/mountView'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-masthead-search bv-submission\"> <div class=\"bv-fieldsets\"> ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "contentFilter", options) : helperMissing.call(depth0, "ifHasFeature", "contentFilter", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <label for=\"bv-text-field-search-";
  if (stack2 = helpers.componentId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.componentId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2);
  stack2 = helpers['if'].call(depth0, depth0.lightboxSearch, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("content_"),
    'includeComponentId': ("true")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "search_placeholder", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "search_placeholder", depth0.msgpack, depth0, options)))
    + "</label> ";
  options = {hash:{
    'classList': ("bv-search-control-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-search-control", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-search-control", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <input id=\"bv-text-field-search-";
  if (stack2 = helpers.componentId) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.componentId; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2);
  stack2 = helpers['if'].call(depth0, depth0.lightboxSearch, {hash:{},inverse:self.noop,fn:self.program(6, program6, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" class=\"bv-text bv-focusable bv-search-text\" type=\"text\" name=\"bv-search\" placeholder=\"";
  options = {hash:{
    'prefix': ("content_"),
    'includeComponentId': ("true")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "search_placeholder", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "search_placeholder", depth0.msgpack, depth0, options)))
    + "\" > <button class=\"bv-focusable bv-search-clear-icon bv-hidden\"> ";
  options = {hash:{
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-close", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-close", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "close", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "close", depth0.msgpack, depth0, options)))
    + "</span> </button> <button type=\"button\" class=\"bv-content-btn bv-content-search-btn bv-focusable\"> ";
  options = {hash:{
    'classList': ("bv-search-control-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-search-control", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-search-control", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("content_"),
    'includeComponentId': ("true")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "search_button", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "search_button", depth0.msgpack, depth0, options)))
    + "</span> </button> </div> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentFilterButton", options) : helperMissing.call(depth0, "mountView", "contentFilterButton", options)))
    + " </div> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return " <div class=\"bv-expand-filter-button-offset-on\"> ";
  }

function program4(depth0,data) {
  
  
  return " <div class=\"bv-expand-filter-button-offset-off\"> ";
  }

function program6(depth0,data) {
  
  
  return "-lightboxSearch";
  }

function program8(depth0,data) {
  
  
  return "&#985;";
  }

function program10(depth0,data) {
  
  
  return " &#x2718; ";
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("searchbar"),
    'role': ("search"),
    'ariaLabel': ("Search")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('searchBar', t);
t.deps = [];
t.tplMountedViews = ['contentFilterButton'];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/searchBar',[
  'ENV',
  'framework/bview',
  'framework/util/bvtracker',
  'underscore',
  'jquery',
  'bv/util/loadingOverlay',
  'bv/util/productInfo',
  'hbs!searchBar',
  'mf!bv/c2013/messages/contentSearch',
  'mf!bv/c2013/messages/common',
  'util/specialKeys'
], function (ENV, BView, BVTracker, _, $, LoadingOverlay, ProductInfo, template, msgPackContentSearch, msgPackCommon, specialKeys) {
  return BView.extend({
    name: 'searchBar',

    region: 'SearchBarRatingSummary',

    events: {
      'keydown .bv-search-text': 'preventSubmit',
      'keyup .bv-search-text': 'searchInputChanged',
      'click .bv-content-search-btn': 'searchContent',
      'click .bv-search-clear-icon': 'clearSearch'
    },

    template: template,

    msgpacks: [msgPackContentSearch, msgPackCommon],

    init: function (config) {
      this.debouncedSearch = _(this._searchContent).debounce(500);
      this.searchOnKeyup = this.hasFeature('searchOnKeyup');
    },

    formSetup: function (dataMixin) {
      // Pre-fill the search bar if necessary.
      if (_(dataMixin).has('searchFor') && !_(dataMixin.searchFor).isEmpty()) {
        this.$viewEl.find('.bv-search-text').val(dataMixin.searchFor.join(' '));
      }
    },

    searchContent: function (e) {
      var searchValue = this.$viewEl.find('.bv-search-text').val();
      searchValue = _.str.trim(searchValue);
      this._searchContent(searchValue);
    },

    _searchTracking: function (searchValue) {
      var self = this;
      var coverageContent = this.model.get('coverageContentTypes');

      _(coverageContent).forEach(function (el) {
        var bvProduct = {
          'Reviews': ProductInfo.RATINGSANDREVIEWS,
          'Questions': ProductInfo.ASKANDANSWER
        }[el];

        if (bvProduct) {
          BVTracker.feature({
            type: 'Used',
            name: 'Search',
            detail1: 'UserGeneratedContent',
            detail2: searchValue,
            bvProduct: bvProduct,
            productId: ProductInfo.getId(self),
            categoryId: ProductInfo.getCategoryId(self)
          });
        }
      });
    },

    searchInputChanged: function (e) {
      // Ignore if this is triggered by tabbing over the search field
      if (e.keyCode === specialKeys.TAB) {
        return;
      }
      var searchValue = this.$viewEl.find('.bv-search-text').val();
      searchValue = _.str.trim(searchValue);
      if (e.keyCode === specialKeys.ENTER) {
        e.preventDefault();
        this._searchContent(searchValue);
      }
      else if (searchValue) {
        this.$viewEl.find('.bv-search-clear-icon').removeClass('bv-hidden');
        // We only want to start searching after two characters if we
        // searchOnKeyup is turned on.
        if (this.searchOnKeyup && searchValue.length > 2) {
          this.debouncedSearch(searchValue);
        }
      }
      else {
        this.$viewEl.find('.bv-search-clear-icon').addClass('bv-hidden');
        this.debouncedSearch(searchValue);
      }
    },

    clearSearch: function (e) {
      this.$viewEl.find('.bv-search-text').val('');
      this.$viewEl.find('.bv-search-clear-icon').addClass('bv-hidden');
      this.publish('searchcleared');
    },

    preventSubmit: function (e) {
      // Sometimes clients wrap whole the page in a form. This prevents submission on such forms.
      if (e.keyCode === specialKeys.ENTER) {
        e.preventDefault();
      }
    },

    _searchContent: function (searchValue) {
      if (searchValue) {
        LoadingOverlay.show();
        this.publish('searchcontent', 1, searchValue);

        this._searchTracking(searchValue);
      }
      else {
        this.publish('searchcleared');
      }
    }
  });
});

BV.define('bv/c2013/model/categorySelect',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'framework/util/bvtracker'
], function (ENV, BModel, _, BVTracker) {
  return BModel.extend({
    name: 'categorySelect',

    init: function (config) {
      if (config.parent) {
        config.parent.on('change:subCategories', function (parent, subCategories) {
          var parentCategoryName = parent.get('categoryName');
          this.set('categoryName', parentCategoryName);
          this.set('subCategories', subCategories);
        }, this);
      }
    },

    categorySelected: function (categoryId) {
      var parent = this.get('parent');
      if (parent) {
        parent.trigger('categorySelected', categoryId);
      }
    },

    processData: function (data) {
      this.set(data);
      return this.dataReady(data);
    }
  });
});

BV.define('bv/ui-core/bhoverableview',[
  'ENV',
  'framework/bview',
  'bv/ui-core/focusableview',
  'util/specialKeys',
  'jquery',
  'underscore'
], function (ENV, BView, FocusableView, specialKeys, $, _) {
  var View = BView.extend(FocusableView);

  var DEBOUNCED_ENTER_WAIT = 50;

  return View.extend({

    options: {
      delay: 250
    },

    // Define this in attach
    $targetEl: null,

    // This is called when the popup should come out
    // including hovers and focuses.
    enter: _.debounce(function (e) {
      var self = this;
      var rendered;

      // $targetEl can contain another element that also triggers this view to appear
      this.triggerElement = this.$targetEl.find('[aria-expanded]')[0];

      if (this.triggerElement) {
        $(this.triggerElement).attr('aria-expanded', 'true');
      }
      else {
        this.$targetEl.attr('aria-expanded', 'true');
      }

      // Create the popup view the first time
      if (!this.targetView) {

        this.targetView = new this.TargetView({
          model: this.model,
          parent: this,
          options: this.targetViewOptions
        });

        if (this.$viewEl.closest('.bv-mbox-lightbox').length) {
          this.targetView.options.aboveModestBox = true;
        }
      }

      clearTimeout(this.targetView.keyEventId);
      clearTimeout(this.targetView.startKey);

      rendered = this.targetView.rendered;
      this.targetView.detach(true);

      // Render the thing
      if (this.options.toggleable) {
        if (!rendered) {
          this.targetView.render(e);
        }
      }
      else {
        this.targetView.render(e);
      }

      if (!this.targetView.$focusables || !this.targetView.$focusables.length) {
        $(e.target).off('blur').on('blur', function (event) {
          self.leave();
        });
      }

      e.preventDefault();
    }, DEBOUNCED_ENTER_WAIT, true),

    leave: function (e) {
      var targetView = this.targetView;
      var self = this;

      // Keep the view around for speed,
      // but get it out of the dom
      if (targetView) {
        clearTimeout(targetView.startKey);
        clearTimeout(targetView.keyEventId);
        targetView.keyEventId = setTimeout(function () {
          if (self.triggerElement) {
            $(self.triggerElement).attr('aria-expanded', 'false');
          }
          else {
            self.$targetEl.attr('aria-expanded', 'false');
          }

          targetView.detach();
          // Removing the focus layer asynchronously used to be a problem
          // because we couldn't be certain that it would remove the right
          // one. But now `removeFocusLayer` deregisters the layer by name,
          // so the right one will get removed even if it isn't on top. See
          // CCS-1515.
          if (targetView.removeFocusLayer) {
            targetView.removeFocusLayer();
          }
        }, this.options.delay);
      }
    },

    // Handle focus and ESC cancelation
    setupKeyboardNavigation: function ($targetEl) {
      var self = this;
      $targetEl = $targetEl || self.$targetEl;
      $targetEl.off('focusManagerFocus.bhoverableview').on('focusManagerFocus.bhoverableview', function (e) {
        // The element has been focused by the focus manager, show our target view
        self.targetViewOptions = _.extend({}, self.targetViewOptions, { startDelay: 0 });
        self.enter(e);

        $targetEl.off('keydown.bhoverableview').on('keydown.bhoverableview', function (e2) {
          // Escape key pressed.
          if (e2.keyCode === specialKeys.ESCAPE) {
            e2.preventDefault();
            self.leave(e2);
            self.deregisterFocusableLayer();
          }
        });
      });
    }

  });
});

BV.define('bv/ui-core/bselectview',[
  'ENV',
  'bv/ui-core/bhoverableview',
  'jquery',
  'underscore',
  'body'
], function (ENV, BHoverableView, $, _, body) {
  return BHoverableView.extend({

    options: _.extend({}, BHoverableView.prototype.options, {
      toggleable: true
    }),

    setText: function (text) {
      this.$viewEl.find('.bv-dropdown-title').text(text);
    },

    attach: function (elToAttach) {
      var self = this;
      var attachResult = BHoverableView.prototype.attach.apply(self, [elToAttach]);
      var $targetFocusable = self.$viewEl.find('button.bv-focusable');

      // Wire up the events with jQuery's mouseenter and mouseleave, but keep
      // the Backbone context
      self.$targetEl = self.$viewEl
        // CCS-653: Listening to touchstart event fixes a bug where tapping the select button again
        // after an initial selection makes the button become unresponsive.
        // UIA-5019: We don't add a preventDefault() to this since it will cause the native dropdown
        // sort not to work. There is a preventDefault() in the enter method that will take care of
        // this instead.
        .on('touchstart', $.proxy(self._handleTouchstart, self))
        .on('mouseenter', $.proxy(self.enter, self))
        .on('mouseleave', $.proxy(self.leave, self));

      self.$select = self.$viewEl.find('select');
      if ($targetFocusable.length) {
        self.setupKeyboardNavigation($targetFocusable);
      }
      return attachResult;
    },

    // This exists so that subclasses of BSelectView can call the `enter`
    // method on the parent class without having to know that it's actually
    // defined on the grandparent class.
    enter: function () {
      return BHoverableView.prototype.enter.apply(this, arguments);
    },

    _handleTouchstart: function (e) {
      // Makes the select button toggelable with touchstart event.
      // BHoverableView has an option called toggleable, but we ignore that option whenever
      // there's a touchstart event. This event is fired by mobile devices. Since there is
      // no way to close the popup on mobile besides selecting a value, we toggle the popup.
      if (this.targetView && this.targetView.rendered) {
        this.leave(e);
      }
      else {
        this.enter(e);
        // Once we've opened the selectview, set an event listener for any touch outside
        // of the child menu so we know when to leave
        $(body()).on('touchstart.bhoverable' + this.uniq,
          $.proxy(this._closeViewIfExternalTouch, this));
      }
    },

    _closeViewIfExternalTouch: function (e) {
      // If the event's target el is not a child of the dropdown
      // then we want to deregister this event listener and leave
      if (this.$targetEl.has($(e.target)).length <= 0) {
        $(body()).off('touchstart.bhoverable' + this.uniq);
        this.leave(e);
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!categorySelect',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/renderIcon', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.subCategories),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.program(7, program7, data),fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-dropdown\"> <div class=\"bv-dropdown-target bv-button-proxy\"> <button class=\"bv-focusable\" aria-haspopup=\"true\" role=\"menuitem\"> <span class=\"bv-dropdown-title\">";
  if (stack1 = helpers.categoryName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.categoryName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> ";
  options = {hash:{
    'classList': ("bv-dropdown-arrow"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-down-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-down-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_sort_arrow", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_sort_arrow", depth0.msgpack, depth0, options)))
    + "</span> </button> </div> <label for=\"bv-dropdown-select-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-off-screen\" aria-hidden=\"true\"> ";
  if (stack2 = helpers.categoryName) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.categoryName; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </label> <select id=\"bv-dropdown-select-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-select-cleanslate bv-dropdown-select\" aria-hidden=\"true\"> ";
  stack2 = helpers.each.call(depth0, depth0.subCategories, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </select> </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " &#x25BC; ";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <option value=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " </option> ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span class=\"bv-category-select-category-label\">";
  if (stack1 = helpers.categoryName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.categoryName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("category-select-target")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('categorySelect', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview A view that appears as a menu, typically in response to a
 *  hover or a click.
 */
BV.define('bv/ui-core/bselectdropdownview',[
  'ENV',
  'framework/bview',
  'framework/util/bvtracker',
  'underscore',
  'jquery',
  'document',
  'vendor/fastclick',
  'bv/ui-core/focusableview',
  'bv/util/productInfo',
  'util/specialKeys',
  'body'
], function (
  ENV,
  BView,
  BVTracker,
  _,
  $,
  document,
  FastClick,
  FocusableView,
  ProductInfo,
  specialKeys,
  body) {
  var dropdownClass = 'dropdown-container';
  var View = BView.extend(FocusableView);

  return View.extend({
    name: 'bselectdropdownview',

    classList: ['shared', dropdownClass],

    isEventManager: true,

    moveNextFocusable: true,

    options: {
      delay: 250,
      animDelay: 20,
      focusableClass: 'bv-focusable',
      containerClass: 'bv-absolute-top-container',
      cleanslateClass: 'bv-cleanslate bv-cv2-cleanslate',
      dropdownInClass: 'bv-dropdown-in',
      dropdownOutClass: 'bv-dropdown-out',
      dropdownClass: dropdownClass,
      allowToggle: false,
      startDelay: 120,
      rightAlign: false
    },

    events: {
      'click .bv-dropdown-item': 'select',
      'keydown .bv-dropdown-item': '_select'
    },

    enter: function (e) {
      // Stop any pending detach timeouts
      clearTimeout(this.keyEventId);
    },

    leave: function (e) {
      var self = this;

      if (this.parent.triggerElement) {
        $(this.parent.triggerElement).attr('aria-expanded', 'false');
      }
      else {
        this.parent.$targetEl.attr('aria-expanded', 'false');
      }

      // If we still have a focus layer, remove it
      this.removeFocusLayer();

      // Keep the view around for speed,
      // but get it out of the dom after a
      // grace period
      clearTimeout(this.keyEventId);
      this.keyEventId = setTimeout(function () {
        self.detach();
      }, this.options.delay);
    },

    // These are to encourage placement overrides
    topPositionModifier: function (pos) {
      return pos;
    },

    leftPositionModifier: function (pos) {
      return pos;
    },

    rightPositionModifier: function (pos) {
      return pos;
    },

    /**
     *  Renders the dropdown.
     *  @param {Object} data  Data to pass to the template.
     */
    render: function (data) {
      var self = this;
      // Make sure there is an element
      if (!this.$el || !this.$el.length) {
        this.$el = $('<div/>')
          .addClass(this.options.cleanslateClass)
          .addClass(this.options.containerClass)
          .addClass(this.options.dropdownOutClass);
      }

      if (this.options.aboveModestBox) {
        this.$el.addClass('bv-above-mbox');
      }

      // Inject the HTML.
      data = _.extend({}, data, {
        version: BView.config.version
      });
      this.$el.html(this.toHTML(data));

      // Get references to our DOM nodes.
      this.attach();

      new FastClick(this.$el.get(0));

      // Positioning is extracted into a method so that we can reposition
      // when orientation changes.
      this._position();

      this._positionHandler = function () {
        self._position();
      };

      $(document).on('orientationchange', this._positionHandler);

      if (!this.rendered) {
        // For CSS animations and stuff
        // Remove this if it's been here before
        this.$el.removeClass(this.options.dropdownInClass);

        // Inject it
        this.startKey = setTimeout(function () {
          self.$el.appendTo(body());

          // Wait a tiny bit and add the 'in' class
          setTimeout(function () {
            self.$el.addClass(self.options.dropdownInClass).removeClass(self.options.dropdownOutClass);
            self.model.trigger('dropdownRendered');
          }, self.options.animDelay);

          // Save the state
          self.rendered = true;
        }, this.options.startDelay);
      }
      else {
        clearTimeout(this.detachKey);
      }
    },

    _position: function () {
      var parentEl = this.parent.$targetEl.find('.bv-dropdown-target').first();
      var parentOffset = parentEl.offset();
      var width = this.width;
      var height = this.height;
      var $body = $(body());
      var parentMarginLeft = parseInt(parentEl.css('margin-left'), 10) || 0;
      var left;
      var bodyOffset;
      var elCSS;

      // Should appear directly below the parent element.
      var top = this.topPositionModifier(parentOffset.top) + parentEl.outerHeight();

      if (typeof width === 'function') {
        width = Math.ceil(width() + 10);
      }

      if (typeof height === 'function') {
        height = height();
      }

      if (this.options.rightAlign) {
        // Should have a `left` value such that its right edge is flush with
        // the parent's right edge.
        left = parentOffset.left + parentEl.outerWidth() - width - 2 + parentMarginLeft;
        left = this.rightPositionModifier(left);
      }

      if (left < 0 || !this.options.rightAlign) {
        // CCS-1410: If right alignment forces the left off the page,
        // use the parent's left offset to align instead of the negative value.
        left = this.leftPositionModifier(parentOffset.left);
      }

      // We're measuring offset from the top edge of the document, but
      // we're appending the dropdown inside of the BODY tag. If the top edge
      // of BODY isn't the same as the top edge of the document, _and_ if
      // BODY is not `position: static`, this discrepancy will matter. In
      // that rare case, we'll need to adjust for the BODY offset. See
      // CCS-5403.
      if ($body.css('position') !== 'static') {
        bodyOffset = $body.offset();
        top -= bodyOffset.top;
        left -= bodyOffset.left;
      }

      elCSS = {
        top: top + 'px',
        left: left + 'px',
        width: width + 'px',
        height: height + 'px'
      };

      // TODO: Build z-index management system. zims.
      // The outermost element gets most of the positioning.
      this.$el.css(elCSS);
    },

    detach: function (immediate) {
      var self = this;
      // TODO: Switch this to a handler on the `detach` event.
      View.prototype.detach.call(this);

      // Make sure any focus layer is cleared here
      this.removeFocusLayer();

      function detachFn () {
        self.$el.detach();

        // Save some more state
        self.rendered = false;
      }

      // Remove the fade in class
      self.$el.addClass(self.options.dropdownOutClass);

      $(document).off('orientationchange', this._positionHandler);

      clearTimeout(this.detachKey);
      if (immediate) {
        detachFn();
      }
      else {
        self.detachKey = setTimeout(detachFn, 260);
      }
    },

    _select: function (e) {
      if (e.keyCode === specialKeys.ENTER) {
        this.select(e);
      }
    },

    select: function (e) {
      var $elem = $(e.target).closest('[data-bv-dropdown-value]');
      var val = $elem.data('bv-dropdown-value').toString();
      var valInt = parseInt(val, 10);
      var detail1;
      var name;

      /**
       * When getting the value, we must ensure it is a string otherwise we
       * could encounter the case where we get a boolean value. Using a boolean
       * results in the filters no longer working.
       */

      if (!this.options.allowToggle && val === this._currentValue) {
        return;
      }

      this._currentValue = val;
      this.parent.$select.val(val).change();
      this.detach();
      this.parent.setText($.trim($elem.text()));

      if (valInt) {
        name = 'Filter';
        detail1 = val + 'Star' + ((valInt > 1) ? 's' : '');
      }
      else {
        name = 'Sort';
        detail1 = val;
      }

      BVTracker.feature({
        type: 'Used',
        name: name,
        detail1: detail1,
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        // Will be undefined until we can figure out how to get categoryId here
        categoryId: ProductInfo.getCategoryId(this)
      });
    },

    attach: function () {
      // Call the normal bview attach
      var res = BView.prototype.attach.apply(this, arguments);
      var options = this.options;

      // Use jQuery to do mouseenter and mouseleave, because they're best.
      // But proxy the functions so everything is always in a View Instance scope
      this.$el.find('.bv-' + options.dropdownClass)
        .off('mouseenter').on('mouseenter', $.proxy(this.enter, this))
        .off('mouseleave').on('mouseleave', $.proxy(this.leave, this));

      // Identify focusables in the popup
      this.$focusables = this.$el.find('.' + options.focusableClass);

      // Cache these
      this.$first = this.$focusables.first();
      this.$last = this.$focusables.last();

      // We keep a reference to this focus layer's ID so that we can be
      // certain that we're deregistering the same layer later on. Because of
      // the fun timing issues of floating views, another focusable layer
      // might be on top by the time we get around to deregistering.
      this.focusLayer = this.registerFocusableLayer(this.$el, '.' + options.focusableClass);
      this.listenTo(ENV, 'focusLayerRemoved', this.focusLayerRemoved);

      // Show/hide the dropdown on hover.
      this.$('ul').hover(
        function () {
          $(this).addClass('bv-dropdown-active');
        },
        function () {
          $(this).removeClass('bv-dropdown-active');
        }
      );

      // More event handling specifically for keyboard nav
      this.setupKeyboardNavigation();

      // Return whatever the super function returned before
      return res;
    },

    setupKeyboardNavigation: function () {
      var self = this;
      var $filterSelectButton;

      self.$focusables.off('focus.bselectddv').on('focus.bselectddv', function () {
        $(this).parent('ul').addClass('bv-dropdown-active');
        $(this).addClass('bv-dropdown-item-hover');
        clearTimeout(self.keyEventId);
      });
      self.$focusables.off('blur.bselectddv').on('blur.bselectddv', function () {
        $(this).parent('ul').removeClass('bv-dropdown-active');
        $(this).removeClass('bv-dropdown-item-hover');
      });
      self.$focusables.off('keydown.bselectddv').on('keydown.bselectddv', function (e) {
        if (e.keyCode === specialKeys.ESCAPE) {
          e.preventDefault();
          e.stopPropagation();
          self.deregisterFocusableLayerById(self.focusLayer);
          // Set focus to dropdown button filter select button. See UIA-9226.
          $filterSelectButton = self.parent.$targetEl.find('button.bv-focusable');
          self.moveFocus($filterSelectButton);
        }
      });
    },

    focusLayerRemoved: function (e) {
      if (e.focusLayer.$layerRoot === this.$el) {
        delete this.focusLayer;
        this.leave();
      }
    },

    removeFocusLayer: function () {
      // If we have a focus layer property, that means that we still have a
      // registered focus layer, so we'll remove the key, stop listening for
      // subsequent removal, and deregister our layer.
      if (this.focusLayer) {
        this.stopListening(ENV, 'focusLayerRemoved');
        this.deregisterFocusableLayerById(this.focusLayer);
        delete this.focusLayer;
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!categorySelectDropdown',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/exists'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]><div class=\"bv-compat\"><![endif]--> <div class=\"bv-dropdown\"> <ul role=\"menuitem\"> ";
  stack1 = helpers.each.call(depth0, depth0.subCategories, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </ul> </div> <!--[if gte IE 7]></div><![endif]--> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.exists),stack1 ? stack1.call(depth0, depth0.Name, options) : helperMissing.call(depth0, "exists", depth0.Name, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <li class=\"bv-dropdown-item bv-focusable\" data-bv-dropdown-value=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" tabindex=\"0\" role=\"menuitem\"> ";
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " </li> ";
  return buffer;
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("select-dropdown")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('categorySelectDropdown', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/categorySelectDropdown',[
  'bv/ui-core/bselectdropdownview',
  'underscore',
  'hbs!categorySelectDropdown',
  'bv/util/focusManager',
  'mf!bv/c2013/messages/genericSubmission',
  'util/specialKeys',
  'jquery'
], function (BSelectDropdownView, _, template, focusManager, msgPack, specialKeys, $) {
  return BSelectDropdownView.extend({
    name: 'categorySelectDropdown',
    width: 226,
    height: 400,
    template: template,
    msgpacks: [msgPack],

    init: function () {
      this.classList.push('category-select-dropdown');
      this.options.rightAlign = true;
    },

    topPositionModifier: function (pos) {
      return pos + 5;
    },

    rightPositionModifier: function (pos) {
      return pos + 15;
    },

    select: function (e) {
      this.detach();
      this.deregisterFocusableLayer(true);
      this.parent.change(e);
    },

    setupKeyboardNavigation: function () {
      var self = this;
      var keysToHandle = {};

      _(['TAB', 'SPACE', 'UP', 'DOWN']).each(function (k) {
        keysToHandle[specialKeys[k]] = true;
      });

      // Overriding bselectdropdown keyboard nav behavior.
      self.$focusables.off('focus').on('focus', function () {
        $(this).parent('ul').addClass('bv-dropdown-active');
        $(this).addClass('bv-dropdown-item-hover');
        clearTimeout(self.keyEventId);
      });

      self.$focusables.off('blur').on('blur', function () {
        $(this).parent('ul').removeClass('bv-dropdown-active');
        $(this).removeClass('bv-dropdown-item-hover');
      });

      // Use keyup for listening to the escape key since that is what ModestBox uses
      self.$focusables.off('keyup').on('keyup', function (e) {
        if (e.keyCode === specialKeys.ESCAPE) {
          e.preventDefault();
          e.stopPropagation();
          self.deregisterFocusableLayer();
        }
      });

      self.$el.off('keydown.CategorySelectDropdownView').on('keydown.CategorySelectDropdownView', function (e) {
        var keyCode = e.keyCode;

        if (!keysToHandle[keyCode]) { return; }

        var stopEvent = false;

        switch (keyCode) {
          case specialKeys.TAB:
            stopEvent = true;
            self.leave(e);
            var method = e.shiftKey ? 'focusPrev' : 'focusNext';
            focusManager[method]();
            break;
          case specialKeys.SPACE:
            stopEvent = true;
            $(e.target).click();
            break;
          case specialKeys.UP:
            if (document.activeElement === self.$first[0]) {
              stopEvent = true;
              focusManager.moveFocus(self.$last);
            }
            break;
          case specialKeys.DOWN:
            if (document.activeElement === self.$last[0]) {
              stopEvent = true;
              focusManager.moveFocus(self.$first);
            }
            break;
        }

        if (stopEvent) {
          e.preventDefault();
          e.stopPropagation();
        }
      });
    }
  });
});

BV.define('bv/c2013/view/categorySelect',[
  'bv/ui-core/bselectview',
  'underscore',
  'hbs!categorySelect',
  'bv/c2013/view/categorySelectDropdown',
  'mf!bv/c2013/messages/genericSubmission',
  'jquery',
  'document',
  'bv/util/focusManager',
  'util/specialKeys'
], function (BSelectView, _, template, CategorySelectDropdown, msgPack, $, document, focusManager, specialKeys) {
  return BSelectView.extend({
    targetEl: '.bv-category-select-target',
    selectEl: '.bv-dropdown-select',
    name: 'categorySelect',
    events: {
      'change select': 'change'
    },
    template: template,
    TargetView: CategorySelectDropdown,
    msgpacks: [msgPack],

    change: function (e) {
      var $elem = $(e.target).closest('[data-bv-dropdown-value]');
      var val = $elem.data('bv-dropdown-value');
      this.model.categorySelected(val);
    },

    // Handle focus
    setupKeyboardNavigation: function ($targetEl) {
      var self = this;
      $targetEl = $targetEl || self.$targetEl;
      // This is intentionally overriding bhoverableview's behavior.
      $targetEl.off('click.bhoverableview').on('click.bhoverableview', function (e) {
        e.preventDefault();
        e.stopPropagation();
        // JAWS and IE will not handle arrow keys properly unless we move
        // focus to the containing div first, then open the dropdown, then focus back on the target element.
        self.$viewEl.find('.bv-button-proxy')[0].focus();
        self.targetViewOptions = _.extend({}, self.targetViewOptions, { startDelay: 0 });
        self.enter(e);
        $targetEl[0].focus();
      });
      // Close the dropdown when escape is pressed.
      $targetEl.off('keyup.categorySelect').on('keyup.categorySelect', function (e) {
        if (e.keyCode === specialKeys.ESCAPE) {
          self.leave(e);
          e.preventDefault();
          e.stopPropagation();
        }
      });
    }
  });
});

BV.define('mf!bv/c2013/messages/productItemCollection',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"product_item_collection_no_results" : function (x) { try { return (function(d){
var r = "";
r += "No products found";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `product_item_collection_no_results`: ' + e.toString() ) ] ); return ""; } },"product_item_collection_in_category" : function (x) { try { return (function(d){
var r = "";
r += "in";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `product_item_collection_in_category`: ' + e.toString() ) ] ); return ""; } },"product_item_collection_other_categories" : function (x) { try { return (function(d){
var r = "";
r += "in all categories";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `product_item_collection_other_categories`: ' + e.toString() ) ] ); return ""; } }
};
});

/**
 *  @fileOverview This is the collection that holds a list of products for
 *  display during generic review submission.
 */
BV.define('bv/c2013/collection/productItemCollection',[
  'framework/bcollection',
  'framework/bmodel',
  'underscore',
  'bv/api/fetch',
  'util/url',
  'ENV',
  'bv/util/pageInfo',
  'mf!bv/c2013/messages/productItemCollection'
], function ProductItemCollection (
  BCollection,
  BModel,
  _,
  api,
  url,
  ENV,
  pageInfo,
  msgPack
) {
  return BCollection.extend({
    name: 'productItemCollection',
    pageSize: 12,
    model: BModel,

    init: function init (models, config) {
      var clientAPIConfig;

      _(this).extend(config);
      clientAPIConfig = this.getComponent().clientAPIConfig;
      this.categoryId = clientAPIConfig.categoryId;
      this.rootCategoryId = clientAPIConfig.withCategoryList ? this.categoryId : -1;
      this.showProductList = !clientAPIConfig.withCategoryList;
      this.familyProductId = clientAPIConfig.familyProductId;
      this.productsPerRow = this.getComponent().productsPerRow || 4;
      this.subscribe({
        searchcontent: this.fetchProducts,
        searchcleared: this.clearProducts,
        'change:categoryId': this.clearProducts
      });
      if (!this.hasFeature('searchOnly')) {
        this.subscribe({
          pageto: this.fetchProducts
        });
      }
      else {
        this.isSearchOnly = true;
        // do nothing on the inital pageto, but listen for subsequent pages
        this.subscribeOnce('pageto', function oncePageTo () {
          this.subscribe('pageto', this.fetchProducts);
        });
      }
    },

    attachDataReady: function attachDataReady () {
      this.on('productDataReady', function onPRoductDataReady (data, reset) {
        var myPageInfo = pageInfo(
          'product',
          this.currentPage,
          data.TotalResults === 0 ? 0 : data.Results.length,
          data.TotalResults,
          this.pageSize,
          false
        );

        // we always use loadMore so start is always 1 unless it is the last page
        myPageInfo.start = myPageInfo.orphanEnd ? myPageInfo.total : 1;

        if (reset) {
          this.reset();
        }

        this.loadMore(data.Results);

        if (data.TotalResults === 0) {
          myPageInfo.message = msgPack.product_item_collection_no_results();
        }

        if (this.isSearchOnly) {
          myPageInfo.inlineMessage = msgPack.product_item_collection_other_categories();
        }

        else {
          myPageInfo.inlineMessage = msgPack.product_item_collection_in_category();
        }

        // _dataReadyDfd is resolved when dataReady is called, so this check
        // just ensures that dataReady is only called once (the first time we
        // get productData).
        if (this._dataReadyDfd.state() !== 'resolved') {
          this.dataReady(data);
          this.dataProcessed(data);
        }

        this.publish('pageinfo', myPageInfo, { instanceName: this.getInstanceName() });
      });

      // If we only respond to search events or are disabled from display we
      // have no initial results
      if (this.isSearchOnly || !this.showProductList) {
        this.trigger('productDataReady', {
          Results: [],
          TotalResults: 0
        }, false);
      }
    },

    /**
     * Request products by category from the dev api.
     *
     * @param clientAPIConfig : The client api configuration
     */
    fetchProducts: function fetchProducts (pageNum, searchText, pagingSrc) {
      var self = this;
      var productsRequest;

      if (!this.showProductList) {
        if (!searchText) {
          return;
        }
        else {
          // If we are searching show the product list no matter what
          this.showProductList = true;
        }
      }
      // if productCollection instance doesn't match pagingSrc instance bailout
      if (this.hasFeature('instanceNameScope') && pagingSrc) {
        if (pagingSrc.instanceName !== this.getInstanceName()) {
          return;
        }
      }
      // if we have search text and no category then we dont want to request data for
      // productCollection:unfiltered because we are doing a full-category search
      if (this.hasFeature('instanceNameScope') && searchText) {
        // will be undefined on initialization, and set to null when category is selected
        // and then 'return to all categories' is selected in dropdown
        if (this.getInstanceName() === 'unfiltered' &&
          ((typeof (this.categoryId) === 'undefined') || this.categoryId === null)) {
          return;
        }
      }

      this.currentPage = pageNum;

      if (searchText) {
        if (searchText === '') {
          this.searchText = null;
        }
        else {
          this.searchText = searchText;
        }
      }

      productsRequest = api.get('products')
        .offset((pageNum - 1) * this.pageSize)
        .sortBy('asc', 'Name')
        .limit(this.pageSize)
        .filterBy('isActive');

      if (!this.familyProductId) {
        if (this.categoryId) {
          if (this.hasFeature('filterByCategory')) {
            productsRequest.filterBy('categoryancestorid', '=', this.categoryId);
          }

          else if (this.hasFeature('filterWithoutCategory')) {
            productsRequest.filterBy('categoryancestorid', '!=', this.categoryId);
          }
        }

        if (this.searchText) {
          productsRequest.searchFor(this.searchText);
        }
      }
      else {
        // We can only request a max of 20 products in a family due to a Dev API limitation :(.
        productsRequest
          .filterBy('id', '=', this.familyProductId)
          .include('products')
          .filterIncluded('products')
          .by('isActive', '=', true)
          .limitIncluded('products').to(20);
      }

      productsRequest.fetch(self.name).done(function productsRequestFetchDone (_data) {
        var data = _data.data;

        if (
          self.familyProductId &&
          data &&
          data.Results &&
          data.Includes &&
          data.Includes.Products
        ) {
          _(data.Includes.ProductsOrder).forEach(function forEachProductId (productId) {
            var productToAdd = data.Includes.Products[productId];

            // Only push if it's not already in data.Results
            if (!_(data.Results).contains(productToAdd)) {
              data.Results.push(productToAdd);
            }
          });
        }

        // API can send us "empty" products. This is a bug/limitation of
        // Concierge. We'll need to filter out these empty products. We need
        // to filter out products that don't have the necessary fields. We're
        // pretty safe to check for Name and ImageUrl, as those are the two
        // we'll need to display the product.
        // Fortunately, the ProductItemCollection will load more products as
        // soon as we get to the bottom of the container, so we don't have
        // to worry about loading more products here.
        // See CCS-4466 for details.
        if (data && data.Results) {
          data.Results = _.filter(data.Results, function filterProductInfo (productInfo) {
            return productInfo.Name && productInfo.ImageUrl;
          });
        }

        self.trigger('productDataReady', data, !!searchText);
      });
    },

    clearProducts: function clearProducts (categoryId) {
      if (categoryId !== undefined) {
        this.categoryId = categoryId;
        this.showProductList = categoryId !== this.rootCategoryId;
      }
      else {
        this.showProductList = this.categoryId !== this.rootCategoryId;
      }

      this.reset();
      delete this.searchText;

      if (this.isSearchOnly || !this.showProductList) {
        // Clear out data when search is cleared
        this.trigger('productDataReady', {
          Results: [],
          TotalResults: 0
        }, false);
      }
      else {
        this.fetchProducts(1);
      }
    },

    productItemSelected: function productItemSelected (productId) {
      this.publish('productItemSelected', productId);
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!productItems',['hbs','vendor/handlebars/runtime', 'template/helpers/ensureProtocolRelative'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.Id, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-product-item\"> <button type=\"button\" class=\"bv-product-item-btn bv-focusable\" aria-label=\"";
  if (stack1 = helpers.Name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" data-bv-product-id=\"";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <ul class=\"bv-content-media-container\"> <li class=\"bv-media-item bv-media-item-photo\" itemprop=\"image\" itemscope itemtype=\"http://schema.org/ImageObject\"> <div class=\"bv-media-item-wrapper\"> <meta itemprop=\"image\" content=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ensureProtocolRelative),stack1 ? stack1.call(depth0, depth0.ImageUrl, options) : helperMissing.call(depth0, "ensureProtocolRelative", depth0.ImageUrl, options)))
    + "\"> <img src=\"";
  if (stack2 = helpers.ImageUrl) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.ImageUrl; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" alt=\"\" title=\"";
  if (stack2 = helpers.Name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " - ";
  if (stack2 = helpers.Id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </div> </li> <li class=\"bv-media-item-name\">";
  if (stack2 = helpers.Name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</li> ";
  stack2 = helpers.each.call(depth0, depth0.ModelNumbers, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> </button> </li> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "";
  buffer += " <li class=\"bv-media-item-name\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</li> ";
  return buffer;
  }

  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('productItems', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!productItemCollection',['hbs','vendor/handlebars/runtime','hbs!productItems', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.productItems, 'productItems', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("ol"),
    'alwaysRender': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('productItemCollection', t);
t.deps = ["productItems"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/productItemCollection',[
  'ENV',
  'framework/bview',
  'hbs!productItemCollection',
  'hbs!productItems',
  'bv/ui-core/focusableview',
  'jquery',
  'underscore',
  'bv/util/loadingOverlay'
], function (ENV, BView, template, productItemsTemplate, FocusableView, $, _, LoadingOverlay) {
  var View = BView.extend(FocusableView);
  return View.extend({
    name: 'productItemCollection',
    template: template,
    events: {
      'click .bv-product-item-btn': 'productItemSelected'
    },
    classList: ['product-list'],

    init: function () {
      this.classList.push('product-list-' + this.model.productsPerRow + '-col');
    },

    modelDataReady: function () {
      BView.prototype.modelDataReady.call(this);

      // After the model's initial data is ready, listen for changes.
      this.listenTo(this.model, {
        loadmore: this.loadMore
      });

      this.model.on('reset', this.reset, this);
    },

    reset: function () {
      this.render();
      this.rescanFocusLayer();
    },

    loadMore: function (collection, loadedContent) {
      var data = _(loadedContent).map(function (c) {
        return c.toJSON();
      });
      var resultHTML = productItemsTemplate(data);
      this.$viewEl.append(resultHTML);
      this.rescanFocusLayer();
      if (this.model.searchText) {
        this.$viewEl.find('.bv-media-item-name').bvhighlight({ searchFor: this.model.searchText });
      }
      LoadingOverlay.hide();
    },

    productItemSelected: function (e) {
      var selectedProductId = $(e.currentTarget).attr('data-bv-product-id');
      this.model.productItemSelected(selectedProductId);
    }
  });
});

BV.define('bv/c2013/model/ratingItem',[
  'ENV',
  'framework/bmodel',
  'underscore'
], function (ENV, BModel, _) {
  return BModel.extend({
    options: {},
    name: 'ratingItem',

    init: function (config, options) {
      _.extend(this.options, options);
    },

    index: function () {
      return this.get('parent').indexOf(this);
    },

    remove: function (options) {
      this.get('parent').remove(this, options);
    },

    toJSON: function () {
      return {
        Product: this.get('Product'),
        ClientName: ENV.get('config').clientname,
        IsRatingItem: true
      };
    }
  });
});

/**
 * @fileOverview The collection that manages rating items, used for
 * inline ratings.
 */
BV.define('bv/c2013/collection/ratingItemCollection',[
  'framework/bcollection',
  'underscore',
  'bv/c2013/model/ratingItem',
  'bv/api/fetch',
  'util/url',
  'util/array',
  'ENV',
  'jquery',
  'vendor/json2',
  'framework/util/ie',
  'bv/api/util/statsRequest'
],
function (BCollection, _, RatingItem, api, url, array, ENV, $, JSON, IE, statsRequest) {
  IE = IE();

  return BCollection.extend({
    model: RatingItem,
    name: 'ratingItemCollection',
    statsTypes: ['Reviews'],

    /**
     * Process product IDs we get from clientAPIConfig.
     *
     * Use lowercased product ID as `key`
     * Save client input product ID in `_Id`
     *
     * Example of processed product item:
     *
     * {
     *   product1 : {
     *     _Id           : 'Product1',
     *     _Url          : 'http://testclient.com/products/product1',
     *     _ContainerId  : 'BVRRInlineRating_Product1_temp'
     *   }
     * }
     *
     */
    _processProductIds: function (productIds) {
      var result = {};
      _(productIds).each(function (product, key) {
        var productItem;
        var pid;

        if (product) {
          if (_(product).isObject()) {
            // The clientAPI code may have previously processed the keys
            // on the objects in `productIds`, so `key` will be lowercased.
            // In that scenario, we'll have an `_origId` property, so we'll
            // use that for `_Id`, falling back to `key`. (UIA-3594)
            productItem = {
              _Id: product._origId || key
            };

            if (!_(product.url).isEmpty()) {
              productItem._Url = product.url;
            }

            if (!_(product.containerId).isEmpty()) {
              productItem._ContainerId = product.containerId;
            }

            result[key.toLowerCase()] = productItem;
          }
          else {
            pid = (product + '').toLowerCase();
            result[pid] = {
              _Id: $.trim(product + '')
            };
          }
        }
      });
      return result;
    },

    /**
     * Chunk up the product Ids array to an appropriate sized array.
     * API allows up to 100 products per requrest.
     * Thus, if inline rating contains more than 100 products, we need to chunk it up into multiple requests.
     *
     * @param {Array} productIds : an array of product ids.
     *
     * @returns {Array} : an array of multiple arrays.
     */
    _chunkProductIds: function (productIds) {
      var chunks = array.chunk(productIds, 100);
      var urlLimit = (IE && IE < 9) ? 1800 : null;

      var totalChunks = [];
      _(chunks).forEach(function (chunk) {
        var arrayChunks = array.chunkWithLimit(chunk, Number.MAX_VALUE, function (id) { return id.length; }, urlLimit);
        totalChunks = totalChunks.concat(arrayChunks);
      });
      return totalChunks;
    },

    /**
     * Request content from the dev api.
     *
     * @param clientAPIConfig : The client api configuration
     * @param filters : extra filters to apply to the request
     */
    fetchContent: function (clientAPIConfig, filters) {
      var self = this;
      var inputProductIds = _(clientAPIConfig.productIds).isString() ?
        clientAPIConfig.productIds.split(',') :
        clientAPIConfig.productIds;
      var productIds = this._processProductIds(inputProductIds);
      var subjectIds = this.subjectIds = _(productIds).keys();
      var arrayChunks;

      if (_(subjectIds).isEmpty()) {
        return;
      }

      arrayChunks = this._chunkProductIds(subjectIds);

      _(arrayChunks).forEach(function (requestIds, index) {
        var statisticsRequest = api.get('statistics').withStatsOn(self.statsTypes);
        var productNames = {};
        var productsRequest = api.get('products');
        statisticsRequest.filterBy('productid', requestIds.join());
        statisticsRequest.limit(requestIds.length);
        productsRequest.filterBy('id', requestIds.join());
        productsRequest.limit(requestIds.length);

        productsRequest.fetch(self.name).done(function productsRequestFetchDone (_data) {
          var data = _data.data;

          if (
            data &&
            data.Results &&
            data.Includes &&
            data.Includes.Products
          ) {
            _(data.Includes.Products).forEach(function forEachProductId (product) {
              productNames[product.Id] = { Id: product.Id, Name: product.Name };
            });
          }
        });

        statisticsRequest.fetch('inlineRatings' + index).done(function (contentData) {
          // Deep-copy this data so that the properties we append to it are
          // only ours.
          //
          // TODO: It is, of course, _ridiculous_ that we're messing with
          // this data in the first place, and that will be addressed in a
          // refactor.
          var list = JSON.parse(JSON.stringify(contentData.data.Results));
          var existIds;
          var missingIds;

          // Adding the appropriate product names
          _(list).each(function (product) {
            product.Product.Name = productNames[product.Product.Id].Name;
          });

          // If we are missing statistics for some products,
          // we need to add them.
          if (contentData.data.TotalResults < requestIds.length) {
            existIds = _(list).map(function (item) {
              return item.Product.Id.toLowerCase();
            });
            missingIds = _.difference(requestIds, existIds);
            _(missingIds).each(function (pid) {
              var obj = {
                Product: {
                  Id: pid,
                  Reviews: {
                    Statistics: {
                      AverageOverallRating: 0,
                      OverallRatingRange: 5,
                      TotalCount: 0,
                      TotalReviewCount: 0
                    }
                  }
                },
                Type: 'statistics'
              };
              list.push(obj);
            });
            contentData.data.TotalResults = requestIds.length;
          }

          self._addClientInputs(list, requestIds, productIds);
          self.add(list);
        });

      });

    },

    _addClientInputs: function (list, filterIds, productIds) {
      _(list).map(function (item) {
        var lowerCaseId = item.Product.Id.toLowerCase();
        if (_(filterIds).contains(lowerCaseId)) {
          _(item.Product).extend(productIds[lowerCaseId]);
        }
        return item;
      });
    }

  });
});

BV.define('bv/c2013/model/ratingList',[
  'ENV',
  'jquery',
  'framework/bmodel',
  'util/url',
  'underscore',
  'bv/c2013/collection/ratingItemCollection',
  'bv/util/pageInfo',
  'BV',
  'bv/api'
],
function (ENV, $, BModel, url, _, ratingItemCollection, pageInfo, BV, api) {
  return BModel.extend({
    options: {},
    name: 'ratingList',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);

      // listen for paging requests for some reason
      this.subscribe('pageto', this.fetchContent);
      var contentCollection = this.get('content');
      this.dataReady();
    },

    setupDataProcessing: function () {
    },

    _initContent: function () {
      var contentCollection;
      // If we have a ratingItemCollection feature use it, else bail.
      contentCollection = this.getFeatureModel('ratingItemCollection');
      if (ratingItemCollection) {
        this.set({ content: contentCollection }, { silent: true });
        return contentCollection;
      }
      return null;
    },

    processData: function (data) {
    },

    getSubject: function () {
      // Eventually need to make this handle other types?
      return {
        type: 'statistic',
        ids: this.get('clientAPIConfig').productIds,
        contentType: this.get('contentType')
      };
    },

    toJSON: function () {
      return BModel.prototype.toJSON.call(this);
    },

    getContent: function () {
      var content = this.get('content');
      if (!content) {
        // If there is no content, see if we have loaded the content feature
        // and use that, else bail.
        content = this._initContent();
        if (!content) {
          return;
        }
      }
      return content;
    },

    /**
     * Tell our content collection to fetch new content from the server.
     *
     * @param {Boolean} force
     */
    fetchContent: function (force) {
      if (this.getComponent().model !== this) {
        return;
      }

      var filters = this.get('activeFilters');

      var content = this.getContent();

      // If we haven't processed data, but there is initial data, there is no
      // reason to fetch data again.
      if (this.dataReadyPromise().state() !== 'resolved' && this.componentGet('initData')) {
        return;
      }
      content.fetchContent(this.get('clientAPIConfig'), filters);
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!ratingList',['hbs','vendor/handlebars/runtime', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " ";
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("ratingList")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  return buffer;
  });
Handlebars.registerPartial('ratingList', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/ratingList',[
  'framework/bview',
  'underscore',
  'jquery',
  'hbs!ratingList',
  'window',
  'bv/api',
  'bv/util/productInfo',
  'framework/util/bvtracker'
],
function (BView, _, $, template, window, api, ProductInfo, BVTracker) {
  return BView.extend({
    name: 'ratingList',

    events: {
      'mouseenter .bv-shared': 'hoverAnalytics'
    },

    classList: ['core-container-' + BView.config.version],

    template: template,

    /**
     *  Override BView.prototype.toHTML
     *
     *  When called with zero or one arguments, returns an HTML string.
     *
     *  When called with two or more, returns a promise of an HTML string.
    **/
    toHTML: function (data_mixin, isAsync) {
      // this is a dummy top component
      // we don't really need anything to be rendered here.

      if (arguments.length < 2) {
        // isAsync was not provided, so adhere to the synchronous contract
        return '';
      }

      // isAsync was provided. regardless of its value, adhere to the async
      // contract and return a promise
      return $.Deferred().resolve('').promise();
    },

    hoverAnalytics: function (e) {
      BVTracker.feature({
        type: 'Used',
        name: 'Hover',
        detail1: 'InlineRatingDisplay',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!prsStars',['hbs','vendor/handlebars/runtime', 'template/helpers/renderIcon', 'template/helpers/loop', 'template/helpers/ratingIconChar', 'template/helpers/percentage', 'template/helpers/ifHasFeature', 'template/helpers/notEqual', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'classList': ("bv-rating-stars bv-rating-stars-off"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.programWithDepth(program2, data, depth1)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-prs-rating-stars-off", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-prs-rating-stars-off", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-rating-stars-on bv-rating-stars bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.AverageOverallRating, depth0.OverallRatingRange, 1, options) : helperMissing.call(depth0, "percentage", depth0.AverageOverallRating, depth0.OverallRatingRange, 1, options)))
    + "\" aria-hidden=\"true\"> ";
  stack2 = helpers.unless.call(depth0, depth1.IsRatingItem, {hash:{},inverse:self.program(6, program6, data),fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }
function program2(depth0,data,depth2) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth2.IsRatingItem, {hash:{},inverse:self.program(6, program6, data),fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.OverallRatingRange, depth0, options) : helperMissing.call(depth0, "loop", depth0.OverallRatingRange, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var stack1, options;
  options = {hash:{}};
  return escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "prs-rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "prs-rating-stars-on", options)));
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.OverallRatingRange, depth0, options) : helperMissing.call(depth0, "loop", depth0.OverallRatingRange, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var stack1, options;
  options = {hash:{}};
  return escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "category-rating-on", options) : helperMissing.call(depth0, "ratingIconChar", "category-rating-on", options)));
  }

function program9(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <meta itemprop=\"bestRating\" content=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.OverallRatingRange)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/> ";
  return buffer;
  }

function program12(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.TotalCount, {hash:{},inverse:self.programWithDepth(program15, data, depth1),fn:self.programWithDepth(program13, data, depth1)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program13(depth0,data,depth2) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_summaryStars", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_summaryStars", depth2.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth2.Product),stack1 == null || stack1 === false ? stack1 : stack1.Name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> ";
  return buffer;
  }

function program15(depth0,data,depth2) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_summaryStarsNoValue", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_summaryStarsNoValue", depth2.msgpack, depth0, options)))
    + " "
    + escapeExpression(((stack1 = ((stack1 = depth2.Product),stack1 == null || stack1 === false ? stack1 : stack1.Name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> ";
  return buffer;
  }

  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program9, data, depth0)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.programWithDepth(program12, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('prsStars', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!prsOverallRating',['hbs','vendor/handlebars/runtime', 'template/helpers/ifHasFeature', 'template/helpers/fixedNumber', 'template/helpers/mountView'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "histogram", depth0, options) : helperMissing.call(depth0, "mountView", "histogram", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-rating\"><span";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1._Url), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " aria-hidden=\"true\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.fixedNumber),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), 1, options) : helperMissing.call(depth0, "fixedNumber", ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), 1, options)))
    + "</span></span> ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " class=\"bv-text-link\"";
  }

function program6(depth0,data) {
  
  
  return " itemprop=\"ratingValue\"";
  }

  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "histogram", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "histogram", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('prsOverallRating', t);
t.deps = [];
t.tplMountedViews = ['histogram'];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_categoryTotalReviewCount', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function categoryTotalReviewCount( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "(";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += ")";
return r;
},
"other" : function(d){
var r = "";
r += "(";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += ")";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `categoryTotalReviewCount`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_categoryTotalReviewCount', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return categoryTotalReviewCount(data);
});
return categoryTotalReviewCount;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!categoryTotalCount',['hbs','vendor/handlebars/runtime', '_i18n_categoryTotalReviewCount'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  
  return " bv-text-link";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_categoryTotalReviewCount),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_categoryTotalReviewCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  buffer += "<span class=\"bv-rating-label";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1._Url), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> ";
  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  });
Handlebars.registerPartial('categoryTotalCount', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!categoryStars',['hbs','vendor/handlebars/runtime','hbs!prsStars', 'hbs!prsOverallRating', 'hbs!categoryTotalCount', 'template/helpers/ifHasFeature', 'template/helpers/notEqual'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "stars", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "stars", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "overallRating", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "overallRating", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(21, program21, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "reviewCount", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "reviewCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <dl class=\"bv-stars-container\" itemprop=\"aggregateRating\" itemscope itemtype=\"http://schema.org/AggregateRating\" role=\"presentation\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " ";
  }

function program6(depth0,data) {
  
  
  return " <dl class=\"bv-stars-container\"> ";
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <dt class=\"bv-rating-ratio\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1._Url), {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.prsStars, 'prsStars', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1._Url), {hash:{},inverse:self.program(16, program16, data),fn:self.program(14, program14, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dd> ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <a href=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1._Url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-rating-stars-container bv-focusable\"> ";
  return buffer;
  }

function program12(depth0,data) {
  
  
  return " <span class=\"bv-rating-stars-container\"> ";
  }

function program14(depth0,data) {
  
  
  return " </a> ";
  }

function program16(depth0,data) {
  
  
  return " </span> ";
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), {hash:{},inverse:self.noop,fn:self.program(19, program19, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dd class=\"bv-rating-ratio-number\"> ";
  stack1 = self.invokePartial(partials.prsOverallRating, 'prsOverallRating', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dd> ";
  return buffer;
  }

function program21(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.program(22, program22, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program22(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dd class=\"bv-rating-ratio-count\"> ";
  stack1 = self.invokePartial(partials.categoryTotalCount, 'categoryTotalCount', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dd> ";
  return buffer;
  }

  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('categoryStars', t);
t.deps = ["prsStars","prsOverallRating","categoryTotalCount"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!ratingItem',['hbs','vendor/handlebars/runtime','hbs!categoryStars', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-inline-rating-container\"> ";
  stack1 = self.invokePartial(partials.categoryStars, 'categoryStars', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> </div> ";
  return buffer;
  }

  buffer += " <div class=\"bv-cleanslate bv-cv2-cleanslate\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div>";
  return buffer;
  });
Handlebars.registerPartial('ratingItem', t);
t.deps = ["categoryStars"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 *  @fileOverview View for ratingItem.
 */
BV.define('bv/c2013/view/ratingItem',[
  'framework/bview',
  'framework/util/bvtracker',
  'bv/strings',
  'hbs!ratingItem',
  'mf!bv/c2013/messages/common',
  'jquery',
  'bv/api',
  'window'
], function (BView, BVTracker, str, template, msgPackCommon, $, api, window) {

  return BView.extend({

    name: 'ratingItem',

    template: template,

    msgpacks: [msgPackCommon],

    classList: ['core-container-' + BView.config.version],

    // This view should act as its own event manager since it will render
    // into its own disjoint injection zone.
    isEventManager: true,

    events: {
      'click .bv-rating-ratio-number': 'goToProductUrl',
      'click .bv-rating-ratio-count': 'goToProductUrl'
    },

    attach: function (elToAttach) {
      var self = this;
      var product = self.model.get('Product');

      self.triedOnce = false;

      if (!product || (!self.containerPrefix && !product._ContainerId)) {
        return;
      }

      self._findAndRender();
    },

    _findAndRender: function () {
      var self = this;
      var product = self.model.get('Product');

      // Look for an element to render into, using one of the following selectors,
      // ordered by priority:

      // 1. The container ID itself, if explicitly specified;
      var containerId = product._ContainerId;

      // 2. Use an implied selector, using the original product ID
      var selector = '#' + self.containerPrefix + '-' + product._Id;

      // 3. An implied selector, with a lowercased version of the ID
      var selectorLowerCase = '#' + self.containerPrefix + '-' + product.Id.toLowerCase();

      // The containerId check here is because product._ContainerId could be undefined;
      // without this check, we'd end up doing $('#undefined')[0], which finds an element
      // more often than you'd like to think (see UIA-2977)
      var targetEl = (containerId && $('#' + containerId)[0]) || $(selector)[0] || $(selectorLowerCase)[0];

      if (targetEl) {
        // If we found what we're looking for, render
        self._renderRating($(targetEl));
      }
      else {
        // If we didn't find the target element, check to see if the document was ready when
        // we looked, or if we've already looked once. If either of these things are true, we're
        // not going to find the element we're looking for, so throw an error.
        if ($.isReady || self.triedOnce) {
          BVTracker.error({
            name: str.errors.IMPLEMENTATION,
            detail1: 'Could not find required element for inline ratings'
          });
          return;
        }

        // If we think there's still a chance of finding the element, we'll
        // look for it again on document ready.
        self.triedOnce = true;

        $(function () {
          self._findAndRender();
        });
      }
    },

    _renderRating: function ($targetEl) {
      if ($targetEl.length > 0) {
        this.setElement($targetEl.empty()[0]);
        this.$el.append(this.toHTML());

        // Since we skip the `attach` method here, we need to do a few things
        // manually.
        this.$viewEl = this.$el.find(this.selector());
        this.getEventManager().delegateSubviewEvents(this);
        this.trigger('attach', this);
      }
    },

    goToProductUrl: function () {
      var product = this.model.get('Product');
      var productUrl = product && product._Url;

      if (productUrl) {
        window.location = productUrl;
      }
    }

  });

});

BV.define('bv/c2013/view/ratingItemCollection',[
  'bv/c2013/view/contentItemCollection',
  'hbs!contentItemCollection',
  'bv/c2013/view/ratingItem',
  'bv/util/contentType',
  'bv/util/cssLoadCheck'
], function (BCollectionView, template, ContentItemView, ContentType, cssLoadCheck) {
  return BCollectionView.extend({
    name: 'ratingItemCollection',

    templateName: 'contentItemCollection',

    init: function (config) {
      this.listenTo(this.model, {
        add: this.addContent
      });
    },

    modelDataReady: function () {
      this.views = [];
    },

    addContent: function (contentItemModel, collection, options) {
      var contentType = contentItemModel.get('Type') || contentItemModel.contentType || contentItemModel.get('contentType');
      var v = new ContentItemView({
        model: contentItemModel,
        config: contentItemModel,
        componentId: contentItemModel.componentId || contentItemModel.get('componentId'),
        contentType: ContentType.Nouns(contentType),
        secondaryContentType: contentItemModel.secondaryContentType || contentItemModel.get('secondaryContentType'),
        index: this.views.length,
        classList: ['rating-top-' + ContentType.noun(contentType)],
        parent: this
      });
      this.views.push(v);

      cssLoadCheck.done(function () {
        v.render();
      });
    }
  });
});

BV.define('bv/c2013/model/summary',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/api/fetch',
  'util/url',
  'bv/api/util/statsRequest'
], function (ENV, BModel, _, api, url, statsRequest) {
  return BModel.extend({
    options: {},
    name: 'summary',

    init: function (config, options) {
      var self;
      var components;
      var thisComponent;

      // Mixin options
      _.extend(this.options, options);
      self = this;
      components = ENV.get('componentManager');
      thisComponent = components.find(self.get('componentId'));

      if (!_(thisComponent).isArray() && !_(thisComponent).isEmpty()) {
        this.set('coverageContentTypes', thisComponent.coverageContentTypes);
        this.set('submissionContentTypes', thisComponent.submissionContentTypes);
      }
      this.subscribe('pageto', this.fetchContent);
    },

    setupDataProcessing: function () {
      // listen for the first data response from a content collection to detect that data is ready or initData
      this.subscribe('contentresponse', this.processData);
    },

    processData: function (data) {
      var subject = _.clone(data);
      subject.PrimaryContent = subject.Content ? subject.Content.Reviews : {};
      this.set({
        Product: subject,
        subject: subject
      });
      this.dataReady(this.attributes);
    },

    fetchContent: function (pageNum) {
      var self = this;
      var config = ENV.get('config');
      var clientAPIConfig = _.extend({}, config.clientAPIConfig, this.get('clientAPIConfig'));
      var subjectId = clientAPIConfig[api.noun(this.get('subjectType')) + 'Id'];
      var coverageTypes = this.get('coverageContentTypes');
      var onlyShowDisplayedLocaleStatistics = config.statistics.onlyShowDisplayedLocaleStatistics;
      // this.componentSet('currentPage', pageNum);

      // fetch the content
      var batchContent = api.get('batch', null, [statsRequest({ subjectId: subjectId })]);
      batchContent.fetch(self.name).done(function (dataArray) {
        var contentData = _(dataArray).find(function (d) {
          return d.contentType === 'products';
        }).data;

        var subject = contentData.Results[0];
        var totalContentCount = 0;
        subject.Id = subject.Id || subjectId;

        // For review stats, we need to use the appropriate statistics:
        //  If a client has selected to only show stats for selected locales,
        //  we will use the filtered statistics. Otherwise we use the raw stats.
        //
        // We have to explicitly redefine Reviews.Statistics because we don't know whether that object
        // refers to Filtered or Raw stats.
        //
        // TODO: This can probably live in normalizer OR we can move references to subject to a local
        //       variable that can be accessed by summary and all summary's children.
        if (subject.Content.Reviews) {
          if (onlyShowDisplayedLocaleStatistics) {
            subject.Content.Reviews.Statistics = subject.Content.Reviews.FilteredStatistics;
          }
          else {
            subject.Content.Reviews.Statistics = subject.Content.Reviews.RawStatistics;
          }
        }

        _(coverageTypes).forEach(function (coverType) {
          var contentType = api.Nouns(coverType);
          if (subject.Content && subject.Content[contentType]) {
            subject[contentType] = subject.Content[contentType];
            totalContentCount = totalContentCount + subject[contentType].Statistics.TotalCount;
          }
          else {
            subject[contentType] = {
              List: [],
              Statistics: {
                TotalCount: 0,
                // This seems ugly... not sure how to handle this otherwise though -OW
                OverallRatingRange: config.submission.rating.range[1]
              }
            };
          }
        });
        subject.TotalContentCount = totalContentCount;

        // Cache this product request
        ENV.get('references').set(subject.Type, subject.Id, subject);

        self.publish('contentresponse', subject);
      });

    },

    getSubject: function () {
      // Eventually need to make this handle other types?
      return {
        type: 'product',
        id: this.get('clientAPIConfig').productId,
        contentType: this.get('contentType')
      };
    },

    toJSON: function () {
      var config = ENV.get('config');
      var clientAPIConfig = this.get('clientAPIConfig');
      return {
        Product: this.get('Product'),
        TotalCount: this.get('Product').TotalReviewCount || 0,
        clientLogo: config.clientLogo || null,
        clientDisplayName: config.clientDisplayName || null,
        readOnly: this.readOnly,
        siteAuthReviews: config.siteAuth.review,
        siteAuthLoggedIn: clientAPIConfig.userToken
      };
    }
  });
});

BV.define('bv/c2013/model/contentSearch',[
  'ENV',
  'bv/c2013/model/summary'
], function (ENV, SummaryModel) {
  return SummaryModel.extend({
    name: 'contentSearch'
  });
});

BV.define('bv/util/baseConfig',{
  'global': {},
  'qa': {},
  'sy': {},
  'cp': {},
  'rr': {},
  'loy': {}
});

/* START_TEMPLATE */
BV.define('hbs!prsTotalCount',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <a href=\"#\" class=\"bv-rating-label bv-text-link bv-focusable\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "appTotalContentCount", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "appTotalContentCount", depth1.msgpack, depth0, options)))
    + " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_prsNumberOfReviews", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_prsNumberOfReviews", depth0.msgpack, depth0, options)))
    + "</span> </a> ";
  return buffer;
  }

  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('prsTotalCount', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!summaryMinimalistTotalCount',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "appTotalContentCount", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "appTotalContentCount", depth1.msgpack, depth0, options)))
    + "\" class=\"bv-rating-ratio-count\"> <span aria-hidden=\"true\"> (<span itemprop=\"reviewCount\">";
  if (stack2 = helpers.TotalCount) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.TotalCount; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span>) </span> </span> ";
  return buffer;
  }

  stack2 = helpers['with'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('summaryMinimalistTotalCount', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!stars',['hbs','vendor/handlebars/runtime','hbs!prsStars', 'hbs!prsOverallRating', 'hbs!prsTotalCountAggregate', 'hbs!prsTotalCount', 'hbs!summaryMinimalistTotalCount', 'template/helpers/ifHasFeature', 'template/helpers/notEqual', 'template/helpers/equals', 'template/helpers/extmsg', 'template/helpers/unlessHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program8, data, depth0)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "stars", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "stars", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.AverageOverallRating), {hash:{},inverse:self.noop,fn:self.program(17, program17, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.program(26, program26, data),fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "minimalist", options) : helperMissing.call(depth0, "unlessHasFeature", "minimalist", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dl> ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = ((stack1 = depth1.Product),stack1 == null || stack1 === false ? stack1 : stack1.PrimaryContent)),stack1 == null || stack1 === false ? stack1 : stack1.TotalResults), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <dl class=\"bv-stars-container\" itemprop=\"aggregateRating\" itemscope itemtype=\"http://schema.org/AggregateRating\"> ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews), {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " ";
  }

function program6(depth0,data) {
  
  
  return " <dl class=\"bv-stars-container\"> ";
  }

function program8(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dt class=\"bv-rating-ratio\"> ";
  options = {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.readOnly, true, options) : helperMissing.call(depth0, "equals", depth0.readOnly, true, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.prsStars, 'prsStars', depth1, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.readOnly, true, options) : helperMissing.call(depth0, "equals", depth0.readOnly, true, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dt> ";
  return buffer;
  }
function program9(depth0,data) {
  
  
  return " <span class=\"bv-rating-stars-container bv-rating-none bv-focusable\" aria-readonly=\"true\"> ";
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <a href=\"#\" class=\"bv-rating-stars-container bv-focusable\" title=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "readReviews", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "readReviews", depth0.msgpack, depth0, options)))
    + "\"> ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return " </span> ";
  }

function program15(depth0,data) {
  
  
  return " </a> ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dd class=\"bv-rating-ratio-number\"> ";
  stack1 = self.invokePartial(partials.prsOverallRating, 'prsOverallRating', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dd> ";
  return buffer;
  }

function program19(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(20, program20, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "reviewCount", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "reviewCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program20(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), {hash:{},inverse:self.noop,fn:self.program(21, program21, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program21(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <dd class=\"bv-rating-ratio-count\"> ";
  options = {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "aggregateRatingTag", options) : helperMissing.call(depth0, "ifHasFeature", "aggregateRatingTag", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </dd> ";
  return buffer;
  }
function program22(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.prsTotalCountAggregate, 'prsTotalCountAggregate', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.prsTotalCount, 'prsTotalCount', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program26(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics)),stack1 == null || stack1 === false ? stack1 : stack1.TotalCount), {hash:{},inverse:self.noop,fn:self.program(27, program27, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program27(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <dd class=\"bv-rating-ratio-count\"> ";
  stack1 = self.invokePartial(partials.summaryMinimalistTotalCount, 'summaryMinimalistTotalCount', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </dd> ";
  return buffer;
  }

  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('stars', t);
t.deps = ["prsStars","prsOverallRating","prsTotalCountAggregate","prsTotalCount","summaryMinimalistTotalCount"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_recommendationCount', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function recommendationCount( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RecommendedCount"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalRecommendedCount"];
r += " (";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["percentage"];
r += "%) reviewers recommend this product";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `recommendationCount`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_recommendationCount', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return recommendationCount(data);
});
return recommendationCount;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!percentrecommend',['hbs','vendor/handlebars/runtime','hbs!firstToWriteReview', 'template/helpers/ifHasFeature', 'template/helpers/withIf', 'template/helpers/conditionalContainer', 'template/helpers/withPercentage', '_i18n_recommendationCount'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("percent-recommend-container")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options) : helperMissing.call(depth0, "withIf", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.TotalRecommendedCount, {hash:{},inverse:self.programWithDepth(program7, data, depth1),fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.withPercentage),stack1 ? stack1.call(depth0, depth0.RecommendedCount, depth0.TotalRecommendedCount, 1, options) : helperMissing.call(depth0, "withPercentage", depth0.RecommendedCount, depth0.TotalRecommendedCount, 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_recommendationCount),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_recommendationCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

function program7(depth0,data,depth2) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.TotalCount, {hash:{},inverse:self.noop,fn:self.programWithDepth(program8, data, depth2)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data,depth3) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['with'].call(depth0, depth3, {hash:{},inverse:self.noop,fn:self.program(9, program9, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "writeReviews", options) : helperMissing.call(depth0, "ifHasFeature", "writeReviews", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.firstToWriteReview, 'firstToWriteReview', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program12(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program7, data, depth1)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options) : helperMissing.call(depth0, "withIf", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{},inverse:self.programWithDepth(program12, data, depth0),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "recommended", options) : helperMissing.call(depth0, "ifHasFeature", "recommended", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('percentrecommend', t);
t.deps = ["firstToWriteReview"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/withPercentage',['vendor/handlebars/runtime', 'template/helpers/percentage', 'underscore'], function (Handlebars, percentage, _) {
  var that = this;

  function withPercentage (a, b, c, options) {
    var p = percentage(a, b, c, { hash: {} });
    var result = _(this).extend({
      percentage: p
    });
    return options.fn(result);
  }

  Handlebars.registerHelper('withPercentage', withPercentage);
  return withPercentage;
});

/* START GENERATED MESSAGE */
BV.define('_i18n_totalAAStats', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function totalAAStats( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalSecondaryCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "<a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " question </a> and <a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += " answer </a> for this product";
return r;
},
"other" : function(d){
var r = "";
r += "<a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " question </a> and <a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += " answers </a> for this product";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalSecondaryCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "<a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " questions </a> and <a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += " answer </a> for this product";
return r;
},
"other" : function(d){
var r = "";
r += "<a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-questions bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " questions </a> and <a href=\"\#\" class=\"bv-qa-stats bv-qa-stats-answers bv-focusable\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += " answers </a> for this product";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `totalAAStats`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_totalAAStats', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return totalAAStats(data);
});
return totalAAStats;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!stats',['hbs','vendor/handlebars/runtime', 'template/helpers/ifHasFeature', 'template/helpers/withIf', '_i18n_totalAAStats'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Questions)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options) : helperMissing.call(depth0, "withIf", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Questions)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-stats-container\"> ";
  stack1 = helpers['if'].call(depth0, depth0.TotalCount, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_totalAAStats),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_totalAAStats", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "askQuestions", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "askQuestions", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('stats', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!details',['hbs','vendor/handlebars/runtime','hbs!percentrecommend', 'hbs!stats', 'template/helpers/conditionalContainer', 'template/helpers/unlessHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  stack1 = self.invokePartial(partials.percentrecommend, 'percentrecommend', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "minimalist", options) : helperMissing.call(depth0, "unlessHasFeature", "minimalist", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.stats, 'stats', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("details-bar")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.conditionalContainer),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "conditionalContainer", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('details', t);
t.deps = ["percentrecommend","stats"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!readReviews',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-read-review-container bv-read-container\"> <button type=\"button\" class=\"bv-read-review bv-focusable bv-read-reviews-button\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "readReviews", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "readReviews", depth0.msgpack, depth0, options)))
    + " </button> </div> ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0.TotalCount, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });
Handlebars.registerPartial('readReviews', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview Evaluate the contents of the helper if any of the named
 * features are present. In other words, the block runs if any feature f would
 * run via {{#ifHasFeature f}}.
 */
BV.define('template/helpers/ifAnyFeature',[
  'vendor/handlebars/runtime',
  './ifHasFeature'
], function (Handlebars, ifHasFeature) {

  function ifAnyFeature () {
    var args = [].slice.call(arguments);
    var context = args[args.length - 1];

    for (var i = 0; i < args.length - 1; i ++) {
      if (ifHasFeature.call(this, args[i], context)) {
        return context.fn(this);
      }
    }
    return context.inverse(this);
  }

  Handlebars.registerHelper('ifAnyFeature', ifAnyFeature);
  return ifAnyFeature;
});

/* START_TEMPLATE */
BV.define('hbs!summaryBar',['hbs','vendor/handlebars/runtime','hbs!stars', 'hbs!details', 'hbs!writeReview', 'hbs!askQuestion', 'hbs!readReviews', 'hbs!clientLogo', 'template/helpers/ifHasFeature', 'template/helpers/unlessHasFeature', 'template/helpers/ifAnyFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "bv-summary-bar-minimalist bv-summary-bar-minimalist-horizontal";
  }

function program3(depth0,data) {
  
  
  return "bv-summary-bar-minimalist bv-summary-bar-minimalist-vertical";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.details, 'details', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.ifAnyFeature),stack1 ? stack1.call(depth0, "writeReviews", "askQuestions", "readReviews", "clientLogo", options) : helperMissing.call(depth0, "ifAnyFeature", "writeReviews", "askQuestions", "readReviews", "clientLogo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program8(depth0,data) {
  
  
  return " <div class=\"bv-action-bar\"> ";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.writeReview, 'writeReview', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.askQuestion, 'askQuestion', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.readReviews, 'readReviews', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.clientLogo, 'clientLogo', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(19, program19, data)};
  stack2 = ((stack1 = helpers.ifAnyFeature),stack1 ? stack1.call(depth0, "writeReviews", "askQuestions", "readReviews", "clientLogo", options) : helperMissing.call(depth0, "ifAnyFeature", "writeReviews", "askQuestions", "readReviews", "clientLogo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program19(depth0,data) {
  
  
  return " </div> ";
  }

  buffer += "<div class=\"bv-summary-bar ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "minimalistHorizontal", options) : helperMissing.call(depth0, "ifHasFeature", "minimalistHorizontal", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "minimalistVertical", options) : helperMissing.call(depth0, "ifHasFeature", "minimalistVertical", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> ";
  stack2 = self.invokePartial(partials.stars, 'stars', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "minimalist", options) : helperMissing.call(depth0, "unlessHasFeature", "minimalist", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "minimalistHorizontal", options) : helperMissing.call(depth0, "unlessHasFeature", "minimalistHorizontal", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "writeReviews", options) : helperMissing.call(depth0, "ifHasFeature", "writeReviews", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(12, program12, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "askQuestions", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "askQuestions", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "readReviews", options) : helperMissing.call(depth0, "ifHasFeature", "readReviews", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(16, program16, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "clientLogo", options) : helperMissing.call(depth0, "ifHasFeature", "clientLogo", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(18, program18, data)};
  stack2 = ((stack1 = helpers.unlessHasFeature),stack1 ? stack1.call(depth0, "minimalistHorizontal", options) : helperMissing.call(depth0, "unlessHasFeature", "minimalistHorizontal", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('summaryBar', t);
t.deps = ["stars","details","writeReview","askQuestion","readReviews","clientLogo"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!prs',['hbs','vendor/handlebars/runtime','hbs!summaryBar', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-cleanslate bv-cv2-cleanslate\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-prs-container\"> <div class=\"bv-primarySummary-rating-container\"> ";
  stack1 = self.invokePartial(partials.summaryBar, 'summaryBar', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> </div> </div> ";
  return buffer;
  }

  buffer += " ";
  stack1 = helpers['with'].call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('prs', t);
t.deps = ["summaryBar"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/summary',[
  'ENV',
  'framework/bview',
  'bv/ui-core/focusableview',
  'bv/util/loadingOverlay',
  'bv/util/productInfo',
  'bv/util/baseConfig',
  'bv/util/bvLocal',
  'underscore',
  'jquery',
  'hbs!prs',
  'window',
  '$BV',
  'BV',
  'mf!bv/c2013/messages/common',
  'bv/c2013/model/contentList',
  'framework/util/bvtracker'
], function (ENV, BView, FocusableView, LoadingOverlay, ProductInfo, baseConfig, bvLocal, _, $, template, window, $BV, BV, msgPack, ContentList, BVTracker) {
  var View = BView.extend(FocusableView);

  function clickHandler (statsKey, detail1) {
    return function (e) {
      var statsObject = this.model.get('Product')[statsKey];

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: detail1,
        detail2: this.region,
        quantity: (statsObject && statsObject.Statistics) ? statsObject.Statistics.TotalCount : 0,
        bvProduct: (statsKey === 'Reviews') ? ProductInfo.RATINGSANDREVIEWS : ProductInfo.ASKANDANSWER,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });

      this['_scrollTo' + statsKey](e);
      e.preventDefault();
      e.stopPropagation();
    };
  }

  return View.extend({
    name: 'summary',
    region: 'PrimaryRatingSummary',
    classList: ['core-container-' + BView.config.version],
    msgpacks: [msgPack],
    template: template,

    events: {
      'click .bv-write-review, .bv-write-review-label, .bv-recommend-label': 'loadReviewSubmission',
      'click .bv-read-review': 'clickReadReview',
      'click .bv-ask-question, .bv-ask-question-label': 'loadQuestionSubmission',
      'hover .bv-shared': 'preloadSubmission',
      'click .bv-summary-bar .bv-rating-stars-container': 'clickSummaryStars',
      'click .bv-rating-label': 'clickReviewCount',
      'click .bv-write-review-label': 'clickWriteReviewLabel',
      'click .bv-qa-stats': 'clickSummaryQuestionStats',
      'mouseenter .bv-rating': 'hoverHistogram'
    },

    clickSummaryStars: clickHandler('Reviews', 'SummaryStars'),
    clickReadReview: clickHandler('Reviews', 'ReadReviewsButton'),
    clickWriteReviewLabel: clickHandler('Reviews', 'WriteReviewLabel'),
    clickSummaryQuestionStats: clickHandler('Questions', 'SummaryQuestionStats'),
    clickReviewCount: clickHandler('Reviews', 'ReviewCount'),

    attach: function () {
      if (bvLocal.isBVLocal()) {
        bvLocal.attachLogoHandler(this);
      }

      var listModel = this.model.getClosestAncestor({ modelType: ContentList });
      if (listModel) {
        this.listenTo(listModel, 'pageinfo', this.renderAnchor);
      }
      this.subscribe('readreviews', this.handleReadReviewsClick);
      return BView.prototype.attach.apply(this, arguments);
    },

    preloadSubmission: _.once(function (e) {
      if (!BV._internal.nopreload) {
        BV.require(['secondary'], function () {});
      }
    }),

    loadReviewSubmission: _.debounce(function (e) {
      e.preventDefault();

      var showReviewsConfig = (baseConfig.rr._actions && baseConfig.rr._actions.show_reviews) || {};
      var settings = $.extend({}, this.clientAPIConfig, {
        campaignId: 'BV_RATING_SUMMARY',
        mobileRedirect: true
      });
      // saving a flag to use for set focus back onClose event of Thank You Page
      //  (see CCS-33218 for details)
      sessionStorage.setItem('bvSubmissionTriggerElemenet', 'bvSummary');

      settings.doShowContent = settings.doShowContent || showReviewsConfig.doShowContent;
      this.getTopModel().trigger('showreviewsubmission', settings);

      BVTracker.feature({
        type: 'Used',
        name: 'Write',
        detail1: 'Button',
        detail2: this.region,
        bvProduct: ProductInfo.RATINGSANDREVIEWS,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }, 1000, true),

    loadQuestionSubmission: _.debounce(function (e) {
      e.preventDefault();
      LoadingOverlay.show();

      var showQuestionsConfig = (baseConfig.qa._actions && baseConfig.qa._actions.show_questions) || {};
      var settings = $.extend({}, this.clientAPIConfig, {
        campaignId: 'BV_QUESTION_SUMMARY',
        mobileRedirect: true,
        silentMode: false
      });

      // saving a flag to use for set focus back onClose event of Thank You Page
      //  (see CCS-33218 for details)
      sessionStorage.setItem('bvSubmissionTriggerElemenet', 'bvSummary');

      settings.doShowContent = showQuestionsConfig.doShowContent;
      this.getTopModel().trigger('showquestionsubmission', settings);

      BVTracker.feature({
        type: 'Used',
        name: 'Ask',
        detail1: 'Button',
        detail2: this.region,
        bvProduct: ProductInfo.ASKANDANSWER,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }, 1000, true),

    handleReadReviewsClick: function (e) {
      this._scrollToReviews(e);
    },

    _scrollToReviews: function (e) {
      // We used to do different things based on how many reviews were
      // already present. If there were zero reviews we'd open a review
      // submission form, and if there were one or more we'd focus the review
      // content area. But now we always focus the review content area so
      // that clients who have disabled the "write a review" button don't
      // have to worry about another back-door way for customers to submit
      // reviews. See UIA-7537.
      this.getTopModel().trigger('showreviews', e);
    },

    _scrollToQuestions: function (e) {
      var questions = this.model.get('Product').Questions;
      if (questions && questions.Statistics && questions.Statistics.TotalCount > 0) {
        // If there's content, scroll to content and move focus.
        this.getTopModel().trigger('showquestions', e);
      }
      else {
        // If there are no results, launch submission when clicked.
        this.loadQuestionSubmission(e);
      }
    },

    // TODO - I think we should move this so that the hbs template renders this way.
    // That would require some model changes though (needs to know page #).
    renderAnchor: function () {
      var focusables = this.$('a.bv-focusable');
      if (focusables) {
        var pageNumber = this.model.componentGet('currentPage') || 1;
        focusables.each(function () {
          this.href = '#review/page/' + pageNumber;
        });
      }
    },

    hoverHistogram: function () {
      BVTracker.feature({
        type: 'Used',
        name: 'Hover',
        detail1: 'Histogram',
        detail2: this.region,
        bvProduct: ProductInfo.RATINGSANDREVIEWS,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!contentSearch',['hbs','vendor/handlebars/runtime','hbs!stars', 'hbs!percentrecommend', 'template/helpers/notEqual', 'template/helpers/view', 'template/helpers/ifHasFeature', 'template/helpers/mountView', 'template/helpers/subviews'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-cleanslate bv-cv2-cleanslate\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-content-search\"> ";
  options = {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "sticky", options) : helperMissing.call(depth0, "ifHasFeature", "sticky", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-masthead-product bv-summary-bar\"> <div class=\"bv-secondary-summary\"> ";
  stack2 = self.invokePartial(partials.stars, 'stars', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = self.invokePartial(partials.percentrecommend, 'percentrecommend', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "trustmarkIcon", depth0, options) : helperMissing.call(depth0, "mountView", "trustmarkIcon", depth0, options)))
    + " </div> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "searchBar", depth0, options) : helperMissing.call(depth0, "mountView", "searchBar", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "contentFilter", depth0, options) : helperMissing.call(depth0, "mountView", "contentFilter", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "searchBar", options) : helperMissing.call(depth0, "ifHasFeature", "searchBar", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " <div id=\"BVStickyHeader\" class=\"bv-masthead bv-masthead-sticky\"> ";
  }

function program5(depth0,data) {
  
  
  return " <div class=\"bv-masthead\"> ";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "statsPanel", depth0, options) : helperMissing.call(depth0, "mountView", "statsPanel", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.TotalContentCount), 0, options) : helperMissing.call(depth0, "notEqual", ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.TotalContentCount), 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentSearch', t);
t.deps = ["stars","percentrecommend"];
t.tplMountedViews = ['trustmarkIcon','searchBar','contentFilter','statsPanel'];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/contentSearch',[
  'framework/bview',
  'bv/c2013/view/summary',
  'underscore',
  'jquery',
  'hbs!contentSearch',
  'mf!bv/c2013/messages/contentSearch',
  'mf!bv/c2013/messages/common',
  'window'
], function (BView, SummaryView, _, $, template, msgPack, msgPackCommon, window) {

  var $window = $(window);

  return SummaryView.extend({
    name: 'contentSearch',

    classList: ['core-container-' + BView.config.version],

    region: 'SearchBarRatingSummary',

    events: {
      'click .bv-rating-stars-container': 'clickSummaryStars',
      'click .bv-rating-label': 'clickReviewCount',
      'mouseenter .bv-rating': 'hoverHistogram',
      'focus .bv-search-text': 'onFocusSearch',
      'blur .bv-search-text': 'onBlurSearch'
    },

    template: template,

    msgpacks: [msgPack, msgPackCommon],

    init: function (config) {
      this.currentTarget = null;
      this.targets = null;
      this.limit = null;

      this.isMobile = navigator.userAgent.match(/(iPhone|iPod|Android|BlackBerry)/);
    },

    attach: function () {
      var self = this;
      var stickyOverflows = ['visible', 'hidden'];

      if (this.hasFeature('sticky')) {
        // If the search bar is a descendant of an element whose overflow
        // is anything other than 'visible', then our current sticky logic
        // isn't going to work very well, so we will force ourselves out
        // of sticky mode.
        self.$el.parents().addBack().each(function () {
          if (!_.contains(stickyOverflows, $(this).css('overflow'))) {
            self.forceNoStickyHeader = true;
            return false;
          }
        });

        // If we're not in sticky mode, we're not going to bother with
        // the listener that handles the sticky feature.
        if (!this.forceNoStickyHeader) {
          this.setSticky(true);
        }
      }

      return SummaryView.prototype.attach.apply(this, arguments);
    },

    setSticky: function (bool) {
      $window.off('scroll.contentsearch');
      if (bool) {
        $window.on('scroll.contentsearch', this, this._processScroll);
      }
      else {
        var $fixed = this.$('.bv-masthead-fixed');
        if ($fixed.length) {
          $fixed.removeClass('bv-masthead-fixed');
        }
      }
    },

    /*
     *  this function calculates if we need to add class "bv-masthead-fixed" to the searchBar
     *  "bv-masthead-fixed" makes the searchBar stick on top of the page
     *  this class will be added when 2 conditions are met:
     *    1. contentSearch has "has:sticky" feature
     *    2. window scroll top > the searchBar original position top.
     */
    _processScroll: _.throttle(function (e) {
      var searchBar = e.data;
      var scrollTop = $window.scrollTop();
      if (searchBar) {
        var targets = searchBar.targets;
        if (!targets) {
          searchBar.targets = [];
          searchBar.limit = 0;
          $('.bv-scroll-spy').each(function (index, el) {
            var $el = $(el);
            var offset = $el.offset();
            var height = $el.height();

            // create scroll spy targets
            var target = {
              offset: offset,
              height: height,
              start: offset ? offset.top : 0,
              end: offset ? (offset.top + height) : height,
              target: $el.data().bvTarget
            };
            searchBar.targets.push(target);

            // find the limit of the sticky hearder
            if ((offset.top + height) > searchBar.limit) {
              searchBar.limit = offset.top + height;
            }
          });
        }

        var isSticky = searchBar._updateSticky(searchBar, scrollTop);
        searchBar._updateScrollSpy(searchBar, scrollTop, isSticky);
      }
    }, 200),

    /*
     *  this function calculates if we need to add class "bv-masthead-fixed" to the searchBar
     *  "bv-masthead-fixed" makes the searchBar stick on top of the page
     *  this class will be added when 2 conditions are meet:
     *    1. contentSearch has "has:sticky" feature
     *    2. window scroll top > the searchBar original position top.
     */
    _updateSticky: function (searchBar, scrollTop) {
      // findout if searchBar has "has:sticky" feature.
      var $nav = searchBar.$viewEl.find('.bv-masthead-sticky');
      // if searchBar doesn't have "has:sticky" feature, undelegate the window scroll event.
      if (!$nav.length) {
        return false;
      }

      // if searchBar has "has:sticky" feature, calculate the current offset top value.
      var offset = searchBar.$viewEl.offset();
      var navTop = 0;
      if (offset) {
        navTop = offset.top;
      }

      // check if the searchBar is already in "fixed" position.
      var isFixed = $nav.hasClass('bv-masthead-fixed');

      // add "bv-masthead-fixed" class if window scrolls below the searchBar offset.
      // add padding to keep other dom elements stay the same position.
      var past = (scrollTop > navTop && scrollTop < searchBar.limit) && !isFixed;
      if (past) {
        var navWidth = $nav.width();
        if (navWidth > 0) {
          var widthValue = navWidth + 'px';
          var offsetValue = $nav.height() + 'px 0 0 0';
          $nav.addClass('bv-masthead-fixed');
          if ($.importantizer && $.importantizer.state() === 'resolved') {
            $nav.css('width', widthValue);
          } else {
            $nav.css('cssText', 'width: ' + widthValue + ' !important;');
          }
          searchBar.$viewEl.css('padding', offsetValue);
          $window.off('resize.sticky').on('resize.sticky', searchBar, _.throttle(searchBar._resizeSearchBar, 100));
        }
      }
      // remove "bv-masthead-fixed" class if window scrolls above the searchBar offset.
      else if ((scrollTop <= navTop && isFixed) || (scrollTop >= searchBar.limit && isFixed)) {
        $nav.removeClass('bv-masthead-fixed');
        $nav.removeAttr('style');
        searchBar.$viewEl.removeAttr('style');
        $window.off('resize.sticky');
      }
      return $nav.hasClass('bv-masthead-fixed');
    },

    _updateScrollSpy: function (searchBar, scrollTop, isSticky) {
      // window scroll top position
      // minus 5px for a rough range affect
      if (isSticky) {
        scrollTop = scrollTop + searchBar.$viewEl.find('.bv-masthead-fixed').height() + 5;
      }

      var target = _(searchBar.targets).find(function (target) {
        return (target.offset && target.start <= scrollTop && target.end > scrollTop);
      });
      if ((target && (!searchBar.currentTarget || searchBar.currentTarget !== target.target)) ||
           (!target && searchBar.currentTarget)) {

        searchBar.currentTarget = target ? target.target : null;
        searchBar.publish('highlightstats', target);
      }
    },

    _resizeSearchBar: function (e) {
      var searchBar = e.data;
      if (searchBar.$viewEl) {
        var $nav = searchBar.$viewEl.find('.bv-masthead-sticky');
        var widthValue = searchBar.$viewEl.width() + 'px';
        $nav.css('width', widthValue);
      }
    },

    onFocusSearch: function () {
      if (!this.isMobile) { return; }
      // On iPhone/iPad, we've noticed weird behavior with the sticky header.
      // When the search field focuses, MobileSafari wants to scroll to the
      // top of the page for some reason, and that makes the sticky header
      // un-sticky and disorients the user.
      //
      // So when the text field is focused on a mobile device, we'll
      // temporarily turn off sticky mode and explicitly tell the browser to
      // scroll the search bar into view. When the text field is blurred,
      // we'll restore sticky mode.
      this.setSticky(false);
      var $header = $('#BVStickyHeader');
      if ($header.length) {
        $header[0].scrollIntoView();
      }
    },

    onBlurSearch: function () {
      if (!this.isMobile) { return; }
      // Restore this search bar to sticky mode if it was sticky before the
      // text field was focused.
      if (this.hasFeature('sticky') && !this.forceNoStickyHeader) {
        this.setSticky(true);
      }
    }
  });
});

BV.define('bv/c2013/model/searchContentList',[
  'ENV',
  'framework/bmodel',
  'bv/c2013/model/contentList',
  'underscore',
  'jquery'
],
function (ENV, BModel, ContentListModel, _, $) {
  return ContentListModel.extend({
    options: {},
    name: 'searchContentList',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
      // listen for search requests
      this.subscribe('searchcontent', this.fetchSearchContent);

      // listen for submission
      this.subscribe('submission', this.submission);

      // listen for submission success trigger
      this.getTopModel().subscribe('contentSubmitted', this.fetchRelatedQuestions, this);

      // listen for search response ready
      // listen for related questions requests
      this.listenTo(this.getTopModel(), {
        searchresponse: this.processContentSearch,
        requestresponse: this.processRelatedQuestions
      });
    },

    setupDataProcessing: function () {
      var parent = this.get('parent');
      if (parent) {
        parent.onDataReady(this.processData, this);
      }

      var contentCollection = this.getContent();
      if (!contentCollection) {
        return;
      }

      this.listenTo(contentCollection, 'newresulttotal', function (newTotal) {
        this.set('TotalResults', newTotal);
      }, this);
    },

    processData: function (data) {
      var parent = this.get('parent');
      this.set({
        subject: parent.get('Product'),
        clientAPIConfig: parent.get('clientAPIConfig')
      });

      BModel.prototype.processData.call(this);
    },

    toJSON: function () {
      return BModel.prototype.toJSON.call(this);
    },

    submission: function (config) {
      var clientAPIConfig = this.get('clientAPIConfig');
      config = _.extend({}, clientAPIConfig, config);
      // Wait for DOM ready to inject submission
      this.get('parent').trigger('showsubmission', config);
    },

    /**
     * Respond to "searchresponse" event
     * This function process the "search" API response.
     */
    processContentSearch: function (contentData, keyword) {
      var self = this;
      var page = this.componentGet('currentPage') || 1;
      if (page === 1) {
        this.set('requestModule', 'contentSearchModule');
        this.set('fetchResults', contentData.Results);
      }

      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.model);
        self._processContent(contentData, keyword);
        self.trigger('showcontentsearch', keyword);
      });
    },

    /**
     * Respond to "requestresponse" event
     * This function peforms:
     *   - process the "relatedquestion" API response.
     *   - bind event handle to collection's "remove" event
     *   - set "requestModule" to "answerRequestModule"
     *   - trigger "showrelatedquestions" on the searchContentList view.
     */
    processRelatedQuestions: function (contentData) {
      var self = this;
      var page = this.componentGet('currentPage') || 1;
      if (page === 1) {
        this.set('requestModule', 'answerRequestModule');
        this.set('fetchResults', contentData.Results);
      }

      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.model);
        self._processContent(contentData);

        var content = self.getContent();

        self.stopListening(content, 'remove', self.appendRelatedQuestion);
        self.listenTo(content, 'remove', self.appendRelatedQuestion);
        self.trigger('showrelatedquestions');
      });
    },

    fetchSearchContent: function (page, keyword) {
      var self = this;
      var args = arguments;

      if (keyword) {
        this.set('keyword', keyword);
      }
      else {
        keyword = this.get('keyword');
      }

      if (!keyword) {
        return;
      }

      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.model);
        if (self.dataReadyPromise().state() !== 'pending') {
          self.resetDataReady();
        }
        self.fetchContent.apply(self, [self.get('contentType'), page, keyword]);
      });
    },

    /**
     * Respond to post submission event.
     * - smart search for question submission.
     * - related questions for reivew/answer submission.
     *
     * @param content : contains two properties.
     *    - view : submission view.
     *    - response : processed response.
     */
    fetchRelatedQuestions: function (content) {
      var self = this;
      var submissionView = content.view;
      var submissionResponse = content.response;

      var coverageTypes = this.get('coverageContentTypes');
      if (_(coverageTypes).isEmpty()) {
        coverageTypes = _(ENV.get('componentManager').components).chain().map(function (comp) {
          return comp.contentType;
        }).intersection(['Reviews', 'Questions']).uniq().value();
        this.set('coverageContentTypes', coverageTypes);
      }

      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.model);
        if (self.dataReadyPromise().state() !== 'pending') {
          self.resetDataReady();
        }
        self.fetchContent.apply(self, [submissionView.contentType, 1, submissionResponse]);
      });
    },

    fetchPage: function (page) {
      var self = this;
      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.model);
        self.fetchPageExt.apply(self, [page]);
      });
    }

  });
});

/* START GENERATED MESSAGE */
BV.define('_i18n_searchActionBarHeader', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function searchActionBarHeader( data ) {
try { return (function(d){
var r = "";
r += "Search Results";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `searchActionBarHeader`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_searchActionBarHeader', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return searchActionBarHeader(data);
});
return searchActionBarHeader;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_answerRequestActionBarHeader', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function answerRequestActionBarHeader( data ) {
try { return (function(d){
var r = "";
r += "Can you answer the following questions?";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `answerRequestActionBarHeader`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_answerRequestActionBarHeader', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return answerRequestActionBarHeader(data);
});
return answerRequestActionBarHeader;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!searchContentList',['hbs','vendor/handlebars/runtime','hbs!askQuestion', 'hbs!inlineFormContainer', 'template/helpers/view', 'template/helpers/equals', 'template/helpers/mountView', 'template/helpers/extmsg', 'template/helpers/subviews', '_i18n_searchActionBarHeader', '_i18n_answerRequestActionBarHeader'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.requestModule, "answerRequestModule", options) : helperMissing.call(depth0, "equals", depth0.requestModule, "answerRequestModule", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-header\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.requestModule, "contentSearchModule", options) : helperMissing.call(depth0, "equals", depth0.requestModule, "contentSearchModule", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-action-bar\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.requestModule, "contentSearchModule", options) : helperMissing.call(depth0, "equals", depth0.requestModule, "contentSearchModule", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(12, program12, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.requestModule, "answerRequestModule", options) : helperMissing.call(depth0, "equals", depth0.requestModule, "answerRequestModule", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.requestModule, "contentSearchModule", options) : helperMissing.call(depth0, "equals", depth0.requestModule, "contentSearchModule", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-control-bar\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ugcCount", depth0, options) : helperMissing.call(depth0, "mountView", "ugcCount", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  stack2 = helpers['if'].call(depth0, depth0._noResults, {hash:{},inverse:self.noop,fn:self.program(16, program16, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div id=\"bv-content-list-products-wrapper\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.subviews),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "subviews", depth0, options)))
    + " </div> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return " <div class=\"bv-answer-request\"> ";
  }

function program4(depth0,data) {
  
  
  return " <div class=\"bv-search-content\"> ";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-content-search\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "searchBar", depth0, options) : helperMissing.call(depth0, "mountView", "searchBar", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <h2 class=\"bv-action-bar-header\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_searchActionBarHeader),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_searchActionBarHeader", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </h2> ";
  stack2 = helpers.each.call(depth0, depth0.coverageContentTypes, {hash:{},inverse:self.noop,fn:self.programWithDepth(program9, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program9(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program10, data, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0, "Questions", options) : helperMissing.call(depth0, "equals", depth0, "Questions", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program10(depth0,data,depth2) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.askQuestion, 'askQuestion', depth2, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <h4 class=\"bv-content-title\" itemprop=\"headline\"> ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_answerRequestActionBarHeader),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "_i18n_answerRequestActionBarHeader", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </h4> ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.inlineFormContainer, 'inlineFormContainer', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-content-search-results bv-focusable\" tabindex=\"-1\"> ";
  options = {hash:{
    'prefix': ("content_search_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "no_results", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "no_results", depth0.msgpack, depth0, options)))
    + " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("shared")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('searchContentList', t);
t.deps = ["askQuestion","inlineFormContainer"];
t.tplMountedViews = ['searchBar','ugcCount'];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/searchContentList',[
  'ENV',
  'framework/bview',
  'framework/util/bvtracker',
  'bv/c2013/view/contentList',
  'jquery',
  'underscore',
  'bv/util/loadingOverlay',
  'bv/util/productInfo',
  'hbs!searchContentList',
  'mf!bv/c2013/messages/contentSearch',
  'mf!bv/c2013/messages/common',
  'body'
],
function (ENV, BView, BVTracker, ContentListView, $, _, LoadingOverlay, ProductInfo, template, msgPack, commonMsgPack, body) {
  return ContentListView.extend({
    name: 'searchContentList',
    templateName: 'searchContentList',

    events: {
      'click .bv-ask-question': 'scrollToSubmission'
    },

    classList: ['core-container-' + BView.config.version],

    template: template,

    msgpacks: [msgPack, commonMsgPack],

    init: function (init) {
      _.bindAll(this, 'scrollToSubmission');

      ContentListView.prototype.init.apply(this, arguments);
      this.isSearchRender = false;

      this.listenTo(this.model, {
        showcontentsearch: this.showContentSearch,
        showrelatedquestions: this.showRelatedQuestions
      });
    },

    // Override remove to not stopListening
    remove: function () {
      this.$el.remove();
      return this;
    },

    /**
     *  Override BView.prototype.toHTML
     *
     *  When called with zero or one arguments, returns an HTML string.
     *
     *  When called with two or more, returns a promise of an HTML string.
    **/
    toHTML: function (data, isAsync) {
      if (!this.isSearchRender) {
        if (arguments.length < 2) {
          // isAsync was not provided, so adhere to the synchronous contract
          return '';
        }

        // isAsync was provided. regardless of its value, adhere to the async
        // contract and return a promise
        return $.Deferred().resolve('').promise();
      }

      return BView.prototype.toHTML.apply(this, arguments);
    },

    formSetup: function (dataMixin) {
      this.$viewEl.removeClass('bv-hidden');

      BView.prototype.formSetup.call(this, dataMixin);

      // highlights the search key words
      if (_(dataMixin).has('searchFor') && !_(dataMixin.searchFor).isEmpty()) {
        // TODO: we probably need to figure a way to do it more gracefully.
        // right now we only want to highlight the title and summary (so that we can exclude author names)
        // maybe we can look into how to add this into toHTML() function ??
        this.$viewEl.find('.bv-content-title-container, .bv-content-summary').bvhighlight(dataMixin);
      }
    },

    /**
     * Show "search results" in the modestbox
     * "showContent" function listens to model's "showcontent" event.
     * @param keyword : the search keyward, e.g. best quality
     */
    showContentSearch: function (keyword) {
      var self = this;
      var coverageTypes = this.model.get('coverageContentTypes');
      var includeSubmission = (_(coverageTypes).indexOf('Questions') > -1 && this.getTopModel().name !== 'submission');
      BV.require(['secondary'], function (app) {
        _(self).extend(app.SearchContentListExt.view);
        self.showContentSearchExt(includeSubmission, keyword);
      });
    },

    showRelatedQuestions: function () {
      // for some reason our view gets confused of where the rendered the html goes.
      this.$viewEl = this.viewEl = null;
      this.isSearchRender = true;

      if (this.model.getContent().size() === 0) {
        return;
      }

      if (_(this.classList).indexOf('no-submission') === -1) {
        this.classList.push('no-submission');
      }
      this.detach();
      this.render();
      this.formSetup({ 'short': true });
      LoadingOverlay.hide();
    },

    scrollToSubmission: function (e) {
      var self = this;
      var config = this.getClientAPIConfig();
      var $contentList;

      if (!this.clientAPIConfig.userToken && ENV.get('config').siteAuth.question) {
        this.getTopModel().trigger('showsubmission', config);
        return;
      }
      $contentList = this.$viewEl.find('.bv-content-list:first');
      try {
        $('html').add(body()).animate({
          scrollTop: $contentList.offset().top + $contentList.height()
        }, 600);

        BVTracker.feature({
          type: 'Used',
          name: 'Ask',
          detail1: 'Button',
          detail2: 'Lightbox',
          bvProduct: ProductInfo.ASKANDANSWER,
          productId: ProductInfo.getId(self),
          categoryId: ProductInfo.getCategoryId(self)
        });
      }
      catch (exp) {}
      // TODO: focus on the first field on the submission form.
    },

    /*
     * Overwrite scrollToContent in ContentListView.
     * Trigger modestbox to scroll to top.
     */
    scrollToContent: function (e) {
      this.trigger('scroll');
    }

  });
});

/**
 * @fileOverview Model for the Trustmark Icon
 */
BV.define('bv/c2013/model/trustmarkIcon',[
  'ENV',
  'framework/bmodel'
], function (ENV, BModel) {
  return BModel.extend({
    name: 'trustmarkIcon',

    /**
     * We create the url programmatically based on the base url defined in the ENV config.
     * We only get the end part of the url from a messageformat string.
     * This is why we set this here instead of just putting the url in a msgpack.
     *
     * @return {String} Full path to the desired Trustmark Icon image
     */
    _iconPath: function () {
      // The icon url is stored in s3.
      var imagesPath = ENV.get('config').imagesPath;
      var iconFolder = 'trustmark_icons/';

      var locale = ENV.get('config').locale;
      var languageCode = locale.split('_')[0];

      // It is safe to just use the locale language.
      // Our documentation outlines which locales support Trustmark.
      // We are responsible for making sure those icons are uploaded to the
      // trustmark_icons folder. We are NOT responsible for making sure we are
      // in a locale that supports Trustmark.
      var iconFilename = 'trustmark_' + languageCode + '.png';
      var iconPath = imagesPath + iconFolder + iconFilename;

      return iconPath;
    },

    init: function () {
      this.set('trustmarkUrl', this._iconPath());
    }
  });
});

/**
 * @fileOverview Abstract class for views that show a popup.
 */
BV.define('bv/ui-core/bpopuptargetview',[
  'ENV',
  'bv/ui-core/bhoverableview',
  'jquery',
  'underscore',
  'body',
  'bv/util/focusManager',
  'util/specialKeys'
], function (
  ENV,
  BHoverableView,
  $,
  _,
  body,
  focusManager,
  specialKeys
) {
  return BHoverableView.extend({

    linkEl: '.bv-popup-target',

    options: _.extend({}, BHoverableView.prototype.options, {
      popupInTriggerEvent: 'mouseenter',
      popupOutTriggerEvent: 'mouseleave',
      positionPopupRelativeToLink: true,
      toggleable: false,
      preserveFocus: true
    }),

    attach: function () {
      var attachResult = BHoverableView.prototype.attach.apply(this, arguments);

      // Wire up the events with jQuery's mouseenter and mouseleave, but keep
      // the Backbone context
      this.$targetEl = this.$viewEl.find(this.linkEl)
        .on('touchstart', $.proxy(this._handleTouchstart, this))
        .on(this.options.popupInTriggerEvent, $.proxy(this.enter, this))
        .on(this.options.popupOutTriggerEvent, $.proxy(this.leave, this))
        .on('click', function (e) {
          e.preventDefault();
        });

      if (this.options.toggleable) {
        this.$targetEl.off(this.options.popupOutTriggerEvent);
      }

      this.setupKeyboardNavigation();

      return attachResult;
    },

    /**
     * Overrides BHoverableView enter method.
     * Determines whether to focus on the text in the popup.
     *
     * @param  {Event} e The event that triggered this callback.
     */
    enter: function (e) {
      var self = this;
      BHoverableView.prototype.enter.call(this, e);

      // When keyboard navigating, we want to focus the popup view.
      // If we just hovered the mouse over it, we don't want to move focus.
      if (e.type !== 'mouseenter') {
        // 200ms delay here just to make sure screen reader can announce new state
        // of the popup before focus shifts
        this.targetView.model.once('dropdownRendered', function () {
          setTimeout(function focusDelay () {
            focusManager.moveFocus(self.targetView.$viewEl.find('.bv-focusable'));
          }, 200);
        });
      }

      // Attempt to attach the listener for catching external touches. On a
      // mobile device, this should have been handled already by the
      // `touchstart` listener on first tap, but sometimes that doesn't fire
      // for whatever reason and we get this far because of the simulated
      // `mouseenter` event.
      //
      // If the event is already attached this will do nothing.
      this._attachTouchListener();
    },

    /**
     * Determines if the popup is already open or not.
     *
     * @return {Boolean} true if the popup is open
     *                   false otherwise
     */
    _isOpened: function () {
      return this.targetView && this.targetView.rendered;
    },

    /**
     * Stops the event and opens the popup.
     *
     * @param  {Event} e The event that triggered this callback.
     */
    _openPopup: function (e) {
      e.preventDefault();
      e.stopPropagation();
      if (!this._isOpened()) {
        this.enter(e);
      }
    },

    /**
     * Stops the event and closes the popup.
     *
     * @param  {Event} e The event that triggered this callback.
     */
    _closePopup: function (e) {
      e.preventDefault();
      e.stopPropagation();
      this.leave(e);
    },

    /**
     * Keydown Event Handler should catch Space, Enter, and Escape
     * Space and Enter will open the popup if it is closed.
     * Escape will close it.
     *
     * @param  {Event} e The event that triggered this callback.
     */
    _onKeydown: function (e) {
      // Switch is perfect for this use case.
      // We can handle each key without an if waterfall, and we can simply
      // ignore they keys we don't care about.
      switch (e.keyCode) {
        // Space / Enter toggles opening and closing the popup.
        case specialKeys.SPACE:
        case specialKeys.ENTER:
          this._openPopup(e);
          break;
        // Escape closes the popup.
        case specialKeys.ESCAPE:
          this._closePopup(e);
          break;
      }
    },

    /**
     * Click event handler which opens the popup. This is necessary for older
     * versions of JAWS which send the wrong events.
     *
     * Tapping on the view once the popup is rendered closes the popup. This
     * is necessary because safari on iPad won't fire a mouseleave
     * (or equivalent) event when tapping outside the popup.
     *
     * Qualifier: Safari will file a mouseleave event when tapping on another
     * "tappable" element, but not when tapping on empty space. This "close on
     * second tap" behavior is desireable
     *
     * @param  {Event} e The event that triggered this callback.
     */
    _onClick: function (e) {
      if (!this._isOpened()) {
        this._openPopup(e);
      }
      else {
        this._closePopup(e);
      }
    },

    /**
     * Sets up keyboard navigation.
     *
     * Event callbacks are set up here instead of in an events object so that
     * we don't have misfires, e.g., hovering over trustmark causes the csa
     * popup to appear.
     *
     * click events trigger _onClick.
     * keydown events trigger _onKeydown.
     *
     * This does NOT call BHoverableView's setupKeyboardNavigation.
     * Doing so would cause the popup to appear on focus, which is not what
     * we want.
     *
     * @param $targetEl : The target element.
     * @override
     */
    setupKeyboardNavigation: function ($targetEl) {
      // Remember, no supercalls.
      $targetEl = $targetEl || this.$targetEl;
      $targetEl.off('click.bpopuptargetview').on('click.bpopuptargetview', _.bind(this._onClick, this));
      $targetEl.off('keydown.bpopuptargetview').on('keydown.bpopuptargetview', _.bind(this._onKeydown, this));
    },

    _handleTouchstart: function (e) {
      // If the user is tapping on the target a second time, close the popup.
      if (this.targetView && this.targetView.rendered) {
        this.leave(e);
      }
      else {
        // Otherwise the user is tapping on the target for the first time, so
        // we should set up a listener that will close the popup if the user
        // taps anywhere outside the popup.
        this.enter(e);

        // Attaching this now means that the _closeViewIfExternalTouch
        // handler will react to the same event that triggered this handler,
        // so we have to detect that in _closeViewIfExternalTouch and ignore
        // it. Other options (stopping event propagation, attaching handler
        // after a short timeout) felt slimy. -APD
        this._attachTouchListener();
      }
    },

    _attachTouchListener: function () {
      if (this._listenerAttached) { return; }
      $(body()).on('touchstart.bhoverable' + this.uniq,
        $.proxy(this._closeViewIfExternalTouch, this));
      this._listenerAttached = true;
    },

    _detachTouchListener: function () {
      this._listenerAttached = false;
      $(body()).off('touchstart.bhoverable' + this.uniq);
    },

    _closeViewIfExternalTouch: function (e) {
      if (!this.targetView || !this.targetView.viewEl) {
        // If there's no popup element, it means this popup isn't even
        // visible anymore, so this listener is stale and should be cleaned
        // up.
        this._detachTouchListener();
        return;
      }

      if (this.$targetEl.has($(e.target)).length > 0) {
        // Ignore if the touch was on the target element. This will only
        // happen when we react to the same touch event that opened the popup
        // (as it propagates up to the BODY tag), and we want to ignore that
        // event. We don't need to handle subsequent touches on the target
        // element because those will get handled by _handleTouchstart.
        return;
      }

      // Did this touch happen outside of the popup? If so, close the popup.
      if (this.targetView.$viewEl.has($(e.target)).length <= 0) {
        this._detachTouchListener();
        this.leave(e);
      }
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!trustmarkIcon',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <button class=\"bv-trustmarkIcon-popup-target bv-focusable\" aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "authentic_reviews", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "authentic_reviews", depth0.msgpack, depth0, options)))
    + "\"> <img class=\"bv-trustmarkIcon-image\" alt=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "trustmarkIcon", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "trustmarkIcon", depth0.msgpack, depth0, options)))
    + "\" src=\"";
  if (stack2 = helpers.trustmarkUrl) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.trustmarkUrl; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" /> </button> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("trustmarkIcon")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('trustmarkIcon', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!trustmarkPopup',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div class=\"bv-tm-popup-arrow\"></div> <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-popup-inner bv-popup-trustmark-inner bv-focusable\" tabindex=\"0\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "trustmarkPopupText", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "trustmarkPopupText", depth0.msgpack, depth0, options)))
    + " </div> </div> ";
  return buffer;
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("popup popup-trustmark")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('trustmarkPopup', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview Utility to wrap trustmark URLs with anchor tags for locales that
 *               require all URLs to be links.
 */
BV.define('bv/util/wrapTrustmarkUrl',[
  'ENV',
  'underscore'
], function (
  ENV,
  _
) {

  // Whether a URL is required to be a link depends on local law.
  // As a general rule of thumb, we get in trouble if it should be a link and
  // isn't, but not the other way around.
  // Currently, the US and Canada allow not linking URLs.
  // Everyone else should have a link, unless specified otherwise.
  // Please see https://bits.bazaarvoice.com/jira/browse/RNR-7 for details.
  var doesNotRequireLink = {
    US: true,
    CA: true
  };

  return function (url) {
    var localeSplit = ENV.get('config').locale.split('_');
    var country = _(localeSplit).last();

    if (doesNotRequireLink[country]) {
      // If we are in a country that allows us to not link, we can just
      // return the plaintext url here.
      return url;
    }

    // If the current locale requires us to have links, we'll need to wrap the
    // url in a link tag.
    url = '<a class="bv-focusable" href="' + url + '" target="_blank">' + url + '</a>';

    return url;
  };
});

BV.define('mf!bv/c2013/messages/trustmark',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"trustmarkIcon" : function (x) { try { return (function(d){
var r = "";
r += "The trustmark icon that reveals a popup describing BV authenticity";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `trustmarkIcon`: ' + e.toString() ) ] ); return ""; } },"trustmarkPopupText" : function (x) { try { return (function(d){
var r = "";
r += "These reviews are managed by Bazaarvoice and comply with the Bazaarvoice Authenticity Policy, which is supported by anti-fraud technology and human analysis.<br />Details at ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["url"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `trustmarkPopupText`: ' + e.toString() ) ] ); return ""; } },"authentic_reviews" : function (x) { try { return (function(d){
var r = "";
r += "Authentic Reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `authentic_reviews`: ' + e.toString() ) ] ); return ""; } }
};
});

/**
 * @fileOverview View for the Trustmark Popup
 */
BV.define('bv/c2013/view/trustmarkPopup',[
  'ENV',
  'bv/ui-core/bpopupview',
  'hbs!trustmarkPopup',
  'jquery',
  'underscore',
  'bv/util/wrapTrustmarkUrl',
  'mf!bv/c2013/messages/trustmark'
], function (ENV, BPopupView, template, $, _, wrapTrustmarkUrl, trustmarkMessages) {
  var baseUrlBeginning = 'http://www.bazaarvoice.com/';
  var baseUrlEnd = 'trustmark/';
  var country;

  // Many languages have a country code that matches their language code:
  // fr has FR, de has DE, etc.
  // A few languages don't have this, so we need to match to a country code
  // that for these languages.
  var oddLanguageToCountryCodes = {
    da: 'dk',
    sv: 'se',
    ja: 'jp'
  };

  return BPopupView.extend({

    name: 'trustmarkPopup',

    msgpacks: [trustmarkMessages],

    options: _.extend({}, BPopupView.prototype.options, {
      popupInClass: 'bv-dropdown-in',
      popupOutClass: 'bv-dropdown-out'
    }),

    width: 325,

    template: template,

    topPositionModifier: function (pos) {
      return pos - 5;
    },

    /**
     * Generates the Trustmark URL for the current locale.
     * We are not responsible for making sure the language is supported.
     * We may assume that we are in a language for which there is a translated
     * trustmark page.
     *
     * @return {String} The Trustmark URL for the current locale.
     */
    _trustmarkUrl: function () {
      var url;
      var locale = ENV.get('config').locale;
      var language = locale.split('_')[0];

      // English is a special case.
      // It must not have the language code in the URL.
      if (language === 'en') {
        url = baseUrlBeginning + baseUrlEnd;
        return url;
      }

      // The trustmark page has its language determined by country code, which
      // I hate. For many languages, the language code and correct country code
      // are the same, e.g., French and France are both 'fr'. To build the
      // trustmark URL, we take the language code and assume that it has a
      // country code of the same value. For example, if the locale is 'de_GB',
      // we need to link to http://www.bazaarvoice.com/de/trustmark/.
      //
      // For a few exceptions, this code is not the same, e.g., Danish and
      // Denmark are 'da' and 'dk' respectively.
      // So, if the language is 'da', we need to link to
      // http://www.bazaarvoice.com/dk/trustmark/.
      //
      // These special cases are held in the oddLanguageToCountryCodes object.
      // If our current language has an entry in that object, we need to use
      // that mapping. Otherwise, we can just re-use the language code.
      country = oddLanguageToCountryCodes[language] || language;
      url = baseUrlBeginning + country + '/' + baseUrlEnd;

      return url;
    },

    init: function (config) {
      BPopupView.prototype.init.call(this, config);

      this.model.set('url', wrapTrustmarkUrl(this._trustmarkUrl()));
    }
  });
});

/**
 * @fileOverview View for the Trustmark Icon
 */
BV.define('bv/c2013/view/trustmarkIcon',[
  'bv/ui-core/bpopuptargetview',
  'underscore',
  'hbs!trustmarkIcon',
  'bv/c2013/view/trustmarkPopup',
  'util/specialKeys',
  'mf!bv/c2013/messages/trustmark'
], function (BPopupTargetView, _, template, TrustmarkPopupView, specialKeys, trustmarkMessages) {
  return BPopupTargetView.extend({
    linkEl: '.bv-trustmarkIcon-popup-target',

    name: 'trustmarkIcon',

    msgpacks: [trustmarkMessages],

    classList: ['trustmarkIcon-target'],

    template: template,

    TargetView: TrustmarkPopupView,

    targetViewOptions: { startDelay: 500 }
  });
});

BV.define('bv/c2013/model/statsPanel',[
  'ENV',
  'framework/bmodel',
  'underscore'
], function (ENV, BModel, _) {
  return BModel.extend({
    name: 'statsPanel',

    processData: function (data) {
      var parent = this.get('parent');
      if (parent) {
        this.set({
          Product: parent.get('Product'),
          subject: parent.get('subject')
        });
        parent.onDataReady(function () {
          this.dataReady(data);
        }, this);
      }
    }

  });
});

/* START GENERATED MESSAGE */
BV.define('_i18n_searchStatsTotalReviewCount', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function searchStatsTotalReviewCount( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> <span class=\"bv-content-data-label\">Review</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> <span class=\"bv-content-data-label\">Reviews</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `searchStatsTotalReviewCount`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_searchStatsTotalReviewCount', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return searchStatsTotalReviewCount(data);
});
return searchStatsTotalReviewCount;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_searchStatsTotalQuestionCount', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function searchStatsTotalQuestionCount( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> <span class=\"bv-content-data-label\">Question</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += "</span> <span class=\"bv-content-data-label\">Questions</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `searchStatsTotalQuestionCount`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_searchStatsTotalQuestionCount', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return searchStatsTotalQuestionCount(data);
});
return searchStatsTotalQuestionCount;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_searchStatsTotalAnswerCount', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function searchStatsTotalAnswerCount( data ) {
try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalSecondaryCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += "</span> <span class=\"bv-content-data-label\">Answer</span>";
return r;
},
"other" : function(d){
var r = "";
r += "<span class=\"bv-content-title\">";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalSecondaryCount"];
r += "</span> <span class=\"bv-content-data-label\">Answers</span>";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `searchStatsTotalAnswerCount`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_searchStatsTotalAnswerCount', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return searchStatsTotalAnswerCount(data);
});
return searchStatsTotalAnswerCount;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!statsPanel',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/withIf', '_i18n_searchStatsTotalReviewCount', '_i18n_searchStatsTotalQuestionCount', '_i18n_searchStatsTotalAnswerCount'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Content), options) : helperMissing.call(depth0, "withIf", ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Content), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(5, program5, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Content), options) : helperMissing.call(depth0, "withIf", ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Content), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Reviews, options) : helperMissing.call(depth0, "withIf", depth0.Reviews, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-content-product-stats-item bv-content-product-stats-item-first bv-content-product-stats-item-reviews\"> <a href=\"#\" class=\"bv-content-data-count bv-focusable\" data-content-type=\"review\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_searchStatsTotalReviewCount),stack1 ? stack1.call(depth0, depth0.Statistics, options) : helperMissing.call(depth0, "_i18n_searchStatsTotalReviewCount", depth0.Statistics, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </a> </li> ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Questions, options) : helperMissing.call(depth0, "withIf", depth0.Questions, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-content-product-stats-item bv-content-product-stats-item-questions\"> <a href=\"#\" class=\"bv-content-data-count bv-focusable\" data-content-type=\"question\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_searchStatsTotalQuestionCount),stack1 ? stack1.call(depth0, depth0.Statistics, options) : helperMissing.call(depth0, "_i18n_searchStatsTotalQuestionCount", depth0.Statistics, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </a> </li> <li class=\"bv-content-product-stats-item bv-content-product-stats-item-last bv-content-product-stats-item-answers\"> <a href=\"#\" class=\"bv-content-data-count bv-focusable\" data-content-type=\"question\"> "
    + " ";
  options = {hash:{}};
  stack2 = ((stack1 = helpers._i18n_searchStatsTotalAnswerCount),stack1 ? stack1.call(depth0, depth0.Statistics, options) : helperMissing.call(depth0, "_i18n_searchStatsTotalAnswerCount", depth0.Statistics, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </a> </li> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("ul"),
    'classList': ("content-product-stats")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('statsPanel', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/statsPanel',[
  'framework/bview',
  'framework/util/bvtracker',
  'underscore',
  'hbs!statsPanel',
  'bv/util/contentType',
  'bv/util/productInfo',
  'jquery'
], function (BView, BVTracker, _, template, ContentType, ProductInfo, $) {

  function clickHandler (statsKey, detail1, bvProduct) {
    return function (e) {
      var contentType = $(e.currentTarget).attr('data-content-type');
      var statsObject = this.model.get('Product')[statsKey];

      this.getTopModel().trigger('show' + ContentType.nouns(contentType), e);
      e.preventDefault();

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: detail1,
        detail2: 'SearchBarRatingSummary',
        quantity: (statsObject && statsObject.Statistics) ? statsObject.Statistics.TotalCount : 0,
        bvProduct: bvProduct,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    };
  }

  return BView.extend({
    name: 'statsPanel',
    el: '.bv-content-product-stats',

    events: {
      'click .bv-content-product-stats-item-reviews .bv-content-data-count': 'showReviewContent',
      'click .bv-content-product-stats-item-questions .bv-content-data-count': 'showQuestionContent',
      'click .bv-content-product-stats-item-answers .bv-content-data-count': 'showAnswerContent'
    },

    template: template,

    init: function (config) {
      this.subscribe('highlightstats', this.highlightStats);
    },

    showReviewContent: clickHandler('Reviews', 'ReviewCount', ProductInfo.RATINGSANDREVIEWS),
    showQuestionContent: clickHandler('Questions', 'SummaryQuestionStats', ProductInfo.ASKANDANSWER),
    showAnswerContent: clickHandler('Questions', 'SummaryQuestionStats', ProductInfo.ASKANDANSWER),

    highlightStats: function (target) {
      this.$viewEl.find('.bv-stats-highlight').removeClass('bv-stats-highlight');
      if (target && target.target) {
        this.$viewEl.find('a[data-content-type="' + ContentType.noun(target.target) + '"]').addClass('bv-stats-highlight');
      }
    }

  });
});

BV.define('bv/c2013/model/avatar',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/util/socialAvatar',
  'dimsumFields!fieldCategories'
], function (ENV, BModel, _, SocialAvatar, dimsumFieldCategoryMap) {
  return BModel.extend({

    options: {},
    name: 'avatar',

    init: function (config, options) {
      var parent = this.get('parent');
      var author;
      var _isPreview;
      var isSyndicated;
      // Mixin options
      _.extend(this.options, options);

      if (parent) {
        author = _.extend({}, parent.get('Author'));
        _isPreview = parent.get('_isPreview');
        isSyndicated = parent.get('IsSyndicated');
        this.combineStats(author);
        author.TypeContext = parent.get('Type');

        if (author.TypeContext === 'review') {
          // use the review's location instead of the author's location, if available
          author.Location = parent.get('UserLocation') || author.Location;
        }

        author.DisplayContext = 'popup';
        // Anonymous reviewers have posted 1 review (at least)
        if (author.TypeContext === 'review' && !author.DisplayName) {
          author.TotalReviewCount = 1;
        }

        // Identify and mark the CommunityAnswer author
        author.communityAnswer = parent.get('CampaignId') === 'BVCROWDSOURCE';

        this.set({
          Author: author,
          _isPopup: true,
          _isPreview: _isPreview,
          isSyndicated: isSyndicated
        });
      }

      if (this.hasFeature('socialAvatar')) {
        this.generateAvatarImage(author);
      }
    },

    combineStats: function (author) {
      var stats = {
        TotalCount: 0,
        HelpfulVoteCount: 0
      };

      var reviewStatistics;
      var questionStatistics;

      if (!author || !author.Content) {
        return;
      }

      reviewStatistics = (author.Content.Reviews || {}).Statistics;
      questionStatistics = (author.Content.Questions || {}).Statistics;

      if (reviewStatistics) {
        stats.TotalCount = stats.TotalCount + reviewStatistics.TotalCount;
        stats.HelpfulVoteCount = stats.HelpfulVoteCount + reviewStatistics.HelpfulVoteCount;
      }

      if (questionStatistics) {
        stats.TotalCount = stats.TotalCount + questionStatistics.TotalCount + questionStatistics.TotalSecondaryCount;
        stats.HelpfulVoteCount = stats.HelpfulVoteCount + (questionStatistics.HelpfulVoteCount || 0) + (questionStatistics.AnswerHelpfulVoteCount || 0);
      }
      author.TotalStatistics = stats;
    },

    generateAvatarImage: function (author) {
      var parent = this.get('parent');
      var authorInParent;

      if (author) {
        author._avatarImage = SocialAvatar.image(author);
        authorInParent = parent.get('Author');
        if (parent && authorInParent) {
          authorInParent._avatarImage = author._avatarImage;
          authorInParent.lazyLoad = parent.get('lazyLoad');
        }
      }
    },

    toJSON: function () {
      var json = BModel.prototype.toJSON.call(this);

      // If our author doesn't have ContextDataValues but the item does, copy them onto the author
      // for rendering
      if (!json.Author.ContextDataValues) {
        // Only copy over people questions.
        json.Author.ContextDataValuesOrdered = [];
        json.Author.ContextDataValues = {};
        json.Author.ContextDataValuesOrder = [];
        _(json.parent.get('ContextDataValuesOrdered')).each(function (cdv) {
          if (dimsumFieldCategoryMap.fieldCategoryMap['contextdatavalue_' + cdv.Id] === 'people') {
            json.Author.ContextDataValuesOrdered.push(cdv);
            json.Author.ContextDataValuesOrder.push(cdv.Id);
            json.Author.ContextDataValues[cdv.Id] = cdv;
          }
        });
      }

      // If no DisplayName, check for and use UserNickname
      if (!json.Author.DisplayName) {
        json.Author.DisplayName = json.parent.get('UserNickname');
      }

      return json;
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!authorName',['hbs','vendor/handlebars/runtime', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <h4>"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h4> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <span>"
    + escapeExpression(((stack1 = ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.DisplayName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.contentType, "Answers", options) : helperMissing.call(depth0, "equals", depth0.contentType, "Answers", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('authorName', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorAvatar',['hbs','vendor/handlebars/runtime','hbs!authorName', 'template/helpers/view', 'template/helpers/withIf', 'template/helpers/equals', 'template/helpers/schemaType', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Author, options) : helperMissing.call(depth0, "withIf", depth0.Author, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " ";
  options = {hash:{},inverse:self.programWithDepth(program11, data, depth1),fn:self.programWithDepth(program3, data, depth1)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.ModerationStatus, "APPROVED", options) : helperMissing.call(depth0, "equals", depth0.ModerationStatus, "APPROVED", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "fullProfileLink", depth2, options) : helperMissing.call(depth0, "ifHasFeature", "fullProfileLink", depth2, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <button id=\"bv-avatar-popup-target-";
  if (stack1 = helpers.componentId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.componentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-avatar-popup-target bv-focusable\" itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> ";
  stack2 = self.invokePartial(partials.authorName, 'authorName', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "hoverProfile", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "hoverProfile", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <button id=\"bv-avatar-popup-target-";
  if (stack1 = helpers.componentId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.componentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-avatar-popup-target bv-focusable\" itemprop=\"author\"> ";
  stack2 = self.invokePartial(partials.authorName, 'authorName', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-avatar-author-name\" itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> ";
  stack2 = self.invokePartial(partials.authorName, 'authorName', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }

function program11(depth0,data,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-avatar-author-name\" itemprop=\"";
  options = {hash:{
    'comment': ("creator"),
    'def': ("author")
  }};
  buffer += escapeExpression(((stack1 = helpers.schemaType),stack1 ? stack1.call(depth0, depth0.Type, options) : helperMissing.call(depth0, "schemaType", depth0.Type, options)))
    + "\"> ";
  stack2 = self.invokePartial(partials.authorName, 'authorName', depth2, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("span"),
    'classList': ("author")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorAvatar', t);
t.deps = ["authorName"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorProfile',['hbs','vendor/handlebars/runtime','hbs!contentAuthorIcon', 'hbs!contentAuthor', 'hbs!contentAuthorLocation', 'hbs!contentAuthorStats', 'hbs!userBadges', 'hbs!contentAuthorCDVs', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorIcon, 'contentAuthorIcon', depth0.Author, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "bv-contains-profile-button";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorLocation, 'contentAuthorLocation', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorStats, 'contentAuthorStats', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.userBadges, 'userBadges', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorCDVs, 'contentAuthorCDVs', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += "<div class=\"bv-author-avatar\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "socialAvatar", options) : helperMissing.call(depth0, "ifHasFeature", "socialAvatar", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <div class=\"bv-author-avatar-nickname\"> ";
  stack2 = self.invokePartial(partials.contentAuthor, 'contentAuthor', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> <div class=\"bv-popup-prosnap-userinfo ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "fullProfileLink", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "fullProfileLink", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" > ";
  stack2 = self.invokePartial(partials.contentAuthor, 'contentAuthor', depth0, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers.unless.call(depth0, depth0._isPreview, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorProfile', t);
t.deps = ["contentAuthorIcon","contentAuthor","contentAuthorLocation","contentAuthorStats","userBadges","contentAuthorCDVs"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START GENERATED MESSAGE */
BV.define('_i18n_fullProfileLink', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function fullProfileLink( data ) {
try { return (function(d){
var r = "";
r += "See My Profile";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `fullProfileLink`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_fullProfileLink', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return fullProfileLink(data);
});
return fullProfileLink;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorFullProfileLink',['hbs','vendor/handlebars/runtime', '_i18n_fullProfileLink'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function";


  buffer += "<div class=\"bv-action-bar\"> <button type=\"button\" class=\"bv-view-profile bv-focusable\"> "
    + " ";
  if (stack1 = helpers._i18n_fullProfileLink) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_fullProfileLink; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </button> </div>";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorFullProfileLink', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentAuthorAvatarPopup',['hbs','vendor/handlebars/runtime','hbs!contentAuthorProfile', 'hbs!contentAuthorFullProfileLink', 'template/helpers/view', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-author-profile bv-popup-inner bv-focusable\" tabindex=\"0\"> ";
  stack1 = self.invokePartial(partials.contentAuthorProfile, 'contentAuthorProfile', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.Author),stack1 == null || stack1 === false ? stack1 : stack1.showProfileLink), {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "fullProfileLink", depth0, options) : helperMissing.call(depth0, "ifHasFeature", "fullProfileLink", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentAuthorFullProfileLink, 'contentAuthorFullProfileLink', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role=\"tooltip\" aria-describedby=\"bv-avatar-popup-target-";
  if (stack1 = helpers.componentId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.componentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.parentViewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("popup popup-prosnap")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorAvatarPopup', t);
t.deps = ["contentAuthorProfile","contentAuthorFullProfileLink"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/avatarPopup',[
  'bv/ui-core/bpopupview',
  'bv/util/productInfo',
  'underscore',
  'hbs!contentAuthorAvatarPopup',
  'mf!bv/c2013/messages/avatar',
  'framework/util/bvtracker',
  'bv/util/focusManager'
], function (BPopupView, ProductInfo, _, template, msgPack, BVTracker, focusManager) {
  return BPopupView.extend({

    name: 'avatarPopup',

    options: _.extend({}, BPopupView.prototype.options, {
      alignArrow: false
    }),

    width: 320,

    height: 300,

    events: {
      'click .bv-view-profile': 'viewFullProfile'
    },

    template: template,

    msgpacks: [msgPack],

    attach: function (elToAttach) {
      BPopupView.prototype.attach.apply(this, arguments);
      // Commenting out for UIA-4566.
      // Always move focus to the first focusable item when the dropdown is attached.
      this.model.once('dropdownRendered', function () {
        focusManager.moveFocus(this.$viewEl.find('.bv-focusable'));
      }, this);
    },

    topPositionModifier: function (pos) {
      return pos + this.parent.$targetEl.outerHeight(true);
    },

    viewFullProfile: function (event) {
      // hide profile snapshot
      this.detach();

      // use r&r component outlet to trigger full profile popup component event
      this.getTopModel().trigger('showfullprofile', this.model.get('Author'));

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'ViewProfileButton',
        detail2: 'AuthorAvatar',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }

  });
});

/**
 * @fileOverview View for the Avatar.
 */
BV.define('bv/c2013/view/avatar',[
  'jquery',
  'bv/ui-core/bpopuptargetview',
  'bv/util/productInfo',
  'underscore',
  'hbs!contentAuthorAvatar',
  'bv/c2013/view/avatarPopup',
  'framework/util/bvtracker'
], function ($, BPopupTargetView, ProductInfo, _, template, AvatarPopupView, BVTracker) {
  return BPopupTargetView.extend({

    name: 'avatar',

    linkEl: '.bv-avatar-popup-target',

    template: template,

    TargetView: AvatarPopupView,


    /**
     * Sets up keyboard navigation.
     * Event callbacks are set up here because they are easier to test.
     *
     * @param $targetEl : The target element.
     */
    setupKeyboardNavigation: function ($targetEl) {
      $targetEl = $targetEl || this.$targetEl;
      BPopupTargetView.prototype.setupKeyboardNavigation.call(this, $targetEl);

      // Mouse enter events should trigger the _onMouseenter callback.
      $targetEl.off('mouseenter.avatar').on('mouseenter.avatar', _.bind(this._onMouseenter, this));
    },

    /**
     * When the avatar is moused over, we want to report it to magpie.
     *
     * @param  {Event} e The event that triggered this callback.
     */
    _onMouseenter: function (e) {
      BVTracker.feature({
        type: 'Used',
        name: 'Hover',
        detail1: 'Profile',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }
  });
});

/*
 * JavaScript MD5 1.0
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

BV.define('util/md5',[], function () {

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    function md5(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }

    return md5;

});
// From: http://blog.stevenlevithan.com/archives/parseuri
BV.define('util/parseuri',[],function () {

	function parseUri (str) {
		var o = parseUri.options;
		var m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str);
		var uri = {};
		var i = 14;

		while (i--) {
			uri[o.key[i]] = m[i] || '';
		}

		uri[o.q.name] = {};
		uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
			if ($1) {
				uri[o.q.name][$1] = $2;
			}
		});

		return uri;
	}

	parseUri.options = {
		strictMode : false,
		key : ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
		q :   {
			name :   'queryKey',
			parser : /(?:^|&)([^&=]*)=?([^&]*)/g
		},
		parser : {
			strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
			loose :  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
		}
	};

	return parseUri;

});

/**
 * @fileOverview
 * The DomainPolice module is used to provide validation that content is only
 * being loaded on authorized domains.
 */
BV.define('bv/util/domainPolice',[
  'ENV',
  'underscore',
  'util/parseuri',
  'util/url',
  'window'
], function (ENV, _, parseUri, urlUtil, window) {

  /**
   * Returns the configured domain if the hostname matches one.
   *
   * @param  {String}  url     The URL to check (including protocol, e.g. "http://example.com")
   * @return {String|undefined} The domain as configured e.g. ".example.com"
   */
  function allowedDomain (url) {
    // If no URL is provided, assume the current origin.
    if (!url) {
      url = urlUtil.origin;
    }

    var host = parseUri(url).authority;
    var domains = _(ENV.get('config').allowedDomains).clone();
    var domain;

    for (var i = 0; i < domains.length; i++) {
      if (domainMatches(domains[i].domainAddress, host)) {
        domain = domains[i].domainAddress;

        // Special case: If the domain is a valid IPv4 address,
        // remove the leading period. The return value here is used
        // when setting a cookie, and IPv4 addresses with a prefixed
        // period do not work for cookie setting, as they do for domains.
        if (domain.match(/^(\.\d+){4}$/)) {
          domain = domain.substr(1);
        }

        return domain;
      }
    }

    return undefined;
  }

  /**
   * Returns true if the hostname is an exact match for a specific domain or a
   * suffix match for a wildcard domain (domain starts with a '.').
   *
   * @param  {[type]}  domain      Domain to check.
   * @param  {[type]}  hostAndPort Domain to check against.
   * @return {Boolean}
   */
  function domainMatches (domain, hostAndPort) {
    if (domain.charAt(0) === '.') {
      // Strip the trailing port (if any) from the hostname.
      var match = /^([^:]*)(:\d+)?$/.exec(hostAndPort);
      var host = match && match[1];
      if (host) {
        // domainMatches('.domain.com', 'sub.domain.com') and
        // domainMatches('.sub.domain.com', 'sub.domain.com') are both true.
        var index = ('.' + host).lastIndexOf(domain);
        return index >= 0 && index === (1 + host.length - domain.length);
      }
    }

    if (hostAndPort === domain) {
      return true;
    }

    return hostAndPort === ("www." + domain);
  }

  /**
   * Returns true if third party cookies are enabled for the current domain.
   *
   * @return {Boolean}
   */
  function thirdPartyCookieEnabled () {
    // In the case of server render, we can just return false.
    if (!window.location || !window.location.host) {
      return false;
    }

    var domains = _(ENV.get('config').allowedDomains).clone();

    // If allowedDomains is empty, return false.
    if (_.isEmpty(domains)) {
      return false;
    }

    for (var i = 0; i < domains.length; i++) {
      var matches = domainMatches(domains[i].domainAddress, window.location.host);
      if (matches && domains[i].thirdPartyCookieEnabled) {
        return true;
      }
    }
    return false;
  }


  /**
   * Returns true if first party cookies are enabled for the current domain.
   *
   * @return {Boolean}
   */
  function firstPartyCookieEnabled () {
    // In the case of server render, we can just return false.
    if (!window.location || !window.location.host) {
      return false;
    }

    var domains = _(ENV.get('config').allowedDomains).clone();

    // If allowedDomains is empty, return false.
    if (_.isEmpty(domains)) {
      return false;
    }

    for (var i = 0; i < domains.length; i++) {
      var matches = domainMatches(domains[i].domainAddress, window.location.host);
      if (matches && domains[i].firstPartyCookieEnabled) {
        return true;
      }
    }
    return false;
  }

  return {
    allowedDomain: _.memoize(allowedDomain),
    thirdPartyCookieEnabled: _.memoize(thirdPartyCookieEnabled),
    firstPartyCookieEnabled: _.memoize(firstPartyCookieEnabled)
  };

});

BV.define('bv/util/session',[
  'ENV', 'backbone', 'jquery', 'underscore', 'window', 'client!util/cookie', 'util/checksum', 'util/md5', 'bv/util/domainPolice', 'BV'
], function (ENV, Backbone, $, _, window, Cookie, checksum, md5, DomainPolice, BV) {

  var sessionCookieName = 'bvf_' + checksum(ENV.get('config').clientname) + (ENV.get('config').environment === 'production' ? '' : 's');

  var sessionCookie = Cookie.read ? Cookie.read(sessionCookieName) : null;

  var rpcDfd = $.Deferred();
  var utilPath = ENV.get('config').utilPath;

  var withRPC = _.once(function () {
    BV.require(['secondary'], function (app) {
      var rpc = new BV.easyXDM.Rpc({
        isHost: true,
        hash: true,
        remote: 'https:' + utilPath + 'storage.htm',
        swf: 'https:' + utilPath + 'easyxdm.swf',
        props: {
          role: 'presentation',
          tabindex: '-1',
          title: 'empty'
        }
      }, {
        remote: {
          set: {},
          get: {},
          remove: {}
        }
      });
      rpcDfd.resolve(rpc);
    });
  });

  var cache = {};

  return {
    id: function () {
      return sessionCookie;
    },
    setup: function () {
      withRPC();
      return rpcDfd;
    },
    create: function () {
      this.setup();
      var secret = md5(sessionCookieName + $.now());
      Cookie.create(sessionCookieName, secret, null, DomainPolice.allowedDomain());
      sessionCookie = Cookie.read(sessionCookieName);
      return sessionCookie;
    },
    set: function (key, data, fn, errFn) {
      fn = fn || $.noop;
      errFn = errFn || $.noop;

      if (!sessionCookie) {
        this.create();
      }
      this.setup().done(function (rpc) {
        rpc.set(sessionCookieName + '_' + key, sessionCookie, data,
          function (result) {
            cache[key] = $.Deferred().resolve(result);
            fn(result);
          },
          errFn
        );
      });
    },
    _get: function (key, fn) {
      fn = fn || $.noop;
      if (sessionCookie) {
        this.setup().done(function (rpc) {
          rpc.get(sessionCookieName + '_' + key, sessionCookie, fn);
        });
      } else {
        fn();
      }
    },
    get: function (key, fn) {
      fn = fn || $.noop;
      if (sessionCookie) {
        if (!cache[key]) {
          cache[key] = cache[key] || $.Deferred();
          this._get(key, function (data) {
            cache[key].resolve(data);
          });
        }
        cache[key].done(fn);
      } else {
        fn();
      }
    },
    remove: function (key, fn) {
      fn = fn || $.noop;
      if (sessionCookie) {
        delete cache[key];
        this.setup().done(function (rpc) {
          rpc.remove(sessionCookieName + '_' + key, fn);
        });
      } else {
        fn();
      }
    }
  };

});


BV.define('bv/c2013/model/feedback',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/util/session',
  'bv/util/contentType'
], function (ENV, BModel, _, Session, ContentType) {
  return BModel.extend({
    name: 'feedback',

    processData: function (data) {
      var self = this;

      // We don't want to overwrite any of our own properties
      var feedbackData = _({}).extend(data, this.toJSON());
      self.set(feedbackData);

      Session.get('feedbacks', function (feedbacks) {
        var contentType;
        var contentId;
        var helpfulness;

        if (!feedbacks) {
          self.dataReady(self.toJSON());
          return;
        }

        contentType = self.getSubmitType();
        contentId = self.get('Id');

        if (contentType && contentId) {

          // Check for helpfulness votes
          helpfulness = feedbacks[contentType + '-h-' + contentId];
          if (helpfulness && helpfulness.v && helpfulness.c) {

            _(['Positive', 'Negative']).forEach(function (type) {
              var lcType = type.toLowerCase();
              var countKey = 'Total' + type + 'FeedbackCount';
              var newData = { _FeedbackVoted: lcType };

              if (helpfulness.v === lcType.charAt(0)) {
                newData[countKey] = Math.max(helpfulness.c, self.get(countKey));
                self.set(newData);
              }
            });

          }

          // See if there're inappropriate votes
          if (feedbacks[contentType + '-i-' + contentId]) {
            self.set('_MarkedAsInappropriate', true);
          }
        }

        self.dataReady(self.toJSON());

      });
    },

    getSubmitType: function () {
      var contentType = ContentType.noun(this.get('contentType'));
      var topModel;
      if (contentType === 'comment') {
        topModel = this.getTopModel();
        if (topModel) {
          contentType = ContentType.noun(topModel.get('contentType')) + '_' + contentType;
        }
      }
      return contentType;
    },

    toJSON: function () {
      var json = BModel.prototype.toJSON.call(this);
      json.contentSelectType = ContentType.noun(json.contentType);
      // Create an explicit boolean for screen reader messages to detect if there is a title.
      if (json.Title) {
        json.hasTitle = true;
      }
      return json;
    }

  });
});

/* START GENERATED MESSAGE */
BV.define('_i18n_contentReportedBtn', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function contentReportedBtn( data ) {
try { return (function(d){
var r = "";
r += "Reported";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `contentReportedBtn`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_contentReportedBtn', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return contentReportedBtn(data);
});
return contentReportedBtn;
});
/* END GENERATED MESSAGE */;
/* START GENERATED MESSAGE */
BV.define('_i18n_contentReportBtn', ['vendor/messageformat', 'vendor/handlebars/runtime', 'underscore', 'framework/util/bvtrackerqueue'], function (MessageFormat, Handlebars, _, BVTrackerQueue) {
function contentReportBtn( data ) {
try { return (function(d){
var r = "";
r += "Report";
return r;
})(data); } catch(e) { BVTrackerQueue.push( [ 'error', new Error('MF error on `contentReportBtn`: ' + e.toString() ) ] ); return ''; }
}
Handlebars.registerHelper('_i18n_contentReportBtn', function () {
var data = {};
var args = [].slice.call( arguments, 0, arguments.length-1 );
_(args).forEach(function (arg) {
  _.extend(data, arg);
});
return contentReportBtn(data);
});
return contentReportBtn;
});
/* END GENERATED MESSAGE */;
/* START_TEMPLATE */
BV.define('hbs!inappropriate',['hbs','vendor/handlebars/runtime', '_i18n_contentReportedBtn', '_i18n_contentReportBtn'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var stack1, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  if (stack1 = helpers._i18n_contentReportedBtn) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_contentReportedBtn; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " ";
  if (stack1 = helpers._i18n_contentReportBtn) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._i18n_contentReportBtn; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, depth0, {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });
Handlebars.registerPartial('inappropriate', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!feedback',['hbs','vendor/handlebars/runtime','hbs!inappropriate', 'template/helpers/view', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.isSimple, {hash:{},inverse:self.program(10, program10, data),fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.IsSyndicated, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-content-feedback-vote ";
  stack1 = helpers['if'].call(depth0, depth0._FeedbackVoted, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" role=\"group\" aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentHelpfulAriaLabel", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentHelpfulAriaLabel", depth0.msgpack, depth0, options)))
    + "\"> <div class=\"bv-content-feedback-vote-request\"> <p>";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentHelpfulQuestion", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentHelpfulQuestion", depth0.msgpack, depth0, options)))
    + "</p> </div> <div class=\"bv-content-feedback-btn-container\"> <button type=\"button\" class=\"bv-content-btn bv-content-btn-feedback-yes bv-focusable\" aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "positiveFeedback", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "positiveFeedback", depth0.msgpack, depth0, options)))
    + " ";
  options = {hash:{
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "markAsHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "markAsHelpful", depth0.msgpack, depth0, options)))
    + "\"> <span aria-hidden=\"true\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentIsHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentIsHelpful", depth0.msgpack, depth0, options)))
    + " &middot; <span class=\"bv-content-btn-count\" aria-hidden=\"true\">";
  if (stack2 = helpers.TotalPositiveFeedbackCount) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.TotalPositiveFeedbackCount; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> </span> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreenHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreenHelpful", depth0.msgpack, depth0, options)))
    + "</span> </button> <button type=\"button\" class=\"bv-content-btn bv-content-btn-feedback-no bv-focusable\" aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "negativeFeedback", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "negativeFeedback", depth0.msgpack, depth0, options)))
    + " ";
  options = {hash:{
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "markAsNotHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "markAsNotHelpful", depth0.msgpack, depth0, options)))
    + "\"> <span aria-hidden=\"true\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "contentIsNotHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "contentIsNotHelpful", depth0.msgpack, depth0, options)))
    + " &middot; <span class=\"bv-content-btn-count\" aria-hidden=\"true\">";
  if (stack2 = helpers.TotalNegativeFeedbackCount) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.TotalNegativeFeedbackCount; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span> </span> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreenNotHelpful", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreenNotHelpful", depth0.msgpack, depth0, options)))
    + "</span> </button> </div> <div class=\"bv-content-feedback-vote ";
  stack2 = helpers['if'].call(depth0, depth0._MarkedAsInappropriate, {hash:{},inverse:self.program(6, program6, data),fn:self.program(8, program8, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\"> <button type=\"button\" class=\"bv-content-report-btn bv-focusable\" aria-label=\"";
  options = {hash:{
    'protectString': (true)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "markAsInappropriate", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "markAsInappropriate", depth0.msgpack, depth0, options)))
    + "\"> ";
  stack2 = self.invokePartial(partials.inappropriate, 'inappropriate', depth0._MarkedAsInappropriate, helpers, partials);
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </button> </div> </div> ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "bv-content-feedback-voted-";
  if (stack1 = helpers._FeedbackVoted) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0._FeedbackVoted; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program6(depth0,data) {
  
  
  return "bv-content-feedback-vote-active";
  }

function program8(depth0,data) {
  
  
  return "bv-content-feedback-voted-inappropriate";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <div>";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "helpfulStats", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "helpfulStats", depth0.msgpack, depth0, options)))
    + "</div> ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("feedback-container")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('feedback', t);
t.deps = ["inappropriate"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/feedback',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"aria_alert_voted_positive" : function (x) { try { return (function(d){
var r = "";
r += "Your vote was successful. The number of positive helpfulness votes is now ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += ".";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `aria_alert_voted_positive`: ' + e.toString() ) ] ); return ""; } },"aria_alert_voted_negative" : function (x) { try { return (function(d){
var r = "";
r += "Your vote was successful. The number of negative votes is now ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += ".";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `aria_alert_voted_negative`: ' + e.toString() ) ] ); return ""; } },"aria_alert_voted_inappropriate" : function (x) { try { return (function(d){
var r = "";
r += "You have successfully reported this content as inappropriate.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `aria_alert_voted_inappropriate`: ' + e.toString() ) ] ); return ""; } },"markAsHelpful" : function (x) { try { return (function(d){
var r = "";
r += "Yes, ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["contentSelectType"];
r += " by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " is helpful.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `markAsHelpful`: ' + e.toString() ) ] ); return ""; } },"markAsNotHelpful" : function (x) { try { return (function(d){
var r = "";
r += "No, ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["contentSelectType"];
r += " by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " is not helpful.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `markAsNotHelpful`: ' + e.toString() ) ] ); return ""; } },"markAsInappropriate" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "hasTitle";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"true" : function(d){
var r = "";
r += "Mark ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Title"];
r += " by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "contentSelectType";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"review" : function(d){
var r = "";
r += "Mark this review by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"comment" : function(d){
var r = "";
r += "Mark this comment by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"clientresponse" : function(d){
var r = "";
r += "Mark this response by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"question" : function(d){
var r = "";
r += "Mark this question by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"answer" : function(d){
var r = "";
r += "Mark this answer by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
},
"other" : function(d){
var r = "";
r += "Mark this content by ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["authorDisplayName"];
r += " as inappropriate. ";
return r;
}
};
r += (pf_1[ k_2 ] || pf_1[ "other" ])( d );
r += " ";
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `markAsInappropriate`: ' + e.toString() ) ] ); return ""; } },"positiveFeedback" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Type";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalPositiveFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this review helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this review helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"answer" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalPositiveFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this answer helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this answer helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"comment" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalPositiveFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this comment helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this comment helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalPositiveFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this comment helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this comment helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `positiveFeedback`: ' + e.toString() ) ] ); return ""; } },"negativeFeedback" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Type";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"review" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalNegativeFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this review helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this review helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"answer" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalNegativeFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this answer helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this answer helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"comment" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalNegativeFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this comment helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this comment helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalNegativeFeedbackCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this comment helpful.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this comment helpful.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `negativeFeedback`: ' + e.toString() ) ] ); return ""; } },"offscreenHelpful" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "contentSelectType";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"review" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this review helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this review helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"comment" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this comment helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this comment helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"clientresponse" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this response helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this response helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"question" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this question helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this question helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"answer" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this answer helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this answer helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalPositiveFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " person found this content helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " people found this content helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
}
};
r += (pf_1[ k_2 ] || pf_1[ "other" ])( d );
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreenHelpful`: ' + e.toString() ) ] ); return ""; } },"offscreenNotHelpful" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "contentSelectType";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"review" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this review helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this review helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"comment" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this comment helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this comment helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"clientresponse" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this response helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this response helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"question" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this question helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this question helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"answer" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this answer helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this answer helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_3 = "TotalNegativeFeedbackCount";
var k_3=d[lastkey_3];
var off_2 = 0;
var pf_2 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " person did not find this content helpful. Click to agree.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalNegativeFeedbackCount"];
r += " people did not find this content helpful. Click to agree.";
return r;
}
};
if ( pf_2[ k_3 + "" ] ) {
r += pf_2[ k_3 + "" ]( d ); 
}
else {
r += (pf_2[ MessageFormat.locale["en"]( k_3 - off_2 ) ] || pf_2[ "other" ] )( d );
}
return r;
}
};
r += (pf_1[ k_2 ] || pf_1[ "other" ])( d );
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreenNotHelpful`: ' + e.toString() ) ] ); return ""; } },"contentHelpfulQuestion" : function (x) { try { return (function(d){
var r = "";
r += "Helpful?";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentHelpfulQuestion`: ' + e.toString() ) ] ); return ""; } },"contentHelpfulStatement" : function (x) { try { return (function(d){
var r = "";
r += "helpful";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentHelpfulStatement`: ' + e.toString() ) ] ); return ""; } },"contentHelpfulAriaLabel" : function (x) { try { return (function(d){
var r = "";
r += "Content helpfulness";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentHelpfulAriaLabel`: ' + e.toString() ) ] ); return ""; } },"contentIsHelpful" : function (x) { try { return (function(d){
var r = "";
r += "Yes";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentIsHelpful`: ' + e.toString() ) ] ); return ""; } },"contentIsNotHelpful" : function (x) { try { return (function(d){
var r = "";
r += "No";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `contentIsNotHelpful`: ' + e.toString() ) ] ); return ""; } },"helpfulStats" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "TotalPositiveFeedbackCount";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalFeedbackCount"];
r += " people found this helpful";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalPositiveFeedbackCount"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalFeedbackCount"];
r += " people found this helpful";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpfulStats`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/view/feedback',[
  'ENV',
  'framework/bview',
  'framework/util/bvtracker',
  'hbs!feedback',
  'hbs!inappropriate',
  'underscore',
  'jquery',
  'bv/api',
  'BV',
  'bv/util/session',
  'bv/util/loadingOverlay',
  'bv/util/productInfo',
  'bv/util/focusManager',
  'mf!bv/c2013/messages/feedback'
], function (ENV, BView, BVTracker, template, reportTemplate, _, $, api, BV, Session, LoadingOverlay, ProductInfo, focusManager, msgPack) {
  return BView.extend({
    name: 'feedback',

    events: {
      'click .bv-content-feedback-vote-active .bv-content-btn-feedback-yes': 'positive',
      'click .bv-content-feedback-vote-active .bv-content-btn-feedback-no': 'negative',
      'click .bv-content-feedback-vote-active .bv-content-report-btn': 'inappropriate'
    },

    template: template,

    msgpacks: [msgPack],

    init: function () {
      // Watch for model changes on _FeedbackVoted and _MarkedAsInappropriate.
      // These get set if we fetched remembered data stored in Session.
      // If they change, rerender view to represent user's interactions.
      this.listenTo(this.model, {
        'change:_FeedbackVoted': this.render,
        'change:_MarkedAsInappropriate': this.render
      });
    },

    // debounce to prevent spammy clicks
    _feedback: _.debounce(function (actionType, e) {
      var self = this;
      var dfd = $.Deferred();
      var newCount = (self.model.get('Total' + _.string.capitalize(actionType) + 'FeedbackCount') || 0) + 1;

      var submitType = this.model.getSubmitType();

      // Do the submission
      BV.require(['secondary'], function (app) {
        app.Submission.feedback[actionType](submitType, self.model.get('Id'), newCount)
          .then(dfd.resolve, dfd.reject);
      });

      dfd.fail(function (err, data) {
        self._undoFeedback(actionType, e, newCount - 1);
      });

      if ($.isReady) {
        reRender();
      }
      else {
        $(reRender);
      }

      // This function is responsible for re-rendering the feedback buttons;
      // this runs immediately if we've already reached domready, or on domready
      // if not.
      function reRender () {
        var $el = $(e.target).closest('button');
        var $buttonCount = $el.find('.bv-content-btn-count');

        // We could just trigger rerendering the view, but we're going to do all
        // this crazy stuff so we can animate.
        $el.closest('.bv-content-feedback-vote')
          .addClass('bv-content-feedback-voted-' + actionType)
          .removeClass('bv-content-feedback-vote-active');
        $buttonCount.text(newCount);

        // Also set the disabled property on the buttons
        $el.siblings('button').addBack().prop('disabled', true);

        // Focus the content item
        focusManager.moveFocus($el.closest('.bv-content-item'));

        if (actionType === 'inappropriate') {
          $el.html(reportTemplate(true));
        }

        dfd.done(function () {
          self.showAriaAlert(msgPack['aria_alert_voted_' + actionType]({ Count: newCount }));
        });
      }

      return dfd;
    }, 1000, true),

    _undoFeedback: function (actionType, e, oldCount) {
      var $el = $(e.target);
      var $buttonCount;
      if (actionType === 'inappropriate') {
        $el.html(reportTemplate(false));
      } else {
        $buttonCount = $el.find('.bv-content-btn-count');
        $el.closest('.bv-content-feedback-vote')
          .removeClass('bv-content-feedback-voted-' + actionType)
          .addClass('bv-content-feedback-vote-active');
        $buttonCount.text(oldCount);
      }
    },

    _analytics: function (detail) {
      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        bvProduct: ProductInfo.getType(this),
        contentType: this.model.get('Type'),
        contentId: this.model.get('Id'),
        productId: ProductInfo.getId(this),
        detail1: detail,
        categoryId: ProductInfo.getCategoryId(this)
      });
    },

    positive: function (e) {
      this._feedback('positive', e);
      this._analytics('YesHelpfulVote');
    },

    negative: function (e) {
      this._feedback('negative', e);
      this._analytics('NoHelpfulVote');
    },

    inappropriate: function (e) {
      this._feedback('inappropriate', e);
      this._analytics('ReportLink');
    },

    modelDataReady: function () {
      // If we've rendered already, trigger a re-render.
      if (this.$viewEl) {
        this.render();
      }
    }

  });
});

BV.define('bv/c2013/model/crowdSourcedAnswerBadge',[
  'framework/bmodel'
], function (BModel) {
  return BModel.extend({
    name: 'crowdSourcedAnswerBadge'
  });
});

/* START_TEMPLATE */
BV.define('hbs!crowdSourcedAnswerBadge',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <button class=\"bv-focusable bv-crowdSourcedAnswerBadge-popup-target\" tabindex=\"0\"> <span aria-hidden=\"true\">&#x2139;</span> <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("display_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "crowdSourcedAnswerText", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "crowdSourcedAnswerText", depth0.msgpack, depth0, options)))
    + "</span> </button> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("dl"),
    'classList': ("badge-summary crowdSourcedAnswerBadge-icon"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('crowdSourcedAnswerBadge', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!crowdSourcedAnswerBadgePopup',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-popup bv-popup-crowdSourcedAnswerBadgePopup bv-focusable\" tabindex=\"0\"> ";
  options = {hash:{
    'prefix': ("display_"),
    'defaultDisplay': ("Answer provided by third party; accuracy not guaranteed.")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "crowdSourcedAnswerText", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "crowdSourcedAnswerText", depth0.msgpack, depth0, options)))
    + " </div> </div> ";
  return buffer;
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('crowdSourcedAnswerBadgePopup', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview View for the crowd sourced answer badge popup.
 */
BV.define('bv/c2013/view/crowdSourcedAnswerBadgePopup',[
  'bv/ui-core/bpopupview',
  'hbs!crowdSourcedAnswerBadgePopup',
  'jquery',
  'underscore'
], function (BPopupView, template, $, _) {
  return BPopupView.extend({

    name: 'crowdSourcedAnswerBadgePopup',

    options: _.extend({}, BPopupView.prototype.options, {
      popupInClass: 'bv-dropdown-in',
      popupOutClass: 'bv-dropdown-out'
    }),

    width: 325,

    template: template
  });
});

/**
 * @fileOverview View for the crowd sourced answer badge.
 */
BV.define('bv/c2013/view/crowdSourcedAnswerBadge',[
  'framework/bmodel',
  'bv/ui-core/bpopuptargetview',
  'underscore',
  'hbs!crowdSourcedAnswerBadge',
  'mf!bv/c2013/messages/contentItem',
  'bv/c2013/view/crowdSourcedAnswerBadgePopup'
], function (BModel, BPopupTargetView, _, template, msgPack, CrowdSourcedAnswerBadgePopupView) {
  return BPopupTargetView.extend({
    linkEl: '.bv-crowdSourcedAnswerBadge-popup-target',

    name: 'crowdSourcedAnswerBadge',

    classList: ['crowdSourcedAnswerBadge-target'],

    template: template,

    TargetView: CrowdSourcedAnswerBadgePopupView,

    targetViewOptions: { startDelay: 500 },

    msgpacks: [msgPack]
  });
});

BV.define('bv/c2013/model/histogram',['ENV', 'framework/bmodel', 'underscore'], function (ENV, BModel, _) {
  return BModel.extend({
    name: 'histogram',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
    },

    processData: function () {
      var parent = this.get('parent');

      if (parent) {
        // Check status of `contentFilter` feature. See CCS-27546.
        this.set('filterButton', parent.attributes.features.histogram);
        this.set('Product', parent.get('Product'));
        parent.onDataReady(function () {
          this.set(parent);
          this.dataReady();
        }, this);
      }
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!histogram',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/withIf', 'template/helpers/extmsg', 'template/helpers/fixedNumber'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options) : helperMissing.call(depth0, "withIf", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " <a class=\"bv-rating bv-text-link bv-popup-target bv-focusable\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-label=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_ratingSummaryText", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_ratingSummaryText", depth1.msgpack, depth0, options)))
    + "\" href=\"#histogram\" tabindex=\"0\"> <span itemprop=\"ratingValue\" aria-hidden=\"true\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.fixedNumber),stack1 ? stack1.call(depth0, depth0.AverageOverallRating, 1, options) : helperMissing.call(depth0, "fixedNumber", depth0.AverageOverallRating, 1, options)))
    + "</span> </a> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('histogram', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('template/helpers/reverseEach',['vendor/handlebars/runtime', 'underscore'], function (Handlebars, _) {

  function reverseEach (context, options) {
    var fn = options.fn, inverse = options.inverse;
    var ret = '';

    if (context && context.length > 0) {
      for (var i = 0, j = context.length; i < j; i++) {
        ret = ret + fn(context[j - i - 1]);
      }
    } else {
      ret = inverse(this);
    }
    return ret;
  }

  Handlebars.registerHelper('reverseEach', reverseEach);
  return reverseEach;
});

/* START_TEMPLATE */
BV.define('hbs!histogramPopup',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/withIf', 'template/helpers/reverseEach', 'template/helpers/ratingIconChar', 'template/helpers/extmsg', 'template/helpers/percentage'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0, depth1)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options) : helperMissing.call(depth0, "withIf", ((stack1 = ((stack1 = depth0.Product),stack1 == null || stack1 === false ? stack1 : stack1.Reviews)),stack1 == null || stack1 === false ? stack1 : stack1.Statistics), options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-popup-histogram-ratings\" role=\"tooltip\"> <div class=\"bv-flex-container-column\"> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0, depth1, depth2)};
  stack2 = ((stack1 = helpers.reverseEach),stack1 ? stack1.call(depth0, depth0.RatingDistribution, options) : helperMissing.call(depth0, "reverseEach", depth0.RatingDistribution, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> <div class=\"bv-action-bar\"> <ul class=\"bv-toplevel-actions\" role=\"presentation\"> <li class=\"bv-histogram-action\"><button type=\"button\" class=\"bv-read-review bv-focusable\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "histogram_readReviews", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "histogram_readReviews", depth2.msgpack, depth0, options)))
    + "</button></li> </ul> </div> </div> ";
  return buffer;
  }
function program3(depth0,data,depth1,depth2,depth3) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " "
    + " <div class=\"bv-flex-container";
  stack1 = helpers['if'].call(depth0, depth3.filterButton, {hash:{},inverse:self.noop,fn:self.program(4, program4, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"> <div class=\"bv-popup-histogram-ratings-star\" data-bv-histogram-rating-value=\"";
  if (stack1 = helpers.RatingValue) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role=\"presentation\"> ";
  if (stack1 = helpers.RatingValue) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "<span class=\"bv-glyph\" aria-hidden=\"true\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "prs-rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "prs-rating-stars-on", options)))
    + "</span> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_histogram_stars", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_histogram_stars", depth2.msgpack, depth0, options)))
    + "</span> </div> <div class=\"bv-popup-histogram-ratings-bar\" data-bv-histogram-rating-value=\"";
  if (stack2 = helpers.RatingValue) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.RatingValue; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" role=\"presentation\" data-bv-histogram-rating-count=";
  if (stack2 = helpers.Count) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Count; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "> <span class=\"bv-content-secondary-ratings-container\"> <span class=\"bv-content-secondary-ratings-value bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.Count, depth1.TotalCount, 1, options) : helperMissing.call(depth0, "percentage", depth0.Count, depth1.TotalCount, 1, options)))
    + "\"></span> </span> </div> <div class=\"bv-popup-histogram-ratings-score\" role=\"presentation\"> ";
  if (stack2 = helpers.Count) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Count; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_histogram_count", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_histogram_count", depth2.msgpack, depth0, options)))
    + "</span> </div> </div> ";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " bv-focusable\" tabindex=\"0";
  }

  buffer += " <div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("popup popup-histogram")
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('histogramPopup', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/histogram',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"ratingSnapshotHeader" : function (x) { try { return (function(d){
var r = "";
r += "Rating Snapshot";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `ratingSnapshotHeader`: ' + e.toString() ) ] ); return ""; } },"offscreen_histogram_stars" : function (x) { try { return (function(d){
var r = "";
r += "stars";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_histogram_stars`: ' + e.toString() ) ] ); return ""; } },"offscreen_histogram_count" : function (x) { try { return (function(d){
var r = "";
r += "reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_histogram_count`: ' + e.toString() ) ] ); return ""; } },"histogram_filter" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "RatingValue";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
r += "Select to filter reviews with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " star.";
return r;
},
"other" : function(d){
var r = "";
r += "Select to filter reviews with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " stars.";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `histogram_filter`: ' + e.toString() ) ] ); return ""; } },"histogram_select_to_filter" : function (x) { try { return (function(d){
var r = "";
r += "Select a row below to filter reviews.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `histogram_select_to_filter`: ' + e.toString() ) ] ); return ""; } },"offscreen_histogram_ratingDistribution" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Count";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "RatingValue";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += " review with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " star.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += " review with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " stars.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "RatingValue";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += " reviews with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " star.";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["Count"];
r += " reviews with ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingValue"];
r += " stars.";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
r += " ";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_histogram_ratingDistribution`: ' + e.toString() ) ] ); return ""; } },"histogram_readReviews" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "Gender";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_2 = "TotalCount";
var k_2=d[lastkey_2];
var off_1 = 0;
var pf_1 = { 
"one" : function(d){
var r = "";
r += "Read a Review";
return r;
},
"other" : function(d){
var r = "";
r += "Read ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["TotalCount"];
r += " Reviews";
return r;
}
};
if ( pf_1[ k_2 + "" ] ) {
r += pf_1[ k_2 + "" ]( d ); 
}
else {
r += (pf_1[ MessageFormat.locale["en"]( k_2 - off_1 ) ] || pf_1[ "other" ] )( d );
}
return r;
}
};
r += (pf_0[ k_1 ] || pf_0[ "other" ])( d );
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `histogram_readReviews`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/view/histogramPopup',[
  'bv/ui-core/bpopupview',
  'bv/util/productInfo',
  'hbs!histogramPopup',
  'mf!bv/c2013/messages/histogram',
  'jquery',
  'framework/util/bvtracker'
], function (BPopupView, ProductInfo, template, msgPack, $, BVTracker) {
  return BPopupView.extend({

    name: 'histogramPopup',

    width: 262,

    height: 400,

    events: {
      'click .bv-read-review': 'readReviews',
      'click .bv-popup-histogram-ratings-star, .bv-popup-histogram-ratings-bar': 'filterContent'
    },

    template: template,

    msgpacks: [msgPack],

    filterContent: function (e) {
      var ratingVal;
      var ratingCount;
      var detail1;
      if (this.parent.hasFeature('filterButton')) {
        ratingVal = $(e.currentTarget).data('bv-histogram-rating-value');
        ratingCount = $(e.currentTarget).data('bv-histogram-rating-count');
        if (ratingVal && ratingCount > 0) {
          this.getTopModel().trigger('filtercontent', 'Rating', ratingVal);

          detail1 = ratingVal + 'Star' + ((parseInt(ratingVal, 10) > 1) ? 's' : '');

          BVTracker.feature({
            type: 'Used',
            name: 'Filter',
            detail1: detail1,
            detail2: 'Histogram',
            bvProduct: ProductInfo.RATINGSANDREVIEWS,
            productId: ProductInfo.getId(this),
            categoryId: ProductInfo.getCategoryId(this)
          });
        }
      }
    },

    readReviews: function (event) {
      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'ReadReviewsButton',
        detail2: 'Histogram',
        bvProduct: ProductInfo.RATINGSANDREVIEWS,
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
      this.detach();
      this.model.publish('readreviews');
    },

    leftPositionModifier: function (pos) {
      return pos - 10;
    },

    topPositionModifier: function (pos) {
      return pos + 10;
    }

    // TODO: once we decide to make histogram clickable,
    // we shall add analytics track to those event as well.

  });
});

/**
 * @fileOverview View for the histogram popup target.
 */
BV.define('bv/c2013/view/histogram',[
  'bv/ui-core/bpopuptargetview',
  'underscore',
  'hbs!histogram',
  'bv/c2013/view/histogramPopup',
  'mf!bv/c2013/messages/common'
], function (BPopupTargetView, _, template, HistogramPopupView, msgPack) {
  return BPopupTargetView.extend({

    name: 'histogram',

    classList: ['histogram-target'],

    template: template,

    TargetView: HistogramPopupView,

    msgpacks: [msgPack]
  });
});

BV.define('mf!bv/c2013/messages/contentFilter',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"content_filter_ratings" : function (x) { try { return (function(d){
var r = "";
r += "Rating";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_ratings`: ' + e.toString() ) ] ); return ""; } },"content_filter_list_title" : function (x) { try { return (function(d){
var r = "";
r += "Active Filters";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_list_title`: ' + e.toString() ) ] ); return ""; } },"content_filter_button_clear" : function (x) { try { return (function(d){
var r = "";
r += "Clear All";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_button_clear`: ' + e.toString() ) ] ); return ""; } },"content_filter_locale" : function (x) { try { return (function(d){
var r = "";
r += "Locale";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_locale`: ' + e.toString() ) ] ); return ""; } },"content_filter_clear_label" : function (x) { try { return (function(d){
var r = "";
r += "Clear All";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_clear_label`: ' + e.toString() ) ] ); return ""; } },"content_filter_show_all_label" : function (x) { try { return (function(d){
var r = "";
r += "Show All";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_show_all_label`: ' + e.toString() ) ] ); return ""; } },"content_filter_expand_label" : function (x) { try { return (function(d){
var r = "";
r += "Filter ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["contentType"];
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_expand_label`: ' + e.toString() ) ] ); return ""; } },"offscreen_filter_button_update" : function (x) { try { return (function(d){
var r = "";
r += "Clicking on the following button will update the content below";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_filter_button_update`: ' + e.toString() ) ] ); return ""; } },"content_filter_star_ratings" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
var lastkey_1 = "rating";
var k_1=d[lastkey_1];
var off_0 = 0;
var pf_0 = { 
"one" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["rating"];
r += " star";
return r;
},
"other" : function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["rating"];
r += " stars";
return r;
}
};
if ( pf_0[ k_1 + "" ] ) {
r += pf_0[ k_1 + "" ]( d ); 
}
else {
r += (pf_0[ MessageFormat.locale["en"]( k_1 - off_0 ) ] || pf_0[ "other" ] )( d );
}
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_filter_star_ratings`: ' + e.toString() ) ] ); return ""; } },"offscreen_filter_label" : function (x) { try { return (function(d){
var r = "";
r += "Filter by";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_filter_label`: ' + e.toString() ) ] ); return ""; } },"offscreen_remove_filter" : function (x) { try { return (function(d){
var r = "";
r += "Remove Filter";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_remove_filter`: ' + e.toString() ) ] ); return ""; } },"offscreen_clear_all_filters" : function (x) { try { return (function(d){
var r = "";
r += "Clear All Filters";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_clear_all_filters`: ' + e.toString() ) ] ); return ""; } }
};
});

/* eslint-disable quote-props */
BV.define('bv/util/localeMapping',[], function LocaleMappings () {

  // This file exists to map locale codes (like en_US) to names that are
  // suitable for display to a user (like "English (United States)").
  var LOCALE_MAPPINGS = {
    'en': { 'en': 'English', 'native': 'English' },
    'bg': { 'en': 'Bulgarian', 'native': 'Български език' },
    'ca': { 'en': 'Catalan', 'es': 'Catalán', 'native': 'Català' },
    'cs': { 'en': 'Czech', 'native': 'Čeština' },
    'da': { 'en': 'Danish', 'native': 'Dansk' },
    'de': { 'en': 'German', 'native': 'Deutsch' },
    'el': { 'en': 'Greek', 'native': 'Ελληνικά' },
    'es': { 'en': 'Spanish', 'native': 'Español' },
    'et': { 'en': 'Estonian', 'native': 'Eesti' },
    'eu': { 'en': 'Basque', 'es': 'Vasco', 'fr': 'Basque', 'native': 'Euskara' },
    'fi': { 'en': 'Finnish', 'native': 'Suomi' },
    'hr': { 'en': 'Croatian', 'native': 'Hrvatski jezik' },
    'hu': { 'en': 'Hungarian', 'native': 'Magyar' },
    'fr': { 'en': 'French', 'native': 'Français' },
    'id': { 'en': 'Indonesian', 'native': 'Indonesian' },
    'is': { 'en': 'Icelandic', 'native': 'Íslenska' },
    'it': { 'en': 'Italian', 'native': 'Italiano' },
    'ja': { 'en': 'Japanese', 'native': '日本語' },
    'kk': { 'en': 'Kazakh', 'native': 'Қазақ тілі' },
    'ko': { 'en': 'Korean', 'native': '한국어' },
    'lt': { 'en': 'Lithuanian', 'native': 'Lietuvių kalba' },
    'lv': { 'en': 'Latvian', 'native': 'Latviešu valoda' },
    'ms': { 'en': 'Malay', 'native': 'هاس ملايو‎' },
    'nl': { 'en': 'Dutch', 'native': 'Nederlands' },
    'no': { 'en': 'Norwegian', 'native': 'Norsk' },
    'pl': { 'en': 'Polish', 'native': 'Język polski' },
    'pt': { 'en': 'Portuguese', 'native': 'Português' },
    'ro': { 'en': 'Romanian', 'native': 'Limba română' },
    'ru': { 'en': 'Russian', 'native': 'Русский' },
    'sk': { 'en': 'Slovak', 'native': 'Slovenčina' },
    'sl': { 'en': 'Slovene', 'native': 'Slovenski jezik' },
    'sr': { 'en': 'Serbian', 'native': 'Cрпски језик' },
    'sv': { 'en': 'Swedish', 'native': 'Svenska' },
    'th': { 'en': 'Thai', 'native': 'ไทย' },
    'tr': { 'en': 'Turkish', 'native': 'Türkçe' },
    'uk': { 'en': 'Ukrainian', 'native': 'Українська мова' },
    'vi': { 'en': 'Vietnamese', 'native': 'Việt Nam' },
    'zh': { 'en': 'Chinese', 'native': '中文' },

    'ar_AE': {
      'en': 'Arabic (United Arab Emirates)',
      'native': 'العربية (الإمارات العربية المتحدة)'
    },
    'ar_BH': {
      'en': 'Arabic (Bahrain)',
      'native': 'العربية (البحرين)'
    },
    'ar_EG': {
      'en': 'Arabic (Egypt)',
      'native': 'العربية (مصر)'
    },
    'ar_IQ': {
      'en': 'Arabic (Iraq)',
      'native': 'العربية (العراق)'
    },
    'ar_JO': {
      'en': 'Arabic (Jordan)',
      'native': 'العربية (الأردن)'
    },
    'ar_KW': {
      'en': 'Arabic (Kuwait)',
      'native': 'العربية (الكويت)'
    },
    'ar_LB': {
      'en': 'Arabic (Lebanon)',
      'native': 'العربية (لبنان)'
    },
    'ar_LY': {
      'en': 'Arabic (Libya)',
      'native': 'العربية (ليبيا)'
    },
    'ar_OM': {
      'en': 'Arabic (Oman)',
      'native': 'العربية (عُمان)'
    },
    'ar_QA': {
      'en': 'Arabic (Qatar)',
      'native': 'العربية (قطر)'
    },
    'ar_SA': {
      'en': 'Arabic (Saudi Arabia)',
      'native': 'العربية (المملكة العربية السعودية)'
    },
    'ar_SY': {
      'en': 'Arabic (Syria)',
      'native': 'العربية (سوريا)'
    },
    'ar_XA': {
      'en': 'Arabic (undefined)',
      'native': 'العربية (undefined)'
    },
    'ar_XM': {
      'en': 'Arabic (undefined)',
      'native': 'العربية (undefined)'
    },
    'ar_YE': {
      'en': 'Arabic (Yemen)',
      'native': 'العربية (اليمن)'
    },
    'bg_BG': {
      'en': 'Bulgarian (Bulgaria)',
      'native': 'Български (България)'
    },
    'ca_ES': {
      'en': 'Catalan (Spain)',
      'es': 'catalán (España)',
      'native': 'Сatalà (Espanya)'
    },
    'cs_CZ': {
      'en': 'Czech (Czech Republic)',
      'native': 'Čeština (Česká republika)'
    },
    'da_DK': {
      'en': 'Danish (Denmark)',
      'native': 'Dansk (Danmark)'
    },
    'de_AT': {
      'en': 'German (Austria)',
      'native': 'Deutsch (Österreich)'
    },
    'de_BE': {
      'en': 'German (Belgium)',
      'native': 'Deutsch (Belgien)'
    },
    'de_CH': {
      'en': 'German (Switzerland)',
      'native': 'Deutsch (Schweiz)'
    },
    'de_DE': {
      'en': 'German (Germany)',
      'native': 'Deutsch (Deutschland)'
    },
    'de_DK': {
      'en': 'German (Denmark)',
      'native': 'Deutsch (Dänemark)'
    },
    'de_FR': {
      'en': 'German (France)',
      'native': 'Deutsch (Frankreich)'
    },
    'de_GB': {
      'en': 'German (United Kingdom)',
      'native': 'Deutsch (Vereinigtes Königreich)'
    },
    'de_IT': {
      'en': 'German (Italy)',
      'native': 'Deutsch (Italien)'
    },
    'de_LU': {
      'en': 'German (Luxembourg)',
      'native': 'Deutsch (Luxemburg)'
    },
    'el_GR': {
      'en': 'Greek (Greece)',
      'native': 'Ελληνικά (Ελλάδα)'
    },
    'en_AE': {
      'en': 'English (United Arab Emirates)',
      'native': 'English (United Arab Emirates)'
    },
    'en_AG': {
      'en': 'English (Antigua & Barbuda)',
      'native': 'English (Antigua & Barbuda)'
    },
    'en_AO': {
      'en': 'English (Angola)',
      'native': 'English (Angola)'
    },
    'en_AP': {
      'en': 'English (undefined)',
      'native': 'English (undefined)'
    },
    'en_AR': {
      'en': 'English (Argentina)',
      'native': 'English (Argentina)'
    },
    'en_AT': {
      'en': 'English (Austria)',
      'native': 'English (Austria)'
    },
    'en_AU': {
      'en': 'English (Australia)',
      'native': 'English (Australia)'
    },
    'en_AW': {
      'en': 'English (Aruba)',
      'native': 'English (Aruba)'
    },
    'en_BE': {
      'en': 'English (Belgium)',
      'native': 'English (Belgium)'
    },
    'en_BF': {
      'en': 'English (Burkina Faso)',
      'native': 'English (Burkina Faso)'
    },
    'en_BG': {
      'en': 'English (Bulgaria)',
      'native': 'English (Bulgaria)'
    },
    'en_BH': {
      'en': 'English (Bahrain)',
      'native': 'English (Bahrain)'
    },
    'en_BJ': {
      'en': 'English (Benin)',
      'native': 'English (Benin)'
    },
    'en_BO': {
      'en': 'English (Bolivia)',
      'native': 'English (Bolivia)'
    },
    'en_BR': {
      'en': 'English (Brazil)',
      'native': 'English (Brazil)'
    },
    'en_BY': {
      'en': 'English (Belarus)',
      'native': 'English (Belarus)'
    },
    'en_BZ': {
      'en': 'English (Belize)',
      'native': 'English (Belize)'
    },
    'en_CA': {
      'en': 'English (Canada)',
      'native': 'English (Canada)'
    },
    'en_CG': {
      'en': 'English (Congo - Brazzaville)',
      'native': 'English (Congo - Brazzaville)'
    },
    'en_CH': {
      'en': 'English (Switzerland)',
      'native': 'English (Switzerland)'
    },
    'en_CI': {
      'en': 'English (Côte d’Ivoire)',
      'native': 'English (Côte d’Ivoire)'
    },
    'en_CL': {
      'en': 'English (Chile)',
      'native': 'English (Chile)'
    },
    'en_CM': {
      'en': 'English (Cameroon)',
      'native': 'English (Cameroon)'
    },
    'en_CN': {
      'en': 'English (China)',
      'native': 'English (China)'
    },
    'en_CO': {
      'en': 'English (Colombia)',
      'native': 'English (Colombia)'
    },
    'en_CR': {
      'en': 'English (Costa Rica)',
      'native': 'English (Costa Rica)'
    },
    'en_CZ': {
      'en': 'English (Czech Republic)',
      'native': 'English (Czech Republic)'
    },
    'en_DE': {
      'en': 'English (Germany)',
      'native': 'English (Germany)'
    },
    'en_DK': {
      'en': 'English (Denmark)',
      'native': 'English (Denmark)'
    },
    'en_DO': {
      'en': 'English (Dominican Republic)',
      'native': 'English (Dominican Republic)'
    },
    'en_DZ': {
      'en': 'English (Algeria)',
      'native': 'English (Algeria)'
    },
    'en_EC': {
      'en': 'English (Ecuador)',
      'native': 'English (Ecuador)'
    },
    'en_EE': {
      'en': 'English (Estonia)',
      'native': 'English (Estonia)'
    },
    'en_EG': {
      'en': 'English (Egypt)',
      'native': 'English (Egypt)'
    },
    'en_ES': {
      'en': 'English (Spain)',
      'native': 'English (Spain)'
    },
    'en_ET': {
      'en': 'English (Ethiopia)',
      'native': 'English (Ethiopia)'
    },
    'en_EU': {
      'en': 'English (European Union)',
      'native': 'English (European Union)'
    },
    'en_FI': {
      'en': 'English (Finland)',
      'native': 'English (Finland)'
    },
    'en_FR': {
      'en': 'English (France)',
      'native': 'English (France)'
    },
    'en_GA': {
      'en': 'English (Gabon)',
      'native': 'English (Gabon)'
    },
    'en_GB': {
      'en': 'English (United Kingdom)',
      'native': 'English (United Kingdom)'
    },
    'en_GH': {
      'en': 'English (Ghana)',
      'native': 'English (Ghana)'
    },
    'en_GR': {
      'en': 'English (Greece)',
      'native': 'English (Greece)'
    },
    'en_GT': {
      'en': 'English (Guatemala)',
      'native': 'English (Guatemala)'
    },
    'en_HK': {
      'en': 'English (Hong Kong SAR China)',
      'native': 'English (Hong Kong SAR China)'
    },
    'en_HN': {
      'en': 'English (Honduras)',
      'native': 'English (Honduras)'
    },
    'en_HU': {
      'en': 'English (Hungary)',
      'native': 'English (Hungary)'
    },
    'en_ID': {
      'en': 'English (Indonesia)',
      'native': 'English (Indonesia)'
    },
    'en_IE': {
      'en': 'English (Ireland)',
      'native': 'English (Ireland)'
    },
    'en_IL': {
      'en': 'English (Israel)',
      'native': 'English (Israel)'
    },
    'en_IN': {
      'en': 'English (India)',
      'native': 'English (India)'
    },
    'en_IQ': {
      'en': 'English (Iraq)',
      'native': 'English (Iraq)'
    },
    'en_IR': {
      'en': 'English (Iran)',
      'native': 'English (Iran)'
    },
    'en_IT': {
      'en': 'English (Italy)',
      'native': 'English (Italy)'
    },
    'en_JM': {
      'en': 'English (Jamaica)',
      'native': 'English (Jamaica)'
    },
    'en_JO': {
      'en': 'English (Jordan)',
      'native': 'English (Jordan)'
    },
    'en_JP': {
      'en': 'English (Japan)',
      'native': 'English (Japan)'
    },
    'en_KE': {
      'en': 'English (Kenya)',
      'native': 'English (Kenya)'
    },
    'en_KR': {
      'en': 'English (South Korea)',
      'native': 'English (South Korea)'
    },
    'en_KW': {
      'en': 'English (Kuwait)',
      'native': 'English (Kuwait)'
    },
    'en_KZ': {
      'en': 'English (Kazakhstan)',
      'native': 'English (Kazakhstan)'
    },
    'en_LB': {
      'en': 'English (Lebanon)',
      'native': 'English (Lebanon)'
    },
    'en_LR': {
      'en': 'English (Liberia)',
      'native': 'English (Liberia)'
    },
    'en_LT': {
      'en': 'English (Lithuania)',
      'native': 'English (Lithuania)'
    },
    'en_LU': {
      'en': 'English (Luxembourg)',
      'native': 'English (Luxembourg)'
    },
    'en_LV': {
      'en': 'English (Latvia)',
      'native': 'English (Latvia)'
    },
    'en_LY': {
      'en': 'English (Libya)',
      'native': 'English (Libya)'
    },
    'en_MA': {
      'en': 'English (Morocco)',
      'native': 'English (Morocco)'
    },
    'en_MU': {
      'en': 'English (Mauritius)',
      'native': 'English (Mauritius)'
    },
    'en_MX': {
      'en': 'English (Mexico)',
      'native': 'English (Mexico)'
    },
    'en_MY': {
      'en': 'English (Malaysia)',
      'native': 'English (Malaysia)'
    },
    'en_NG': {
      'en': 'English (Nigeria)',
      'native': 'English (Nigeria)'
    },
    'en_NI': {
      'en': 'English (Nicaragua)',
      'native': 'English (Nicaragua)'
    },
    'en_NL': {
      'en': 'English (Netherlands)',
      'native': 'English (Netherlands)'
    },
    'en_NO': {
      'en': 'English (Norway)',
      'native': 'English (Norway)'
    },
    'en_NZ': {
      'en': 'English (New Zealand)',
      'native': 'English (New Zealand)'
    },
    'en_OM': {
      'en': 'English (Oman)',
      'native': 'English (Oman)'
    },
    'en_PA': {
      'en': 'English (Panama)',
      'native': 'English (Panama)'
    },
    'en_PE': {
      'en': 'English (Peru)',
      'native': 'English (Peru)'
    },
    'en_PH': {
      'en': 'English (Philippines)',
      'native': 'English (Philippines)'
    },
    'en_PK': {
      'en': 'English (Pakistan)',
      'native': 'English (Pakistan)'
    },
    'en_PL': {
      'en': 'English (Poland)',
      'native': 'English (Poland)'
    },
    'en_PR': {
      'en': 'English (Puerto Rico)',
      'native': 'English (Puerto Rico)'
    },
    'en_PT': {
      'en': 'English (Portugal)',
      'native': 'English (Portugal)'
    },
    'en_PY': {
      'en': 'English (Paraguay)',
      'native': 'English (Paraguay)'
    },
    'en_QA': {
      'en': 'English (Qatar)',
      'native': 'English (Qatar)'
    },
    'en_RO': {
      'en': 'English (Romania)',
      'native': 'English (Romania)'
    },
    'en_RU': {
      'en': 'English (Russia)',
      'native': 'English (Russia)'
    },
    'en_SA': {
      'en': 'English (Saudi Arabia)',
      'native': 'English (Saudi Arabia)'
    },
    'en_SD': {
      'en': 'English (Sudan)',
      'native': 'English (Sudan)'
    },
    'en_SE': {
      'en': 'English (Sweden)',
      'native': 'English (Sweden)'
    },
    'en_SG': {
      'en': 'English (Singapore)',
      'native': 'English (Singapore)'
    },
    'en_SK': {
      'en': 'English (Slovakia)',
      'native': 'English (Slovakia)'
    },
    'en_SN': {
      'en': 'English (Senegal)',
      'native': 'English (Senegal)'
    },
    'en_SV': {
      'en': 'English (El Salvador)',
      'native': 'English (El Salvador)'
    },
    'en_SY': {
      'en': 'English (Syria)',
      'native': 'English (Syria)'
    },
    'en_TH': {
      'en': 'English (Thailand)',
      'native': 'English (Thailand)'
    },
    'en_TN': {
      'en': 'English (Tunisia)',
      'native': 'English (Tunisia)'
    },
    'en_TR': {
      'en': 'English (Turkey)',
      'native': 'English (Turkey)'
    },
    'en_TT': {
      'en': 'English (Trinidad & Tobago)',
      'native': 'English (Trinidad & Tobago)'
    },
    'en_TW': {
      'en': 'English (Taiwan)',
      'native': 'English (Taiwan)'
    },
    'en_TZ': {
      'en': 'English (Tanzania)',
      'native': 'English (Tanzania)'
    },
    'en_UA': {
      'en': 'English (Ukraine)',
      'native': 'English (Ukraine)'
    },
    'en_UG': {
      'en': 'English (Uganda)',
      'native': 'English (Uganda)'
    },
    'en_US': {
      'en': 'English (United States)',
      'native': 'English (United States)'
    },
    'en_UY': {
      'en': 'English (Uruguay)',
      'native': 'English (Uruguay)'
    },
    'en_VE': {
      'en': 'English (Venezuela)',
      'native': 'English (Venezuela)'
    },
    'en_VN': {
      'en': 'English (Vietnam)',
      'native': 'English (Vietnam)'
    },
    'en_XA': {
      'en': 'English (undefined)',
      'native': 'English (undefined)'
    },
    'en_XM': {
      'en': 'English (undefined)',
      'native': 'English (undefined)'
    },
    'en_YE': {
      'en': 'English (Yemen)',
      'native': 'English (Yemen)'
    },
    'en_ZA': {
      'en': 'English (South Africa)',
      'native': 'English (South Africa)'
    },
    'es_AG': {
      'en': 'Spanish (Antigua & Barbuda)',
      'native': 'Español (Antigua y Barbuda)'
    },
    'es_AR': {
      'en': 'Spanish (Argentina)',
      'native': 'Español (Argentina)'
    },
    'es_AW': {
      'en': 'Spanish (Aruba)',
      'native': 'Español (Aruba)'
    },
    'es_BO': {
      'en': 'Spanish (Bolivia)',
      'native': 'Español (Bolivia)'
    },
    'es_BZ': {
      'en': 'Spanish (Belize)',
      'native': 'Español (Belice)'
    },
    'es_CL': {
      'en': 'Spanish (Chile)',
      'native': 'Español (Chile)'
    },
    'es_CO': {
      'en': 'Spanish (Colombia)',
      'native': 'Español (Colombia)'
    },
    'es_CR': {
      'en': 'Spanish (Costa Rica)',
      'native': 'Español (Costa Rica)'
    },
    'es_DO': {
      'en': 'Spanish (Dominican Republic)',
      'native': 'Español (República Dominicana)'
    },
    'es_EC': {
      'en': 'Spanish (Ecuador)',
      'native': 'Español (Ecuador)'
    },
    'es_ES': {
      'en': 'Spanish (Spain)',
      'native': 'Español (España)'
    },
    'es_GT': {
      'en': 'Spanish (Guatemala)',
      'native': 'Español (Guatemala)'
    },
    'es_HN': {
      'en': 'Spanish (Honduras)',
      'native': 'Español (Honduras)'
    },
    'es_JM': {
      'en': 'Spanish (Jamaica)',
      'native': 'Español (Jamaica)'
    },
    'es_MX': {
      'en': 'Spanish (Mexico)',
      'native': 'Español (México)'
    },
    'es_NI': {
      'en': 'Spanish (Nicaragua)',
      'native': 'Español (Nicaragua)'
    },
    'es_PA': {
      'en': 'Spanish (Panama)',
      'native': 'Español (Panamá)'
    },
    'es_PE': {
      'en': 'Spanish (Peru)',
      'native': 'Español (Perú)'
    },
    'es_PR': {
      'en': 'Spanish (Puerto Rico)',
      'native': 'Español (Puerto Rico)'
    },
    'es_PY': {
      'en': 'Spanish (Paraguay)',
      'native': 'Español (Paraguay)'
    },
    'es_SV': {
      'en': 'Spanish (El Salvador)',
      'native': 'Español (El Salvador)'
    },
    'es_TT': {
      'en': 'Spanish (Trinidad & Tobago)',
      'native': 'Español (Trinidad y Tobago)'
    },
    'es_US': {
      'en': 'Spanish (United States)',
      'native': 'Español (Estados Unidos)'
    },
    'es_UY': {
      'en': 'Spanish (Uruguay)',
      'native': 'Español (Uruguay)'
    },
    'es_VE': {
      'en': 'Spanish (Venezuela)',
      'native': 'Español (Venezuela)'
    },
    'et_EE': {
      'en': 'Estonian (Estonia)',
      'native': 'Eesti (Eesti)'
    },
    'eu_ES': {
      'en': 'Basque (Spain)',
      'es': 'Vasco (España)',
      'fr': 'Basque (Espagne)',
      'native': 'Euskara (Espainia)'
    },
    'fi_FI': {
      'en': 'Finnish (Finland)',
      'native': 'Suomi (Suomi)'
    },
    'fi_NO': {
      'en': 'Finnish (Norway)',
      'native': 'Suomi (Norja)'
    },
    'fi_SE': {
      'en': 'Finnish (Sweden)',
      'native': 'Suomi (Ruotsi)'
    },
    'fr_BE': {
      'en': 'French (Belgium)',
      'native': 'Français (Belgique)'
    },
    'fr_BF': {
      'en': 'French (Burkina Faso)',
      'native': 'Français (Burkina Faso)'
    },
    'fr_BJ': {
      'en': 'French (Benin)',
      'native': 'Français (Bénin)'
    },
    'fr_CA': {
      'en': 'French (Canada)',
      'native': 'Français (Canada)'
    },
    'fr_CG': {
      'en': 'French (Congo - Brazzaville)',
      'native': 'Français (Congo-Brazzaville)'
    },
    'fr_CH': {
      'en': 'French (Switzerland)',
      'native': 'Français (Suisse)'
    },
    'fr_CI': {
      'en': 'French (Côte d’Ivoire)',
      'native': 'Français (Côte d’Ivoire)'
    },
    'fr_CM': {
      'en': 'French (Cameroon)',
      'native': 'Français (Cameroun)'
    },
    'fr_DE': {
      'en': 'French (Germany)',
      'native': 'Français (Allemagne)'
    },
    'fr_DZ': {
      'en': 'French (Algeria)',
      'native': 'Français (Algérie)'
    },
    'fr_FR': {
      'en': 'French (France)',
      'native': 'Français (France)'
    },
    'fr_GA': {
      'en': 'French (Gabon)',
      'native': 'Français (Gabon)'
    },
    'fr_GB': {
      'en': 'French (United Kingdom)',
      'native': 'Français (Royaume-Uni)'
    },
    'fr_LU': {
      'en': 'French (Luxembourg)',
      'native': 'Français (Luxembourg)'
    },
    'fr_MA': {
      'en': 'French (Morocco)',
      'native': 'Français (Maroc)'
    },
    'fr_MU': {
      'en': 'French (Mauritius)',
      'native': 'Français (Maurice)'
    },
    'fr_NL': {
      'en': 'French (Netherlands)',
      'native': 'Français (Pays-Bas)'
    },
    'fr_SN': {
      'en': 'French (Senegal)',
      'native': 'Français (Sénégal)'
    },
    'fr_TN': {
      'en': 'French (Tunisia)',
      'native': 'Français (Tunisie)'
    },
    'fr_XA': {
      'en': 'French (undefined)',
      'native': 'Français (undefined)'
    },
    'fr_XM': {
      'en': 'French (undefined)',
      'native': 'Français (undefined)'
    },
    'hr_HR': {
      'en': 'Croatian (Croatia)',
      'native': 'Hrvatski (Hrvatska)'
    },
    'hu_HU': {
      'en': 'Hungarian (Hungary)',
      'native': 'Magyar (Magyarország)'
    },
    'id_ID': {
      'en': 'Indonesian (Indonesia)',
      'native': 'Indonesia (Indonesia)'
    },
    'is_IS': {
      'en': 'Icelandic (Iceland)',
      'native': 'Íslenska (Ísland)'
    },
    'it_CH': {
      'en': 'Italian (Switzerland)',
      'native': 'Italiano (Svizzera)'
    },
    'it_IT': {
      'en': 'Italian (Italy)',
      'native': 'Italiano (Italia)'
    },
    'ja_JP': {
      'en': 'Japanese (Japan)',
      'native': '日本語 (日本)'
    },
    'kk_KZ': {
      'en': 'Kazakh (Kazakhstan)',
      'native': 'Қазақ тілі (Қазақстан)'
    },
    'ko_KR': {
      'en': 'Korean (South Korea)',
      'native': '한국어 (대한민국)'
    },
    'lt_LT': {
      'en': 'Lithuanian (Lithuania)',
      'native': 'Lietuvių (Lietuva)'
    },
    'lv_LV': {
      'en': 'Latvian (Latvia)',
      'native': 'Latviešu (Latvija)'
    },
    'ms_MY': {
      'en': 'Malay (Malaysia)',
      'native': 'Bahasa Melayu (Malaysia)'
    },
    'nl_AW': {
      'en': 'Dutch (Aruba)',
      'native': 'Nederlands (Aruba)'
    },
    'nl_BE': {
      'en': 'Dutch (Belgium)',
      'native': 'Nederlands (België)'
    },
    'nl_BG': {
      'en': 'Dutch (Bulgaria)',
      'native': 'Nederlands (Bulgarije)'
    },
    'nl_NL': {
      'en': 'Dutch (Netherlands)',
      'native': 'Nederlands (Nederland)'
    },
    'no_NO': {
      'en': 'Norwegian (Norway)',
      'native': 'Norsk (Norge)'
    },
    'pl_PL': {
      'en': 'Polish (Poland)',
      'native': 'Polski (Polska)'
    },
    'pt_AO': {
      'en': 'Portuguese (Angola)',
      'native': 'Português (Angola)'
    },
    'pt_BR': {
      'en': 'Portuguese (Brazil)',
      'native': 'Português (Brasil)'
    },
    'pt_PT': {
      'en': 'Portuguese (Portugal)',
      'native': 'Português (Portugal)'
    },
    'pt_XA': {
      'en': 'Portuguese (undefined)',
      'native': 'Português (undefined)'
    },
    'ro_RO': {
      'en': 'Romanian (Romania)',
      'native': 'Română (România)'
    },
    'ru_BY': {
      'en': 'Russian (Belarus)',
      'native': 'Русский (Беларусь)'
    },
    'ru_EE': {
      'en': 'Russian (Estonia)',
      'native': 'Русский (Эстония)'
    },
    'ru_GE': {
      'en': 'Russian (Georgia)',
      'native': 'Русский (Грузия)'
    },
    'ru_LV': {
      'en': 'Russian (Latvia)',
      'native': 'Русский (Латвия)'
    },
    'ru_KZ': {
      'en': 'Russian (Kazakhstan)',
      'native': 'Русский (Казахстан)'
    },
    'ru_RU': {
      'en': 'Russian (Russia)',
      'native': 'Русский (Россия)'
    },
    'ru_UA': {
      'en': 'Russian (Ukraine)',
      'native': 'Русский (Украина)'
    },
    'ru_XM': {
      'en': 'Russian (undefined)',
      'native': 'Русский (undefined)'
    },
    'sk_SK': {
      'en': 'Slovak (Slovakia)',
      'native': 'Slovenčina (Slovensko)'
    },
    'sl_SI': {
      'en': 'Slovenian (Slovenia)',
      'native': 'Slovenščina (Slovenija)'
    },
    'sr_RS': {
      'en': 'Serbian (Serbia)',
      'native': 'Српски (Србија)'
    },
    'sv_FI': {
      'en': 'Swedish (Finland)',
      'native': 'Svenska (Finland)'
    },
    'sv_SE': {
      'en': 'Swedish (Sweden)',
      'native': 'Svenska (Sverige)'
    },
    'th_TH': {
      'en': 'Thai (Thailand)',
      'native': 'ไทย (ไทย)'
    },
    'tr_TR': {
      'en': 'Turkish (Turkey)',
      'native': 'Türkçe (Türkiye)'
    },
    'uk_UA': {
      'en': 'Ukrainian (Ukraine)',
      'native': 'Українська (Україна)'
    },
    'vi_VN': {
      'en': 'Vietnamese (Vietnam)',
      'native': 'Tiếng Việt (Việt Nam)'
    },
    'zh_CN': {
      'en': 'Chinese (China)',
      'native': '中文 (中国)'
    },
    'zh_HK': {
      'en': 'Chinese (Hong Kong SAR China)',
      'native': '中文 (中国香港特别行政区)'
    },
    'zh_SG': {
      'en': 'Chinese (Singapore)',
      'native': '中文 (新加坡)'
    },
    'zh_TW': {
      'en': 'Chinese (Taiwan)',
      'native': '中文 (台湾)'
    }
  };

  return LOCALE_MAPPINGS;

});

BV.define('dimsumFields!filters',[], [{"id":"ContentLocale","options":[{"id":"zh_CN","label":"zh_CN"},{"id":"da_DK","label":"da_DK"},{"id":"en_US","label":"en_US"}],"labelRef":"content_filter_locale"}]);

/**
 * @fileOverview contentFilter model
 */
BV.define('bv/c2013/model/contentFilter',[
  'framework/bmodel',
  'backbone',
  'underscore',
  'mf!bv/c2013/messages/contentFilter',
  'jquery',
  'util/lookup',
  'bv/util/localeMapping',
  'bv/util/configFieldInfo',
  'dimsumFields!filters'
], function ContentFilter (
  BModel,
  Backbone,
  _,
  msgPack,
  $,
  lookup,
  localeMapping,
  configFieldInfo,
  configFilters
) {

  var FilterOptionModel = BModel.extend({
    name: 'FilterOptionModel',
    defaults: {
      enabled: false
    },

    toggleEnabled: function toggleEnabled () {
      this.set('enabled', !this.get('enabled'));
    }

  });

  var FilterModel = BModel.extend({

    name: 'FilterModel',
    options: [],

    defaults: {
      enabled: false,
      activeCount: 0
    },

    init: function init (config, options) {
      var self = this;
      this.options = options;
      _(options).forEach(function forEachOption (option) {
        self.listenTo(option, 'change:enabled', self.filterOptionChanged);
      });

      this.set('isMobile', (
        BV._internal.mobile ||
        navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/)
      ));

      this.on('change:activeCount', this.activeCountChanged, this);
    },

    toggleFilterEnabled: function toggleFilterEnabled () {
      this.set('enabled', !this.get('enabled'));
    },

    filterOptionChanged: function filterOptionChanged (option, enabled) {
      var oldActiveCount = this.get('activeCount');
      var delta = enabled ? 1 : -1;

      this.set('activeCount', oldActiveCount + delta);
      this.trigger('filterOptionChanged', option, enabled);
    },

    activeCountChanged: function activeCountChanged (model, count) {
      if (count === 0) {
        this.set('enabled', false);
      }
      else {
        this.set('enabled', true);
      }
    },

    showAll: function showAll () {
      _(this.options).forEach(function forEachOption (option) {
        option.set('enabled', false);
      });
    },

    clear: function clear (_opts) {
      var opts = _opts || {};
      _(this.options).forEach(function forEachOption (option) {
        option.set('enabled', false, opts);
      });
    },

    disableOption: function disableOption (optionId) {
      var option = this.getOption(optionId);
      option.set('enabled', false);
    },

    getOption: function getOption (optionId) {
      var option = _(this.options).find(function findOption (o) {
        return o.id === '' + optionId;
      });
      return option;
    },

    toJSON: function toJSON () {
      var json = BModel.prototype.toJSON.apply(this, arguments);
      var options = _(this.options).map(function mapOptions (option) { return option.toJSON(); });

      json.options = options;
      return json;
    }

  });

  return BModel.extend({
    name: 'contentFilter',
    filters: [],
    activeFilters: [],

    defaults: {
      expanded: false
    },

    init: function init (config, options) {
      var self = this;
      // Mixin options
      _.extend(this.options, options);
      this.subscribe('filtercontent', this.filterContent);

      // Guard against multiple filters enabling/disabling at once.
      this.triggerFilter = _.debounce(function debounceTriggerFilter () {
        self.getTopModel().trigger('filterresults', self.activeFilters);
      }, 500);
    },

    processData: function processData (data) {
      this.initContentFilter();
      this.dataReady(data);
    },

    filterContent: function filterContent (filterId, optionId, disabled, options) {
      // Whether we should clear out any existing filter criteria.
      var replaceExistingFilters = options && !!options.replace;

      // possible to get these events before we initialize, wait for dataready
      this.onDataReady(function onDataReadyFunction () {
        var opts;
        if (replaceExistingFilters) {
          this.clearAllFilters();
        }
        opts = _(optionId).isArray() ? optionId : [optionId];
        _(opts).forEach(function forEachOptionId (oId) {
          var option;
          var filter = this.getFilter(filterId);

          // We need to bail if there's no matching filter or options. This
          // happens when we run the rr_filter_reviews UI method. Our framework
          // stuffs a bunch of junk into the config that we can't really filter
          // out, so we just have to ignore it.
          if (!filter) {
            return;
          }

          option = filter.getOption(oId);

          if (!option) {
            return;
          }

          option.set('enabled', !disabled);
        }, this);
      }, this);
    },

    // Called when the number of active filters has changed.
    filterEnabledChanged: function filterEnabledChanged (filter, enabled) {
      if (enabled === true) {
        this.activeFilters.push(filter);
      }
      else {
        this.activeFilters = _(this.activeFilters).without(filter);
      }

      this.trigger('filterEnabledChanged', filter, enabled);
    },

    // Reset all filters to their defaults. Carries an `options` argument so
    // that one can pass `{ silent: true }` if needed.
    _clearAllFilters: function _clearAllFilters (options) {
      _(this.filters).invoke('clear', options || {});
      this.activeFilters = [];
    },

    clearAllFilters: function clearAllFilters (options) {
      this._clearAllFilters(options);
      this.trigger('allFiltersCleared');
    },

    getFilter: function getFilter (filterId) {
      var filter = _(this.filters).find(function findFilter (f) {
        return f.id === filterId;
      });
      return filter;
    },

    toggleContentFilter: function toggleContentFilter () {
      this.set('expanded', !this.get('expanded'));
    },

    initContentFilter: function initContentFilter () {
      var initReviewData;
      var tagDistribution;
      if (this.filters.length > 0) {
        // If there are pre-existing filters, it means we're hitting this
        // method again because someone is making a new BV.ui call. To
        // prevent duplicate data, we should explicitly clear all filters and
        // put the view back into its default state.
        this.clearAllFilters();
        this.filters = [];
      }

      initReviewData = this.getTopModel().get('subject');

      if (initReviewData) {
        initReviewData = initReviewData.Content ? (initReviewData.Content.Reviews || null) : null;
      }

      tagDistribution = lookup(
        this.get('parent').get('subject'),
        'Content.Reviews.Statistics.TagDistribution',
        { undefinedDefault: [] }
      );

      // There should always be a filter for ratings.
      this._initRatingsFilter(initReviewData);

      // Build CDV filters based on initReviewData
      this._initCDVFilters(initReviewData);

      // Build other filters based on config.
      _(configFilters).each(this._initFilter, this);

      // Build tag filters based on data from API.
      _(tagDistribution).each(this._initTagFilter, this);

      this.trigger('filtersInitialized');

      _(this.filters).forEach(function forEachFilter (filter) {
        this.listenTo(filter, 'change:enabled', this.filterEnabledChanged);
        this.listenTo(filter, 'filterOptionChanged', this.triggerFilter);
      }, this);
      /* eslint-enable vars-on-top */
    },

    _initTagFilter: function _initTagFilter (label) {
      var filterOptions;
      var filterLabel;
      var filter;

      filterOptions = _(label.Values).map(function mapOptions (option) {
        return new FilterOptionModel({
          id: option.Value,
          label: option.Value,
          active: false,
          parent: this
        });
      }, this);

      filterLabel = configFieldInfo.getLabel('tag', label.Id);
      if (!filterLabel) {
        filterLabel = label.Label;
      }

      filter = new FilterModel({
        id: 'tag_' + label.Id,
        label: filterLabel,
        activeCount: 0,
        parent: this
      }, filterOptions);

      this.filters.push(filter);
    },

    // Create the model for an arbitrary filter.
    _initFilter: function _initFilter (filter) {
      var filterOptions = _(filter.options).map(function mapOptions (option) {
        var label = option.label;
        var mapping;

        if (filter.id === 'ContentLocale') {
          // Turn wildcard locales like 'en*' into 'en'
          label = label.replace('*', '');
          // Locale options have to be mapped to human-readable strings.
          mapping = localeMapping[label];
          if (mapping) {
            label = mapping.native;
          }
        }

        return new FilterOptionModel({
          id: option.id,
          label: label,
          active: false,
          parent: this
        });
      }, this);

      var filterId = filter.id;
      var filterLabel = filter.labelRef ? msgPack[filter.labelRef] : filter.label;

      var newFilter = new FilterModel({
        id: filterId,
        label: filterLabel,
        activeCount: 0,
        parent: this
      }, filterOptions);

      this.filters.push(newFilter);
    },

    // Create the model for the ratings filter.
    _initRatingsFilter: function _initRatingsFilter (initReviewData) {
      var filterOptions = [];
      var ratingLabel;
      var filter;
      var i;

      var ratingRange = lookup(initReviewData, 'Statistics.OverallRatingRange');
      if (!ratingRange) {
        return;
      }

      for (i = 1; i <= ratingRange; i++) {
        // Turn (e.g.) "3" into "3 stars."
        ratingLabel = msgPack.content_filter_star_ratings({ rating: i });

        filterOptions.push(new FilterOptionModel({
          id: String(i),
          label: ratingLabel,
          active: false,
          parent: this
        }));
      }

      filter = new FilterModel({
        id: 'Rating',
        label: msgPack.content_filter_ratings(),
        activeCount: 0,
        parent: this
      }, filterOptions);

      this.filters.push(filter);
    },

    _initCDVFilters: function _initCDVFilters (initReviewData) {
      var filterOptions;
      var self = this;

      // Build CDV filters based on ContextDataDistribution in the Review Statistics
      // This will ensure only CDV's for this product that have results will display.
      var cdvData = lookup(initReviewData, 'Statistics.ContextDataDistribution');
      if (!cdvData) {
        return;
      }

      _(cdvData).forEach(function forEachCDV (cdv) {
        // Sadly, the api doesn't return the labels for the CDV options,
        // so we still have to look in the config for those labels.
        var configCDV = configFieldInfo.getField('cdv', cdv.Id);
        var label;
        var configOptionLabels;
        if (!configCDV || !configCDV.filterable) {
          return;
        }
        label = configFieldInfo.getLabel(configCDV);
        configOptionLabels = configFieldInfo.getValueLabels(configCDV);
        filterOptions = _(cdv.Values).map(function mapOptions (option) {
          return new FilterOptionModel({
            id: option.Value,
            label: configOptionLabels[option.Value],
            active: false,
            parent: self
          });
        });
        self.filters.push(new FilterModel({
          id: 'contextdatavalue_' + cdv.Id,
          label: label,
          activeCount: 0,
          parent: self
        }, filterOptions));
      });
    },

    toJSON: function toJSON () {
      var baseJSON = BModel.prototype.toJSON.call(this);
      baseJSON.filters = [];
      _(this.filters).forEach(function forEachFilter (filter) {
        var filterJSON = filter.toJSON();
        filterJSON.options = _(filter.options).map(function mapOptions (option) {
          return option.toJSON();
        });
        baseJSON.filters.push(filterJSON);
      });
      baseJSON.activeCount = this.activeFilters.length;
      return baseJSON;
    }
  });
});

/* START_TEMPLATE */
BV.define('hbs!contentFilterButton',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/renderIcon', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{
    'classList': ("bv-filter-control-icon"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-filter-control", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-filter-control", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-filter-control-text\">";
  options = {hash:{
    'prefix': ("content_filter_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "expand_label", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "expand_label", depth0.msgpack, depth0, options)))
    + "</span> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_filter_button_update", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_filter_button_update", depth0.msgpack, depth0, options)))
    + "</span> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "&equiv;";
  }

  buffer += " ";
  options = {hash:{
    'tag': ("button"),
    'elemType': ("button"),
    'classList': ("content-btn filter-control expand-filter-button focusable")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentFilterButton', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/contentFilterButton',[
  'jquery',
  'underscore',
  'framework/bview',
  'bv/ui-core/focusableview',
  'hbs!contentFilterButton',
  'mf!bv/c2013/messages/contentFilter'
], function ($, _, BView, FocusableView, tmplButton, msgPack) {

  // FilterButtonView:
  // A button that, when clicked, toggles the visibility of the filter
  // controls.
  //
  // This exists elsewhere in the view hierarchy, but we look at feature
  // definitions and create one if it's needed.
  //
  var FilterButtonView = BView.extend({
    name: 'contentFilterButton',

    events: {
      'click button': 'filterControlButtonClicked'
    },

    template: tmplButton,
    msgpacks: [msgPack],

    init: function () {
      this.listenTo(this.model, 'change:expanded', this.toggleExpandFilter);
    },

    filterControlButtonClicked: function (e) {
      var $filterOptions = this.$el.find('.bv-filters-option');
      var $filterOptionAll = this.$el.find('.bv-filters-option-all');
      var $focusables = $filterOptionAll.add($filterOptions);

      if ($filterOptions.attr('tabindex')) {
        $filterOptionAll.removeAttr('tabindex', 0);
        $filterOptions.removeAttr('tabindex', 0);
        $filterOptionAll.removeClass('bv-focusable');
        $filterOptions.removeClass('bv-focusable');
        this.removeFocusables($focusables);
      }
      else {
        $filterOptionAll.attr('tabindex', 0);
        $filterOptions.attr('tabindex', 0);
        $filterOptionAll.addClass('bv-focusable');
        $filterOptions.addClass('bv-focusable');
        this.addFocusables($focusables, this.$viewEl);
      }

      this.model.toggleContentFilter();
    },

    toggleExpandFilter: function () {
      this.$viewEl.toggleClass('bv-filter-active');
    }
  });

  return FilterButtonView.extend(FocusableView);
});

/* START_TEMPLATE */
BV.define('hbs!contentFilter',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/mountView'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "FilterControls", depth0, options) : helperMissing.call(depth0, "mountView", "FilterControls", depth0, options)))
    + " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "ActiveFilters", depth0, options) : helperMissing.call(depth0, "mountView", "ActiveFilters", depth0, options)))
    + " ";
  return buffer;
  }

  buffer += " "
    + " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-filter"),
    'alwaysRender': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentFilter', t);
t.deps = [];
t.tplMountedViews = ['FilterControls','ActiveFilters'];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/contentFilter',[
  'framework/bview',
  'bv/c2013/view/contentFilterButton',
  'jquery',
  'backbone',
  'underscore',
  'BV',
  'hbs!contentFilter',
  'mf!bv/c2013/messages/contentFilter'
],
function (
  BView,
  FilterButtonView,
  $,
  Backbone,
  _,
  BV,
  template,
  msgPack
) {

  return BView.extend({
    name: 'contentFilter',
    template: template,

    msgpacks: [msgPack],

    init: function () {
      this._loaded = false;
      // Create a free floating button view that our parent can mount separately
      if (this.hasFeature('filterButton')) {
        this.parent.views.push(new FilterButtonView({
          model: this.model,
          parent: this.parent
        }));
      }

      this._filterInitDfd = $.Deferred();

      this.listenTo(this.model, {
        filtersInitialized: this._onFiltersInitialized,
        filterEnabledChanged: this._checkViewState,
        'change:expanded': this.toggleExpandFilter
      });
    },

    _onFiltersInitialized: function () {
      this._filterInitDfd.resolve();
    },

    // Because we're lazy-loading content filters, this method doesn't get
    // called until the user clicks the filter toggle button. At that point
    // it creates its child views and then triggers a re-render.
    //
    // This method returns a promise that resolves when the view has finished
    // lazy-loading.
    _createViews: function () {
      var self = this;
      var dfd = $.Deferred();

      if (!this.views) { this.views = []; }

      if (this._loaded) {
        dfd.resolve();
        return dfd.promise();
      }

      // We have to wait until the filters are initialized before we try to
      // render this view.
      this._filterInitDfd.done(function () {

        BV.require(['secondary'], function (app) {
          var controlsView;
          var filtersView;

          controlsView = new app.FilterControlsView({
            model: self.model,
            parent: self.parent,
            componentId: self.componentId
          });
          self.views.push(controlsView);
          controlsView.createFilterViews();

          filtersView = new app.ActiveFiltersView({
            model: self.model,
            parent: self.parent,
            componentId: self.componentId
          });
          self.views.push(filtersView);

          // Set a flag so that we do this only once.
          self._loaded = true;

          dfd.resolve();
        });

      });

      return dfd.promise();
    },

    attach: function () {
      BView.prototype.attach.apply(this, arguments);
      this._checkViewState();
    },

    // We've got an element for the filter controls and one for the active
    // filters, and either of them can be either visible or hidden,
    // independent of the other. So there are four different UI states here.
    // We add class names so that we can style them accordingly.
    _checkViewState: function () {
      var self = this;
      var controlsVisible;
      var activeFiltersVisible;

      if (this.isBeforeAttach()) { return; }

      controlsVisible = this.model.get('expanded');
      activeFiltersVisible = this.model.activeFilters.length > 0;

      function toggleClasses () {
        self.$viewEl.toggleClass('bv-filter-controls-visible', controlsVisible);
        self.$viewEl.toggleClass('bv-active-filters-visible', activeFiltersVisible);

        self.$viewEl.toggleClass('bv-filter-controls-hidden', !controlsVisible);
        self.$viewEl.toggleClass('bv-active-filters-hidden', !activeFiltersVisible);
      }

      // The view is about to appear, so if we haven't loaded it already
      // then we need to do it now.
      if (this._loaded) {
        toggleClasses();
      }
      else {
        // We haven't loaded yet, so before we can change our class names we
        // need to pull in secondary.js, create our subviews, then trigger a
        // re-render.
        this._createViews().done(function () {
          self.render();
          toggleClasses();
        });
      }
    },

    toggleExpandFilter: function (model, expanded) {

      if (this.isBeforeAttach()) {
        return;
      }

      this.$('.bv-filters').toggleClass('bv-hidden', !expanded);
      this._checkViewState();
    },

    // TODO: Generalize this? Figure out a different check?
    isBeforeAttach: function () {
      return !this.$viewEl || !this.$viewEl.length;
    }
  });
});

BV.define('mf!bv/c2013/messages/headToHead',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"show_full_Review" : function (x) { try { return (function(d){
var r = "";
r += "Show Full Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `show_full_Review`: ' + e.toString() ) ] ); return ""; } },"show_full_offscreen_Review" : function (x) { try { return (function(d){
var r = "";
r += "This action will open a modal dialog.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `show_full_offscreen_Review`: ' + e.toString() ) ] ); return ""; } },"mostHelpfulFavorable_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "Most Helpful Favorable Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostHelpfulFavorable_Reviews`: ' + e.toString() ) ] ); return ""; } },"mostHelpfulCritical_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "Most Helpful Critical Review";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostHelpfulCritical_Reviews`: ' + e.toString() ) ] ); return ""; } },"morePositiveLink_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "See more 4 and 5 star reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `morePositiveLink_Reviews`: ' + e.toString() ) ] ); return ""; } },"moreCriticalLink_Reviews" : function (x) { try { return (function(d){
var r = "";
r += "See more 1, 2, and 3 star reviews";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `moreCriticalLink_Reviews`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/model/headToHead',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/api/fetch',
  'bv/c2013/model/contentItem',
  'mf!bv/c2013/messages/headToHead'
], function HeadToHeadModel (ENV, BModel, _, api, ContentItemModel, msgPack) {

  return BModel.extend({
    options: {},
    name: 'headToHead',
    statsTypes: ['Reviews', 'Questions'],
    minContent: 10,
    minVotes: 3,

    init: function init (config, options) {
      // Mixin options
      _.extend(this.options, options);
      this.set('contentType', this.getTopModel().get('contentType'));
      this.listenTo(this.getTopModel(), 'filterresults', this.handleFilter);
      this.subscribe({
        pageto: this.fetchMostHelpful,
        // Subscribe to outlet triggered when RR lightbox opens
        showinlightbox: this.fetchMostHelpful
      });

      // The "show more positive/negative reviews" links rely on the
      // component having the contentFilter feature.
      this.set('hasContentFilter', this.getTopModel().hasFeature('contentFilter'));
    },

    handleFilter: function handleFilter (filters) {
      this.set('filterActive', filters.length);
    },

    setupDataProcessing: function setupDataProcessing () {
      this.on('dataready', this.processData, this);
    },

    processData: function processData (data) {
      var favoribleMessageName = 'mostHelpfulFavorable_' + this.get('contentType');
      var criticalMessageName = 'mostHelpfulCritical_' + this.get('contentType');

      if (
        data.mostHelpfulPositive &&
        data.mostHelpfulNegative &&
        (data.totalResults >= this.minContent)
      ) {
        // if we have 2 pieces of content to compare, create models for them
        data.mostHelpfulPositive.parent = this;
        data.mostHelpfulPositive.isSimple = true;
        data.mostHelpfulPositive.contentTitle = msgPack[favoribleMessageName]();

        data.mostHelpfulNegative.parent = this;
        data.mostHelpfulNegative.isSimple = true;
        data.mostHelpfulNegative.contentTitle = msgPack[criticalMessageName]();

        this.set({
          mostHelpfulPositiveModel: new ContentItemModel(data.mostHelpfulPositive),
          mostHelpfulNegativeModel: new ContentItemModel(data.mostHelpfulNegative),
          hasResults: true
        });
      }

      this.trigger('contentInitialized');
      BModel.prototype.processData.call(this, data);
    },

    fetchMostHelpful: function fetchMostHelpful () {
      var self = this;
      var mostHelpfulPositive = this.makeRequest(true);
      var mostHelpfulNegative = this.makeRequest(false);
      var contentRequest = this.makeContentRequest();

      // only run once
      this.unsubscribe('pageto', this.fetchMostHelpful);

      api.get('batch', null, [contentRequest, mostHelpfulPositive, mostHelpfulNegative])
        .fetch(self.name)
        .done(function fetchMostHelpfulCallback (dataArray) {
          self.trigger('dataready', {
            totalResults: dataArray[0].data.TotalResults,
            mostHelpfulPositive: dataArray[1].data.Results[0],
            mostHelpfulNegative: dataArray[2].data.Results[0]
          });
        });
    },

    makeRequest: function makeRequest (isPositive) {
      var clientAPIConfig = _.extend(
        {},
        ENV.get('config').clientAPIConfig,
        this.get('clientAPIConfig')
      );

      var subjectId = clientAPIConfig[api.noun(this.get('subjectType')) + 'Id'];
      var requestType = api.nouns(this.get('contentType'));
      var mostHelpfulRequest = api.get(requestType);
      var ratingDir = isPositive ? '>' : '<=';

      // only run once
      this.unsubscribe('pageto', this.fetchMostHelpful);

      mostHelpfulRequest
        .filterBy('productid', subjectId)
        .filterBy('isRatingsOnly', 'false')
        .filterBy('IsSyndicated', 'false')
        .include(['Authors', api.Nouns(requestType), 'Products']);

      // Only 4's and 5's for positive and 1's, 2's, 3's for negative
      mostHelpfulRequest.filterBy('rating', ratingDir, '3');

      // At least three feedback votes
      mostHelpfulRequest.filterBy('TotalPositiveFeedbackCount', '>=', this.minVotes);

      // Most helpful positive and negative review
      mostHelpfulRequest.sortBy('desc', 'TotalPositiveFeedbackCount');

      mostHelpfulRequest.limit('1');

      return mostHelpfulRequest;
    },

    makeContentRequest: function makeContentRequest () {
      // Make a minimal content request to get the total count.
      // This is faster than waiting for the same data to come back from the parent.
      var clientAPIConfig = _.extend(
        {},
        ENV.get('config').clientAPIConfig,
        this.get('clientAPIConfig')
      );

      var subjectId = clientAPIConfig[api.noun(this.get('subjectType')) + 'Id'];
      var requestType = api.nouns(this.get('contentType'));
      var contentRequest = api.get(requestType).forProduct(subjectId).limit('1');

      return contentRequest;
    },

    showMorePositive: function showMorePositive () {
      this.getTopModel().trigger('showhelpfulpositive');
    },

    showMoreCritical: function showMoreCritical () {
      this.getTopModel().trigger('showhelpfulcritical');
    }

  });
});

BV.define('template/helpers/urlForRoute',[
  'vendor/handlebars/runtime',
  'util/url',
  'window'
], function (Handlebars, URL, window) {

  function urlForRoute () {
    var args = Array.prototype.slice.call(arguments, 0);

    if (typeof args[args.length - 1] === 'object') {
      // That's our `options` argument. We won't be needing it.
      args.pop();
    }

    var url;
    var contentType;
    var route;
    if (args.length === 2) {
      url = window.location.href || '';
      contentType = args[0];
      route = args[1];
    } else {
      url = args[0];
      contentType = args[1];
      route = args[2];
    }

    var fullRoute = contentType + '/' + route;

    url = URL.splice(url, 'bvroute');
    var newUrl = URL.push(url, 'bvroute', fullRoute);
    return newUrl;
  }

  Handlebars.registerHelper('urlForRoute', urlForRoute);
  return urlForRoute;
});

/* START_TEMPLATE */
BV.define('hbs!headToHead',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/mountView', 'template/helpers/urlForRoute', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, depth0.hasResults, {hash:{},inverse:self.noop,fn:self.program(2, program2, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-head-to-head-item\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "mostHelpfulPositive", options) : helperMissing.call(depth0, "mountView", "mostHelpfulPositive", options)))
    + " ";
  stack2 = helpers['if'].call(depth0, depth0.hasContentFilter, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> <div class=\"bv-head-to-head-item\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.mountView),stack1 ? stack1.call(depth0, "mostHelpfulNegative", options) : helperMissing.call(depth0, "mountView", "mostHelpfulNegative", options)))
    + " ";
  stack2 = helpers['if'].call(depth0, depth0.hasContentFilter, {hash:{},inverse:self.noop,fn:self.program(5, program5, data)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <a class=\"bv-head-to-head-see-more-positive bv-focusable\" href=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.urlForRoute),stack1 ? stack1.call(depth0, depth0.contentType, "showHelpfulPositive", options) : helperMissing.call(depth0, "urlForRoute", depth0.contentType, "showHelpfulPositive", options)))
    + "\"> ";
  options = {hash:{
    'prefix': ("morePositiveLink_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + " </a> ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += " <a class=\"bv-head-to-head-see-more-critical bv-focusable\" href=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.urlForRoute),stack1 ? stack1.call(depth0, depth0.contentType, "showHelpfulCritical", options) : helperMissing.call(depth0, "urlForRoute", depth0.contentType, "showHelpfulCritical", options)))
    + "\"> ";
  options = {hash:{
    'prefix': ("moreCriticalLink_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + " </a> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("head-to-head head-to-head-list flex-container-responsive")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('headToHead', t);
t.deps = [];
t.tplMountedViews = ['mostHelpfulPositive','mostHelpfulNegative'];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!simpleContentItem',['hbs','vendor/handlebars/runtime','hbs!content', 'hbs!previewMessage', 'hbs!contentActions', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <h3 class=\"bv-content-title\">";
  if (stack1 = helpers.contentTitle) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.contentTitle; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</h3> <div class=\"bv-content-item-avatar-offset bv-content-item-avatar-offset-off\"> ";
  stack1 = self.invokePartial(partials.content, 'content', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.previewMessage, 'previewMessage', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = self.invokePartial(partials.contentActions, 'contentActions', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("content-item section-summary-block"),
    'dataContentId': (true)
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('simpleContentItem', t);
t.deps = ["content","previewMessage","contentActions"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!viewFullContentLink',['hbs','vendor/handlebars/runtime', 'template/helpers/urlForRoute', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<a class=\"bv-text-link bv-show-more-link bv-focusable\" href=\"";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.urlForRoute),stack1 ? stack1.call(depth0, depth0.contentType, depth0.reviewId, options) : helperMissing.call(depth0, "urlForRoute", depth0.contentType, depth0.reviewId, options)))
    + "\"> ";
  options = {hash:{
    'prefix': ("show_full_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + " <span class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("show_full_offscreen_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.contentType, depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.contentType, depth0.msgpack, depth0, options)))
    + "</span> </a>";
  return buffer;
  });
Handlebars.registerPartial('viewFullContentLink', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/headToHead',[
  'framework/bview',
  'underscore',
  'jquery',
  'hbs!headToHead',
  'hbs!simpleContentItem',
  'hbs!viewFullContentLink',
  'bv/c2013/view/contentItem',
  'bv/util/contentType',
  'mf!bv/c2013/messages/headToHead'
], function (BView, _, $, template, contentItemTemplate, contentLinkTemplate, ContentItemView, ContentType, msgPack) {
  return BView.extend({
    name: 'headToHead',

    template: template,

    msgpacks: [msgPack],
    maxCharacters: 100,

    events: {
      'click .bv-head-to-head-see-more-positive': 'showMorePositive',
      'click .bv-head-to-head-see-more-critical': 'showMoreCritical'
    },

    init: function () {
      this.listenTo(this.model, {
        'contentInitialized': this.initComparison,
        'change:filterActive': this.handleFilter
      });
    },

    initComparison: function () {
      var self = this;
      var mostHelpfulPositiveModel = self.model.get('mostHelpfulPositiveModel');
      var mostHelpfulNegativeModel = self.model.get('mostHelpfulNegativeModel');
      this.views = this.views || [];
      if (mostHelpfulPositiveModel && mostHelpfulNegativeModel) {
        self.initContentView(mostHelpfulPositiveModel, 0, 'mostHelpfulPositive');
        self.initContentView(mostHelpfulNegativeModel, 1, 'mostHelpfulNegative');
      }
    },

    initContentView: function (contentItemModel, index, name) {
      var v;
      var contentType = contentItemModel.get('Type') || contentItemModel.contentType || contentItemModel.get('contentType');
      var self = this;

      v = new ContentItemView({
        model: contentItemModel,
        config: contentItemModel,
        componentId: contentItemModel.componentId || contentItemModel.get('componentId'),
        contentType: ContentType.Nouns(contentType),
        secondaryContentType: contentItemModel.secondaryContentType || contentItemModel.get('secondaryContentType'),
        index: index,
        classList: ['content-top-' + ContentType.noun(contentType)],
        parent: self,
        viewAlias: name
      });

      v.template = contentItemTemplate;

      self.views.push(v);
      return v;
    },

    attach: function (elToAttach) {
      var self = this;
      BView.prototype.attach.call(this, elToAttach);
      // Remove paragraphized text. p:nth-child(n+2) matches paragraphs with an index > 1 within a sibling set
      this.$viewEl.find('.bv-content-summary-body p:nth-child(n+2)').remove();
      // Truncate long reviews.
      this.$viewEl.find('.bv-content-summary-body p').each(function (index, contentTextEl) {
        var showMoreHTML = contentLinkTemplate({
          msgpack: msgPack,
          reviewId: self.views[index].model.get('Id'),
          contentType: ContentType.Noun(self.model.get('contentType'))
        });
        var tmpTxt = _.escape($(contentTextEl).text().substring(0, self.maxCharacters));
        $(contentTextEl).html(tmpTxt + '&hellip;' + showMoreHTML);
      });
    },

    handleFilter: function (model, filterCount) {
      // might get filter events before rendering
      if (!this.$viewEl && filterCount) {
        this.classList.push('hidden');
        return;
      }
      this.$viewEl.toggleClass('bv-hidden', filterCount > 0);
    },

    showMorePositive: function (e) {
      // allow cmd + tab on mac for opening in a new tab
      if (e.isDefaultPrevented() || e.metaKey || e.ctrlKey) {
        return;
      }
      e.preventDefault();
      this.model.showMorePositive();
    },

    showMoreCritical: function (e) {
      // allow cmd + tab on mac for opening in a new tab
      if (e.isDefaultPrevented() || e.metaKey || e.ctrlKey) {
        return;
      }
      e.preventDefault();
      this.model.showMoreCritical();
    }

  });
});

BV.define('bv/c2013/model/inlineHistogram',['ENV', 'underscore', 'framework/bmodel'], function (ENV, _, BModel) {
  return BModel.extend({
    name: 'inlineHistogram',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
    },

    setupDataProcessing: function () {
      var componentModel = this.getTopModel();
      componentModel.onDataReady(function () {
        this.processData(componentModel.get('initData'));
      }, this);
    },

    processData: function (data) {
      this.set({
        Statistics: data.Statistics
      });
      BModel.prototype.processData.call(this, data);
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!inlineHistogram',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/withIf', 'template/helpers/extmsg', 'template/helpers/reverseEach', 'template/helpers/notEqual', 'template/helpers/ratingIconChar', 'template/helpers/percentage'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.withIf),stack1 ? stack1.call(depth0, depth0.Statistics, options) : helperMissing.call(depth0, "withIf", depth0.Statistics, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-inline-histogram-ratings\"> <div class=\"bv-inline-histogram-header\"> <h3 class=\"bv-content-title\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "ratingSnapshotHeader", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "ratingSnapshotHeader", depth1.msgpack, depth0, options)))
    + "</h3> </div> <p class=\"bv-histogram-filter-helper\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "histogram_select_to_filter", depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "histogram_select_to_filter", depth1.msgpack, depth0, options)))
    + "</p> <div class=\"bv-flex-container-column\"> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program3, data, depth0, depth1)};
  stack2 = ((stack1 = helpers.reverseEach),stack1 ? stack1.call(depth0, depth0.RatingDistribution, options) : helperMissing.call(depth0, "reverseEach", depth0.RatingDistribution, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> </div> ";
  return buffer;
  }
function program3(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program4, data, depth1, depth2)};
  stack2 = ((stack1 = helpers.notEqual),stack1 ? stack1.call(depth0, depth0.RatingValue, 0, options) : helperMissing.call(depth0, "notEqual", depth0.RatingValue, 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data,depth2,depth3) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-inline-histogram-ratings-star-container bv-flex-container\" aria-labelledby=\"bv-inline-histogram-ratings-star-label-";
  if (stack1 = helpers.RatingValue) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" role=\"button\"> <div class=\"bv-inline-histogram-ratings-star\" data-bv-histogram-rating-value=\"";
  if (stack1 = helpers.RatingValue) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  if (stack1 = helpers.RatingValue) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.RatingValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "<span class=\"bv-glyph\" aria-hidden=\"true\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "rating-stars-on", options)))
    + "</span> <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_histogram_stars", depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_histogram_stars", depth3.msgpack, depth0, options)))
    + "</span> </div> <div class=\"bv-inline-histogram-ratings-bar\" data-bv-histogram-rating-value=\"";
  if (stack2 = helpers.RatingValue) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.RatingValue; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" role=\"presentation\" data-bv-histogram-rating-count=";
  if (stack2 = helpers.Count) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Count; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "> <span class=\"bv-content-secondary-ratings-container\"> <span class=\"bv-content-secondary-ratings-value bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.Count, depth2.TotalCount, 1, options) : helperMissing.call(depth0, "percentage", depth0.Count, depth2.TotalCount, 1, options)))
    + "\"></span> </span> </div> <div class=\"bv-inline-histogram-ratings-score\"> <span aria-hidden=\"true\"> ";
  if (stack2 = helpers.Count) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Count; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + " </span> <span class=\"bv-off-screen\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_histogram_ratingDistribution", depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_histogram_ratingDistribution", depth3.msgpack, depth0, options)))
    + " </span> <button type=\"button\" id=\"bv-inline-histogram-ratings-star-label-";
  if (stack2 = helpers.RatingValue) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.RatingValue; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-focusable bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "histogram_filter", depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "histogram_filter", depth3.msgpack, depth0, options)))
    + "</button> </div> </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("inline-histogram section-summary-block")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('inlineHistogram', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/inlineHistogram',[
  'framework/bview',
  'underscore',
  'jquery',
  'bv/ui-core/focusableview',
  'hbs!inlineHistogram',
  'mf!bv/c2013/messages/histogram',
  'util/specialKeys',
  'framework/util/bvtracker',
  'bv/util/productInfo'
], function (
  BView,
  _,
  $,
  FocusableView,
  template,
  msgPack,
  specialKeys,
  BVTracker,
  ProductInfo
) {

  // NOTE: Previously, each table row acted as a button via ARIA. This didn't
  // work properly in some combinations of IE and JAWS, so instead there's an
  // off-screen button in each row. Focusing this hidden button via keyboard
  // simulates focus of the row. This is ugly, but not as ugly as you'd
  // think. -APD

  return BView.extend({

    name: 'inlineHistogram',

    template: template,

    msgpacks: [msgPack],

    events: {
      'click .bv-inline-histogram-ratings-star-container': 'filterContent',
      'keydown .bv-inline-histogram-ratings-star-container button': 'filterContent',
      'mouseenter .bv-inline-histogram-ratings .bv-flex-container': 'mouseenter',
      'mouseleave .bv-inline-histogram-ratings .bv-flex-container': 'mouseleave',
      'focus .bv-inline-histogram-ratings .bv-flex-container button': 'focus',
      'blur .bv-inline-histogram-ratings .bv-flex-container button': 'blur'
    },

    init: function () {
      // The click-on-a-row-to-filter thing should only be enabled when we've
      // actually turned on content filtering.
      this._hasContentFilter = this.getTopModel().hasFeature('contentFilter');
    },

    filterContent: function (e) {
      var $row;
      var ratingVal;
      var ratingCount;
      var detail1;

      if (!this._hasContentFilter) { return; }

      // Adding keypress filter for UIA-3008 so that the enter key (keyCode 13)
      // and the space bar key (keyCode 32) trigger the filtercontent event. We
      // want to filter out all other key* events that are not the enter
      // or spacebar keys.
      if (e.type.substr(0, 3) === 'key' && e.keyCode !== specialKeys.ENTER && e.keyCode !== specialKeys.SPACE) { return; }

      // Keep the event from bubbling, spacebar will try to page down.
      e.preventDefault();

      $row = $(e.currentTarget).closest('.bv-flex-container');
      ratingVal = $row.children('.bv-inline-histogram-ratings-bar').first().data('bv-histogram-rating-value');
      ratingCount = $row.children('.bv-inline-histogram-ratings-bar').first().data('bv-histogram-rating-count');

      if (ratingVal && ratingCount > 0) {
        // Remove option { replace: true } to add possibility to select several filters
        // by clicking on the histograms in the summary section. See UIA-9220.
        this.publish('filtercontent', 'Rating', ratingVal, false);
        detail1 = ratingVal + 'Star' + ((ratingVal > 1) ? 's' : '');
        // Send out an event. See CCS-32993 and CCS-32618.
        BVTracker.feature({
          type: 'Used',
          name: 'Filter',
          detail1: detail1,
          detail2: 'InlineHistogram',
          bvProduct: ProductInfo.getType(this),
          productId: ProductInfo.getId(this),
          // Will be undefined until we can figure out how to get categoryId here
          categoryId: ProductInfo.getCategoryId(this)
        });
      }

      // Clicking the row should focus the (hidden) button. Moving that focus
      // will trigger the handler below that simulates focus of the row.
      FocusableView.moveFocus($row.find('button'));
    },

    mouseenter: function (event) {
      if (!this._hasContentFilter) { return; }

      $(event.target).closest('.bv-flex-container').addClass('bv-inline-histogram-row-active');
    },

    mouseleave: function (event) {
      if (!this._hasContentFilter) { return; }

      $(event.target).closest('.bv-flex-container').removeClass('bv-inline-histogram-row-active');
    },

    // These two handlers work like the two above, except they also
    // add/remove a pseudo-focus ring the way one would expect when
    // navigating via keyboard.
    focus: function (event) {
      if (!this._hasContentFilter) { return; }

      $(event.target).closest('.bv-flex-container').addClass('bv-inline-histogram-row-active bv-pseudo-focused');
    },

    blur: function (event) {
      if (!this._hasContentFilter) { return; }

      $(event.target).closest('.bv-flex-container').removeClass('bv-inline-histogram-row-active bv-pseudo-focused');
    }

  });
});

BV.define('mf!bv/c2013/messages/secondaryRatingSummary',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"secondaryRatingSummaryHeader" : function (x) { try { return (function(d){
var r = "";
r += "Average Customer Ratings";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `secondaryRatingSummaryHeader`: ' + e.toString() ) ] ); return ""; } },"secondaryRatingSummaryOverallRatingLabel" : function (x) { try { return (function(d){
var r = "";
r += "Overall";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `secondaryRatingSummaryOverallRatingLabel`: ' + e.toString() ) ] ); return ""; } },"offscreen_secondary_rating_summary" : function (x) { try { return (function(d){
var r = "";
r += "average rating value is ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["AverageRating"];
r += " of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingRange"];
r += ".";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_secondary_rating_summary`: ' + e.toString() ) ] ); return ""; } },"offscreen_secondary_rating_summary_value_of_one_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of 1 means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_secondary_rating_summary_value_of_one_means`: ' + e.toString() ) ] ); return ""; } },"offscreen_secondary_rating_summary_value_max_means" : function (x) { try { return (function(d){
var r = "";
r += "Rating of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingRange"];
r += " means";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_secondary_rating_summary_value_max_means`: ' + e.toString() ) ] ); return ""; } },"offscreen_secondary_rating_summary_stars" : function (x) { try { return (function(d){
var r = "";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["AverageRating"];
r += " out of ";
if(!d){
throw new Error("MessageFormat: No data passed to function.");
}
r += d["RatingRange"];
r += " stars.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_secondary_rating_summary_stars`: ' + e.toString() ) ] ); return ""; } }
};
});

BV.define('bv/c2013/model/secondaryRatingSummary',[
  'ENV',
  'underscore',
  'framework/bmodel',
  'dimsumFields!fields',
  'mf!bv/c2013/messages/secondaryRatingSummary'
], function (ENV, _, BModel, dimsumFields, msgPack) {
  return BModel.extend({
    name: 'secondaryRatingSummary',

    init: function (config, options) {
      // Mixin options
      _.extend(this.options, options);
    },

    setupDataProcessing: function () {
      var componentModel = this.getTopModel();
      componentModel.onDataReady(function () {
        this.processData(componentModel.get('initData'));
      }, this);
    },

    processData: function (data) {
      var secondaryRatingsAverages = data.Statistics.SecondaryRatingsAverages;
      var secondaryRatingsAveragesOrder = data.Statistics.SecondaryRatingsAveragesOrder;
      var ratingRange = data.Statistics.OverallRatingRange || 5;
      var secondaryRatings = [];

      // For each rating in the order received from the API,
      // use the config data for that rating to populate
      // some missing/incorrect data
      _(secondaryRatingsAveragesOrder).forEach(function (rating) {
        var toRating = secondaryRatingsAverages[rating];

        // lookup secondary rating in dimsumFields
        var dimsumRating = dimsumFields && dimsumFields.rating && dimsumFields.rating[rating];
        if (dimsumRating) {
          toRating.HideDisplay = dimsumRating.hideDisplay;
          toRating.DisplayType = dimsumRating.type;
          toRating.Label = dimsumRating.displayLabel;
          if (dimsumRating.type === 'SLIDER') {
            toRating.RatingRange = toRating.RatingRange || dimsumRating.sliderSize;
            toRating.MinLabel = dimsumRating.sliderDimension1Label;
            toRating.MaxLabel = dimsumRating.sliderDimension2Label;
          }
        }

        toRating.RatingRange = toRating.RatingRange || ratingRange;
        secondaryRatings.push(toRating);
      });
      this.set({
        OverallRating: {
          AverageRating: data.Statistics.AverageOverallRating,
          Id: msgPack.secondaryRatingSummaryOverallRatingLabel(),
          RatingRange: ratingRange
        },
        SecondaryRatings: secondaryRatings
      });
      BModel.prototype.processData.call(this, data);
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!secondaryRatingSummary',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/extmsg', 'template/helpers/renderIcon', 'template/helpers/loop', 'template/helpers/ratingIconChar', 'template/helpers/percentage', 'template/helpers/fixedNumber', 'template/helpers/equals', 'template/helpers/renderSlider'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-secondary-rating-summary-header\"> <h3 class=\"bv-content-title\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "secondaryRatingSummaryHeader", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "secondaryRatingSummaryHeader", depth0.msgpack, depth0, options)))
    + "</h3> </div> <div class=\"bv-secondary-rating-summary-list bv-table\" role=\"presentation\"> ";
  stack2 = helpers['with'].call(depth0, depth0.OverallRating, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0, depth1)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers.each.call(depth0, depth0.SecondaryRatings, {hash:{},inverse:self.noop,fn:self.programWithDepth(program6, data, depth0, depth1)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  }
function program2(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-secondary-rating-summary-stars bv-table-row\" aria-labelledby=\"offscreen-secondary-rating-";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <div class=\"bv-secondary-rating-summary-id bv-td bv-table-cell\" aria-hidden=\"true\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Id)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + "</div> <span class=\"bv-table-cell\"> <span class=\"bv-rating-stars-container\"> ";
  options = {hash:{
    'classList': ("bv-rating-stars bv-rating-stars-off"),
    'ariaHidden': ("true")
  },inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-prs-rating-stars-off", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-prs-rating-stars-off", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-rating-stars bv-rating-stars-on bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.AverageRating, 5, 1, options) : helperMissing.call(depth0, "percentage", depth0.AverageRating, 5, 1, options)))
    + "\" aria-hidden=\"true\"> ";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.RatingRange, depth0, options) : helperMissing.call(depth0, "loop", depth0.RatingRange, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> </span> </span> <span class=\"bv-secondary-rating-summary-rating bv-table-cell\" aria-hidden=\"true\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.fixedNumber),stack1 ? stack1.call(depth0, depth0.AverageRating, 1, options) : helperMissing.call(depth0, "fixedNumber", depth0.AverageRating, 1, options)))
    + " </span> <span id=\"offscreen-secondary-rating-";
  if (stack2 = helpers.Id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Id)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + ", ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_secondary_rating_summary", depth2.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_secondary_rating_summary", depth2.msgpack, depth0, options)))
    + "</span> </div> ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.RatingRange, depth0, options) : helperMissing.call(depth0, "loop", depth0.RatingRange, depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {
  
  var stack1, options;
  options = {hash:{}};
  return escapeExpression(((stack1 = helpers.ratingIconChar),stack1 ? stack1.call(depth0, "rating-stars-on", options) : helperMissing.call(depth0, "ratingIconChar", "rating-stars-on", options)));
  }

function program6(depth0,data,depth1,depth2) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers.unless.call(depth0, depth0.HideDisplay, {hash:{},inverse:self.noop,fn:self.programWithDepth(program7, data, depth0, depth1, depth2)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program7(depth0,data,depth1,depth2,depth3) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <div class=\"bv-secondary-rating-summary-bars-container bv-table-row\" aria-labelledby=\"offscreen-secondary-rating-";
  if (stack1 = helpers.Id) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.Id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> <div class=\"bv-secondary-rating-summary-id bv-td bv-table-cell\" aria-hidden=\"true\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Id)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + "</div> ";
  options = {hash:{},inverse:self.program(10, program10, data),fn:self.programWithDepth(program8, data, depth2)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.DisplayType, "SLIDER", options) : helperMissing.call(depth0, "equals", depth0.DisplayType, "SLIDER", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span id=\"offscreen-secondary-rating-";
  if (stack2 = helpers.Id) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.Id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" class=\"bv-off-screen\">";
  options = {hash:{
    'prefix': ("rating_"),
    'defaultDisplay': (depth0.Id)
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.Id, depth1.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", depth0.Id, depth1.msgpack, depth0, options)))
    + ", ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_secondary_rating_summary", depth3.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_secondary_rating_summary", depth3.msgpack, depth0, options)))
    + "</span> </div> ";
  return buffer;
  }
function program8(depth0,data,depth3) {
  
  var buffer = "", stack1, options;
  buffer += " <span class=\"bv-secondary-rating-summary-container bv-content-slider bv-table-cell\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.renderSlider),stack1 ? stack1.call(depth0, depth3.msgpack, depth0, options) : helperMissing.call(depth0, "renderSlider", depth3.msgpack, depth0, options)))
    + " </span> ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <span class=\"bv-secondary-rating-summary-container bv-table-cell\"> <ul class=\"bv-secondary-rating-summary-bars\" role=\"presentation\"> ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program11, data, depth0)};
  stack2 = ((stack1 = helpers.loop),stack1 ? stack1.call(depth0, depth0.RatingRange, options) : helperMissing.call(depth0, "loop", depth0.RatingRange, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <li class=\"bv-secondary-rating-summary-value bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, depth0.AverageRating, depth0.RatingRange, 1, options) : helperMissing.call(depth0, "percentage", depth0.AverageRating, depth0.RatingRange, 1, options)))
    + "\" role=\"presentation\"></li> </ul> </span> <span class=\"bv-secondary-rating-summary-rating bv-table-cell\" aria-hidden=\"true\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.fixedNumber),stack1 ? stack1.call(depth0, depth0.AverageRating, 1, options) : helperMissing.call(depth0, "fixedNumber", depth0.AverageRating, 1, options)))
    + "</span> ";
  return buffer;
  }
function program11(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += "<li class=\"bv-secondary-rating-summary-bar bv-width-from-rating-stats-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.percentage),stack1 ? stack1.call(depth0, 1, depth1.RatingRange, 1, options) : helperMissing.call(depth0, "percentage", 1, depth1.RatingRange, 1, options)))
    + "\" role=\"presentation\"></li>";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("secondary-rating-summary section-summary-block")
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('secondaryRatingSummary', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/secondaryRatingSummary',[
  'framework/bview',
  'underscore',
  'jquery',
  'hbs!secondaryRatingSummary',
  'mf!bv/c2013/messages/secondaryRatingSummary'
], function (BView, _, $, template, msgPack) {
  return BView.extend({
    name: 'secondaryRatingSummary',
    events: {
      'click a.bv-rating-stars-container': 'clickStars'
    },
    template: template,
    msgpacks: [msgPack],

    clickStars: function (e) {
      e.preventDefault();
    }
  });
});

BV.define('bv/c2013/model/inlineProfile',[
  'ENV',
  'bv/c2013/model/avatar'
], function (ENV, AvatarModel) {
  return AvatarModel.extend({

    name: 'inlineProfile',

    init: function (config, options) {
      AvatarModel.prototype.init.apply(this, arguments);
      this.set('_isPopup', false);
      this.get('Author').DisplayContext = 'inline';
      this.subscribe('updateprofile', this.updateProfile);
    },

    updateProfile: function (parent, author) {
      AvatarModel.prototype.generateAvatarImage.call(this, author);
      parent.set('Author', this.get('Author'));
    }

  });
});

/* START_TEMPLATE */
BV.define('hbs!contentAuthorProfileInline',['hbs','vendor/handlebars/runtime','hbs!contentAuthorProfile', 'template/helpers/view'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " <div class=\"bv-inline-profile\"> ";
  stack1 = self.invokePartial(partials.contentAuthorProfile, 'contentAuthorProfile', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </div> ";
  return buffer;
  }

  buffer += " ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("author-profile")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentAuthorProfileInline', t);
t.deps = ["contentAuthorProfile"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview A view to display inline profiles.
 */
BV.define('bv/c2013/view/inlineProfile',[
  'framework/bview',
  'underscore',
  'hbs!contentAuthorProfileInline',
  'mf!bv/c2013/messages/avatar',
  'bv/util/productInfo',
  'framework/util/bvtracker',
  'util/specialKeys'
], function (BView, _, template, msgPack, ProductInfo, BVTracker, specialKeys) {
  return BView.extend({
    name: 'inlineProfile',

    templateName: 'contentAuthorProfileInline',

    events: {
      'click .bv-content-author-name .bv-fullprofile-popup-target': 'launchProfile'
    },

    template: template,

    msgpacks: [msgPack],

    /**
     * Opens a modal with the full profile.
     * First checks if full profile link is enabled, and bails if it isn't.
     * Then opens the full profile, and triggers a BVTracker event.
     *
     * @param  {Event} e The event that triggered opening the profile.
     */
    launchProfile: function (e) {
      // If full profile link is not enabled, bail.
      if (!this.hasFeature('fullProfileLink')) {
        return;
      }

      // If this review is syndicated, there's no profile to show.
      if ( this.model.get('isSyndicated') ) {
        return;
      }

      // use r&r component outlet to trigger full profile popup component event
      this.getTopModel().trigger('showfullprofile', this.model.get('Author'));

      BVTracker.feature({
        type: 'Used',
        name: 'Click',
        detail1: 'ViewProfileButton',
        detail2: 'AuthorAvatar',
        bvProduct: ProductInfo.getType(this),
        productId: ProductInfo.getId(this),
        categoryId: ProductInfo.getCategoryId(this)
      });
    }
  });
});

BV.define('bv/c2013/model/contentSort',[
  'ENV',
  'framework/bmodel',
  'underscore'
], function (ENV, BModel, _) {
  return BModel.extend({
    name: 'contentSort',

    init: function (config, options) {
      // Mixin options
      var dimsumConfig = config.dimsumConfig;
      _.extend(this.options, options);
      this.set({
        defaultSort: dimsumConfig.sortDefault,
        sortTypes: _(dimsumConfig.sortTypes).isEmpty() ? [] : dimsumConfig.sortTypes,
        currentSort: dimsumConfig.sortDefault
      });
    },

    initReady: function (self) {
      this.trigger('setupme', this);
      BModel.prototype.initReady.apply(this, arguments);
    },

    sort: function (val) {
      // If the sort key/direction haven't changed, don't do anything.
      if (this.get('currentSort') === val) {
        return;
      }

      this.set('currentSort', val);

      // Force reload the first page with the new sort setting.
      this.trigger('sortcontent', val);
    },

    /**
     * Map sort strings into an object that can be used to set the sort options
     * for an API request.
     *
     * @param  {String} key
     * @return {Object}
     */
    lookup: function (key) {
      var map = {
        // Ratings and reviews.
        'featured': { primary: [['IsFeatured', 'desc']] },
        'sortReviewsExpertDescending': { primary: [['IsExpert', 'desc']] },
        'sortReviewsStaffDescending': { primary: [['IsStaff', 'desc']] },
        'mostRecent': { primary: [['SubmissionTime', 'desc']] },
        'oldest': { primary: [['SubmissionTime', 'asc']] },
        'positive': { primary: [['Rating', 'desc']] },
        'negative': { primary: [['Rating', 'asc']] },
        'mostHelpful': { primary: [['Helpfulness', 'desc'], ['TotalPositiveFeedbackCount', 'desc']] },
        'mostUnhelpful': { primary: [['Helpfulness', 'asc'], ['TotalPositiveFeedbackCount', 'asc']] },
        'sortReviewsHelpfulnessAscending': { primary: [['Helpfulness', 'asc'], ['TotalNegativeFeedbackCount', 'desc']] },
        'sortReviewsLengthDescending': { primary: [['Length', 'desc']] },
        'sortReviewsLengthAscending': { primary: [['Length', 'asc']] },
        'relevancy': { primary: [['Relevancy', 'a1']] },

        // Ask and answer.
        'recentQuestionsFirst': {
          primary: [['SubmissionTime', 'desc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'recentQuestionsLast': {
          primary: [['SubmissionTime', 'asc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'recentAnswersFirst': {
          primary: [['LastApprovedAnswerSubmissionTime', 'desc']],
          secondary: { 'answers': [['SubmissionTime', 'desc']] }
        },
        'recentAnswersLast': {
          primary: [['LastApprovedAnswerSubmissionTime', 'asc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'mostAnsweredQuestionsFirst': {
          primary: [['TotalAnswerCount', 'desc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'mostAnsweredQuestionsLast': {
          primary: [['TotalAnswerCount', 'asc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'answersWithAffiliationStaffFirst': {
          primary: [['HasStaffAnswers', 'desc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'featuredQuestionsFirst': {
          primary: [['IsFeatured', 'desc']],
          secondary: { 'answers': [['SubmissionTime', 'asc']] }
        },
        'helpfulnessAnswersFirst': {
          primary: [['TotalAnswerCount', 'desc']],
          secondary: { 'answers': [['TotalPositiveFeedbackCount', 'desc'], ['TotalNegativeFeedbackCount', 'asc']] }
        },
        'helpfulnessAnswersLast': {
          primary: [['TotalAnswerCount', 'desc']],
          secondary: { 'answers': [['TotalNegativeFeedbackCount', 'desc'], ['TotalPositiveFeedbackCount', 'asc']] }
        }
      };

      if (_(map).has(key)) {
        return map[key];
      }
    },

    toJSON: function () {
      var json = BModel.prototype.toJSON.call(this);
      json.sortTypes = _(json.sortTypes).map(function (type) {
        return {
          name: type
        };
      });
      return json;
    }

  });
});

(function () {
  function toLowerCase (value) {
    return value.toLowerCase();
  }

      BV.define('template/helpers/toLowerCase',['vendor/handlebars/runtime'], function (hbs) {
      hbs.registerHelper('toLowerCase', toLowerCase);
      return toLowerCase;
    });
  })();

/* START_TEMPLATE */
BV.define('hbs!contentSortHover',['hbs','vendor/handlebars/runtime', 'template/helpers/toLowerCase', 'template/helpers/extmsg', 'template/helpers/equals', 'template/helpers/renderIcon'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.name, depth1.defaultSort, options) : helperMissing.call(depth0, "equals", depth0.name, depth1.defaultSort, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, options;
  buffer += " ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.name, depth1.msgpack, depth0.name, options) : helperMissing.call(depth0, "extmsg", depth0.name, depth1.msgpack, depth0.name, options)))
    + " ";
  return buffer;
  }

function program4(depth0,data) {
  
  
  return " &#x25BC; ";
  }

function program6(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <option value=\"";
  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.name, depth1.defaultSort, options) : helperMissing.call(depth0, "equals", depth0.name, depth1.defaultSort, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.name, depth1.msgpack, depth0.name, options) : helperMissing.call(depth0, "extmsg", depth0.name, depth1.msgpack, depth0.name, options)))
    + " </option> ";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return "selected";
  }

  buffer += " <div class=\"bv-dropdown\"> <div class=\"bv-dropdown-target\" role=\"menu\"> <span id=\"bv-dropdown-select-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + "\" class=\"bv-dropdown-label\"> ";
  options = {hash:{
    'prefix': ("content_sort_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "label", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "label", depth0.msgpack, depth0, options)))
    + ": </span> "
    + " <button type=\"button\" class=\"bv-focusable\" aria-haspopup=\"true\" aria-expanded=\"false\" role=\"menuitem\" aria-labelledby=\"bv-dropdown-select-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + " bv-dropdown-title-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + "\"> <span id=\"bv-dropdown-title-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + "\" class=\"bv-dropdown-title\"> ";
  stack2 = helpers.each.call(depth0, depth0.sortTypes, {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </span> ";
  options = {hash:{
    'classList': ("bv-dropdown-arrow"),
    'ariaHidden': ("true"),
    'role': ("presentation")
  },inverse:self.noop,fn:self.program(4, program4, data)};
  stack2 = ((stack1 = helpers.renderIcon),stack1 ? stack1.call(depth0, "bv-sprite-down-arrow-dark", options) : helperMissing.call(depth0, "renderIcon", "bv-sprite-down-arrow-dark", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " <span class=\"bv-off-screen\">";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "offscreen_sort_arrow", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "offscreen_sort_arrow", depth0.msgpack, depth0, options)))
    + "</span> </button> </div> <select class=\"bv-select-cleanslate bv-dropdown-select\" aria-hidden=\"true\" aria-labelledby=\"bv-dropdown-select-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + "\" tabindex=\"-1\"> ";
  stack2 = helpers.each.call(depth0, depth0.sortTypes, {hash:{},inverse:self.noop,fn:self.programWithDepth(program6, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </select> </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentSortHover', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentSortNative',['hbs','vendor/handlebars/runtime', 'template/helpers/extmsg', 'template/helpers/equals'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <option value=\"";
  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" ";
  options = {hash:{},inverse:self.noop,fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.name, depth1.defaultSort, options) : helperMissing.call(depth0, "equals", depth0.name, depth1.defaultSort, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.name, depth1.msgpack, depth0.name, options) : helperMissing.call(depth0, "extmsg", depth0.name, depth1.msgpack, depth0.name, options)))
    + " </option> ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "selected";
  }

  buffer += " <div class=\"bv-sort-native\"> <span id=\"bv-dropdown-label-select-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"> ";
  options = {hash:{
    'prefix': ("content_sort_")
  }};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, "label", depth0.msgpack, depth0, options) : helperMissing.call(depth0, "extmsg", "label", depth0.msgpack, depth0, options)))
    + ": </span> <select id=\"bv-dropdown-select-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" aria-labelledby=\"bv-dropdown-label-select-"
    + escapeExpression(((stack1 = ((stack1 = depth0._bview),stack1 == null || stack1 === false ? stack1 : stack1.viewId)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"bv-focusable\"> ";
  stack2 = helpers.each.call(depth0, depth0.sortTypes, {hash:{},inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </select> </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentSortNative', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/* START_TEMPLATE */
BV.define('hbs!contentSort',['hbs','vendor/handlebars/runtime','hbs!contentSortHover', 'hbs!contentSortNative', 'template/helpers/view', 'template/helpers/ifHasFeature'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers; partials = partials || Handlebars.partials;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " ";
  options = {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data)};
  stack2 = ((stack1 = helpers.ifHasFeature),stack1 ? stack1.call(depth0, "hoverDropdown", options) : helperMissing.call(depth0, "ifHasFeature", "hoverDropdown", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentSortHover, 'contentSortHover', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = self.invokePartial(partials.contentSortNative, 'contentSortNative', depth0, helpers, partials);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }

  options = {hash:{
    'tag': ("div"),
    'classList': ("control-bar-sort")
  },inverse:self.noop,fn:self.program(1, program1, data)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  return buffer;
  });
Handlebars.registerPartial('contentSort', t);
t.deps = ["contentSortHover","contentSortNative"];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('mf!bv/c2013/messages/sort',['vendor/messageformat', 'framework/util/bvtrackerqueue'], function (MessageFormat, BVTrackerQueue) { 
  return {
"content_sort_label" : function (x) { try { return (function(d){
var r = "";
r += "Sort by";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `content_sort_label`: ' + e.toString() ) ] ); return ""; } },"featured" : function (x) { try { return (function(d){
var r = "";
r += "Featured";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `featured`: ' + e.toString() ) ] ); return ""; } },"mostRecent" : function (x) { try { return (function(d){
var r = "";
r += "Most Recent";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostRecent`: ' + e.toString() ) ] ); return ""; } },"oldest" : function (x) { try { return (function(d){
var r = "";
r += "Oldest";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `oldest`: ' + e.toString() ) ] ); return ""; } },"negative" : function (x) { try { return (function(d){
var r = "";
r += "Lowest to Highest Rating";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `negative`: ' + e.toString() ) ] ); return ""; } },"positive" : function (x) { try { return (function(d){
var r = "";
r += "Highest to Lowest Rating";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `positive`: ' + e.toString() ) ] ); return ""; } },"mostHelpful" : function (x) { try { return (function(d){
var r = "";
r += "Most Helpful";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostHelpful`: ' + e.toString() ) ] ); return ""; } },"mostUnhelpful" : function (x) { try { return (function(d){
var r = "";
r += "Least Helpful";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostUnhelpful`: ' + e.toString() ) ] ); return ""; } },"relevancy" : function (x) { try { return (function(d){
var r = "";
r += "Most Relevant";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `relevancy`: ' + e.toString() ) ] ); return ""; } },"recentAnswersFirst" : function (x) { try { return (function(d){
var r = "";
r += "Newest answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `recentAnswersFirst`: ' + e.toString() ) ] ); return ""; } },"recentAnswersLast" : function (x) { try { return (function(d){
var r = "";
r += "Oldest answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `recentAnswersLast`: ' + e.toString() ) ] ); return ""; } },"mostAnsweredQuestionsFirst" : function (x) { try { return (function(d){
var r = "";
r += "Most answered";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostAnsweredQuestionsFirst`: ' + e.toString() ) ] ); return ""; } },"mostAnsweredQuestionsLast" : function (x) { try { return (function(d){
var r = "";
r += "Answers needed";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `mostAnsweredQuestionsLast`: ' + e.toString() ) ] ); return ""; } },"answersWithAffiliationStaffFirst" : function (x) { try { return (function(d){
var r = "";
r += "Staff answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `answersWithAffiliationStaffFirst`: ' + e.toString() ) ] ); return ""; } },"recentQuestionsFirst" : function (x) { try { return (function(d){
var r = "";
r += "Newest questions";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `recentQuestionsFirst`: ' + e.toString() ) ] ); return ""; } },"recentQuestionsLast" : function (x) { try { return (function(d){
var r = "";
r += "Oldest questions";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `recentQuestionsLast`: ' + e.toString() ) ] ); return ""; } },"helpfulnessAnswersFirst" : function (x) { try { return (function(d){
var r = "";
r += "Most helpful answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpfulnessAnswersFirst`: ' + e.toString() ) ] ); return ""; } },"helpfulnessAnswersLast" : function (x) { try { return (function(d){
var r = "";
r += "Least helpful answers";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `helpfulnessAnswersLast`: ' + e.toString() ) ] ); return ""; } },"featuredQuestionsFirst" : function (x) { try { return (function(d){
var r = "";
r += "Featured questions first";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `featuredQuestionsFirst`: ' + e.toString() ) ] ); return ""; } },"offscreen_sort_arrow" : function (x) { try { return (function(d){
var r = "";
r += "Menu";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_sort_arrow`: ' + e.toString() ) ] ); return ""; } },"offscreen_relevancy_link_description" : function (x) { try { return (function(d){
var r = "";
r += "Display a popup with information about Relevancy Sort.";
return r;
})(x||{}); } catch(e){ BVTrackerQueue.push([ 'error', new Error( 'MF error on `offscreen_relevancy_link_description`: ' + e.toString() ) ] ); return ""; } }
};
});

/* START_TEMPLATE */
BV.define('hbs!contentSortDropdown',['hbs','vendor/handlebars/runtime', 'template/helpers/view', 'template/helpers/toLowerCase', 'template/helpers/equals', 'template/helpers/extmsg'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <!--[if lt IE 7]> <div class=\"bv-compat bvie6 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 7]> <div class=\"bv-compat bvie7 bvie-lt8 bvie\"> <![endif]--> <!--[if IE 8]> <div class=\"bv-compat bvie8 bvie\"> <![endif]--> <!--[if IE 9]> <div class=\"bv-compat bvie9 bvie\"> <![endif]--> <!--[if gt IE 9]> <!--><div class=\"bv-compat\"> <!--<![endif]--> <div class=\"bv-dropdown\"> <ul id=\"bv-dropdown-select-";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.toLowerCase),stack1 ? stack1.call(depth0, ((stack1 = depth1._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options) : helperMissing.call(depth0, "toLowerCase", ((stack1 = depth1._bview),stack1 == null || stack1 === false ? stack1 : stack1.contentType), options)))
    + "-sortby\" role=\"menu\"> ";
  stack2 = helpers.each.call(depth0, depth0.sortTypes, {hash:{},inverse:self.noop,fn:self.programWithDepth(program2, data, depth0)});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </ul> </div> </div> ";
  return buffer;
  }
function program2(depth0,data,depth1) {
  
  var buffer = "", stack1, stack2, options;
  buffer += " <li class=\"bv-dropdown-item";
  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data)};
  stack2 = ((stack1 = helpers.equals),stack1 ? stack1.call(depth0, depth0.name, depth1.currentSort, options) : helperMissing.call(depth0, "equals", depth0.name, depth1.currentSort, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " bv-focusable\" data-bv-dropdown-value=\"";
  if (stack2 = helpers.name) { stack2 = stack2.call(depth0, {hash:{}}); }
  else { stack2 = depth0.name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" tabindex=\"0\" role=\"menuitem\"> ";
  options = {hash:{}};
  buffer += escapeExpression(((stack1 = helpers.extmsg),stack1 ? stack1.call(depth0, depth0.name, depth1.msgpack, depth0.name, options) : helperMissing.call(depth0, "extmsg", depth0.name, depth1.msgpack, depth0.name, options)))
    + " </li> ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return " bv-dropdown-item-selected";
  }

  buffer += "<div class=\"bv-core-container-";
  if (stack1 = helpers.version) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.version; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"> ";
  options = {hash:{
    'tag': ("div"),
    'classList': ("select-dropdown")
  },inverse:self.noop,fn:self.programWithDepth(program1, data, depth0)};
  stack2 = ((stack1 = helpers.view),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, "view", depth0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " </div> ";
  return buffer;
  });
Handlebars.registerPartial('contentSortDropdown', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
BV.define('bv/c2013/view/contentSortDropdown',[
  'jquery',
  'bv/ui-core/bselectdropdownview',
  'hbs!contentSortDropdown',
  'underscore',
  'mf!bv/c2013/messages/sort',
  'bv/util/focusManager',
  'util/specialKeys',
  'framework/util/bvreporter'
], function ($, BSelectDropdownView, template, _, sortMsgPack, focusManager, specialKeys, BVReporter) {
  return BSelectDropdownView.extend({

    name: 'contentSortDropdown',

    width: 226,

    height: 400,

    template: template,

    msgpacks: [sortMsgPack],

    setupKeyboardNavigation: function () {
      var self = this;
      var parent = self.parent;
      var leaveDropdown;
      var moveForward;
      var moveBackward;
      var movement;
      self.$viewEl.off('keydown.contentSortDropdown').on('keydown.contentSortDropdown', function (e) {
        var $target = $(e.target);

        var keysToHandle = {};
        _(['TAB', 'ENTER', 'ESCAPE', 'SPACE', 'LEFT', 'UP', 'RIGHT', 'DOWN']).each(function (k) {
          keysToHandle[specialKeys[k]] = true;
        });

        // If it's not one of our keys, pretend like we never saw it
        if (!keysToHandle[e.keyCode]) { return; }

        // Stops the event from doing more stuff
        e.preventDefault();
        e.stopPropagation();

        // Deregister the focus layer and make sure the parent knows
        leaveDropdown = function () {
          self.deregisterFocusableLayer();
          parent.leave(e);
        };

        // Move forward in the list, taking care to wrap
        moveForward = function () {
          if (document.activeElement === self.$last[0]) {
            focusManager.moveFocus(self.$first);
          }
          else {
            focusManager.focusNext();
          }
        };

        // Move backward in the list, taking care to wrap
        moveBackward = function () {
          if (document.activeElement === self.$first[0]) {
            focusManager.moveFocus(self.$last);
          }
          else {
            focusManager.focusPrev();
          }
        };

        // Control our own keyboard navigation
        switch (e.keyCode) {
          // Enter / Spacebar act as clicks, then leave the dropdown
          case specialKeys.SPACE:
          case specialKeys.ENTER:
            $target.click();
            leaveDropdown();
            break;

          // Escape leaves the menu without clicking
          case specialKeys.ESCAPE:
            leaveDropdown();
            break;

          // Tab / Shift + Tab will leave the menu, then move focus
          case specialKeys.TAB:
            leaveDropdown();  // We have to leave _before_ calling movement
            movement = e.shiftKey ? 'focusPrev' : 'focusNext';
            focusManager[movement]();
            break;

          // Left / Up arrows navigate backwards
          case specialKeys.LEFT:
          case specialKeys.UP:
            moveBackward();
            break;

          // Right / Down arrows navigate forward
          case specialKeys.RIGHT:
          case specialKeys.DOWN:
            moveForward();
            break;
        }
      });
    },

    /**
     * A method to focus an option in the dropdown.
     * As of now, only intended for first or last element
     *
     * @param firstOrLast String Should be '$first' or '$last'
     */
    focusElement: function (firstOrLast) {
      var validStrings = ['$first', '$last'];
      var $option;
      if (_.indexOf(validStrings, firstOrLast) < 0) {
        BVReporter.warn('Invalid string passed to contentSortDropdown.focusElement. Please pass in \'$first\' or \'$last\'. Defaulting to \'$first\'');
        firstOrLast = '$first';
      }

      $option = this[firstOrLast];
      focusManager.moveFocus($option);
    },

    init: function () {
      this.classList.push('content-sort-dropdown');
      this.options.rightAlign = true;

      if (this.getComponent().lightbox) {
        this.options.aboveModestBox = true;
      }

      this.model.on('focusElement.contentSort', this.focusElement, this);
    },

    topPositionModifier: function (pos) {
      return pos - 5;
    },

    rightPositionModifier: function (pos) {
      // Sort dropdown should have such `left` value that its right edge is flush with
      // the parent's right edge. See CCS-8934.
      return pos;
    }

  });
});

BV.define('bv/c2013/view/contentSort',[
  'jquery',
  'bv/ui-core/bhoverableview',
  'bv/ui-core/bselectview',
  'hbs!contentSort',
  'underscore',
  'mf!bv/c2013/messages/sort',
  'bv/c2013/view/contentSortDropdown',
  'bv/util/productInfo',
  'framework/util/bvtracker',
  'bv/util/focusManager',
  'util/specialKeys',
  'framework/util/bvreporter'
], function ContentSort (
  $,
  BHoverableView,
  BSelectView,
  template, _,
  sortMsgPack,
  ContentSortDropdown,
  ProductInfo,
  BVTracker,
  focusManager,
  specialKeys,
  BVReporter) {
  var dropdownIsVisible = false;
  return BSelectView.extend({
    targetEl: '.bv-control-bar-sort',
    selectEl: '.bv-dropdown-select',
    dropdownFocusables: '.bv-content-sort-dropdown .bv-focusable',

    name: 'contentSort',

    events: {
      'change select': 'change',
      'click button.bv-focusable': 'enter'
    },

    template: template,

    TargetView: ContentSortDropdown,

    msgpacks: [sortMsgPack],

    setupKeyboardNavigation: function setupKeyboardNavigation ($targetEl) {
      var self = this;
      $targetEl = $targetEl || self.$targetEl;

      // Catch key presses on the sort button
      $targetEl.off('keydown.contentSort').on('keydown.contentSort', function setupKeyboard (e) {

        var keysToHandle = {};
        var movement;
        // Enter the dropdown if needed
        // Then tell the dropdown to focus one of the options
        // @param firstOrLast String Should be '$first' or '$last'
        function enterAndSelect (firstOrLast) {
          var validStrings = ['$first', '$last'];
          if (_.indexOf(validStrings, firstOrLast) < 0) {
            BVReporter.warn('Invalid string passed to contentSort.enterAndSelect. Please pass in \'$first\' or \'$last\'. Defaulting to \'$first\'');
            firstOrLast = '$first';
          }
          if (dropdownIsVisible) {
            self.model.trigger('focusElement.contentSort', firstOrLast);
          }
          else {
            self.model.once('dropdownRendered', function () {
              self.model.trigger('focusElement.contentSort', firstOrLast);
            });
            self.enter(e);
          }
        };

        _(['TAB', 'ENTER', 'ESCAPE', 'SPACE', 'LEFT', 'UP', 'RIGHT', 'DOWN']).each(function (k) {
          keysToHandle[specialKeys[k]] = true;
        });

        // If it's not one of our keys, pretend like we never saw it
        if (!keysToHandle[e.keyCode]) { return; }

        // Stops the event from doing more stuff
        // like scrolling the page, or changing focus again
        e.preventDefault();
        e.stopPropagation();

        switch (e.keyCode) {
          // Space / Enter opens the menu and focuses the first element if menu is closed
          // otherwise closes the menu
          case specialKeys.SPACE:
          case specialKeys.ENTER:
            if (!dropdownIsVisible) {
              enterAndSelect('$first');
            }
            else {
              self.leave(e);
            }
            break;

          // Right / Down arrows should enter the menu and focus the first
          case specialKeys.RIGHT:
          case specialKeys.DOWN:
            enterAndSelect('$first');
            break;

          // Left / Up arrows should enter the menu and focus the last
          case specialKeys.LEFT:
          case specialKeys.UP:
            enterAndSelect('$last');
            break;

          // Tab / Shift + Tab should skip past the menu
          case specialKeys.TAB:
            if (dropdownIsVisible) {
              self.leave(e);
            }
            movement = e.shiftKey ? 'focusPrev' : 'focusNext';
            focusManager[movement]();
            break;

          // Escape closes the menu if it's open
          case specialKeys.ESCAPE:
            if (dropdownIsVisible) {
              self.leave(e);
            }
            break;
        }
      });
    },

    enter: function enter (e) {
      var $currentElement = $(this.$viewEl).find('button');
      dropdownIsVisible = true;
      $currentElement.attr('aria-controls', 'bv-dropdown-select-' + this.contentType.toLowerCase() + '-sortby');
      if (this.hasFeature('hoverDropdown')) {
        return BHoverableView.prototype.enter.apply(this, arguments);
      }
    },

    leave: function leave (e) {
      var $currentElement = $(this.$viewEl).find('button.bv-focusable');
      dropdownIsVisible = false;
      $currentElement.removeAttr('aria-controls');
      // Set focus to content sort button. See UIA-9226.
      focusManager.moveFocus($currentElement);
      if (this.hasFeature('hoverDropdown')) {
        return BHoverableView.prototype.leave.apply(this, arguments);
      }
    },

    change: function change (e) {
      var value = e.target.value;
      this.model.sort(value);
    }
  });
});

BV.define('mappings!nonsubmission',[
"bv/c2013/model/fullProfile",
"bv/c2013/view/fullProfile",
"bv/c2013/model/sidebar",
"bv/c2013/view/sidebar",
"bv/c2013/model/tabs",
"bv/c2013/view/tabs",
"bv/c2013/model/profileContentList",
"bv/c2013/view/profileContentList",
"bv/c2013/model/profileContentList",
"bv/c2013/view/profileContentList",
"bv/c2013/model/profileContentList",
"bv/c2013/view/profileContentList",
"bv/c2013/collection/contentItemCollection",
"bv/c2013/view/contentItemCollection",
"bv/c2013/model/ugcCount",
"bv/c2013/view/ugcCount",
"bv/c2013/model/pagination",
"bv/c2013/view/pagination",
"bv/c2013/model/secondaryContentList",
"bv/c2013/view/secondaryContentList",
"bv/c2013/collection/secondaryContentItemCollection",
"bv/c2013/view/secondaryContentItemCollection",
"bv/c2013/model/loadMore",
"bv/c2013/view/loadMore",
"bv/c2013/model/mediaViewer",
"bv/c2013/view/mediaViewer",
"bv/c2013/model/guidelines",
"bv/c2013/view/guidelines",
"bv/c2013/model/genericSubmission",
"bv/c2013/view/genericSubmission",
"bv/c2013/model/searchBar",
"bv/c2013/view/searchBar",
"bv/c2013/model/categorySelect",
"bv/c2013/view/categorySelect",
"bv/c2013/model/ugcCount",
"bv/c2013/view/ugcCount",
"bv/c2013/model/ugcCount",
"bv/c2013/view/ugcCount",
"bv/c2013/collection/productItemCollection",
"bv/c2013/view/productItemCollection",
"bv/c2013/collection/productItemCollection",
"bv/c2013/view/productItemCollection",
"bv/c2013/model/loadMore",
"bv/c2013/view/loadMore",
"bv/c2013/model/loadMore",
"bv/c2013/view/loadMore",
"bv/c2013/model/ratingList",
"bv/c2013/view/ratingList",
"bv/c2013/collection/ratingItemCollection",
"bv/c2013/view/ratingItemCollection",
"bv/c2013/model/contentSearch",
"bv/c2013/view/contentSearch",
"bv/c2013/model/searchContentList",
"bv/c2013/view/searchContentList",
"bv/c2013/model/trustmarkIcon",
"bv/c2013/view/trustmarkIcon",
"bv/c2013/model/statsPanel",
"bv/c2013/view/statsPanel",
"bv/c2013/model/avatar",
"bv/c2013/view/avatar",
"bv/c2013/model/feedback",
"bv/c2013/view/feedback",
"bv/c2013/model/crowdSourcedAnswerBadge",
"bv/c2013/view/crowdSourcedAnswerBadge",
"bv/c2013/model/summary",
"bv/c2013/view/summary",
"bv/c2013/model/histogram",
"bv/c2013/view/histogram",
"bv/c2013/model/contentList",
"bv/c2013/view/contentList",
"bv/c2013/model/contentFilter",
"bv/c2013/view/contentFilter",
"bv/c2013/model/headToHead",
"bv/c2013/view/headToHead",
"bv/c2013/model/inlineHistogram",
"bv/c2013/view/inlineHistogram",
"bv/c2013/model/secondaryRatingSummary",
"bv/c2013/view/secondaryRatingSummary",
"bv/c2013/model/inlineProfile",
"bv/c2013/view/inlineProfile",
"bv/c2013/collection/secondaryContentItemCollection",
"bv/c2013/view/secondaryContentItemCollection",
"bv/c2013/collection/secondaryContentItemCollection",
"bv/c2013/view/secondaryContentItemCollection",
"bv/c2013/model/contentSort",
"bv/c2013/view/contentSort"
], function (
fullProfileModel,
fullProfileView,
sidebarModel,
sidebarView,
tabsModel,
tabsView,
profileContentListModel,
profileContentListView,
profileContentListModel,
profileContentListView,
profileContentListModel,
profileContentListView,
contentItemCollectionModel,
contentItemCollectionView,
ugcCountModel,
ugcCountView,
paginationModel,
paginationView,
secondaryContentListModel,
secondaryContentListView,
secondaryContentItemCollectionModel,
secondaryContentItemCollectionView,
loadMoreModel,
loadMoreView,
mediaViewerModel,
mediaViewerView,
guidelinesModel,
guidelinesView,
genericSubmissionModel,
genericSubmissionView,
searchBarModel,
searchBarView,
categorySelectModel,
categorySelectView,
ugcCountModel,
ugcCountView,
ugcCountModel,
ugcCountView,
productItemCollectionModel,
productItemCollectionView,
productItemCollectionModel,
productItemCollectionView,
loadMoreModel,
loadMoreView,
loadMoreModel,
loadMoreView,
ratingListModel,
ratingListView,
ratingItemCollectionModel,
ratingItemCollectionView,
contentSearchModel,
contentSearchView,
searchContentListModel,
searchContentListView,
trustmarkIconModel,
trustmarkIconView,
statsPanelModel,
statsPanelView,
avatarModel,
avatarView,
feedbackModel,
feedbackView,
crowdSourcedAnswerBadgeModel,
crowdSourcedAnswerBadgeView,
summaryModel,
summaryView,
histogramModel,
histogramView,
contentListModel,
contentListView,
contentFilterModel,
contentFilterView,
headToHeadModel,
headToHeadView,
inlineHistogramModel,
inlineHistogramView,
secondaryRatingSummaryModel,
secondaryRatingSummaryView,
inlineProfileModel,
inlineProfileView,
secondaryContentItemCollectionModel,
secondaryContentItemCollectionView,
secondaryContentItemCollectionModel,
secondaryContentItemCollectionView,
contentSortModel,
contentSortView
) { 
  var mappings = {
    bvRouter : {name : 'bvRouter'},
    fullProfile : {name : 'fullProfile', model : fullProfileModel, view : fullProfileView},
    sidebar : {name : 'sidebar', model : sidebarModel, view : sidebarView},
    tabs : {name : 'tabs', model : tabsModel, view : tabsView},
    profileContentList : {name : 'profileContentList', type : [], model : profileContentListModel, view : profileContentListView},
    contentItemCollection : {name : 'contentItemCollection', collection : contentItemCollectionModel, view : contentItemCollectionView},
    ugcCount : {name : 'ugcCount', model : ugcCountModel, view : ugcCountView},
    pagination : {name : 'pagination', model : paginationModel, view : paginationView},
    secondaryContentList : {name : 'secondaryContentList', model : secondaryContentListModel, view : secondaryContentListView},
    secondaryContentItemCollection : {name : 'secondaryContentItemCollection', collection : secondaryContentItemCollectionModel, view : secondaryContentItemCollectionView},
    loadMore : {name : 'loadMore', model : loadMoreModel, view : loadMoreView},
    mediaViewer : {name : 'mediaViewer', model : mediaViewerModel, view : mediaViewerView},
    guidelines : {name : 'guidelines', model : guidelinesModel, view : guidelinesView},
    rrSubmissionGuidelines1 : {name : 'rrSubmissionGuidelines1'},
    genericSubmission : {name : 'genericSubmission', model : genericSubmissionModel, view : genericSubmissionView},
    searchBar : {name : 'searchBar', model : searchBarModel, view : searchBarView},
    categorySelect : {name : 'categorySelect', model : categorySelectModel, view : categorySelectView},
    productItemCollection : {name : 'productItemCollection', collection : productItemCollectionModel, view : productItemCollectionView},
    ratingList : {name : 'ratingList', model : ratingListModel, view : ratingListView},
    ratingItemCollection : {name : 'ratingItemCollection', collection : ratingItemCollectionModel, view : ratingItemCollectionView},
    contentSearch : {name : 'contentSearch', model : contentSearchModel, view : contentSearchView},
    searchContentList : {name : 'searchContentList', model : searchContentListModel, view : searchContentListView},
    trustmarkIcon : {name : 'trustmarkIcon', model : trustmarkIconModel, view : trustmarkIconView},
    statsPanel : {name : 'statsPanel', model : statsPanelModel, view : statsPanelView},
    avatar : {name : 'avatar', model : avatarModel, view : avatarView},
    feedback : {name : 'feedback', model : feedbackModel, view : feedbackView},
    crowdSourcedAnswerBadge : {name : 'crowdSourcedAnswerBadge', model : crowdSourcedAnswerBadgeModel, view : crowdSourcedAnswerBadgeView},
    summary : {name : 'summary', model : summaryModel, view : summaryView},
    histogram : {name : 'histogram', model : histogramModel, view : histogramView},
    contentList : {name : 'contentList', model : contentListModel, view : contentListView},
    contentFilter : {name : 'contentFilter', model : contentFilterModel, view : contentFilterView},
    headToHead : {name : 'headToHead', model : headToHeadModel, view : headToHeadView},
    inlineHistogram : {name : 'inlineHistogram', model : inlineHistogramModel, view : inlineHistogramView},
    secondaryRatingSummary : {name : 'secondaryRatingSummary', model : secondaryRatingSummaryModel, view : secondaryRatingSummaryView},
    inlineProfile : {name : 'inlineProfile', model : inlineProfileModel, view : inlineProfileView},
    secondaryContentItemCollection : {name : 'secondaryContentItemCollection', type : [], collection : secondaryContentItemCollectionModel, view : secondaryContentItemCollectionView},
    contentSort : {name : 'contentSort', has : { name : 'contentSort'}, model : contentSortModel, view : contentSortView},
    stars : { name : 'stars', has : { name : 'stars'}},
    productImage : { name : 'productImage', has : { name : 'productImage'}},
    prosCons : { name : 'prosCons', has : { name : 'prosCons'}},
    contentBadges : { name : 'contentBadges', has : { name : 'contentBadges'}},
    secondarySubmission : { name : 'secondarySubmission', has : { name : 'secondarySubmission'}},
    secondaryContentBtn : { name : 'secondaryContentBtn', has : { name : 'secondaryContentBtn'}},
    secondaryContentLink : { name : 'secondaryContentLink', has : { name : 'secondaryContentLink'}},
    userBadges : { name : 'userBadges', has : { name : 'userBadges'}},
    reviewHelperText : { name : 'reviewHelperText', has : { name : 'reviewHelperText'}},
    searchOnKeyup : { name : 'searchOnKeyup', has : { name : 'searchOnKeyup'}},
    infiniteScroll : { name : 'infiniteScroll', has : { name : 'infiniteScroll'}},
    instanceNameScope : { name : 'instanceNameScope', has : { name : 'instanceNameScope'}},
    filterByCategory : { name : 'filterByCategory', has : { name : 'filterByCategory'}},
    filterWithoutCategory : { name : 'filterWithoutCategory', has : { name : 'filterWithoutCategory'}},
    searchOnly : { name : 'searchOnly', has : { name : 'searchOnly'}},
    overallRating : { name : 'overallRating', has : { name : 'overallRating'}},
    reviewCount : { name : 'reviewCount', has : { name : 'reviewCount'}},
    socialAvatar : { name : 'socialAvatar', has : { name : 'socialAvatar'}},
    aggregateRatingTag : { name : 'aggregateRatingTag', has : { name : 'aggregateRatingTag'}},
    writeReviews : { name : 'writeReviews', has : { name : 'writeReviews'}},
    askQuestions : { name : 'askQuestions', has : { name : 'askQuestions'}},
    minimalistHorizontal : { name : 'minimalistHorizontal', has : { name : 'minimalistHorizontal'}},
    minimalist : { name : 'minimalist', has : { name : 'minimalist'}},
    filterButton : { name : 'filterButton', has : { name : 'filterButton'}},
    secondaryRatings : { name : 'secondaryRatings', has : { name : 'secondaryRatings'}},
    reviewPhotos : { name : 'reviewPhotos', has : { name : 'reviewPhotos'}},
    reviewVideos : { name : 'reviewVideos', has : { name : 'reviewVideos'}},
    tags : { name : 'tags', has : { name : 'tags'}},
    recommended : { name : 'recommended', has : { name : 'recommended'}},
    fullProfileLink : { name : 'fullProfileLink', has : { name : 'fullProfileLink'}},
    reviewAttribution : { name : 'reviewAttribution', has : { name : 'reviewAttribution'}},
    productFamiliesAttribution : { name : 'productFamiliesAttribution', has : { name : 'productFamiliesAttribution'}},
    inlineSubmission : { name : 'inlineSubmission', has : { name : 'inlineSubmission'}}
  };

  mappings.profileContentList.type.push('Reviews');
  mappings.profileContentList.type.push('Questions');
  mappings.profileContentList.type.push('Answers');
  mappings.secondaryContentItemCollection.type.push('ClientResponses');
  mappings.secondaryContentItemCollection.type.push('Comments');

  return mappings;

});

BV.define('bv/util/userToken',[], function () {
  function hex2str (hex) {
    var length = hex.length;
    if (length % 2) {
      return null;
    }

    var chars = [];
    for (var i = 0; i < length; i += 2) {
      var charCode = parseInt(hex[i] + hex[i + 1], 16);
      chars[i / 2] = String.fromCharCode(charCode);
    }

    return chars.join('');
  }

  function getIdFromToken (token) {
    // Remove the md5 hash
    var hexStr = (token || '').substr(32);

    var userStr = hex2str(hexStr);
    var idMatch = userStr.match(/userid=([^&]+)/i);
    if (idMatch && idMatch.length > 1) {
      return idMatch[1];
    }

    return null;
  }

  function getDataFromToken (token) {
    // Remove the md5 hash
    var hexStr = (token || '').substr(32);

    return hex2str(hexStr);
  }

  var UserToken = {
    getId: getIdFromToken,
    getData: getDataFromToken
  };
  return UserToken;
});

BV.define('bv/util/user',[
  'ENV',
  'backbone',
  'underscore',
  'window',
  'client!util/cookie',
  'bv/util/session',
  'bv/util/userToken',
  'util/checksum',
  'jquery'
], function (ENV, Backbone, _, window, Cookie, Session, UserToken, checksum, $) {

  if (window.BV && window.BV.serverRender) {
    return {};
  }

  var modelName = 'user';

  var siteAuthEnabled = _(ENV.get('config').siteAuth).reduce(function (memo, siteauth) { return memo || siteauth; });

  var Store = function (name) {
    this.name = name;
  };

  _(Store.prototype).extend({
    save: function (data, fn) {
      Session.set(this.name, data, function (result) {
        fn(result);
      });
    },
    read: function (model, options) {
      Session.get(this.name, function (result) {
        options.success(result || {});
      });
    },
    create: function (model, options) {
      this.save(model.attributes, options.success);
    },
    update: function (model, options) {
      this.save(model.attributes, options.success);
    },
    destroy: function (model, options) {
      Session.remove(this.name, function (result) {
        options.success(result);
      });
    }
  });

  // Clears session data if a different user ID is detected
  // Only clears if there was an existing user ID
  function detectUserChange (newToken) {
    var dfd = $.Deferred();
    if (newToken) {
      Session.get(modelName, function (sessionData) {
        var sessionToken = (sessionData || {}).token;
        var userChanged = sessionToken && UserToken.getId(sessionToken) !== UserToken.getId(newToken);
        if (userChanged) {
          Session.create();
        }
        dfd.resolve(userChanged);
      });
    } else {
      dfd.resolve(false);
    }
    return dfd.promise();
  }

  var UserModel = Backbone.Model.extend({
    name: modelName,

    initialize: function () {
      var self = this;

      this.on('change:token', function (model, newToken) {
        if (newToken) {
          detectUserChange(newToken).done(function () {
            self.tokenDfd.resolve(newToken);
          });
        }
      });

      ENV.on('firstUI', function (config) {
        // If we get a token here, it didn't come from session (either URL and/or clientAPIConfig)
        var setToken = self.get('token');
        if (Session.id()) {
          self.fetch({
            success: function () {
              detectUserChange(setToken).done(function () {
                // If we had a token that didn't come from session, reset it
                if (setToken) {
                  self.set({ token: setToken }, { silent: true });
                }
                // If we didn't and we have site auth, don't use the token stored in session
                else if (siteAuthEnabled) {
                  self.unset('token', { silent: true });
                }
                self.fetchDfd.resolve();
              });
            }
          });
        }
        else {
          self.fetchDfd.resolve();
        }
      });

    },
    storage: new Store(modelName),
    // This is resolved after we get our first token
    tokenDfd: $.Deferred(),
    // This is resolved after we've read from session store
    fetchDfd: $.Deferred(),
    sync: function (method, model, options) {
      method = method === 'delete' ? 'destroy' : method;
      model.storage[method](model, options);
    },
    thirdPartyIds: function () {
      var self = this;
      var result = {};
      _(['gravatar', 'facebook']).forEach(function (thirdparty) {
        var id = self.get(thirdparty);
        if (id) {
          result['thirdpartyid_' + thirdparty] = id;
        }
      });
      return result;
    },
    thirdPartyIdsArray: function () {
      var self = this;
      var result = [];
      _(self.thirdPartyIds()).forEach(function (id, thirdparty) {
        result.push({
          Name: thirdparty.substr('thirdpartyid_'.length),
          Id: id
        });
      });
      return result;
    },
    // The promise returned here will give you the current token
    // after ensuring data from session has been read. The token
    // may be undefined if no user is "logged in."
    token: function () {
      var dfd = $.Deferred();
      var self = this;
      self.fetchDfd.done(function () {
        dfd.resolve(self.get('token'));
      });
      return dfd.promise();
    },
    // The promise returned from this will only be resolved
    // when we have a token (not undefined).
    promise: function () {
      var self = this;
      if (this.tokenDfd.state() === 'resolved') {
        return $.Deferred().resolve(self.get('token')).promise();
      }
      return this.tokenDfd.promise();
    },
    checksum: function () {
      return checksum(UserToken.getId(this.get('token')) || '');
    },
    getAuthor: function () {
      return {
        ThirdPartyIds: this.thirdPartyIdsArray()
      };
    }
  });

  return new UserModel({});

});

/**
 * @file Abstract class for device fingerprinting
 */
BV.define('framework/deviceFingerprinting/abstractDeviceFingerprint',[
  'jquery',
  'underscore',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'bv/strings'
], function abstractDeviceFingerprint (
  $,
  _,
  BVReporter,
  BVTracker,
  str
) {

  /**
   * AbstractDeviceFingerprint constuctor
   *
   * @param {Function?} scriptLoadedCallback - Callback to run when the script
   *   loads, whether it succeeds or fails. May be run multiple times.
   *
   * @constructor
   */
  function AbstractDeviceFingerprint (scriptLoadedCallback) {
    BVReporter.assert(
      this.constructor !== AbstractDeviceFingerprint,
      'AbstractDeviceFingerprint is an abstract class'
    );

    this.URL = ''; // will be updated with correct URL in base classes
    this.vendor = '';
    this.scriptLoaded = false;
    this.scriptLoadedCallbacks = $.Callbacks('unique');
    this.scriptLoadedCallbacks.add(scriptLoadedCallback || $.noop);
  }

  // --- Abstract Methods ---
  // These methods don't need to be touched by child classes.

  /**
   * A public endpoint to load the script for fingerprinting
   */
  AbstractDeviceFingerprint.prototype.loadScript = function loadScript () {
    var self = this;
    var scriptElement;

    // We've already loaded the script and don't need to try again.
    if (this.scriptLoaded) {
      this.scriptLoadedCallbacks.fire();
      return;
    }

    BVReporter.assert(
      _(this.URL).isString(),
      'Device Fingerprinting script must be a string'
    );

    BVReporter.assert(
      this.URL !== '',
      'Device Fingerprinting script URL not specified'
    );

    // Let's create a script element to load our script.
    scriptElement = document.createElement('script');
    scriptElement.type = 'text/javascript';
    scriptElement.src = this.URL;

    // Once we successfully load our script, set the flag & fire the callbacks
    // to let everyone know.
    scriptElement.onload = function loadScriptOnLoad () {
      self.scriptLoaded = true;
      self.scriptLoadedCallbacks.fire();
    };

    // Bind some error catching.
    scriptElement.onerror = function loadScriptOnError (err) {
      self.scriptLoadedCallbacks.fire(err);

      BVTracker.error({
        name: str.errors.THIRD_PARTY,
        detail1: 'Failed to fetch fingerprinting script',
        detail2: self.vendor
      });
    };

    // Now we try to load the script.
    document.getElementsByTagName('head')[0].appendChild(scriptElement);
  };

  /**
   * The action to take to prepare for loading the script.
   *
   * @purevirtual
   */
  AbstractDeviceFingerprint.prototype.setup =
  function setup ($form, callback) {
    throw new Error(
      'AbstractDeviceFingerPrint #setup is a pure virtual method.' +
      'It must be overriden.'
    );
  };

  /**
   * The action to take on a fingerprinting vendor _before_ submitting.
   *
   * @purevirtual
   */
  AbstractDeviceFingerprint.prototype.preSubmitAction =
  function preSubmitAction ($form, callback) {
    throw new Error(
      'AbstractDeviceFingerPrint #preSubmitAction is a pure virtual method.' +
      'It must be overriden.'
    );
  };

  /**
   * The action to take on a fingerprinting vendor _after_ submitting.
   *
   * @purevirtual
   */
  AbstractDeviceFingerprint.prototype.postSubmitAction =
  function postSubmitAction (submissionId, callback) {
    throw new Error(
      'AbstractDeviceFingerPrint #postSubmitAction is a pure virtual method.' +
      'It must be overriden.'
    );
  };

  return AbstractDeviceFingerprint;
});

/**
 * @file Class to handle ioVation device fingerprinting
 */
BV.define('framework/deviceFingerprinting/iovationDeviceFingerprint',[
  'jquery',
  'underscore',
  'framework/util/bvreporter',
  'framework/deviceFingerprinting/abstractDeviceFingerprint',
  'util/descendFrom',
  'window'
], function iovationDeviceFingerprint (
  $,
  _,
  BVReporter,
  AbstractDeviceFingerprint,
  descendFrom,
  window
) {

  // url to load the script from for figerprinting
  var IOVATION_SCRIPT_URL = 'https://mpsnare.iesnare.com/snare.js';

  // number of iterations of waiting for black box
  var MAX_ITERATIONS = 5;

  // time between requests to get black box
  var FINGERPRINT_REQUEST_INTERVAL = 100;

  /**
   * ioVation contstuctor
   *
   * @constructor
   * @extends {AbstractDeviceFingerprint}
   */
  function IovationDeviceFingerprint () {
    AbstractDeviceFingerprint.apply(this, arguments);

    // Set our URL and vendor name info here.
    this.URL = IOVATION_SCRIPT_URL;
    this.vendor = 'iovation';
  }
  descendFrom(AbstractDeviceFingerprint, IovationDeviceFingerprint);

  /**
   * Get ready to load the script.
   *
   * @override
   */
  IovationDeviceFingerprint.prototype.setup =
  function setup () {
    this._collectFingerprint();
  };

  /**
   * The action to take on a fingerprinting vendor _before_ submitting
   * For Iovation, this is most of the work. First, we need to collect the
   * fingerprint. We may already have it, in which case, we can just re-use
   * the same blackbox data. Or, we may have to fish it off the page. Lastly,
   * and likely the most common path, we may just have to load the script
   * ourselves to get the blackbox data.
   *
   * Once we have the data, we go ahead and stamp it into the fp field of the
   * form.
   *
   * @param {jQuery} $form - the form to stamp
   * @param {Function} callback - A callback function
   *
   * @override
   */
  IovationDeviceFingerprint.prototype.preSubmitAction =
  function preSubmitAction ($form, callback) {
    var $inputs;
    var bbDataPromise;

    // Normalize the callback.
    var myCallback = callback || $.noop;

    // If there is no form, just bail.
    if (!$form) {
      BVReporter.warn('No form given to IovationDeviceFingerprint #preSubmitAction');
      myCallback(new Error('No form provided to stamp'));
      return;
    }

    // Find the input to stamp.
    $inputs = $form.find(':input[name=fp]');

    // If there is no fp field, just bail.
    if ($inputs.size() === 0) {
      BVReporter.warn('Form given to IovationDeviceFingerprint #preSubmitAction has no fp field');
      myCallback(new Error('Provided form did not include fp field to stamp'));
      return;
    }

    // Collect the fingerprint or die trying.
    bbDataPromise = this._collectFingerprint();

    bbDataPromise.done(function bbDataSuccess (bbData) {
      // Now stamp that input and run the callback.
      $inputs.val(bbData);
      myCallback();
    });

    bbDataPromise.fail(function bbDataFail (err) {
      myCallback(err);
    });
  };

  /**
   * The action to take on a fingerprinting vendor _after_ submitting.
   * For Iovation, this is a no-op.
   * We've already stuffed our info into the submission form before sending
   * it off. This is because iovation doesn't require the submission ID.
   *
   * @param {String} submissionId - Doesn't matter for this class
   * @param {Function} callback - Callback function
   *
   * @override
   */
  IovationDeviceFingerprint.prototype.postSubmitAction =
  function postSubmitAction (submissionId, callback) {
    callback();
  };

  /**
   * A public endpoint used to get the blackbox information
   *
   * @param {Function} callback - callback function that accepts a fingerprint
   *
   * @override
   */
  IovationDeviceFingerprint.prototype._collectFingerprint =
  function _collectFingerprint () {
    // Create a new promise.
    var bbDataPromise = $.Deferred();

    // If we have collected the black box already, use it, then bail.
    if (this.blackboxData) {
      this.scriptLoadedCallbacks.fire();
      bbDataPromise.resolve(this.blackboxData);
    }

    // We don't already have the blackbox data, but iovation has already loaded
    // on the page. Let's try to call out for blackbox data. This is a
    // recursive call that will go ahead and take care of stuff for us. We can
    // return after this.
    else if (_.isFunction(window.ioGetBlackbox)) {
      this._getPreexistingBlackboxData(0, bbDataPromise);
    }

    // iovation hasn't already loaded, so let's get it ready and load it.
    else {
      this._getNewBlackboxData(bbDataPromise);
    }

    return bbDataPromise;
  };

  /**
   * A private function that attempts to get the blackbox information already
   * on the page. This executes in the event that someone else has already
   * loaded iovation for whatever reason, and we don't need to do it again.
   *
   * As currently configured, we will wait up to a maximum of ~600 ms.
   *
   * @param {Number} iterationCount - count of number of iterations that have
   *   surpassed; initial call to function should not contain this
   */
  IovationDeviceFingerprint.prototype._getPreexistingBlackboxData =
  function _getPreexistingBlackboxData (iterationCount, bbDataPromise) {
    var self = this;
    var state = window.ioGetBlackbox();

    // Collection is finished. Return it up the promise chain & bail.
    if (state.finished) {
      this.blackboxData = state.blackbox;
      this.scriptLoadedCallbacks.fire();
      bbDataPromise.resolve(this.blackboxData);
      return;
    }

    // We're giving up. Reject the promise.
    if (iterationCount > MAX_ITERATIONS) {
      bbDataPromise.reject(new Error('Could not collect blackbox data'));
      return;
    }

    // Recursively poll until we get the blackbox data.
    setTimeout(function recursiveCall () {
      self._getPreexistingBlackboxData(iterationCount + 1, bbDataPromise);
    }, FINGERPRINT_REQUEST_INTERVAL);
  };


  /**
   * A private function that attempts to get the blackbox information on our
   * own. This will load the script and make all the necessary calls to get
   * the blackbox data. This usually happens when no one else has loaded
   * iovation on the page.
   *
   * @param {Number} iterationCount - count of number of iterations that have
   *   surpassed; initial call to function should not contain this
   */
  IovationDeviceFingerprint.prototype._getNewBlackboxData =
  function _getNewBlackboxData (bbDataPromise) {
    /* eslint-disable camelcase */
    var self = this;

    // We want to add a callback for when the blackbox data loads, but we
    // don't want to wipe out any preexisting callbacks. So, let's have our
    // callback call the existing callback, if it exists.
    var previousCallback = window.io_bb_callback;

    // iovation hasn't been loaded yet. We need to go ahead and load it now.
    window.io_install_stm = false;
    window.io_exclude_stm = 12;
    window.io_install_flash = false;
    window.io_enable_rip = true;

    // Here's a fun one: if we want to completely disable Flash for Iovation,
    // a proper setting doesn't currently exist. For now, the best way to
    // accomplish this is to set the minimum required Flash version to some
    // high number. Flash is currently around 24 on most browsers, so 3000
    // should be good for a while.
    // See UIA-8205 for details.
    window.io_min_flash_version = 3000;

    window.io_bb_callback = function bvBBCallback (blackboxData, isComplete) {

      // If the collection is complete, store it in an internal variable so
      // we can re-use it later.
      if (isComplete) {
        self.blackboxData = blackboxData;
        window.io_bb_callback = undefined;
        bbDataPromise.resolve(blackboxData);
      }

      // If we couldn't get the blackbox data, reject.
      else {
        bbDataPromise.reject(new Error('Could not collect blackbox data'));
      }

      // If there was another callback already set, we need to go ahead and
      // run it now. The reason we run it in a setTimeout is because we don't
      // control that code, and we don't want to run it synchronously, lest we
      // get blocked on it. -Taylor
      if (previousCallback) {
        setTimeout(previousCallback.bind(window, blackboxData, isComplete), 0);
      }
    };

    // If there's an error loading the script, we need to fail the collection.
    this.scriptLoadedCallbacks.add(function iovationScriptLoadCallback (err) {
      // We need to remove this function from the callbacks to avoid
      // complications when attempting multiple times.
      self.scriptLoadedCallbacks.remove(iovationScriptLoadCallback);

      if (err) {
        bbDataPromise.reject(err);
      }
    });

    // We've set up all the iovation stuff, so go ahead and load the script.
    this.loadScript();
    /* eslint-enable camelcase */
  };

  return IovationDeviceFingerprint;
});

/**
 * @file Class to handle the Disabled Device Fingerprint
 */
BV.define('framework/deviceFingerprinting/disabledDeviceFingerprint',[
  'jquery',
  'framework/deviceFingerprinting/abstractDeviceFingerprint',
  'util/descendFrom'
], function disabledDeviceFingerprint (
  $,
  AbstractDeviceFingerprint,
  descendFrom
) {


  /**
   * Disabled Fingerprinting constructor
   *
   * @constructor
   * @extends {AbstractDeviceFingerprint}
   */
  function DisabledDeviceFingerprint () {
    AbstractDeviceFingerprint.apply(this, arguments);
    this.vendor = 'disabled';
    this.URL = 'disabled';

    // Just pretend we've already loaded the script.
    this.scriptLoaded = true;
    this.loadScript();
  }
  descendFrom(AbstractDeviceFingerprint, DisabledDeviceFingerprint);

  // We need to replace the pure virtual methods with dud methods.

  /**
   * Noop
   * @override
   */
  DisabledDeviceFingerprint.prototype.setup = function setup () {};

  /**
   * Just call the callback.
   *
   * @param {jQuery} $form - Doesn't matter for this class
   * @param {Function} callback - Callback function
   * @override
   */
  DisabledDeviceFingerprint.prototype.preSubmitAction =
  function preSubmitAction ($form, callback) {
    var myCallback = callback || $.noop;
    myCallback();
  };

  /**
   * Just call the callback.
   *
   * @param {String} submissionId - Doesn't matter for this class
   * @param {Function} callback - Callback function
   * @override
   */
  DisabledDeviceFingerprint.prototype.postSubmitAction =
  function postSubmitAction (submissionId, callback) {
    var myCallback = callback || $.noop;
    myCallback();
  };

  return DisabledDeviceFingerprint;
});

/**
 * @file Class to handle InAuth device fingerprinting
 */
BV.define('framework/deviceFingerprinting/inAuthDeviceFingerprint',[
  'jquery',
  'underscore',
  'framework/util/bvreporter',
  'framework/deviceFingerprinting/abstractDeviceFingerprint',
  'util/descendFrom',
  'document',
  'window'
], function inAuthDeviceFingerprint (
  $,
  _,
  BVReporter,
  AbstractDeviceFingerprint,
  descendFrom,
  document,
  window
) {

  // Let's build us some URLs !!
  // Please note that these are the European server URLs.
  //
  // We're building the collector url as separate chunks because we'll need
  // different parts of the URL throughout different parts of this process.
  var inAuthCollectorDomain = 'https://uk.cdn-net.com';
  var inAuthCollectorScript = inAuthCollectorDomain + '/cc.js';

  // NOTE: to verify, we need to use the verification URL. This URL looks like
  // this:
  // <host>/v1/device-info?apiKey=<apiKey>&transactionId=<submissionId>

  // The API key is encrypted in our secrets.x file, and is NOT the same as
  // the Collector Key. Yes, we have two separate keys for this vendor. The
  // collector key is public facing and is exposed on the PDP. The API key is
  // internal and is used for collecting data from the vendor. This here is
  // the collector key.
  var inAuthCollectorKey = '54b684cc-4b18-4193-be5f-9548d46cabaa';

  // InAuth uses the old school system of using an int as a series of option
  // bits. Basically, you pick the options you want, add them all up, and they
  // can look at each bit of the number to determine which options are enabled.
  // This is the magic number we want. See the doc linked in UIA-8205 for
  // details.
  // Currently, this includes most of the detection options except for:
  //
  // * Geolocation (don't want to pop up a dialog)
  // * Any method that requires Flash (mobile, etc.)
  // * The "CSS Fonts" option (the detection locked up IE for at least a few
  //   seconds)
  // * The "manual submission" option (payload is automatically submitted)
  //
  var myCFValue = 1022707;

  /**
   * InAuth contstructor
   *
   * @constructor
   * @extends {AbstractDeviceFingerprint}
   */
  function InAuthDeviceFingerprint () {
    var timeStamp;
    var url;

    AbstractDeviceFingerprint.apply(this, arguments);

    // We'll need a timestamp for the url.
    timeStamp = new Date().getTime();

    // Now let's put this URL together.
    url = inAuthCollectorScript + '?ts=' + timeStamp;

    this.vendor = 'inauth';
    this.URL = url;
  }
  descendFrom(AbstractDeviceFingerprint, InAuthDeviceFingerprint);

  /**
   * Setup the script and load it.
   */
  InAuthDeviceFingerprint.prototype.setup =
  function setup () {
    this._queuePreSubmitCommands();
    this.loadScript();
  };

  /**
   * The action to take on a fingerprinting vendor _before_ submitting.
   *
   * @param {jQuery} $root - The form to stamp
   * @param {Function} callback - Standard callback function
   *
   * @purevirtual
   */
  InAuthDeviceFingerprint.prototype.preSubmitAction =
  function preSubmitAction ($root, callback) {
    var self = this;
    var myCallback = callback || $.noop;

    // InAuth just needs to make sure that the fp field is empty, so we don't
    // actually need the script to load before 'stamping'.
    this._stamp($root);

    this.scriptLoadedCallbacks.add(function inAuthScriptLoadCallback (err) {
      // We need to remove this from the callbacks to avoid complications when
      // attempting multiple times.
      self.scriptLoadedCallbacks.remove(inAuthScriptLoadCallback);
      myCallback(err);
    });

    // Attempt to reload the script
    this.loadScript();
  };

  /**
   * Stamp the fp field with an empty string.
   * @param {jQuery} $root - The form to stamp
   */
  InAuthDeviceFingerprint.prototype._stamp =
  function _stamp ($root) {
    var $inputs;

    // If there is no form, just bail.
    if (!$root) {
      BVReporter.warn('No form given to InAuthDeviceFingerprint #preSubmitAction');
      return;
    }

    $inputs = $root.find(':input[name=fp]');

    // If there is no fp field, just bail.
    if ($inputs.size() === 0) {
      BVReporter.warn('Form given to InAuthDeviceFingerprint #preSubmitAction has no fp field');
      return;
    }

    // We make sure the fp field is blank.
    $inputs.val('');
  };

  /**
   * Queue up commands into the global _cc object. Before submission, we want
   * to queue up everything except the callback and the submission ID. We'll
   * want to wait until after submission to do that.
   *
   * @param {String} submissionId - The unique id for the submission
   */
  InAuthDeviceFingerprint.prototype._queuePreSubmitCommands =
  function _queuePreSubmitCommands () {


    // InAuth requires the use of a global.
    // We need to go ahead and set up that global.
    window._cc = [];

    window._cc.push(['ci', {
      sid: inAuthCollectorKey
    }]);

    // You might be wondering "Hey, Taylor, what are these magic numbers?".
    // Well, these magic numbers come from a magical implementation doc. If
    // you'd like to read more about it, read up on the ticket VOL-438.
    window._cc.push(['st', 1000]);
    window._cc.push(['cf', myCFValue]);

    // This tells the collector script to run.
    window._cc.push(['run', inAuthCollectorDomain]);
  };

  /**
   * The action to take on a fingerprinting vendor _after_ submitting.
   * For InAuth, this is the bulk of the work. We need to set a few things
   * up for InAuth, using the submission ID as a key. Then we load the script.
   * Once the InAuth callback runs, we'll run our own callback.
   *
   * @param {String} submissionId - Submission ID, which will be used as
   *   a unique identifier for this fingerprint data.
   *
   * @param {Function} callback - Callback function
   *
   * @purevirtual
   */
  InAuthDeviceFingerprint.prototype.postSubmitAction =
  function postSubmitAction (submissionId, callback) {
    var myCallback = callback || $.noop;
    this._queuePostSubmitCommands(submissionId, myCallback);
  };

  /**
   * Queue up commands into the global _cc object. Here, we need to queue up
   * our submission ID and the callback function.
   *
   * @param {String} submissionId - The unique id for the submission
   */
  InAuthDeviceFingerprint.prototype._queuePostSubmitCommands =
  function _queuePostSubmitCommands (submissionId, callback) {

    window._cc.push(['ci', {
      tid: submissionId
    }]);

    // Add a callback function.
    window._cc.push(['csd', callback]);
  };

  return InAuthDeviceFingerprint;
});

/**
 * @file Returns a fingerprinting vendor class
 */

BV.define('util/deviceFingerprint',[
  'ENV',
  'underscore',
  'jquery',
  'framework/util/bvreporter',
  'framework/deviceFingerprinting/iovationDeviceFingerprint',
  'framework/deviceFingerprinting/disabledDeviceFingerprint',
  'framework/deviceFingerprinting/inAuthDeviceFingerprint'
], function DeviceFingerprint (
  ENV,
  _,
  $,
  BVReporter,
  IovationDeviceFingerprint,
  DisabledDeviceFingerprint,
  InAuthDeviceFingerprint
) {


  /**
   * Initial setup of Fingerprint class. Determines which vendor/class to use and loads the script
   * NOTE: this function must be called before use of Fingerprint as such: Fingerprint();
   *
   * @return {Object} Fingerprint - the class to use for device fingerprinting
   */
  function FingerprintGenerator (callback) {

    var fingerprint;
    var ENVConfig = ENV.get('config');
    var fingerprintingEnabled = ENVConfig.fingerprintingEnabled;
    var trackingDataRegion = ENVConfig.trackingDataRegion;

    // If fingerprinting is disabled, return a blank class that won't do
    // any fingerprinting.
    if (!fingerprintingEnabled) {
      fingerprint = new DisabledDeviceFingerprint(callback);
    }

    // If configured for the US specifically or if the setting is left on the
    // default 'undecided', we want to use the US-based Iovation
    // fingerprinting vendor.
    else if (
      trackingDataRegion === 'undecided' ||
      trackingDataRegion === 'unitedStates'
    ) {
      fingerprint = new IovationDeviceFingerprint(callback);
    }

    // If configured for Europe, we need to use the Ireland-based InAuth
    // fingerprinting vendor. See PM-538 for details.
    else if (trackingDataRegion === 'europe') {
      fingerprint = new InAuthDeviceFingerprint(callback);
    }

    else {
      // If we reach this point, it means the client config was somehow
      // broken or we haven't implemented a new tracking data region. Either
      // way, we should throw an error here so we're not running around
      // confused.
      BVReporter.warn('Unable to determine which fingerprinting vendor to load.');
      fingerprint = new DisabledDeviceFingerprint(callback);
    }

    return fingerprint;
  }

  return FingerprintGenerator;
});

BV.define('dimsumFields!fieldIdMap',[], {"CustomerService":{"prefix":"rating_CustomerService"},"TestSlider":{"prefix":"rating_TestSlider"},"Slider7":{"prefix":"rating_Slider7"},"anotherTestSlider3":{"prefix":"rating_anotherTestSlider3"},"TestDropdown":{"prefix":"contextdatavalue_TestDropdown"},"TestText":{"prefix":"additionalfield_TestText"},"BestUsesTelecom":{"prefix":"tag_BestUsesTelecom"}});

BV.define('dimsumFields!agreements',[], {"reviews":{"termsAndConditions":{"userDefined":false,"name":"Terms & Conditions","id":"termsAndConditions","enabled":true,"displayType":"HOSTED","submissionTitle":"Do you agree?","agreementTitle":"Terms and Conditions","hostedText":"<p>\n\t<strong>CUSTOMER RATINGS AND REVIEWS TERMS OF USE</strong></p>\n<div>\n\tThese Terms of Use govern your conduct associated with the Customer Ratings and Review service offered by <strong>[ABC Company]</strong> (the \"CRR Service\"). To the extent of any conflict between <strong>[ABC Company's]</strong> Privacy Policy and these Terms of Use, these Terms of Use shall control with respect to the CRR Service.</div>\n<div>\n\t&nbsp;</div>\n<div>\n\tBy submitting any content to <strong>[ABC Company]</strong>, you represent and warrant that:</div>\n<ul>\n\t<li>\n\t\tYou are the sole author and owner of the intellectual property rights thereto;</li>\n\t<li>\n\t\tAll \"moral rights\" that you may have in such content have been voluntarily waived by you;</li>\n\t<li>\n\t\tAll content that you post is accurate;</li>\n\t<li>\n\t\tYou are at least <strong>[xx]</strong> years old;</li>\n\t<li>\n\t\tUse of the content you supply does not violate these Terms of Use and will not cause injury to any person or entity.</li>\n</ul>\n<div>\n\tYou further agree and warrant that you shall not submit any content:</div>\n<ul>\n\t<li>\n\t\tThat is known by you to be false, inaccurate or misleading;</li>\n\t<li>\n\t\tThat infringes any third party's copyright, patent, trademark, trade secret or other proprietary rights or rights of publicity or privacy;</li>\n\t<li>\n\t\tThat violates any law, statute, ordinance or regulation (including, but not limited to, those governing export control, consumer protection, unfair competition, anti-discrimination or false advertising);</li>\n\t<li>\n\t\tThat is, or may reasonably be considered to be, defamatory, libelous, hateful, racially or religiously biased or offensive, unlawfully threatening or unlawfully harassing to any individual, partnership or corporation;</li>\n\t<li>\n\t\tFor which you were compensated or granted any consideration by any third party;</li>\n\t<li>\n\t\tThat includes any information that references other websites, addresses, email addresses,&nbsp;contact information or phone numbers;</li>\n\t<li>\n\t\tThat contains any computer viruses, worms or other potentially damaging computer programs or files.</li>\n</ul>\n<div>\n\tYou agree to indemnify and hold <strong>[ABC Company]</strong> (and its officers, directors, agents, subsidiaries, joint ventures, employees and third-party service providers, including but not limited to Bazaarvoice, Inc.), harmless from all claims, demands, and damages (actual and consequential) of every kind and nature, known and unknown including reasonable attorneys' fees, arising out of a breach of your representations and warranties set forth above, or your violation of any law or the rights of a third party.</div>\n<div>\n\t&nbsp;</div>\n<div>\n\tFor any content that you submit, you grant <strong>ABC Company</strong> a perpetual, irrevocable, royalty-free, transferable right and license to use, copy, modify, delete in its entirety, adapt, publish, translate, create derivative works from and/or sell and/or distribute such content and/or incorporate such content into any form, medium or technology throughout the world without compensation to you.</div>\n<div>\n\t&nbsp;</div>\n<div>\n\tAll content that you submit may be used at <strong>[ABC Company's]</strong> sole discretion. <strong>[ABC Company]</strong> reserves the right to change, condense or delete any content on <strong>[ABC Company's]</strong> website that <strong>[ABC Company]</strong> deems, in its sole discretion, to violate the content guidelines or any other provision of these Terms of Use. <strong>[ABC Company]</strong> does not guarantee that you will have any recourse through <strong>[ABC Company]</strong> to edit or delete any content you have submitted. Ratings and written comments are generally posted within two to four business days. However, <strong>[ABC Company]</strong> reserves the right to remove or to refuse to post any submission for any reason. You acknowledge that you, not <strong>[ABC Company]</strong>, are responsible for the contents of your submission. None of the content that you submit shall be subject to any obligation of confidence on the part of <strong>[ABC Company]</strong>, its agents, subsidiaries, affiliates, partners or third party service providers and their respective directors, officers and employees.</div>\n<div>\n\t&nbsp;</div>\n<div>\n\tBy submitting your email address in connection with your rating and review, you agree that <strong>[ABC Company]</strong> and its third party service providers may use your email address to contact you about the status of your review and other administrative purposes.</div>","remoteUrl":"https://www.yslbeautyus.com/terms.html","required":true}},"questions":{"termsAndConditions":{"userDefined":false,"name":"Terms & Conditions","id":"termsAndConditions","enabled":true,"displayType":"HOSTED","submissionTitle":"I agree to the <a href=\"#\" class=\"bv-text-link bv-focusable\">terms &amp; conditions</a>","agreementTitle":"Terms and Conditions","hostedText":"<span><strong>Introduction.&nbsp; </strong>Thank you for submitting UGC (as defined below) through the Bazaarvoice, Inc. (“we”, “our” or “Bazaarvoice”) services. &nbsp;The UGC submitted by consumers such as yourself is helpful to many parties including other consumers, retailers and manufacturers.&nbsp; You probably already know UGC is heavily relied-upon by consumers that are considering purchases.&nbsp; What you may not know is that UGC is also used by product retailers and manufacturers for many other purposes, including product development and improvement, making decisions on which products to stock and marketing.&nbsp; By submitting content you are helping improve both the shopping experience and the product and service quality for the entire market.&nbsp; Bazaarvoice would like to be the first to thank you for your contribution!</span>We have found that there are a number of common questions that consumers have about the submission process.&nbsp; We have tried to answer those questions as thoroughly as possible, below. Please review these questions and explanations because they control your submission of UGC.&nbsp; If you’ve read the below and still have questions or would like further explanation you can contact our Privacy Team at privacy@bazaarvoice.com, and they will get back to you as soon as possible.<span><strong>What do Bazaarvoice and its clients need to use the UGC:</strong> In order to use the UGC as described in these terms, Bazaarvoice needs a license to use the UGC.&nbsp; Accordingly, you hereby grant Bazaarvoice, Bazaarvoice’s clients and each of their sublicensees and affiliates a perpetual, unlimited, nonexclusive, fully sublicenseable, irrevocable, worldwide right and license to use, reproduce, modify, adapt, publish, translate, create derivative works from, distribute, and display such content throughout the world in any media. You further grant Bazaarvoice, Bazaarvoice’s clients and each of their and sublicensees and affiliates the right to use the name and likeness that you submit in connection with such content.</span><span><strong>What you may post</strong>: Depending on the Bazaarvoice service, you may post reviews, comments, photos, questions and other user-generated content (collectively “UGC”).</span><span><strong>What you may not post:</strong> You may not post any UGC that is illegal, obscene, threatening, defamatory, infringes the intellectual property rights of any party, contains software viruses, commercial solicitation, chain letters, mass mailings or any form of spam.&nbsp; Additionally, you may not use a false e-mail address, impersonate any person or entity, or otherwise mislead as to the origin of any UGC.&nbsp; Bazaarvoice reserves the right, but not the obligation, to remove any UGC from a website on the Bazaarvoice network for any reason or no reason.</span><span><strong>What happens to UGC that you submit:</strong>&nbsp; Any UGC you submit may be used for other advertising purposes and posted to publicly-facing websites, including other websites across the Internet on the Bazaarvoice network in addition to the website that you originally submitted the UGC. Accordingly, please do not post anything that you do not want to share with the general public (for example, financial information, social security number, etc.).&nbsp; In addition, as mentioned in the introduction, the UGC that you submit may be used for advertising, analytic and other statistical purposes including, for example, product improvement, benchmarking (e.g. where various products/services or categories of products/services are compared against each other or against the market as a whole), sentiment analysis (e.g. using the data from multiple reviews it is possible to determine how consumers as a whole feel about a product/service), and online behavioral advertising.</span><span><strong>What you are promising by submitting UGC:</strong>&nbsp; By submitting UGC you represent and warrant that: (i) you are the sole owner of the UGC; (ii) the UGC is accurate; (iii) you are at least thirteen (13) years old; and, (iv) the UGC you submit does not violate these Terms of Use.&nbsp; Because you are solely responsible for what you post, you also agree to indemnify Bazaarvoice and Bazaarvoice’s clients for a breach of your representations and warranties.&nbsp;</span><span><strong>Where you can find additional information on Bazaarvoice’s use of the UGC:</strong>&nbsp; Bazaarvoice’s use of any UGC you submit is subject to Bazaarvoice’s Privacy Policy, which can be found at <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.bazaarvoice.com/privacy-policy\">http://www.bazaarvoice.com/privacy-policy</a>.</span><span><strong>What happens if there is a dispute:</strong>&nbsp; You agree that all disputes between you and Bazaarvoice (whether or not such dispute involves a third party) with regard to your relationship with Bazaarvoice, including without limitation disputes related to these Terms of Use, your use of this Site, and/or rights of privacy and/or publicity, will be resolved by binding, individual arbitration under the American Arbitration Association's rules for arbitration of consumer-related disputes and you and Bazaarvoice hereby expressly waive trial by jury. As an alternative, you may bring your claim in your local \"small claims\" court, if permitted by that small claims court's rules. You may bring claims only on your own behalf. Neither you nor Bazaarvoice will participate in a class action or class-wide arbitration for any claims covered by this agreement. You also agree not to participate in claims brought in a private attorney general or representative capacity, or consolidated claims involving another person's account, if Bazaarvoice is a party to the proceeding. This dispute resolution provision will be governed by the Federal Arbitration Act. In the event the American Arbitration Association is unwilling or unable to set a hearing date within one hundred and sixty (160) days of filing the case, then either Bazaarvoice or you can elect to have the arbitration administered instead by the Judicial Arbitration and Mediation Services. Judgment on the award rendered by the arbitrator may be entered in any court having competent jurisdiction. Any provision of applicable law notwithstanding, the arbitrator will not have authority to award damages, remedies or awards that conflict with these Terms of Use.</span>You may opt out of this agreement to arbitrate. If you do so, neither you nor Bazaarvoice can require the other to participate in an arbitration proceeding. To opt out, you must notify Bazaarvoice in writing within 30 days of the date that you first became subject to this arbitration provision. You must use this address to opt out:Bazaarvoice, Inc.ATTN: Legal - Arbitration Opt Out3900 N. Capital of Texas Hwy, Suite 300Austin, Texas 78746privacy@bazaarvoice.com","remoteUrl":"","required":true}}});

BV.define('bv/util/sanitize',{
	// Used to sanitize a subjectID like a product ID. Since clients
	// can define product IDs they can contain all characters including
	// special characters like spaces or periods that can give us problems
	// when we go to use subjectIDs in the DOM.
	                    subjectId: function (id) {

		// replace all non-alphanumer characters with _
		                    return id ? id.replace(/\W/g, '_') : '';
	}
});

BV.define('bv/ugc/auth',[
  'backbone',
  'underscore'
], function (Backbone, _) {

  var Auth = {
    error: function (error) {
      this.trigger('error', error);
    }
  };

  _(Auth).extend(Backbone.Events);

  return Auth;
});

/**
 * @fileOverview Backbone data model that powers Submissions
 */

// Some of the submission fields use not-camelcase for historical reasons.
/* eslint-disable camelcase */

BV.define('bv/c2013/model/submission',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'jquery',
  'bv/api/fetch',
  'window',
  'vendor/json2',
  'bv/util/user',
  'bv/util/domainPolice',
  'bv/util/userToken',
  'bv/strings',
  'util/url',
  'util/deviceFingerprint',
  'dimsumFields!fieldCategories',
  'dimsumFields!fields',
  'dimsumFields!fieldIdMap',
  'dimsumFields!agreements',
  'framework/util/bvtracker',
  'framework/util/bvreporter',
  'bv/util/sanitize',
  'bv/ugc/auth'
], function SubmissionModel (
  ENV,
  BModel,
  _,
  $,
  api,
  window,
  JSON,
  User,
  DomainPolice,
  UserToken,
  str,
  Url,
  Fingerprint,
  fieldCategories,
  dimsumFields,
  fieldIdMap,
  agreements,
  BVTracker,
  BVReporter,
  sanitize,
  Auth,
  bvStrings
) {
  var ENVConfig = ENV.get('config');

  var commonFields = {
    useremail: true,
    usernickname: true,
    userlocation: true,
    hostedauthentication_authenticationemail: true,
    agreements: true
  };

  var reviewFields = _.extend({}, commonFields, {
    rating: true,
    title: true,
    reviewtext: true,
    isrecommended: true,
    netpromoterscore: true,
    netpromotercomment: true,
    // these are the fields we currently support
    // if the api returns a required field that isn't here, no submission will work :(
    wildcards: [
      '^contextdatavalue.*',
      '^rating.*',
      '^photourl_.*',
      'photocaption_.*',
      'videourl_.*',
      'videocaption_.*',
      '^additionalfield_.*',
      '^tagid_.*'
    ]
  });

  var commentFields = _.extend({}, commonFields, {
    commenttext: true
  });

  var questionFields = _.extend({}, commonFields, {
    questionsummary: true
  });

  var answerFields = _.extend({}, commonFields, {
    answertext: true
  });

  var submissionFields = {
    review: reviewFields,
    comment: commentFields,
    question: questionFields,
    answer: answerFields
  };

  // Fields the client should NOT be able to prefill for end users
  var injectionBlacklistFields = {
    rating: true,
    title: true,
    reviewtext: true,
    isrecommended: true,
    agreedtotermsandconditions: true,
    agreements: true,
    netpromoterscore: true,
    commenttext: true,
    questionsummary: true,
    answertext: true
  };

  return BModel.extend({
    name: 'submission',

    init: function init (config) {
      var myFieldCategories;
      var injectedString;
      var injectedDataFromUrl;
      var fingerprint;
      var fingerprintDeferred;
      var self = this;
      var clientAPIConfig = config.clientAPIConfig || this.get('clientAPIConfig') || {};
      var subjectType = api.noun(clientAPIConfig.subjectType || config.subjectType);
      var contentType = api.noun(clientAPIConfig.contentType || config.contentType);

      // Handle fieldCategory stuff without modifying the global reference.
      // We need to protect against either the map or order being undefined.
      myFieldCategories = _({}).extend(fieldCategories, {
        fieldCategoryMap: fieldCategories.fieldCategoryMap || {},
        fieldCategoryOrder: fieldCategories.fieldCategoryOrder || []
      });

      // Get the pre-filled data from the query
      // The client is responsible for setting up the query correctly
      injectedString = Url.getParam(window.location.href, 'bvinjecteddata');
      injectedDataFromUrl = JSON.parse(injectedString);

      // Remove blacklisted fields from injectedDataFromUrl
      _(injectedDataFromUrl).forEach(function forEachInjectedData (value, fieldName) {
        // We're getting both halves this way because we only want to split on
        // the first _, not all of them.
        var indexToSplit = fieldName.indexOf('_');
        var fieldType = fieldName.substr(0, indexToSplit);
        var fieldShortName = fieldName.substr(indexToSplit + 1);

        // Check if we're blacklisting the full name, short name, or type (rating)
        var blacklisted = injectionBlacklistFields[fieldName] ||
          injectionBlacklistFields[fieldType] ||
          injectionBlacklistFields[fieldShortName];

        if (blacklisted) {
          injectedDataFromUrl[fieldName] = null;
        }
      });

      fingerprintDeferred = $.Deferred();
      fingerprint = Fingerprint(function fingerprintScriptLoaded (err) {
        self.set('fingerprintScriptError', !!err);
        fingerprintDeferred.resolve();
      });

      self.set({
        subjectType: subjectType,
        clientAPIConfig: clientAPIConfig,
        subjectId: clientAPIConfig[subjectType + 'Id'],
        contentType: contentType,
        submitSchema: null,
        fieldCategories: myFieldCategories,
        dimsumFields: dimsumFields,
        agreements: agreements,
        photos: [],
        videos: [],
        Author: User.getAuthor(),
        injectedDataFromUrl: injectedDataFromUrl,
        postCallback: str.rpc.postCallback,
        isGenericSubmission: clientAPIConfig.isGenericSubmission,
        bvNotificationId: Url.getParam(window.location.href, 'bvnotificationId') || Url.getBvParam(window.location.href, 'notificationId'),
        bvMessageType: Url.getParam(window.location.href, 'bvmessageType') || Url.getBvParam(window.location.href, 'messageType'),
        bvRecipientDomain: Url.getParam(window.location.href, 'bvrecipientDomain') || Url.getBvParam(window.location.href, 'recipientDomain'),
        bvQuestionId: Url.getParam(window.location.href, 'bvquestionId') || Url.getBvParam(window.location.href, 'questionId'),
        campaignId: clientAPIConfig.campaignId,
        fingerprint: fingerprint,
        fingerprintDeferred: fingerprintDeferred
      });

      self.off('load').on('load', self.loadTrigger, self);
      self.off('queryError').on('queryError', Auth.error, Auth);

      // We can get in trouble if we cache a submission schema for a specific
      // user too aggressively. Disabling this for now.
      // wait 4s then fetch/cache submission schema
      // self.cacheTimeout = _.delay(function () {
      //   try {
      //     if (!BV._internal.nopreload && self.get('preload')) {
      //       self.fetchSubmitSchema();
      //     }
      //   } catch (e) {}
      // }, 4000);
    },

    setupDataProcessing: function setupDataProcessing () {},

    // return an object that $.validator can use directly
    _validationRules: function _validationRules () {
      var rules = {};
      var self = this;
      var contentType = self.get('contentType');
      var agrType;
      var agreementRule;
      var fieldRule = function fieldRule (field, name) {
        var selector = '[name="' + name + '"]';
        rules[selector] = field.validation;
      };

      agrType = api.nouns(contentType);

      agreementRule = function agreementRules (field, name) {
        var selector;
        if (agrType === 'answers') {
          agrType = 'questions';
        }
        selector = '[name="agreements_' + agrType + '_' + name + '"]';
        rules[selector] = {
          required: field.required
        };
      };

      _(this.get('formFields')).forEach(fieldRule);

      if (agrType !== 'answers') {
        _(this.get('agreements')[agrType]).forEach(agreementRule);
      }
      else {
        _(this.get('agreements').questions).forEach(agreementRule);
      }

      _(this.get('specialFields')).forEach(function forEachSpecialField (type, key) {
        _(type.formFields).forEach(fieldRule);
      });

      return { rules: rules };
    },

    /**
     * This processes all of the field data passed to it and sets the
     * results to the model.
     *
     * @param  {Object} fields The fields to process.
     *
     * @param  {Object} fieldGroups The field groups ? Used for tags.
     *
     * @param  {Array} myFieldOrder So named to avoid confusion with
     *   fieldOrder above. This is a list of strings that define the order in
     *   which to inject the fields.
     */
    _processFields: function _processFields (fields, fieldGroups, myFieldOrder) {
      var self = this;
      var verifiedPurchaser;
      var supportedFields = submissionFields[self.get('contentType')];
      var specialFields = {};
      var fieldTypeCategoryMap = {
        contextdatavalue: 'default',
        additionalfield: 'default',
        tagid: 'default',
        rating: 'ratings'
      };
      var myFormFields = self.get('formFields') || {};
      var myFieldCategoryMap = self.get('fieldCategories').fieldCategoryMap;
      var myDimsumFields = self.get('dimsumFields');

      var injectedDataFromToken = self.get('injectedDataFromToken');
      var injectedDataFromUrl = self.get('injectedDataFromUrl');
      var injectedDataFromRejectedReview = self.get('injectedDataFromRejectedReview');

      var allInjectedData = _.extend(
        {},
        injectedDataFromRejectedReview,
        injectedDataFromUrl,
        injectedDataFromToken
      );

      // Inject data that is not in the token. Data from the token is already part of the data
      // from the API.
      var fieldsToInject = _.omit(allInjectedData, _(injectedDataFromToken).keys());

      _(fields).forEach(function forEachField (field, fieldName) {
        var fieldToSave;
        var sliderOptions;
        var sliderDimsumField;
        var fieldCategory = myFieldCategoryMap[fieldName];
        var fieldType = fieldName.substr(0, fieldName.indexOf('_'));
        var fieldShortName = fieldName.substr(fieldName.indexOf('_') + 1);
        var myDimsumField = myDimsumFields[fieldType] || {};
        var tagData;
        var tagGroupShortName;
        var tagGroup;
        var tagGroupName;
        var tagIndex;
        var isTag = fieldType === 'tagid';

        var isHideOnSubmission = myDimsumField[fieldShortName] &&
          myDimsumField[fieldShortName].hideOnSubmission;

        // Tolerate both category_id and id
        var injectedValue = fieldsToInject[fieldName] || fieldsToInject[fieldShortName];

        if (isTag) {
          tagData = fieldName.substr(fieldName.indexOf('_') + 1).split('/');
          tagGroupShortName = tagData[0];
          tagGroupName = 'tag_' + tagGroupShortName;
          fieldCategory = myFieldCategoryMap[tagGroupName];
          // CCS-2743: Hide on submission is not communicated through either
          // API so we need to pull it off the dimsum config. The property is
          // actually tied to the taggroup and not the individual tag so we
          // need to index the dimsumFields with the tagGroupShortName prefix.
          // In the event of a broken config we will default to false, ie, we
          // will not hide on submission.
          isHideOnSubmission = myDimsumFields.tag[tagGroupShortName] &&
            myDimsumFields.tag[tagGroupShortName].hideOnSubmission;
        }

        // If there isn't a category map throw special fields into the 'default' category
        if (!_(myFieldCategoryMap).size()) {
          fieldCategory = fieldTypeCategoryMap[fieldType];
        }

        // See if we have a direct match with a supported field.
        if (_(supportedFields).has(fieldName)) {
          fieldToSave = self.calculateRules(fieldName, isHideOnSubmission);
        }
        // See if we have any wildcard matches.
        else if (_(supportedFields).has('wildcards')) {
          _(supportedFields.wildcards).forEach(function forEachWildcard (wildcard) {
            if (fieldName.match(wildcard)) {
              fieldToSave = self.calculateRules(fieldName, isHideOnSubmission, wildcard);
            }
          });
        }

        // UIA-2203 Read default values from injectedDataFromUrl
        if (injectedValue && fieldToSave) {
          // Since we're adding this field now, no need to inject it
          // as a hidden field later, so remove it from the list
          fieldsToInject = _.omit(fieldsToInject, [fieldName, fieldShortName]);

          // Set the field with the injected value.
          if (fieldToSave.schema.Type === 'SelectInput' && !isHideOnSubmission) {
            _(fieldToSave.schema.Options).forEach(function forEachOption (option) {
              option.Selected = option.Value === injectedValue;
            });
          }
          else {
            fieldToSave.schema.Value = injectedValue;
          }
        }

        if (fieldToSave && fieldCategory) {

          specialFields[fieldCategory] = specialFields[fieldCategory] || { formFields: {} };

          if (isTag) {
            // Create a tag group to contain this tag if one doesn't already exist
            tagGroup = specialFields[fieldCategory].formFields[tagGroupName] || {
              schema: { Type: 'TagGroup' },
              label: fieldGroups[tagGroupName].Label,
              hidden: isHideOnSubmission,
              id: fieldGroups[tagGroupName].Id,
              type: fieldGroups[tagGroupName].Type,
              tags: []
            };

            _(fieldGroups[tagGroupName + '_id'].SubElements)
              .forEach(function forEachSubElement (tag, index) {
                if (tag.Id === fieldName) {
                  tagIndex = index;
                }
              });

            tagGroup.tags[tagIndex] = _(fieldToSave).extend({
              tagIndex: tagIndex,
              parentSchemaId: tagGroup.id
            });

            specialFields[fieldCategory].formFields[tagGroupName] = tagGroup;
          }
          else {
            if (fieldType === 'rating') {
              // TODO why are we even using this pragma ? If this code isn't
              // ready for prod, shouldn't we just remove it ? It's not like
              // we're planning to add crazy new features to Submission any
              // time soon. -Taylor
              
              // Pass dimsum configured values to slider field.
              if (myDimsumField[fieldShortName]) {
                fieldToSave.dimsumField = myDimsumField[fieldShortName];
                if (fieldToSave.dimsumField.type === 'SLIDER') {
                  fieldToSave.range[1] = fieldToSave.dimsumField.sliderSize;
                }
              }
            }
            // I wasn't really sure of the best way to format this. I did
            // something that looked the least terrible to me. This does not,
            // however, mean that I like this pattern. If anyone has a better
            // solution, feel free. -Taylor
            else if (
              fieldType === 'contextdatavalue' &&
              !(allInjectedData[fieldName] ||
                allInjectedData[fieldShortName]
              )
            ) {
              // Makes non data-injected fields respect the autoPopulate
              // setting. Even though autoPopulate is set to false in Config
              // Hub, the API still sets the previously submitted option as
              // "Selected = true". When autoPopulate is false, the code below
              // forces autoPopulate to be off by only selecting the first
              // option which usually is the "Select" option.
              if (
                myDimsumField[fieldShortName] &&
                myDimsumField[fieldShortName].autoPopulate === false &&
                fieldToSave.schema.Options
              ) {

                // Set the first option as selected if it has no label while
                // setting the rest of the options as unselected. Options with
                // no labels are the ones that say "Select".
                fieldToSave.schema.Options = _.map(fieldToSave.schema.Options,
                  function mapOptions (option, i) {
                    option.Selected = i === 0 && !option.Label;

                    return option;
                  }
                );

                // The Value property does not determine which value is
                // selected, but set to null just in case.
                fieldToSave.schema.Value = null;
              }
            }

            specialFields[fieldCategory].formFields[fieldName] = fieldToSave;
          }
        }
        else if (fieldToSave) {
          myFormFields[fieldName] = fieldToSave;
        }
      });

      this._appendAsHiddenFields(fieldsToInject, specialFields, myFieldOrder);
      this._createOrderedFormFields(specialFields, myFieldOrder);

      verifiedPurchaser = fields.contextdatavalue_VerifiedPurchaser || {};
      self.set({
        formFields: myFormFields,
        specialFields: specialFields,
        hostedAuth: _(fields).has('hostedauthentication_authenticationemail'),
        verifiedPurchaser: verifiedPurchaser.Value === 'true'
      });

      // the emailField field is calculated based on hostedAuth and useremail
      if (myFormFields.hostedauthentication_authenticationemail || myFormFields.useremail) {
        myFormFields.emailField = myFormFields.hostedauthentication_authenticationemail ||
          myFormFields.useremail;

        myFormFields.emailField.schema.Value = myFormFields.emailField.schema.Value ||
          User.get('email');
      }
    },

    /**
     * When injected fields aren't already on the form, we need to append them
     * as hidden fields. This method takes care of appending them to the
     * specialFields object and the myFieldOrder list.
     */
    _appendAsHiddenFields: function _appendAsHiddenFields (
      fieldsToInject,
      specialFields,
      myFieldOrder
    ) {
      var myFieldCategoryOrder;

      BVReporter.assert(
        _(specialFields).isObject(),
        'A specialFields object is required for _appendAsHiddenFields'
      );
      BVReporter.assert(
        _(myFieldOrder).isArray(),
        'A myFieldOrder array is required for _appendAsHiddenFields'
      );

      // If we don't have any fields to inject, we can bail.
      if (_(fieldsToInject).isEmpty()) {
        return;
      }

      myFieldCategoryOrder = this.get('fieldCategories').fieldCategoryOrder;

      // Make sure the target object is ready to recieve injected data.
      specialFields.injected = specialFields.injected || { formFields: {} };

      // Ensure that the fieldCategoryOrder has an "injected" entry.
      if (_(myFieldCategoryOrder).indexOf('injected') === -1) {
        _(myFieldCategoryOrder).push('injected');
      }

      _(fieldsToInject).forEach(function forEachFieldToInject (value, name) {
        var fieldToInject;
        var newFieldId;

        // We can bail if this field has already been injected or if the value
        // is undefined. We want to ignore undefined values and null values.
        // However, we don't want to ignore all falsy values, such as the
        // empty string.
        if (
          specialFields.injected.formFields[name] ||
          _(value).isUndefined() ||
          _(value).isNull()
        ) {
          return;
        }

        // if name is a known dimsum field, use the proper prefix for its field-type
        // using our fieldIdMap
        if (fieldIdMap[name]) {
          newFieldId = fieldIdMap[name].prefix;
        }
        else {
          newFieldId = name;
        }
        // Barebones setup that our templates need for a hidden input
        fieldToInject = {
          Id: newFieldId,
          Value: value,
          Type: 'HiddenInput',
          hidden: true,
          enabled: true,
          schema: {
            Id: newFieldId,
            Value: value,
            Type: 'HiddenInput'
          }
        };

        // Inject into specialFields.injected
        specialFields.injected.formFields[newFieldId] = fieldToInject;
        myFieldOrder.push(newFieldId);
      });
    },

    /**
     * Creates a sorted list of fields in each category, based on the order in
     * the submission schema.
     */
    _createOrderedFormFields: function _createOrderedFormFields (specialFields, myFieldOrder) {
      var tagIdTest = /^tagid_.+\/.+$/;

      _(specialFields).forEach(function forEachSpecialField (category) {
        var sorted;
        var seenField;
        var keys = _.keys(category.formFields);
        var keyNames = category.formFields;

        // We only need to sort if there is more than one field in the category.
        if (keys.length > 1) {
          sorted = [];
          seenField = {};

          // Compare fields in this category to the API order returned from the submission schema.
          // Creates a new array with ordered references to the field's data.
          _(myFieldOrder).forEach(function forEachField (name) {

            // Tags are formatted specially, and require special parsing
            var fieldName = tagIdTest.test(name) ? 'tag_' + name.split('/')[0].substring(6) : name;

            // Prevent duplicate fields (tag groups have several tag values for the same group).
            if (seenField[fieldName]) {
              return;
            }

            if (_(keyNames).has(fieldName)) {
              sorted.push(keyNames[fieldName]);
            }

            seenField[fieldName] = true;

          });
          category.orderedFormFields = sorted;

          // If the fields aren't in the fieldOrder
        }
        else {
          // If there is only one field in the category, just make an array with it.
          category.orderedFormFields = keys.length ? [keyNames[keys[0]]] : null;
        }
      });
    },

    reset: function reset (config) {
      // I think it would be nice to call clear() here before running init again,
      // but we probably need an implementation of it in BModel.
      // this.clear();
      this.init(config);
    },

    // return the field rules for a particular field (enabled, required, min, max, etc.)
    calculateRules: function calculateRules (fieldName, isHideOnSubmission, wildcard) {
      var submissionSchema;
      var fieldRules;
      var apiRules;

      // these serve as the defaults
      var configDefaults = ENVConfig.submission[fieldName] || {};
      if (wildcard) {
        configDefaults = ENVConfig.submission[fieldName.split('_')[0]] || configDefaults;
      }

      // rules from api submit schema override defaults
      submissionSchema = this.get('submitSchema').Data.Fields[fieldName];

      fieldRules = {
        enabled: !!submissionSchema,
        hidden: isHideOnSubmission || this._hiddenIfValue(fieldName, submissionSchema),
        validation: {},
        schema: submissionSchema
      };

      if (!_.isEmpty(configDefaults.range)) {
        fieldRules.range = _(configDefaults.range).clone();
      }

      apiRules = {};

      if (submissionSchema) {
        // We need to override the API's submission schema here and always mark
        // terms and conditions as required as well as the hosted auth email
        // field. Site auth uses a different email field called useremail.
        // Add override for useremail field (CCS-11758).
        apiRules.required = !!submissionSchema.Required ||
          fieldName === 'hostedauthentication_authenticationemail';

        if (submissionSchema.MaxLength || configDefaults.maxlength) {
          apiRules.maxlength = submissionSchema.MaxLength || configDefaults.maxlength;
        }
        if (submissionSchema.MinLength || configDefaults.minlength) {
          apiRules.minlength = submissionSchema.MinLength || configDefaults.minlength;
        }

        $.extend(fieldRules.validation, {}, apiRules);
      }

      return fieldRules;
    },

    // Intuit the number of allowed photos from the number of fields we're
    // given by the submission schema. Ugly.
    getMaxNumByMediaType: function getMaxNumByMediaType (type) {
      var fields = this.get('submitSchema').Data.FieldsOrder;
      var mediaFields = _(fields).filter(function filterMediaFields (field) {
        return field.indexOf(type + 'url_') === 0;
      });

      return mediaFields.length;
    },

    getSubject: function getSubject () {
      return {
        id: this.get('subjectId'),
        type: this.get('subjectType'),
        contentType: this.get('contentType')
      };
    },

    apiCall: function apiCall () {
      var apiHolder;
      var baseUrl = 'https:' + ENVConfig.apiconfig.baseUrl;
      var submissionRequest;
      var subject = this.getSubject();
      var user = this.get('user');
      var hasSubmitted = this.get('hasSubmitted');

      if (subject.contentType === 'comment') {
        submissionRequest = 'submit' + subject.type + subject.contentType;
      }
      else {
        submissionRequest = 'submit' + subject.contentType;
      }

      apiHolder = api.get(submissionRequest)
        .limitTo(false)
        .withSubject(subject.type + 'id', subject.id)
        .inLocale(ENVConfig.locale)
        .withBaseUrl(baseUrl);

      if (user) {
        apiHolder = apiHolder.withUser(user);
      }
      if (hasSubmitted) {
        apiHolder = apiHolder.withHasSubmitted();
      }
      return apiHolder;
    },

    // fetch the submission schema from the api
    fetchSubmitSchema: function fetchSubmitSchema () {
      var self = this;
      var apiHolder;
      var resultDfd = $.Deferred();
      var subject = self.getSubject();

      function handleError (errorMessage, detail) {
        var schemaError = new Error(errorMessage);
        BVTracker.error({
          name: str.errors.API,
          detail1: detail || 'Error fetching submission schema',
          detail2: apiHolder.serialize()
        });
        resultDfd.reject(schemaError);
      }

      // Clean up whatever we didn't get from the API.
      function getInjectedFields (fields) {
        var compactedValues = {};

        // Fields that are null or undefined were not answered in the first place,
        // so we don't want to treat them as injected.
        _(fields).forEach(function forEachField (field, key) {
          var value = field.Value;
          if (value !== null && typeof value !== 'undefined') {
            compactedValues[key] = value;
          }
        });

        return compactedValues;
      }

      function processSchema (_data) {
        var codeActions;
        var defaultErrorHandler;
        var defaultErrorMessage;
        var action;
        var filteredFields;
        var allInjectedData;
        var unexpectedErrorMessage;
        var unexpectedDetail;
        var injectedFieldsSubmission;

        var data = _data.data;
        self.set('submitSchema', data);

        if (!_.isEmpty(data.Errors)) {
          // This is a map that can handle the API errors we may be expecting:
          // https://ig.bazaarvoice.com/xref/prr-trunk/product/api/app/src/main
          // /java/com/bazaarvoice/api/error/APIErrorCode.java
          codeActions = {
            ERROR_DUPLICATE_SUBMISSION: _.partial(resultDfd.reject, 'duplicate')
          };

          defaultErrorMessage = 'Error fetching submission schema: ' +
            apiHolder.serialize() +
            ' -- ' +
            JSON.stringify(data);

          defaultErrorHandler = _.partial(handleError, defaultErrorMessage);

          // Determine and execute the appropriate action
          action = codeActions[data.Errors[0].Code] || defaultErrorHandler;
          action();
        }
        else if (data && data.Data && data.Data.Fields) {
          injectedFieldsSubmission = getInjectedFields(data.Data.Fields);
          self.set('injectedDataFromToken', injectedFieldsSubmission);

          if (!_.isEmpty(data.FormErrors)) {
            // Editing a rejected review (ERR)
            filteredFields = getInjectedFields(data.Data.Fields);

            // set up injected data with the field data and the previous
            // submission id from the api
            allInjectedData = _.extend(filteredFields, {
              PreviousSubmissionId: data.PreviousSubmissionId
            });

            self.set('injectedDataFromRejectedReview', allInjectedData);
          }

          self._setupERRErrors(data.FormErrors);

          ENV.get('references')
            .get(subject.type, subject.id)
            .done(function done (subjectData) {
              self.set('subjectData', subjectData);

              // TODO CCS-4210 data.Data.FieldsOrder may be the wrong order.
              // We should be using the info from the client's config, not
              // from the api.
              self._processFields(data.Data.Fields, data.Data.Groups, data.Data.FieldsOrder);
              self.dataReady(subjectData);
              resultDfd.resolve(data.Data.Fields);
            });
        }
        else {
          unexpectedErrorMessage = 'Unexpected submission schema: ' +
           apiHolder.serialize() +
            ' -- ' +
            JSON.stringify(data);

          unexpectedDetail = 'Unexpected submission schema';
          handleError(unexpectedErrorMessage, unexpectedDetail);
        }
      }

      User.token().done(function done (userToken) {
        if (userToken) {
          self.set('user', userToken);
        }
        if (User.get('hasSubmitted' + '-' + subject.id + '-' + subject.contentType)) {
          self.set('hasSubmitted', true);
        }

        apiHolder = self.apiCall();

        apiHolder.fetch('submissionSchema')
          .done(processSchema)
          .fail(function fail (startDate, endDate) {
            var errorMessage = 'Submission schema load fail: ' +
              apiHolder.serialize() +
              ' -- ' +
              startDate +
              ' -- ' +
              endDate;

            handleError(errorMessage);
          });
      });

      return resultDfd;
    },

    /**
     * Prepares the model for showing ERR errors.
     * Sets formErrors and rejectionErrors to the model.
     *
     * @param {Object} formErrors - The FormErrors sent from the submit
     *   schema response.
     */
    _setupERRErrors: function _setupERRErrors (formErrors) {
      var rejectionErrors;
      var errors;

      // We can bail if there are no form errors.
      if (_.isEmpty(formErrors)) {
        return;
      }

      // Set the formErrors so the view can access them.
      this.set('formErrors', formErrors);

      // We need to compile a list of rejection error codes.
      rejectionErrors = [];

      // Combine the GeneralErrors and FieldErrors into a single list.
      errors = [].concat(
        formErrors.GeneralErrors,
        _(formErrors.FieldErrors).values()
      );

      // Dig into the errors and get the error subcodes.
      _(errors).forEach(function forEachError (error) {

        // Get the list of subcodes from the error.
        var subcodes = error.SubCodes.split(' ');

        // Push each code into the list.
        rejectionErrors.push.apply(rejectionErrors, subcodes);
      });

      // Once we've got the list, we need to remove duplicates.
      rejectionErrors = _(rejectionErrors).uniq();

      // Now set this list to the model.
      this.set('rejectionErrors', rejectionErrors);
    },

    // submission trigger - if we don't already have the schema, get it
    loadTrigger: function loadTrigger () {
      var self = this;

      self.publish('updateprofile', self, User.getAuthor());

      // Run the fingerprint setup. This is where the fingerprint should load.
      self.get('fingerprint').setup();

      this.fetchSubmitSchema().done(function done () {
        self.get('fingerprintDeferred').done(function fpDone () {
          self.trigger('loadsucceeded', self);
        });
      }).fail(function fail (error) {
        Auth.error(error);
        self.trigger('loadfailed', self, error);
      });
    },

    toJSON: function toJSON () {
      var data;
      var subjectData = this.get('subjectData');

      // Fail pretty hardcore if these aren't defined. Bad things happen
      // somewhat transparently if we don't blow up here, so probably better
      // just to die in a huge explosion.
      if (
        _(subjectData).isUndefined() ||
        _(subjectData.Type).isUndefined() ||
        _(subjectData.Id).isUndefined()
      ) {
        throw new Error('Incomplete subject data', subjectData);
      }

      // Adding sanitizedId to subject data as we are using the Subject.Id in the DOM.
      subjectData.SanitizedId = sanitize.subjectId(subjectData.Id);

      data = {
        apiConfig: api._config,
        author: this.get('Author'),
        campaignId: this.get('clientAPIConfig').campaignId || '',
        channelId: this.get('channelId'),
        clientName: ENVConfig.clientDisplayName || ENVConfig.clientname,
        contentType: this.get('contentType'),
        hostedAuth: this.get('hostedAuth'),
        hostedAuthCallbackUrl: this.hostedAuthUrl(),
        fieldCategoryOrder: this.get('fieldCategories').fieldCategoryOrder,
        fingerprintScriptError: this.get('fingerprintScriptError'),
        formFields: this.get('formFields'),
        locale: ENVConfig.locale,
        maxPhotos: this.getMaxNumByMediaType('photo'),
        modelCid: this.cid,
        postCallback: this.get('postCallback'),
        Product: this.get('subjectData'),
        rejectionErrors: this.get('rejectionErrors'),
        specialFields: this.get('specialFields'),
        subject: subjectData,
        agreements: this.get('agreements'),
        agreementsReviews: !_(agreements.reviews).isEmpty(),
        agreementsQuestions: !_(agreements.questions).isEmpty(),
        user: this.get('user'),
        validationRules: this._validationRules(),
        verifiedPurchaser: this.get('verifiedPurchaser')
      };

      data[data.contentType] = true;

      _(data.specialFields).forEach(function forEachSpecialField (fieldSet) {
        // If user token is present in session delete unnecessary
        // hostedauthentication_authenticationemail field injected form url. See CCS-31828.
        if (data.user && fieldSet.formFields.hostedauthentication_authenticationemail) {
          delete fieldSet.formFields.hostedauthentication_authenticationemail;
        }
        // Goofy handlebars necessity
        fieldSet.rawData = data;
      });

      return data;
    },

    /**
     * This takes values from:
     *
     * {
     *   people : {
     *     formFields : {
     *       contextdatavalue_Age : {...}
     *     }
     *   },
     *   ratings : {
     *     formFields : {
     *       rating_Ambience : {...}
     *     }
     *   },
     *   ...
     * }
     *
     * and puts them into a single object:
     *
     * {
     *   contextdatavalue_Age : {...},
     *   rating_Ambience : {...},
     *   ...
     * }
     *
     * Sometimes, the keys are numbers. It would be bad if two keys from different groups
     * were the same, because one would be overwritten by the other.
     *
     * Luckily, for PRR reasons, ConfigHub guarantees that question keys
     * are unique.
     */
    // TODO test
    getFields: function getFields () {
      var specialFormFields = _.pluck(this.get('specialFields'), 'formFields');
      var fieldGroups = _.union(specialFormFields, [this.get('formFields')]);

      return _.reduce(fieldGroups, function reduceFieldGroups (allFields, nextGroup) {
        function addField (field, name) {
          allFields[name] = field;
        }

        _(nextGroup).forEach(addField);
        return allFields;
      }, {});
    },

    /**
     *  Determines the URL that the user will return to in order to
     *  authenticate their submission (i.e., confirm their review). Based on
     *  configuration and other details, this will either be the PDP or the
     *  container page.
     *
     *  @return {String} The URL to use for the callback.
     */
    hostedAuthUrl: function hostedAuthUrl () {
      if (!this.get('hostedAuth')) {
        // With site auth, the hidden INPUT that needs this value won't even
        // be on the page, so it doesn't matter what we return.
        return;
      }

      // The URL to the page we're currently on.
      function getPageUrl () {
        var url = window.location.href;
        // Remove URL params that will trigger unwanted actions.
        // (https://bits.bazaarvoice.com/jira/browse/CCS-2756)
        url = Url.splice(url, 'userToken');
        url = Url.splice(url, 'authToken');
        url = Url.splice(url, 'action');
        return url;
      }

      // The URL in the LINK[rel=canonical] tag, with the page URL as fallback.
      function getCanonicalUrl () {
        var canonicalHref = $('link[rel="canonical"]').attr('href');
        // Poor-man's URL normalization.
        var url = $('<a/>', { href: canonicalHref })[0].href;

        // Make sure the LINK tag exists and that the URL points to an
        // allowed domain. This _should_ always be true on a container page,
        // but we might as well be safe.
        if (canonicalHref && DomainPolice.allowedDomain(url)) {
          return url;
        }

        // Otherwise we can just fall back to the URL we're on.
        return getPageUrl();
      }

      // The URL to the BV-hosted container page.
      function getContainerUrl () {
        var containerHost;
        var containerPaths;
        var containerPath;
        var containerUrl;
        var containerProtocol = Url.protocol;

        var containerHostMap = {
          rc: {
            production: 'display-rc',
            staging: 'display-rc'
          },
          qa: {
            production: 'display-qa',
            staging: 'display-qa'
          },
          production: {
            production: 'display',
            staging: 'display-stg'
          },
          local: {
            production: 'localhost',
            staging: 'localhost'
          }
        };

        containerHost = containerHostMap[ENVConfig.workspace][ENVConfig.environment] +
          '.ugc.bazaarvoice.com';

        containerPaths = ['static', ENVConfig.clientname, ENVConfig.locale];
        if (ENVConfig.siteId) {
          containerPaths.splice(2, 0, ENVConfig.siteId);
        }
        containerPath = containerPaths.join('/') + '/container.htm';
        containerUrl = containerProtocol + '//' + containerHost + '/' + containerPath;

        return containerUrl;
      }

      if (this.get('isGenericSubmission')) {
        // We're on a GRS landing page. We don't want to return here to
        // confirm the submission because it's common for GRS landing pages
        // not to trigger any UI actions until the user clicks on something,
        // and without a UI action we won't do the bootstrapping needed to
        // confirm the submission. Instead let's use the container page...
        // unless we're already on a container page, in which case we should
        // use the canonical URL as described below.
        return BV._internal.container ? getCanonicalUrl() : getContainerUrl();
      }

      // If "Use Product Page for Submission" is disabled, we should use the
      // container page instead of the PDP.
      if (!ENVConfig.container.subjectRedirect) {
        return getContainerUrl();
      }

      // If we're already on a container page, we should assume it's for a
      // good reason (e.g., mobile submission) and use the container page as
      // the callback URL instead of the PDP. We check for the canonical URL
      // in the LINK tag as is typically present on the container page. (We
      // don't do this on a client's PDP because we have no guarantee that
      // that "canonical" URL will actually lead us back to that same PDP.)
      if (BV._internal.container) {
        return getCanonicalUrl();
      }

      // Failing that, we'll assume that we're on a client's PDP, and thus
      // should return to this page to confirm submission.
      return getPageUrl();
    },

    // Return a user from the upload-photo flow, image in tow.
    addMedia: function addMedia (mediaType, media) {
      var allMedia = this.get(api.nouns(mediaType));

      // Check if the photo ID already exists. If so, we're editing an
      // existing photo.
      var mediaIndex = this._indexOfMediaId(media.id, mediaType, allMedia);
      if (mediaIndex === -1) {
        allMedia.push(media);
      }
      else {
        allMedia[mediaIndex] = media;
      }

      // TODO: Do I need this? -APD
      this.set(api.nouns(mediaType), allMedia);
    },

    removeMedia: function removeMedia (id, mediaType) {
      var allMedia = this.get(api.nouns(mediaType));

      // Remove the photo with the given ID from the array.
      var index = this._indexOfMediaId(id, mediaType, allMedia);
      if (index > -1) {
        allMedia.splice(index, 1);
      }

      // TODO: Do I need this? -APD
      this.set(api.nouns(mediaType), allMedia);
    },

    _indexOfMediaId: function _indexOfMediaId (id, mediaType, _allMedia) {
      var allMedia = _allMedia || this.get(api.nouns(mediaType));
      var i = 0;
      var index = -1;
      var media = allMedia[i];

      while (media) {
        if (media.id === id) {
          index = i;
          return index;
        }
        i = i + 1;
        media = allMedia[i];
      }

      return index;
    },

    _hiddenIfValue: function _hiddenIfValue (fieldName, submissionSchema) {
      // These fields are read-only/hidden iff a Value is supplied
      var hiddenFields = {
        usernickname: true,
        userlocation: true
      };

      return hiddenFields[fieldName] && submissionSchema && submissionSchema.Value;
    },

    getMediaById: function getMediaById (id, mediaType, _allMedia) {
      var allMedia = _allMedia || this.get(api.nouns(mediaType));
      return allMedia[this._indexOfMediaId(id, mediaType, allMedia)];
    }

  });
});

BV.define('bv/c2013/model/thankYouPage',[
  'ENV',
  'framework/bmodel',
  'underscore',
  'bv/util/contentType'
], function (ENV, BModel, _, ContentType) {
  return BModel.extend({
    name: 'thankYouPage',

    init: function (options) {
      // Mixin options
      _.extend(this.options, options);
      this.set({
        icon: '&#x2714;',
        messageContentType: ContentType.noun(this.get('contentType'))
      });
    }

  });
});

BV.define('bv/c2013/model/dropdownable',[
  'framework/bmodel'
], function (BModel) {
  return BModel.extend({
    name: 'dropdownable'
  });
});

BV.define('mappings!submission/models',[
"bv/c2013/model/submission",
"bv/c2013/model/thankYouPage",
"bv/c2013/model/dropdownable"
], function (
submissionModel,
thankYouPageModel,
dropdownableModel
) { 
  var mappings = {
    submission : {name : 'submission', model : submissionModel},
    thankYouPage : {name : 'thankYouPage', model : thankYouPageModel},
    dropdownable : {name : 'dropdownable', model : dropdownableModel},
    submissionPreview : { name : 'submissionPreview', has : { name : 'submissionPreview'}},
    mbox : { name : 'mbox', has : { name : 'mbox'}}
  };



  return mappings;

});

BV.define('bv/util/normalizeParams',['underscore'], function (_) {
  // Many URL parameters are taken and stuck into clientAPIConfig.
  // For example, &bvproductid=moo should end up being { productId : 'moo' }, but
  // there's not really a straightforward way to handle all the various capitalization states.
  // This attempts to handle some of the more common suffixes.
  // Long term, may want to lowercase everything going into a clientAPIConfig...
  return function (params) {
    var result = _.clone(params);
    _(result).forEach(function (value, key) {
      // If ends with lowercase id/type/token, upper case it
      _(['Id', 'Type', 'Token']).forEach(function (suffix) {
        var regex = new RegExp(suffix.toLowerCase() + '$');
        if (key.match(regex)) {
          delete result[key];
          result[key.replace(regex, suffix)] = value;
        }
      });
    });
    return result;
  };
});

/**
 *  @fileOverview Backbone-style router that triggers actions based on the
 *  "route" (either a URL hash or a `bvroute` parameter). Also exposes
 *  methods for matching routes (and triggering actions) against arbitrary
 *  strings.
 */
BV.define('framework/approuter',[
  'backbone',
  'ENV',
  'underscore',
  'bv/util/contentType',
  'framework/util/bvreporter',
  'util/url',
  'bv/util/normalizeParams',
  'window'
], function (Backbone, ENV, _, ContentType, BVReporter, Url, normalizeParams, window) {
  var prefix = ''; // 'bv/';

  var Route = function (config) {
    this.routes = _(config.route).isArray() ? config.route : [config.route];
    this.handler = config.handler;
  };
  Route.prototype.initialize = function (router) {
    var self = this;
    this.router = router;
    _(self.routes).forEach(function (route) {
      router.route(prefix + route, null, self.handler);
    });
  };
  // Example: appRouter.submit.reverse({ contentType : 'review', campaignId : 'email1' })
  Route.prototype.reverse = function (components) {
    return this.routes[0].replace(/:(\w+)/g, function (m, c) {
      return components[c] || '';
    });
  };

  /**
   *  Tests if the route matches the given fragment, and if so, dispatches
   *  the handler.
   *
   *  If there are multiple routes, will dispatch the first one that matches
   *  the fragment.
   *
   *  @param   {String} fragment  The fragment to match against.
   *  @returns {Boolean} Whether the fragment matched the route.
   */
  Route.prototype.match = function (fragment) {
    var params;
    var matchedRoute = _(this.routes).detect(function (route) {
      var regex = this.router._routeToRegExp(route);
      if (!regex.test(fragment)) { return false; }

      // This route matches. Extract the parameters.
      params = this.router._extractParameters(regex, fragment);
      return true;
    }, this);

    if (!matchedRoute) {
      return false;
    }

    // Dispatch the handler.
    this.handler.apply(this, params);
    return true;
  };


  // A quick primer for the code below:
  //
  // Its purpose is to eliminate our reliance on the URL hash. We should
  // treat it as off-limits because customers' sites might rely on the URL
  // hash for a number of reasons. Instead, we should use a parameter named
  // `bvroute`, since it's far less likely to introduce a conflict.
  //
  // But we want to reuse Backbone's router, so we monkeypatch it to check
  // the `bvroute` parameter and treat that as its "hash." For
  // backward-compatibility, we're going to continue to recognize the old
  // hash-based route approach, at least for now, and that means we have to
  // use some tricky logic to decide which one "wins" if both are present.
  //

  // The original simple logic for getting the URL hash. We'll use this later.
  var originalGetHash = Backbone.history.getHash;

  function patchHistory (canTouchUrlHash) {
    Backbone.history.getHash = function (window) {
      var win = window || this;
      // to support encoded URI hash, it's being decoded here - see CCS-33331 for clarity
      var href = decodeURIComponent(win.location.href);

      var bvRouteHash = null;
      var urlHash = null;

      // First, look for a `bvroute` parameter. We prefer this to the URL hash
      // for safety's sake; it's less likely to collide with a specific URL
      // parameter than with a URL hash.
      var match = href.match(/(?:&|\?)bvroute=(.*?)(?:&|$)/);

      if (match) {
        // Unlike an actual hash, a `bvroute` is URL-encoded, so we have to
        // decode it.
        bvRouteHash = decodeURIComponent(match[1]);
      }

      // But also check if there's an URL hash.
      match = href.match(/#(.*)$/);
      if (match) {
        urlHash = match[1];
      }

      // If both are present, we have to decide which one "wins." For
      // backward-compatibility reasons, we'll have the URL hash win _if_ we
      // recognize it as a Firebird route. Otherwise the `bvroute` parameter
      // wins.
      if (bvRouteHash && urlHash) {
        return recognizeRoute(urlHash) ? urlHash : bvRouteHash;
      }

      if (bvRouteHash) {
        return bvRouteHash;
      }

      if (urlHash) {
        return urlHash;
      }

      return '';
    };

    // If it's safe to update the URL hash on this page, we're done
    // monkeypatching.
    if (canTouchUrlHash) {
      return;
    }

    // If it isn't, we should turn _updateHash into a no-op. This doesn't
    // prevent someone from putting a URL hash in an anchor's HREF, but it
    // does prevent any explicit calls to `navigate` from changing the URL
    // hash.
    Backbone.history._updateHash = function (location, fragment, replace) {
      return;
    };
  }

  // Returns whether the URL hash is a recognized Firebird route.
  function recognizeRoute (hash) {
    if (typeof hash === 'undefined') {
      hash = originalGetHash(window);
    }

    var matched = _.any(Backbone.history.handlers, function (handler) {
      return handler.route.test(hash);
    });

    return matched;
  }


  return Backbone.Router.extend({
    initialize: function (options) {
      var self = this;
      self.clientAPIConfig = options.clientAPIConfig;
      _(options.routes).forEach(function (route, index) {
        var name = route.name;
        var newRoute = new Route({
          route: route.paths,
          handler: function () {
            BVReporter.log('Handling route', name, route);

            var data = {};
            var args = _(arguments).toArray();

            _(route.params).forEach(function (param, pindex) {
              if (param === 'urlData') {
                var urlData = Url.toQueryParams(args[pindex]);
                _(data).extend(urlData);
              }
              else {
                data[param] = args[pindex];
              }
            });

            _(route.actions).forEach(function (action, aindex) {
              if (action.event) {
                var targetComponent = ENV.get('componentManager').find(action.component);
                if (targetComponent) {
                  targetComponent.triggerRouteEvent(targetComponent.scopeEvent(action.event), data);
                } else {
                  BVReporter.warn('Tried to trigger event on', action.component, "but couldn't find it");
                }
              }
              else if (action.action) {
                _(data).extend({ componentId: action.component }, self.clientAPIConfig);
                $BV.ui(action.scope, action.action, data);
              }
              else if (action.bvdata) {
                // Normalize and make sure action is still there...
                data = _({}).extend(self.clientAPIConfig, normalizeParams(data));
                $BV.ui(data.scope, data.action, data);
              }
            });
          }
        });
        newRoute.initialize(self);
        self[name] = newRoute;
      });
      delete self.routes;

      // Before we finish, we should look at the URL hash and see if it
      // matches any of our routes.
      var hash = originalGetHash(window);
      var recognized = recognizeRoute(hash);

      // We consider it safe to touch if it's absent or if it matches one of
      // our own routes.
      var canTouchUrlHash = (hash === '') || recognized;

      // Now we should overwrite `getHash` with our own version (and perhaps
      // `_updateHash`, if the URL hash above is unrecognized).
      patchHistory(canTouchUrlHash);
    },

    /**
     *  Retrieves the route with the given name.
     *  @param   {String} name The name of the route to retrieve.
     *  @returns {Object} The route object.
     */
    getRouteByName: function (name) {
      var route = this[name];
      if (!(route instanceof Route)) {
        return null;
      }
      return route;
    },

    /**
     *  Compares a fragment to a named route, and dispatches the route's
     *  handler if they match.
     *  @param   {String}  fragment The fragment that should be matched.
     *  @param   {String}  name     The name of the route we should match against.
     *  @returns {Boolean} Whether the fragment matched the route.
     */
    matchFragmentToRoute: function (fragment, name) {
      var route = this.getRouteByName(name);
      if (!route || route.routes.length !== 1) { return; }
      return route.match(fragment);
    }

  });
});

BV.define('bv/ugc/postInjectTriggers',[
  'ENV',
  '$BV',
  'jquery'
], function (ENV, $BV, $) {

  var firstLoad = true;

  function postInjectTriggers (clientAPIConfig, apiTime, initData) {
    if (firstLoad) {
      firstLoad = false;

      // loadCSS is defined for IE<9. If it exists, reload it. This helps IE<9
      // render with fonts more reliably.
      if (BV._internal.loadCSS) {
        $(function () {
          BV._internal.loadCSS();
        });
      }

      // _onLoad may change to something else - not intended to be used
      // externally by clients.
      if (clientAPIConfig._onLoad) {
        clientAPIConfig._onLoad({
          loadTime: new Date() - BV._internal.startTime,
          apiTime: apiTime,
          initData: initData
        });
      }
    }
  }

  return postInjectTriggers;
});

BV.define('framework/util/hasFeature',[
  'ENV',
  'underscore',
  'framework/util/featureHelper'
], function (ENV, _, ftHelper) {
  /**
   * This checks whether a component has a given feature for a given parent name.
   * It provides a fast path where the actual component instance is the first argument,
   * and provides a fallback if the first argument is the ID of a component instead.
   *
   * @param {Object|String} component A compnent or component ID to use for the lookup.
   * @param {String} parentName The "parent" to look at when looking for the feature.
   * @param {String} featureName The name of the feature we're looking for.
   * @param {String} [featureType] The type of feature we're after.
   */
  function hasFeature (component, parentName, featureName, contentType, instanceName, featureType) {
    component = _(component).isString() ? _componentFromId(component) : component;
    var parentFeatures = component && component.features && component.features[parentName];

    parentFeatures = ftHelper.getFeaturesForInstance(parentFeatures, contentType, instanceName);
    return parentFeatures && _hasFeatureType(parentFeatures, featureName, featureType);
  }

  /**
   * Helper to check whether a featureName with the given featureType exists in the input features.
   * Returns true if feature exists; otherwise return false
   *
   * @param {array} features - an array of all the features
   * @param {string} fetaureName - the lookup feature's name.
   * @param {string} fetaureType - the lookup feature's type.
   */
  function _hasFeatureType (features, featureName, featureType) {
    var i;
    var feature;
    var featureObj;
    var subFeature;
    var mappings = ENV.get('mappings');
    var type;
    var featureTypes = featureType ? [featureType] : ['has', 'model', 'collection', 'view'];

    for (i = 0; i < features.length; i++) {
      feature = ftHelper.getName(features[i]);
      featureObj = mappings[feature];
      if (featureObj) {
        for (var j = 0; j < featureTypes.length; j++) {
          type = featureTypes[j];
          subFeature = featureObj[type];
          if (subFeature && featureObj.name === featureName) {
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * Helper to get the component instance given a component ID.
   * @param  {String} id The ID of the component to look for.
   */
  function _componentFromId (id) {
    var components = ENV.get('componentManager');

    // if id is undefined
    if (_(id).isUndefined()) {
      return false;
    }

    if (!components) {
      return false;
    }

    return components.find(id);
  }

  return hasFeature;
});

BV.define('framework/outlet',[
  'ENV',
  'underscore',
  'framework/util/bvreporter',
  'bv/util/baseConfig'
], function (ENV, _, BVReporter, baseConfig) {
  var Outlet = function (options) {
    BVReporter.assert(options.originatingComponent, 'Originating component required to set up outlet');
    BVReporter.assert(options.target, 'Target required to set up outlet');
    BVReporter.assert(options.key, 'Key required to set up outlet');
    BVReporter.assert(options.target.event || options.target.action, 'Target for outlet has event or action');

    this.originatingComponent = options.originatingComponent;
    this.target = options.target;
    this.key = options.key;
    this.allowedParams = /\d*Id|Type|able|Mode|mobile|doShowContent\d*/;

    this.createHandler();
  };

  Outlet.prototype.createHandler = function () {
    var event = this.event = 'outlet:' + this.key;

    if (this.target.event) {
      this.originatingComponent.on(event, this._eventHandler());
    }

    if (this.target.action) {
      this.originatingComponent.on(event, this._actionHandler());
    }
  };

  Outlet.prototype._eventHandler = function () {
    BVReporter.assert(this.target.component, 'Event outlet target must have component');

    var self = this;
    var target = this.target;

    return function () {
      var targetComponent = ENV.get('componentManager').find(target.component);

      BVReporter.info('Handling outlet event', target.event, 'originated by', self.originatingComponent.getScope());

      if (!targetComponent) {
        return;
      }

      /**
       * Component exists, but no model has been created.
       * Trigger the doShowContent() in the default clientAPIConfig set through $BV.config({ ... }).
       *
       * This situation happenes when the client has both R&R and Q&A enabled,
       * but for some reason only shows R&R/Q&A on a single page.
       * On that page, the summary and search contain stats for the other non-shown list.
       * We shall make those components be able to trigger doShowContent defined for the correct scope.
       */
      if (targetComponent && !targetComponent.model && target.scope && target.fallback) {
        var fn = baseConfig[target.scope][target.fallback];
        if (_(fn).isFunction()) {
          fn(arguments);
        }
        return;
      }

      var args = [targetComponent.scopeEvent(target.event)].concat([].slice.call(arguments));
      targetComponent.trigger.apply(targetComponent, args);

      return;
    };
  };

  Outlet.prototype._actionHandler = function () {
    var target = this.target;
    var self = this;

    return function (data) {
      BVReporter.info('Handling outlet action', target.action, target.scope, 'originated by', self.originatingComponent.getScope());

      data = data || {};
      var targetData = {};

      // Action outlets trigger BV ui call.
      // Need to pass:
      //  - productId, questionId, categoryId
      //  - contentType, secondaryContentType, subjectType
      //  - onShow() callback
      _(data).chain().keys().forEach(function (key) {
        if (self.allowedParams.test(key)) {
          targetData[key] = data[key];
        }
      });

      targetData.componentId = target.component;
      targetData.onShow = data.onShow;
      $BV.ui(target.scope, target.action, targetData);
      return;
    };
  };

  Outlet.prototype.detach = function () {
    this.originatingComponent.off(this.event);
  };

  return Outlet;
});

/**
 * @fileOverview Checks visibility of an element by calculate the
 * visible pixels.
 */
BV.define('util/pixelsDisplayed',[
  'window',
  'document'
], function (window, document) {
  var docEl = document && document.documentElement;

  function pixelsDisplayed (el) {
    var rect = el.getBoundingClientRect();
    var displayed;

    var windowHeight = window.innerHeight || docEl.clientHeight;

    // There are five potential DOM node positions relative to the viewport:
    // * Completely above the viewport, not visible
    // * Completely below the viewport, not visible
    // * A top portion (or all) of the DOM node is visible
    // * A middle portion of the DOM node is visible
    // * A bottom portion of the DOM node is visible

    if (rect.top <= 0) {
      // The top of the node is at or above the top of the viewport,
      // so the top plus its height would be how much is shown.
      // However, we never want to provide a negative number for amount displayed.
      displayed = Math.max( rect.top + rect.height, 0 );

      // Once we know how much is potentially showing, we want to ensure that we don't over-report.
      // If the window height is less than our calculated display, use that.
      displayed = Math.min ( displayed, windowHeight );

      // Cases handled:
      // * Completely above the viewport, not visible
      //   * First displayed value would be 0, as the sum would be negative and so Math.max would return 0
      //   * Second displayed will remain 0, as that is (hopefully) less than viewport height
      // * A middle portion of the DOM node is visible, or a bottom portion of the DOM node is visible
      //   * First displayed value will be the height of the DOM node below the top of the viewport
      //   * Second displayed value will be either that height, or the height of the viewport itself

      return displayed;
    }

    // If the top of our rectangle is greater than the viewport's height,
    // we're not visible, as the node is completely below the viewport.
    if (rect.top >= windowHeight) { return 0; }

    // At this point, the only remaining case is that the top of the DOM node is
    // somewhere in the viewport. We can determine the maximum possible amount
    // displayed rather easily, by determining how much distance there is between
    // the top of the bounding rectangle and the viewport's height.
    // However, if this is larger than our DOM node, we don't want to report more
    // displayed than the node's full height;
    return Math.min( windowHeight - rect.top, rect.height );
  }

  return pixelsDisplayed;
});

/**
 * @fileOverview A module for reporting visibility based events
 */
BV.define('util/visibilityObserver',[
  'window',
  'document',
  'jquery',
  'underscore',
  'backbone',
  'framework/util/bvreporter',
  'util/pixelsDisplayed'
], function (window, document, $, _, Backbone, BVReporter, pixelsDisplayed) {
  var WAITING = 'waiting';
  var PENDING = 'pending';
  var VISIBLE = 'visible';
  var DEBOUNCE_INTERVAL = 150;

  var $window = $(window);
  var $document = $(document);
  var queue = {};
  var nextId = 0;
  var firstCheckTime;

  var defaultOptions = {
    // Minimum pixels to be displayed before an element is considered visible
    visibleThreshold : 100,
    // How long to wait before checking visibility again and sending the
    // viewedUGC notice
    viewObserved : 5000
  };

  // ### Queue Management
  function processQueue () {
    _(queue).each(function (item) {
      if (item.state === WAITING) { item.checkVisibility(); }
    });
  }

  function removeFromQueue (item) {
    delete queue[item.id];
  }

  function registerObserver (observer) {
    if (!observer.id) {
      if (observer.el.id) {
        // Use the DOM node's ID
        observer.id = observer.el.id;
      }
      else {
        // Use an autoincrementing value for the ID
        observer.id = nextId++;
      }
    }

    queue[observer.id] = observer;
  }

  // ### Event handlers
  function process () {
    if (!firstCheckTime) {
      firstCheckTime = new Date();
    }

    processQueue();
  }

  var debouncedProcess = _.debounce(process, DEBOUNCE_INTERVAL);

  // Events to process:
  // window onload: Immediately set window size and process
  // window resized or scrolled: size and process after a short delay
  // document clicked: no need to resize, just process the queue
  if ( !(window && window.BV && window.BV.serverRender) ) {
    if (document.readyState === 'complete') {
      // In case we're in a post-onload scenario
      process();
    }
    else {
      // Otherwise, fire this on load
      $window.on('load', process);
    }
    $window.on('resize scroll', debouncedProcess);
    $document.on('click', processQueue);
  }

  // ### Constructor for Visibility Observers
  function VisibilityObserver (options) {
    _.extend(this, defaultOptions, options);

    BVReporter.assert(this.el, 'VisibilityObserver has an element');

    // Intentionally not using `setState` here, as triggering an event during
    // initialization, before any opportunity to trigger an event has happened,
    // makes no sense.
    this.state = WAITING;

    registerObserver(this);
  }

  VisibilityObserver.prototype = {
    isVisible : function () {
      return pixelsDisplayed(this.el) > this.visibleThreshold;
    },

    /**
     * Check if the element is visible.
     * If so, trigger the firstVisible event (only the first time), and
     * create a timeout to confirm visibility in a few seconds
     */
    checkVisibility : function () {
      var time = new Date();

      // If we've already hit visible for the full duration,
      // don't reprocess.
      if (this.state === VISIBLE) { return; }

      if ( this.isVisible() ) {
        if (!this.timeFirstVisible) {
          this.timeFirstVisible = time;
          this.trigger('firstVisible', this.viewObserved, time - firstCheckTime);
        }

        this.setState(PENDING);

        setTimeout(_.bind(this.confirmVisibility, this), this.viewObserved);
      }
    },

    confirmVisibility : function () {
      var time = new Date();

      if ( this.isVisible() ) {
        this.timeVisible = time;

        this.setState(VISIBLE);
        this.trigger('fullyVisible', this.viewObserved, time - firstCheckTime);

        removeFromQueue(this);
        return;
      }

      // If we get here, we're not visible, back to waiting
      this.setState(WAITING);
    },

    setState : function (state) {
      this.state = state;
      this.trigger('visibility', state);
    },

    stop : function () {
      removeFromQueue(this);
    }

  };

  _.extend(VisibilityObserver.prototype, Backbone.Events);

  // Exposing several internal properties for debugging and development purposes.
  // These properties are not valid for development use, and should only be used
  // during testing and debugging. The underscore prefix is intended to imply
  // that these should effectively be treated as private, as well as making it easy
  // to know which properties are intended for debugging use (since they're the
  // only prefixed values).
  
  return VisibilityObserver;
});

/**
 * @fileOverview Provide the `Compenent` class, the base of all Firebird
 * components.
 */
BV.define('framework/bcomponent',[
  'window',
  'ENV',
  'underscore',
  'backbone',
  'jquery',
  'bv/util/contentType',
  'bv/ugc/postInjectTriggers',
  'framework/async-queue',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'framework/util/hasFeature',
  'framework/util/scoped',
  'framework/util/experiments',
  'framework/outlet',
  'bv/util/baseConfig',
  'client!util/visibilityObserver',
  'framework/performance',
  'bv/util/bvLocal'
], function (
  window,
  ENV,
  _,
  Backbone,
  $,
  ContentType,
  postInjectTriggers,
  queue,
  BVReporter,
  BVTracker,
  hasFeature,
  Scoped,
  experiments,
  Outlet,
  baseConfig,
  VisibilityObserver,
  performance,
  bvLocal
) {
  /**
   * Component is responsible for managing the life cycle of a component:
   * initializing its view, initializing its model, and providing notification
   * that the model has been created. It also provides information about the
   * component that can be used by other pieces of the application to determine
   * what other resources need to be loaded, initialized, etc.
   *
   * Most interactions with Component instances happen from the
   * ComponentManager.
   *
   * @constructor
   * @param {Object} config - The component config
   */
  var Component = Backbone.Model.extend({
    initialize: function (config) {
      BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });

      BVReporter.log('Initializing component', config.componentId, 'with config', config);
      var self = this;

      _.extend(this, config);

      this.componentData = config;
      this.isRouter = this.type === 'bvRouter';
      this.isAutoloadComponent = this.autoload;

      this._startTime = new Date();
      this.uniqueId = (this.container || this.containerPrefix) + '_' + this.componentId;

      // The sort string is a way to control the order in which components
      // initialize and render. Components without `autoload` are
      // deprioritized because they may not need to be shown at all. And the
      // `priority` property allows for certain marked components to jump
      // ahead of other `autoload` components.
      this.sortString = (this.autoload ? '' : '~') + (this.priority ? '' : '~') + this.componentId;

      this._eventQueue = [];

      if (this.monitorVisibility) {
        this._monitorVisibility();
      }

      // Keep track of whether we've rendered at least once.
      this._rendered = false;
      this.on('viewRendered', function () {
        self._rendered = true;
      });

      this._asyncRender = !!experiments.asyncRender;
      this._asyncDataProcessing = !!experiments.asyncDataProcessing;
      this._asyncComponentRender = !!experiments.asyncComponentRender;
    }
  });

  /**
   * Set the container for the component based on the component's config and
   * any overrides provided by the client's API config.
   */
  Component.prototype.updateContainer = function (config, clientAPIConfig) {
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });

    BVReporter.debug('Updating container for', this.componentId);

    var containerId = _(config.containers).has(this.container) ?
                        config.containers[this.container] :
                        this.container;

    var nouns = null;

    if (clientAPIConfig.contentType) {
      nouns = ContentType.Nouns(clientAPIConfig.contentType);
    }

    var injectionList;

    if (
      !_(clientAPIConfig[containerId]).isEmpty() &&
      (nouns === this.contentType || _(this.coverageContentTypes).contains(nouns))
    ) {

      if (_(config.injectionZone).chain().keys().contains(this.container).value()) {
        injectionList = config.injectionZone[this.container];
        delete config.injectionZone[this.container];
        config.injectionZone[clientAPIConfig[containerId]] = injectionList;
      }

      this.container = clientAPIConfig[containerId];
    }

    if (clientAPIConfig.containerPrefix) {
      this.containerPrefix = clientAPIConfig.containerPrefix;
    }
    this.uniqueId = (this.container || this.containerPrefix) + '_' + this.componentId;
  };

  /**
   * If the component instance is associated with the desired ui action, return
   * the components for all of the "event" outlets; otherwise, returns an empty
   * array.
   *
   * @param {String} actionKey - The desired ui action
   * @param {Object} uiActions - An object containing all possible ui actions
   * as keys, with an array of associated components as their corresponding values.
   *
   * @returns {Array}
   */
  Component.prototype.getOutlets = function (actionKey, uiActions) {
    BVReporter.assert(function () { return [_(actionKey).isString(), 'actionKey is string']; });
    BVReporter.assert(function () { return [_(uiActions).isObject(), 'uiActions is object']; });
    BVReporter.debug('Getting outlets for', this.componentId);

    var listedComponents = uiActions[actionKey];

    if (!_(listedComponents).contains(this.componentId)) {
      return [];
    }

    return _(this.outlets).chain()
      .values().flatten()
      .filter(function (outlet) {
        return ! _.isUndefined(outlet.event);
      })
      .pluck('component').value();
  };

  /**
   * Initializes the component's view, then waits for the model's data to be
   * ready before proceeding with rendering the view.
   *
   * @param {Number} index - The order of the component in the list of required
   * components.
   * @param {Object} injectionZoneReadyDfds - An object with keys corresponding
   * to the various injection zones, with deferreds as the corresponding
   * values. The deferreds are created in ComponentManager.
   * @param {Object} domReadyDfd - A deferred that is resolved when the DOM is
   * ready, created in ComponentManager.
   */
  Component.prototype.initView = function (index, injectionZoneReadyDfds, domReadyDfd) {
    var clientAPIConfig = this.clientAPIConfig;

    BVReporter.assert(function () { return [_(index).isNumber(), 'index is number']; });
    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });
    BVReporter.assert(function () { return [_(injectionZoneReadyDfds).isObject(), 'injectionZoneReadyDfds is object']; });
    BVReporter.assert(!!domReadyDfd.promise, 'domReadyDfd is deferred');
    BVReporter.debug('Initializing view for', this.componentId);

    // TODO: fewer arguments please!
    var startTime = this._startTime;
    var componentManager = ENV.get('componentManager');

    var uniqueId = this.uniqueId;
    var view = componentManager && componentManager.views ? componentManager.views()[uniqueId] : null;
    var model = this.model;

    if (!view) {
      view = this.createView(index);
    }

    // NOTE:  We do not setup postInjection callback if actionInit is
    // called by bv.ui[submit_contentType]. This is OK because submission
    // render in a different way. If in the future, submission requires
    // other components to auto inject on the client page, we will need
    // to revisit this logic.
    if (view && this.inject && this.type !== 'submission') {
      var promises = [model.dataProcessedPromise()];
      var self = this;

      _(model.subModels).each(function (m) {
        if (m) {
          promises.push(m.dataProcessedPromise());
        }
      });

      $.when.apply($, promises).done(function () {
        // We wait until the next tick here because the
        // `dataProcessedPromise` which triggers this call also triggers
        // `modelDataReady`, which is used as a last-call for collections to
        // initialize their views before render. If we don't wait we end up
        // rendering before those collections can add their views.
        setTimeout(function () {
          var injected = [];

          function _renderView () {
            injected.push(self.renderView(injectionZoneReadyDfds, domReadyDfd));
          }

          function _postRender () {
            // Handle deep-linking to content/submission.
            var fn = _.partial(postInjectTriggers, clientAPIConfig, new Date() - startTime, self.get('initData'));

            if (_.all(injected)) {
              fn();
            }
            else {
              $(fn);
            }
          }

          // When all data is processed, render the views.
          if (self._asyncComponentRender) {
            queue.push(_renderView);
            queue.push(_postRender);
          }
          else {
            _renderView();
            _postRender();
          }
        }, 0);
      });
    }

    return view;
  };

  /**
   * The actual view creation step. It looks up the correct view for the
   * component based on the component's type property, and then creates the
   * view instance.
   *
   * @param {Number} index - The order of the component in the list of
   * required components.
   */
  Component.prototype.createView = function (index) {
    BVReporter.assert(function () { return [_(index).isNumber(), 'index is number']; });
    BVReporter.debug('Creating view for', this.componentId);

    var mappings = ENV.get('mappings');
    var View = _(mappings).has(this.type) ? mappings[this.type].view : null;
    var model = this.model;

    if (!View) {
      BVReporter.warn('No view for', this.componentId);
      return;
    }

    return new View({
      model: model,
      parent: {
        name: this.type,
        containerId: this.container,
        containerPrefix: this.containerPrefix || model.get('clientAPIConfig').containerPrefix,
        uniq: index
      },
      isTopView: true
    });
  };

  Component.prototype.setTopView = function (view) {
    this.view = view;
  };

  /**
   * Initializes the component's model.
   *
   * @param {Object} clientAPIConfig - the client ui configuration
   * @param {Object} initData - additional data from the ENV config
   */
  Component.prototype.initModel = function (initData) {
    BVReporter.debug('Initializing model for', this.componentId);

    var componentManager = ENV.get('componentManager');
    this.model = componentManager && componentManager.models ? componentManager.models()[this.uniqueId] : null;

    if (!this.model) {
      this.model = this.createModel(initData);
      this._initOutlets();
    }

    // Now that the model is initialized, see if there are any events in the
    // queue that it needs to respond to. (FIFO order)
    if (this._eventQueue.length > 0) {
      var eventData;
      while (this._eventQueue.length) {
        eventData = this._eventQueue.shift();
        this.trigger(eventData.event, eventData.data);
      }
    }

    return this.model;
  };

  /**
   * The actual model creation. It looks up the correct model for the
   * component based on the component's type property, and then creates an
   * instance of the model.
   *
   * Note that the component can provide its own apiName property if desired.
   *
   * @param {Object} clientAPIConfig
   * @param {Object} initData
   */
  Component.prototype.createModel = function (initData) {
    var clientAPIConfig = this.clientAPIConfig;

    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });
    BVReporter.debug('Creating model for component', this.componentId);

    var mappings = ENV.get('mappings');
    var Model = _(mappings).has(this.type) ? mappings[this.type].model : null;

    if (!Model) {
      BVReporter.warn('No model for', this.componentId, this.type, mappings);
      return;
    }

    var modelAPIConfig = _.extend({}, clientAPIConfig, {
      subjectType: this.subjectType,
      contentType: this.contentType,
      secondaryContentType: this.secondaryContentType
    });

    var config = {
      initData: initData,
      clientAPIConfig: modelAPIConfig,
      dimsumConfig: this.componentData,
      component: this
    };

    // Fetch alternate api client for component (if specified).
    if (this.apiName) {
      config.apiName = this.apiName;
    }

    return new Model(config);
  };

  /**
   * Sets up outlets associated with the component. Here's an example of an
   * outlet configuration for a component:
   *
   * "outlets" : {
   *   "showreviews" : [{
   *     "component" : "reviewContentList1",
   *     "event" : "scrolltocontent"
   *   }],
   *   "showquestionsubmission" : [{
   *     "component" : "questionSubmission1",
   *     "scope" : "qa",
   *     "action" : "submit_question"
   *   }]
   * }
   *
   * There are two kinds of outlets: actions and events. Both types of
   * outlets are triggered by an event on the component's model. For example,
   * in the example above, if the top model triggers a showreviews event, an
   * 'outlet:showreviews' event will get triggered on the model's component, which
   * it will end up triggering the 'outlet:scrolltocontent' event on the
   * reviewContentList1 component. For the second outlet, when the component's
   * model triggers the showquestionsubmission event, 'outlet:showquestinsubmission'
   * will be triggred on the model's component, which will result in a $BV.ui call.
   */
  Component.prototype._initOutlets = function () {
    var outlets = this.outlets;
    var self = this;
    if (this._registeredOutlets) {
      this._detachOutlets();
    }

    var registeredOutlets = this._registeredOutlets = [];

    if (_(outlets).isEmpty()) {
      return;
    }

    _(outlets).each(function (targets, key) {
      _(targets).each(function (target) {
        var outlet = new Outlet({
          originatingComponent: self,
          target: target,
          key: key
        });
        registeredOutlets.push(outlet);
      });
    });

    if (this._scheduledEvents) {
      _(this._scheduledEvents).each(function (event) {
        this.trigger('outlet:' + event);
      }, this);
      this._scheduledEvents = [];
    }
  };

  /**
   * Detach outlets from the model.
   */
  Component.prototype._detachOutlets = function () {
    _(this._registeredOutlets).invoke('detach');
  };

  /**
   * Reset the component.
   * This includes:
   *  - Destroy top model and its subModels
   *  - Empty top view and its subViews
   */
  Component.prototype.reset = function () {
    BVReporter.group(BVReporter.INFO, 'Reset Component', this.componentId);

    this._detachOutlets();
    this.clear();

    if (this.view) {
      this.view.remove();
    }
    if (this.model) {
      this.model.destroy();
    }

    delete this.model;
    delete this.view;

    BVReporter.groupEnd(BVReporter.INFO, 'Reset Component');
  };

  /**
   * Recreate a new model and a new view for the component.
   *
   * For components like full profile and media viewer, they
   * often display different data.
   * In order to make sure we don't display staled data,
   * creating a new model with new data, and render it in a new view
   * is the most safe solution.
   */
  Component.prototype.restore = function () {
    var viewParentUniq = this.view.parent.uniq;
    var componentManager = ENV.get('componentManager');
    componentManager.reset(this);

    var model = this.initModel();
    /**
     * 2nd argument is ComponentManager.injectionZoneReadyDfds.
     * 3rd argument is ComponentManager.domReadyDfd.
     * Since this function only happenes after the app is loaded,
     * we don't need to wait for all these deferreds.
     */
    var view = this.initView(viewParentUniq, [], $.Deferred().resolve());

    componentManager.models()[this.uniqueId] = model;
    componentManager.views()[this.uniqueId] = view;

    // TODO:  We shall probably revisit bv:initReady.
    // It is originally designed for setting correct relationship
    // between contentSort & contentList.
    ENV.trigger('bv:initReady');
  };

  /**
   * Triggers the pageto event on the component's model if the model is an
   * auload model and:
   *
   * - there is no currentPage for the model OR
   * - the target page is not 1 and is different from the currentPage for the
   *   model
   *
   * @param {Number} pageNum - the target page number for the model
   */
  Component.prototype.triggerAction = function (pageNum) {
    BVReporter.assert(this.model, 'model exists on component');
    BVReporter.debug('Triggering action on component', this.componentId);

    var pageTo = pageNum || ENV.get('config').page.initPageNum || 1;
    var model = this.model;
    var modelCurrentPage = this.get(Scoped('currentPage', model.getContentType()));

    // There is one exception for condition 2.  That is the route.
    // When route sets page number (if it is not page 1), we won't want to
    // fetch page 1 again to reinject the content.
    if (
      model.get('autoload') &&
      (!modelCurrentPage || (pageTo !== modelCurrentPage && pageTo !== 1))
    ) {
      model.publish('pageto', pageTo);
    }
  };

  /**
   * Determines whether rendering the component is required, based on the
   * desired UI action and the list of required outlets. Also potentially
   * overrides the component's inject property as follows:
   *
   * - true if the component is required by the desired UI action
   * - false if the component is required by an outlet AND is a shared
   *   component
   *
   * @param {String} actionKey - The desired UI action
   * @param {Object} uiActions - An object containing all possible UI actions,
   * and their corresponding components
   * @param {Array} allOutlets - An array containing all of the required
   * outlets.
   * @param {Array} sharedComponentTypes - An array containing components that
   * can be shared by multiple top-level components.
   *
   * @returns {Boolean} A value indicating whether render is required. True if
   * the component is required by the desired UI action or if it's required by
   * one of the resulting outlets; false otherwise.
   */
  Component.prototype.isRenderRequired = function (actionKey, uiActions, allOutlets, sharedComponentTypes) {
    var listedComponents = uiActions[actionKey];

    if (_(listedComponents).contains(this.componentId)) {
      this.inject = true;
      return true;
    }

    if (_(allOutlets).contains(this.componentId) && _(sharedComponentTypes).contains(this.type)) {
      this.inject = false;
      return true;
    }

    return false;
  };

  /**
   * Renders the view.
   *
   * @param {Object} injectionZoneReadyDfds
   * @param {Object} domReadyDfd
   * @param {Boolean} doNotDefer - If true, this method will not re-try
   * render once the component's injectionZoneReadyDfd has resolved.
   *
   * @returns {Boolean} True if the render was successful, false otherwise.
   */
  Component.prototype.renderView = function (injectionZoneReadyDfds, domReadyDfd, doNotDefer) {
    var config = ENV.get('config');
    var view = this.view;
    var self = this;

    function _renderView (view, done) {
      function _render () {
        if (self._asyncRender) {
          view.renderAsync().done(done);
        }
        else {
          view.render();
          done();
        }
      }

      // Hopefully temporary for UIA-5586, defer render *only* for BVL until we know whether
      // the BVL node is disabled, which we determine by hooking into the data extension.
      if (bvLocal.isBVLocal()) {
        bvLocal.shouldRender().done(function (shouldRender) {
          if (shouldRender) {
            _render();
          }
          else {
            BVReporter.error('Bazaarvoice Local is disabled for this node. Contact Bazaarvoice for support.');
          }
        });
        return;
      }

      _render();
    }

    BVReporter.assert(function () { return [_(injectionZoneReadyDfds).isObject(), 'injectionZoneReadyDfds is object']; });
    BVReporter.assert(function () { return [view && _(view.render).isFunction(), 'view is defined']; });
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(!!domReadyDfd.promise, 'domReadyDfd is promise');

    BVReporter.debug('Rendering view for', this.componentId);

    if (!window.BV.serverRender) {

      performance.mark(this.componentId + '-render-start');

      // Since we now completely rely on our polyfill for marks, scoutStart
      // _should_ always exist. However, we still need to check gently because
      // this is in the direct rendering path.
      var scoutStart = performance.getEntriesByName('scoutStart')[0];
      if (!scoutStart) {
        BVReporter.warn('performance does not have a scoutStart mark');
      }
      else {
        performance.measure(
          this.componentId + '-render-ready',
          'scoutStart',
          this.componentId + '-render-start'
        );
      }
    }

    if (!this.container) {
      _renderView(view, function () {
        if (!window.BV.serverRender) {
          performance.mark(self.componentId + '-render-end');
          performance.measure(
            self.componentId + '-render',
            self.componentId + '-render-start',
            self.componentId + '-render-end'
          );
        }
      });
      return true;
    }

    var selector = '#' + this.container;
    var $el = $(selector);
    var cssLoaded = ENV.get('cssLoaded');

    // If we have the element available, inject immediately
    if ($el.length) {
      // If the server has already rendered the page, supply the el to attach to
      if (!config.page.reInject) {
        view.attach($el[0]);
        this.trigger('viewRendered');
        return true;
      }

      view.detach();
      view.setElement($el.empty()[0]);

      cssLoaded
        .done(function () {
          _renderView(view, function () {
            self.trigger('viewRendered');

            if (!window.BV.serverRender) {
              performance.mark(self.componentId + '-render-end');
              performance.measure(
                self.componentId + '-render',
                self.componentId + '-render-start',
                self.componentId + '-render-end'
              );
            }
          });
        });

      return true;
    }

    if (doNotDefer) {
      // we've already deferred the render once; don't defer it again,
      // even if we didn't find an element
      BVReporter.warn('Failed to render view for ', this.componentId);
      self.trigger('viewFailedToRender');
      return false;
    }

    // If we don't have an element, wait until doc ready, then try again
    var renderDfd;

    _(config.injectionZone).find(function (zones, key) {
      var result = _(zones).contains(view.componentId);
      if (result) {
        renderDfd = injectionZoneReadyDfds[key];
      }
      return result;
    });

    if (!renderDfd) {
      renderDfd = domReadyDfd;
    }

    renderDfd.done(_.bind(function () {
      Component.prototype.renderView.apply(this, [injectionZoneReadyDfds, domReadyDfd, true]);
    }, this));

    return false;
  };

  /**
   * Register a view after it has been initialized.
   *
   * Views call this method automatically when they initialize themselves.
   *
   * @param {BView} view
   */
  Component.prototype.registerView = function (view) {
    var parent = view.parent;
    var hashId = [parent.name, parent.uniq, view.name, view.uniq].join('_');
    if (!this.views[hashId]) {
      this.views[hashId] = {};
    }
    this.views[hashId][view.uniq] = view;
  };

  /**
   * Get the scope of the component.
   *
   * @param {String} contentType
   *
   * @returns {String} component scope
   * E.g. BVRRContainer[reviewContentList1<Reviews>]
   */
  Component.prototype.getScope = function (contentType) {
    contentType = ContentType.Nouns(contentType || this.contentType);
    return this.container + '[' + this.componentId + '<' + contentType + '>]';
  };

  /**
   * Determines if a component has a particular feature.
   *
   * @param {String} the feature owner's name
   * @param {String} the lookup feature's name
   * @param {String} the content type of the lookup feature
   * @param {String} the instance name that we are looking for.
   * @param {String} the feature type that we are looking for.
   *                 If undefined, we will look for 'model', 'view', and 'has' types.
   *
   * @returns {Boolean} True if the feature exists, false otherwise.
   */
  Component.prototype.hasFeature = function (parentName, featureName, contentType, instanceName, featureType) {
    return hasFeature(this, parentName, featureName, contentType, instanceName, featureType);
  };

  /**
   * Returns an event name scoped to the content type of the component.
   * @param  {String} event The event to scope.
   * @return {String}       An event scoped with the component's content type.
   */
  Component.prototype.scopeEvent = function (event) {
    return Scoped(event, ContentType.Nouns(this.contentType));
  };

  /**
   * Triggers an event that is the result of responding to a route. These
   * events are special because they need to be acted on by the model, and if
   * the model doesn't yet exist, they'll fire without any result. So if the
   * component's model doesn't exist yet, the component adds the event to a
   * queue so that the model can handle it after initialization.
   * @param {String} event The event (must be manually scoped with scopeEvent).
   * @param {String} data The data associated with the event.
   *
   * @returns {Object} The component itself (for chaining).
   */
  Component.prototype.triggerRouteEvent = function (event, data) {
    if (this.model) {
      this.trigger(event, data);
    } else {
      // Add it to the queue for handling later.
      this._eventQueue.push({ event: event, data: data });
    }
    return this;
  };

  Component.prototype._monitorVisibility = function () {
    var self = this;

    this.once('viewRendered', function () {
      function createHandler (type) {
        return function (viewObserved, elapsedMs) {
          BVTracker[type]({
            detail1: viewObserved,
            elapsedMs: elapsedMs
          }, self);
        };
      }

      // Make sure we only send inView and viewedUGC events if we have content
      if (self.model.get('TotalResults')) {
        var visibilityObserver = new VisibilityObserver({ el: self.view.el });
        // Fire inView and viewedUGC events once the content is visible
        visibilityObserver.on('firstVisible', createHandler('inView'));
        visibilityObserver.on('fullyVisible', createHandler('viewedUGC'));
      }
    });
  };

  /**
   *  Indicates whether the component should process data asynchronously.
   *
   *  @returns {Boolean} Whether async data processing is enabled.
   */
  Component.prototype.isAsyncDataProcessing = function () {
    // Synchronous unless the experimental feature is enabled.
    if (!this._asyncDataProcessing) {
      return false;
    }
    // Even if the feature is enabled, we're only async on initial render.
    return !this._rendered;
  };

  return Component;
});

/**
 * @fileOverview A module for managing our injection zones.
 */
BV.define('framework/binjectionzone',[
  'underscore',
  'jquery',
  'vendor/fastclick'
], function (_, $, FastClick) {
  function preventHashLinks (event) {
    event.preventDefault();
  }

  function applyContainerDelegation ($containerElement, $fastClickEl) {
    new FastClick($fastClickEl.get(0));
    $containerElement.on('click', 'a[href="#"]', preventHashLinks);
  }

  function createElementForContainer (container) {
    return $('<div/>').attr('id', container);
  }

  var InjectionZone = function (config) {
    var containers = [];
    var zone = config.zone;
    var components = config.components;

    this.dfd = new $.Deferred();
    this.$temporaryElement = $('<div />');

    // find all required containers defined in injectionZone.

    _(zone).each(function (component) {
      var requiredComponent = components[component];

      if (requiredComponent && requiredComponent.container) {
        containers.push(requiredComponent.container);
      }
    });

    this.injected = this._createContainers(containers, config.key, config.isDomReady);
  };

  InjectionZone.prototype._createContainers = function (containers, key, isDomReady) {
    // for each required container, we need to check if they exists
    // If the container exists, do nothing; else, create a DIV and append to the current container.
    _(containers).each(function (container) {
      var $containerElement = $('#' + container);
      var currentHtml;
      var $fastClickEl = $containerElement;

      if (!$containerElement.length) {
        $containerElement = createElementForContainer(container)
          .appendTo(this.$temporaryElement);
        $fastClickEl = this.$temporaryElement;
      }
      else if (container === key) {
        currentHtml = $containerElement.html();
        $containerElement = createElementForContainer(container)
          .html(currentHtml)
          .appendTo(this.$temporaryElement);

        // Recent versions of jQuery no longer strip SCRIPT tags before
        // re-inserting them into the page. If we don't strip SCRIPT tags
        // manually, we run the risk of re-evaluating the very script that
        // triggered the UI action we are now responding to, and causing an
        // infinite loop in the process. See UIA-6421.
        this.$temporaryElement.find('script').remove();

        $fastClickEl = this.$temporaryElement;
      }

      applyContainerDelegation($containerElement, $fastClickEl);
    }, this);

    var $foundElement = $('#' + key);

    if ($foundElement.length) {
      $foundElement.replaceWith(this.$temporaryElement.children());
      this.dfd.resolve();
      return true;
    }
    else {
      if (isDomReady) {
        this.dfd.resolve();
        return true;
      }
      else {
        return false;
      }
    }
  };

  return InjectionZone;

});

BV.define('framework/componentManager',[
  'underscore',
  'framework/bcomponent',
  'framework/binjectionzone',
  'ENV',
  'jquery',
  'framework/util/bvreporter'
], function (
  _,
  BComponent,
  InjectionZone,
  ENV,
  $,
  BVReporter
) {
  var domReadyDfd = $.Deferred();
  var _models = {};
  var _views = {};

  // Use domReady deferred to make sure "injection zone" modification is
  // done after the dom is ready.
  $(domReadyDfd.resolve);

  /**
   * Components used by more than one top-level component.
   */
  var sharedComponentTypes = ['contentSort', 'fullProfile', 'mediaViewer'];

  /**
   * @constructor
   * A ComponentManager instance is basically a wrapper for performing tasks on
   * all components at once. It's responsible for creating individual component
   * instances, and provides methods for interacting with all components at
   * once. For the most part, you'll want to consult BComponent for details on
   * what the individual methods do.
   *
   * @param {Object} componentData - A config object containing details on how
   * to set up all of the components.
   * @param {Boolean} serverRender - True if called in a serverRender context.
   */
  var ComponentManager = function (componentData, serverRender) {
    BVReporter.assert(function () { return [_(componentData).isObject(), 'componentData is object']; });
    BVReporter.debug('Initializing component manager');

    this.isServerRender = !!serverRender;

    this.components = {};
    this.requiredRenderComponents = {};
    this.domReadyDfd = domReadyDfd;
    this.injectionZoneReadyDfds = {};

    BVReporter.group(BVReporter.INFO, 'Component Initialization');

    _(componentData).each(function (cd, componentName) {
      var c = new BComponent(cd);
      this.components[componentName] = c;
    }, this);
    BVReporter.groupEnd(BVReporter.INFO, 'Component Initialization');

    return this;
  };

  ComponentManager.prototype.models = function () {
    return _models;
  };

  ComponentManager.prototype.views = function () {
    return _views;
  };

  /**
   * A helper for iterating over the components.
   *
   * @param  {Function} fn      The function to run on each component. Receives the
   *                            component object and the component name as arguments.
   * @param  {Object}   context Context in which to run the function.
   */
  ComponentManager.prototype.forEach = function (fn, context) {
    _(this.components).each(fn, context);
  };

  ComponentManager.prototype.each = ComponentManager.prototype.forEach;

  /**
   * A helper for finding a component by ID or function.
   *
   * @param  {Function|string} fn      A function or component ID to use to locate
   *                                   the desired component.
   * @param  {Object} [context]        The context in which to run the function
   * @return {BComponent}
   */
  ComponentManager.prototype.find = function (fn, context) {
    if (_(fn).isFunction()) {
      return _(this.components).find(fn, context);
    }

    // if a function wasn't passed, assume an id was passed
    var id = fn;

    return this.components[id];
  };

  /**
   * Returns the router component after setting the clientAPIConfig property on
   * it.
   *
   * @param {Object} clientAPIConfig
   */
  ComponentManager.prototype.getRouter = function (clientAPIConfig) {
    var router = _(this.components).chain().values().find(function (c) {
      return c.isRouter;
    }).value();

    if (router) {
      router = router.componentData;
      router.clientAPIConfig = clientAPIConfig;
      return router;
    }

    return {};
  };

  /**
   * Given a UI action, determine the components that will need to be rendered.
   * We cache the return value, because the calculation is expensive and
   * the result doesn't change for a given UI action.
   *
   * @param {String} method - The desired UI action
   * @param {Object} uiActions - All possible UI actions and their associated
   * components.
   *
   * @returns {Array} The components that need to be rendered.
   */
  ComponentManager.prototype.getClientRenderComponents = function (method, uiActions) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(uiActions).isObject(), 'uiActions is object']; });
    BVReporter.debug('ComponentManager getting client render components');

    var listedComponents = uiActions[method];
    var memoizeKey = method;
    var allOutlets = [];

    if (!this.requiredRenderComponents[memoizeKey]) {

      // ask all the components for their outlets
      BVReporter.group(BVReporter.INFO, 'Getting outlets for render components');
      _(this.components).each(function (c) {
        allOutlets = _(allOutlets).union(c.getOutlets(method, uiActions));
      });
      BVReporter.groupEnd(BVReporter.INFO, 'Getting outlets for render components');

      // we can't just use the outlets list though ... we need to only return
      // the components that we actually know about, so we'll iterate over the
      // known components, use allOutlets to determine whether they're
      // required, and sort them by their sort string, which puts autoloaded
      // components first.
      //
      // fwiw, this could probably be cleaned up more.
      this.requiredRenderComponents[memoizeKey] = _(this.components).chain().values()
        .sortBy(function (c) { return c.sortString; })
        .filter(function (c) {
          return c.isRenderRequired(method, uiActions, allOutlets, sharedComponentTypes);
        })
        .value();
    }
    return this.requiredRenderComponents[memoizeKey];
  };

  /**
   * Get the components required for server render. This calculation is a lot
   * simpler than the one for the client; we just exclude any components in the
   * excludeFromRender list defined at the top of this file, and otherwise
   * render everything else, sorted with autoload components first.
   */
  ComponentManager.prototype.getServerRenderComponents = function () {
    BVReporter.debug('ComponentManager getting server render compnents');

    return _(this.components).chain().values()
      // Sort components by componentId, with the autoload ones at the beginning.
      .sortBy(function (c) { return c.sortString; })
      .filter(function (c) { return c.serverRender; })
      .value();
  };

  /**
   * Get the componentIds of components that need to be injected.
   */
  ComponentManager.prototype.getInjectComponents = function (method, uiActions) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(uiActions).isObject(), 'uiActions is object']; });
    BVReporter.debug('ComponentManager getting inject components');

    var requiredComponents = this.getClientRenderComponents(method, uiActions);

    return _(requiredComponents).chain()
      .filter(function (c) { return c.inject; })
      .pluck('componentId')
      .value();
  };

  /**
   * Run the updateContainers method of all components.
   *
   * @param {String} method - The desired UI action.
   * @param {Object} config - The ENV config
   * @param {Object} clientAPIConfig - The client UI config.
   */
  ComponentManager.prototype.updateContainers = function (method, config, clientAPIConfig) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });
    BVReporter.group(BVReporter.INFO, 'Updating containers');

    var requiredComponents = this.getClientRenderComponents(method, config.uiActions);

    _(requiredComponents).each(function (c) {
      c.updateContainer(config, clientAPIConfig);
    });

    BVReporter.groupEnd(BVReporter.INFO, 'Updating containers');
  };

  /**
   * Run the initModel method of all components, and trigger bv:initready once
   * they're all init'd. Listen for all the models to report that their init is
   * complete (via the initReadyDfd), and then resolve the global
   * modelsInitializedDfd.
   *
   * @param {String} method - The desired UI action.
   * @param {Object} config - The ENV config
   * @param {Object} clientAPIConfig - The client UI config.
   *
   * @returns {Object} An object with the components' uniqueIds as keys, and
   * the corresponding models as values.
   */
  ComponentManager.prototype.initModels = function (method, config, clientAPIConfig) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });
    BVReporter.group(BVReporter.INFO, 'Init Models');

    var requiredComponents = this.getClientRenderComponents(method, config.uiActions);
    var modelDfds = [];
    var models = {};

    _(requiredComponents).each(function (component) {
      // component saves clientAPIConfig
      component.clientAPIConfig = clientAPIConfig;
      var model = _models[component.uniqueId];
      if (model && !component.createOnce) {
        this.reset(component);
        model = null;
      }
      model = model || component.initModel(config.initData);
      modelDfds.push(model.initializedPromise());
      models[component.uniqueId] = model;
    }, this);

    ENV.trigger('bv:initReady');

    $.when.apply($, modelDfds).done(function () {
      ENV.get('modelsInitializedDfds')[method].resolve();
    });

    _models = _(_models).extend(models);

    BVReporter.groupEnd(BVReporter.INFO, 'Init Models');
    return models;
  };

  /**
   * Reset component.
   * This includes:
   *  - Destroy top model and its subModels
   *  - Empty top view and its subViews
   *  - Delete model and view from _models and _views
   *
   * @param {Object} component - The reset component.
   */
  ComponentManager.prototype.reset = function (component) {
    component.reset();
    delete _models[component.uniqueId];
    delete _views[component.uniqueId];
  };

  /**
   * Run the initViews method of all components.
   *
   * @param {String} method - The desired UI action.
   * @param {Object} config - The ENV config
   * @param {Object} clientAPIConfig - The client UI config.
   *
   * @returns {Object} An object with the components' uniqueIds as keys, and
   * the corresponding views as values.
   */
  ComponentManager.prototype.initViews = function (method, config, clientAPIConfig) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.assert(function () { return [_(clientAPIConfig).isObject(), 'clientAPIConfig is object']; });
    BVReporter.group(BVReporter.INFO, 'Init Views');

    var views = {};
    var requiredComponents = this.getClientRenderComponents(method, config.uiActions);
    var dfds = this.injectionZoneReadyDfds;
    var viewsToRender = 0;
    var viewsRendered = 0;
    var dfd = $.Deferred();

    function viewDidRender () {
      viewsRendered++;

      if (viewsToRender === viewsRendered) {
        BVReporter.info('Views rendered for', method, requiredComponents);
        ENV.trigger('init:viewsRendered', method);
        dfd.resolve(views);
      }
    }

    _(requiredComponents).each(function (c, index) {
      c.clientAPIConfig = clientAPIConfig;
      var view = _views[c.uniqueId] || c.initView(index, dfds, this.domReadyDfd);
      var model = c.model;
      views[c.uniqueId] = view;

      if (c.autoload) {
        viewsToRender++;
        c.on('viewRendered', viewDidRender, c);

        // UIA-4688: Even if the view fails to render, we need to call
        // viewDidRender, so that we trigger the viewsRendered event.
        // Otherwise, clients missing a container (e.g., walmart canada is
        // missing the summary container) will have problems because the reviews
        // section never reports that it is fully rendered.
        c.on('viewFailedToRender', viewDidRender, c);
      }
    }, this);

    _views = _(_views).extend(views);

    BVReporter.groupEnd(BVReporter.INFO, 'Init Views');

    return dfd.promise();
  };

  /**
   * An injection zone is a container into which we'll end up putting component
   * views. For example, an entry in config.injectionZone might look like this:
   *
   *   BVQAContainer: [ "contentSearch1", "questionContentList1" ]
   *
   * So, eventually, the app will try to put these two components in an element
   * with the ID of "BVQAContainer".
   *
   * This method figures out which zones are actually needed, by looking at the
   * intersection between the components required for a zone and the components
   * that are marked for injection. It creates a deferred for all zones (?),
   * then hands the needed zones to the _initInjectionZones method to be
   * initialized.
   *
   * @param {String} method - The desired UI method
   * @param {Object} config - The ENV config
   */
  ComponentManager.prototype.prepareInjectionZones = function (method, config) {
    BVReporter.assert(function () { return [_(method).isString(), 'method is string']; });
    BVReporter.assert(function () { return [_(config).isObject(), 'config is object']; });
    BVReporter.debug('ComponentManager preparing injection zones');

    var zones = config.injectionZone;
    var neededZones = {};
    var injectComponents = this.getInjectComponents(method, config.uiActions);
    var dfds = this.injectionZoneReadyDfds;

    _(zones).each(function (zones, key) {
      dfds[key] = $.Deferred();
    });

    _(zones).each(function (zoneComponents, key) {
      if (_.intersection(zoneComponents, injectComponents).length && dfds[key].state() !== 'resolved') {
        neededZones[key] = zoneComponents;
      }
    });

    this._initInjectionZones(neededZones);
  };

  /**
   * This method creates containers for individual components if they don't
   * already exist. It's called by the prepareInjectionZones method above.
   */
  ComponentManager.prototype._initInjectionZones = function (zones, isDomReady) {
    var missingInjectionZone = {};
    var dfds = this.injectionZoneReadyDfds;
    var self = this;
    var components = this.components;

    _(zones).forEach(function (zone, key) {
      var injectionZone = new InjectionZone({
        zone: zone,
        key: key,
        isDomReady: isDomReady,
        components: components
      });

      if (!injectionZone.injected) {
        missingInjectionZone[key] = zone;

        if (isDomReady) {
          dfds[key].resolve();
          delete missingInjectionZone[key];
        }
      }
      else {
        dfds[key].resolve();
      }
    }, this);

    if (!_(missingInjectionZone).isEmpty()) {
      this.domReadyDfd.done(function () {
        self._initInjectionZones(missingInjectionZone, true);
      });
    }
  };

  /**
   * Restore an array of components.
   *
   * Steps involved are
   *   1. Reset components.
   *   2. Create models.
   *   3. Trigger "bv:initReady".
   *   4. Create views.
   *
   * This function is added because component.restore could not solve
   * contentList issues.  ContentSort sets up itself inside contentList.
   * Preserve the sequence of models -> trigger -> views is required.
   *
   * TODO: DRY this out a bit; there is also currently a Component.prototype.restore
   * with a similar purpose
   */
  ComponentManager.prototype.restore = function (components) {
    var self = this;
    var viewParentUniq = [];
    _(components).forEach(function (comp, i) {
      viewParentUniq[i] = comp.view.parent.uniq;
      self.reset(comp);
      _models[comp.uniqueId] = comp.initModel();
    });

    ENV.trigger('bv:initReady');

    _(components).forEach(function (comp, i) {
      _views[comp.uniqueId] = comp.initView(viewParentUniq[i], [], $.Deferred().resolve());
    });
  };

  return ComponentManager;
});

BV.define('framework/util/filteredAPIData',[
  'ENV',
  'underscore',
  'framework/util/bvreporter'
], function (ENV, _, BVReporter) {
  var references = ENV.get('references');

  /**
   * Fetches and filters data from the reference cache for a given subjectType and ID.
   *
   * @param  {String}   subjectType         The subject type to fetch.
   * @param  {String}   subjectId           The subject ID to fetch.
   * @param  {Array}    props (optional)    A list of properties to pick from the returned object.
   * @param  {Function} cb (optional)       A callback to be called on the filtered data.
   *
   * @return {Deferred}                     A deferred that will be resolved with the filtered data.
   */
  return function (subjectType, subjectId, props, cb) {
    BVReporter.assert(subjectType, 'subjectType is defined');
    BVReporter.assert(subjectId, 'subjectId is defined');

    var req = references.get(subjectType, subjectId).then(function (rawData) {
      return props && props.length ? _(rawData).pick(props) : rawData;
    });

    if (_(cb).isFunction()) {
      req.done(cb);
    }

    return req;
  };
});

BV.define('framework/clientEvents',[
  'client!window',
  'bv/util/baseConfig',
  'framework/util/bvreporter',
  'framework/util/filteredAPIData',
  'backbone',
  'underscore',
  'BV'
], function (window, baseConfig, BVReporter, filteredAPIData, Backbone, _, BV) {
  /**
   * This is the event bus for exposing events to customers. A customer can
   * include an events property in their global configuration whose value is an
   * object. The object's keys are event names; the values are the callbacks for
   * those events. See the publicEvents object below for a list of supported
   * events.
   *
   * $BV.configure('global', {
   *   events : {
   *     bvRender : function (data) {
   *       console.log(data.method);
   *     }
   *   }
   * });
   *
   * Private events can be issued; any event with a name that isn't in the
   * publicEvents object will be treated as private. It will be added to the
   * recent event log but not otherwise acted on.
   *
   * @type {Object} eventObj
   */

  /**
   * Clients depend on these fields being present in the object that is returned
   * to them. We must not remove items from this list; we should only add items
   * to this list.
   *
   * @type {Array}
   */
  var productProperties = [
    'Id',
    'TotalContentCount',
    'TotalReviewCount',
    'TotalAnswerCount',
    'TotalQuestionCount'
  ];

  /**
   * This is a list of public events that we will expose to customers. If the
   * property points to an array, then we will do a lookup in the reference
   * cache using the clientAPIConfig object that is passed when the event is
   * triggered; we'll then _.pick() only the properties in the array from what
   * is returned, and provide that filtered object to the customer as the first
   * argument in the callback.
   *
   * So, if some code does this:
   *
   *     ClientEvents.trigger('reviewSubmissionLoad', clientAPIConfig, { extra : 'data' });
   *
   * then we will use the subjectType and <subjectType>Id from the
   * clientAPIConfig to look up the data in the reference cache. We'll then
   * trigger the customer-facing event with an object that contains only the
   * properties listed in the productProperties array.
   *
   * @type {Object}
   */
  var publicEvents = {
    submissionLoad: productProperties,
    submissionSubmitted: productProperties,
    submissionClose: productProperties,
    bvRender: 1,
    error: 1
  };

  var ClientEvents = _.extend({}, Backbone.Events);

  ClientEvents = _.extend(ClientEvents, {
    eventProperties: {
      product: productProperties
    },

    // For keeping a log of recent events.
    //
    // This can be used for verification in tests; it isn't intended to be used
    // in any other way.
    recent: [],

    register: function (eventObj) {
      BVReporter.assert(function () { return [_.isObject(eventObj), 'event object is object']; });
      this.on(eventObj);
    },

    trigger: function (event, data, extras) {
      // All events are stashed to the recent event log, which is truncated
      // when it gets too long.
      var logEntry = this.recent[this.recent.length] = {
        name: event,
        data: data,
        extras: extras,
        timestamp: new Date().getTime()
      };

      if (this.recent.length > 20) {
        this.recent = _.rest(this.recent, 1);
      }

      // Only trigger public events, unless we are set to trigger private events
      // as well.
      if (!BV.options.triggerPrivateEvents && !publicEvents[event]) {
        return;
      }

      var self = this;
      var type = data.subjectType;
      var id = type && data[type + 'Id'];

      function cb (obj) {
        obj = _.extend(obj, extras);
        BVReporter.info('Triggering client event', event, obj);
        Backbone.Events.trigger.apply(self, [event, obj]);
      }

      try {
        if (type && id) {
          // Look up the data in the reference cache if we have the information to do it.
          filteredAPIData(type, id, publicEvents[event]).then(cb);
          return;
        }

        // Otherwise, just trigger with the raw data that was passed in.
        cb(data);
      }
      catch (err) {
        // Catch and notify through our mechanisms
        BVReporter.warn('Error in client event for ' + event + ': ' + err.message);
        logEntry.error = err;

        // Keep the error going, so the client is aware,
        // but do so on the next turn so that we can keep going.
        _.defer(function () { throw err; });
      }
    },

    uiActionComplete: function (method, data) {
      var obj = _.clone(data);
      obj.method = method;

      Backbone.Events.trigger.apply(this, ['bvRender', obj]);
    },

    _publicEvents: function () {
      return _.keys(publicEvents);
    }
  });

  return ClientEvents;
});

BV.define('framework/uiActionResolver',[
  'underscore',
  'framework/util/bvreporter',
  'framework/clientEvents',
  'framework/util/filteredAPIData'
], function (_, BVReporter, ClientEvents, filteredAPIData) {
  var productProperties = ClientEvents.eventProperties.product;

  var clientObjectProperties = {
    rr_show_reviews: productProperties,
    qa_show_questions: productProperties
  };

  var UIActionResolver = function (options) {
    BVReporter.assert(options.clientAPIConfig, 'clientAPIConfig option is set');
    BVReporter.assert(!!options.initViewsPromise, 'initViewsPromise is set');

    if (!options.clientAPIConfig.loadedDeferred) {
      return this;
    }

    this.clientAPIConfig = options.clientAPIConfig;
    this.method = options.method;

    options.initViewsPromise.done(_(this.resolve).bind(this));
  };

  UIActionResolver.prototype.resolve = function () {
    var type = this.clientAPIConfig.subjectType;
    var id = this.clientAPIConfig[type + 'Id'];
    var loadedDfd = this.clientAPIConfig.loadedDeferred;
    var self = this;

    function cb (data) {
      loadedDfd.resolve(data);
      ClientEvents.uiActionComplete(self.method, data);
    }

    if (clientObjectProperties[this.method]) {
      filteredAPIData(type, id, clientObjectProperties[this.method]).then(cb);
      return;
    }

    cb({});
  };

  return UIActionResolver;
});

BV.define('bv/util/urlstate',[
  'underscore',
  'window',
  'framework/util/bvtracker',
  'bv/strings'
], function (_, window, BVTracker, str) {

  function getParams (search, prefix) {
    var results = {};
    prefix = prefix || '';
    if (search) {
      _(search.split('&')).forEach(function (keyVal) {
        var splitParam = keyVal.split('=');
        var key = splitParam[0];
        if (key.indexOf(prefix) === 0) {
          try {
            results[key.substr(prefix.length)] = (splitParam[1] !== undefined) ? decodeURIComponent(splitParam[1]) : undefined;
          }
          catch (e) {
            // In case of invalid URI component
            results[key.substr(prefix.length)] = '';
            BVTracker.error({
              name: str.errors.IMPLEMENTATION,
              detail1: 'Invalid URI component',
              detail2: keyVal
            });
          }
        }
      });
    }
    return results;
  }

  function getQueryParams (searchStr) {
    // Take in a string to search for query parameters. Default to the URL parameters.
    return getParams(searchStr || window.location.search.substr(1));
  }


  // Supports parsing the following:
  // 1. All data encoded in a single bvdata parameter (?bvdata=foo%3Dbar%26moo%3Dcow). Where 'bv' is the prefix.
  // 2. Data in separate URL parameters with BV prefix (?bvfoo=bar&bvmoo=cow). If bvdata exists, it has priority.
  // 3. Similar to #2 but in the hash instead (#bvfoo=bar&bvmoo=cow). These values have priority over #1/#2.

  function bvParams (prefix) {
    var urlParams = getParams(window.location.search.substr(1), prefix);
    var dataParams = prefix ? getParams(urlParams.data) : {};
    var hashParams = getParams(window.location.hash.substr(1), prefix);
    return _.extend(urlParams, dataParams, hashParams);
  }

  function getFromURLorHash (key, prefix) {
    return bvParams(prefix)[key];
  }

  var UrlState = {
    get: getFromURLorHash,
    bvParams: bvParams,
    queryParams: getQueryParams
  };

  return UrlState;
});

/**
 *  @fileOverview Routes actions based on the presence of query parameters
 *  in the URL.
 */
BV.define('bv/util/queryrouter',[
  'ENV',
  'underscore',
  'util/url',
  '$BV',
  'BV',
  'window',
  'jquery',
  'framework/util/bvreporter',
  'bv/util/urlstate',
  'bv/util/bvstate',
  'bv/util/bvstateManager',
  'bv/util/normalizeParams',
  'bv/util/baseConfig',
  'bv/api',
  'bv/util/domainPolice'
], function (
  ENV,
  _,
  url,
  $BV,
  BV,
  window,
  $,
  BVReporter,
  UrlState,
  BVState,
  BVStateManager,
  normalizeParams,
  baseConfig,
  api,
  domainPolice
) {

  var ENVConfig;

  // TODO: Find a way to consolidate this with the Backbone router. This
  // duplication is getting silly. -APD

  // Converts `bvstate` data to an internal route.
  //
  // NOTE: We throw out the subject type and the product ID, since the only
  // actionable parts are the content type and the page number. This is OK.
  // This is an internal route that won't actually be shown anywhere. -APD
  function translateBVStateToRoute (p) {
    // We need a page number _and_ a content type to use it on.
    if (!p.pg || !p.ct) { return; }
    return 'bvstate/' + p.ct + '/' + p.pg;
  }

  // Given `bvstate` data, attempts to trigger a route in the app router that
  // will know what to do with it.
  function triggerBVState (data) {
    var fragment = translateBVStateToRoute(data);
    // If there was no `bvstate` param, no fragment will be returned above.
    if (!fragment) { return; }

    var router = ENV.get('appRouter');
    // We can trigger both of these routes; only the one that it matches will
    // do something.
    router.matchFragmentToRoute(fragment, 'bvstateRR');
    router.matchFragmentToRoute(fragment, 'bvstateQA');
  }

  // If the page has a <link rel="canonical"> tag, and they've enabled a
  // setting in Config Hub, we should make sure that canonical URL has our
  // pagination data.
  function ensureCanonicalLinkValid (bvstate) {
    // We need a page number _and_ a content type to use it on.
    if (!bvstate.pg || !bvstate.ct) { return; }

    // Check if there's a LINK tag.
    var $link = $('link[rel=canonical]');

    // If so, grab its href, parse it with BVState, and check for equivalence.
    var href = $link.attr('href');
    var canonicalBvState = BVState.parseURL(href);

    // We could break here if bvstate and canonicalBvState were equal, but
    // they might have encoding differences, so let's carry on and make sure
    // it comes out the same every time

    // Change the LINK tag to reflect the `bvstate` data
    var newHref = BVState.updateURL(href, bvstate);
    BVReporter.info('Changing page\'s canonical URL from:', href, 'to:', newHref);
    $link.attr('href', newHref);
  }

  var oldSEOParamPattern = '([^\\/]+)\\/([^\\/]+)\\/([^\\/]+)\\/([^\\/]+)\\/([^\\/]+).htm';

  function withoutOldSEOParam (url) {
    // Matches ?bvqap=....&bvrrp=...
    var fullSEOParamPattern = new RegExp('[\\?&](bvqap|bvrrp)=' + oldSEOParamPattern, 'g');
    var matches = url.match(fullSEOParamPattern);

    function reducer (newUrl, match) {
      var prefixToKeep = match[0] === '?' ? '?' : '';
      return newUrl.replace(match, prefixToKeep);
    }

    return _.reduce(matches, reducer, url);
  }

  function ensureCanonicalLinkExists () {
    var $link = $('link[rel=canonical]');

    if ($link.length === 0) {
      $link = $('<link />').attr({
        rel: 'canonical',
        href: withoutOldSEOParam(window.location.href)
      });
      $link.appendTo('head');
    }
  }

  // Converts the old `bvrrp` and `bvqap` parameters to the new `bvstate`
  // style. See https://github.com/bazaarvoice/bv_seo/blob/master/docs/bvstate-seo-link-parameter.md.
  function oldSEOToBVState (contentType, fragment) {
    var match = fragment.match(new RegExp('^' + oldSEOParamPattern + '$'));
    if (!match) { return null; }
    try {
      var data = {
        pg: Number(match[4]),
        ct: api.noun(match[2])
      };

      if (data.ct !== contentType) {
        return null;
      }

      return isValidState(data) ? data : null;
    }
    catch (e) {
      // Ignore a bad query parameter, specifically content type, like 12345/nonsense/product/2/product1.htm
      return null;
    }
  }

  function triggerLoginEvent (userToken) {
    if (_($BV.setUser).isFunction() && domainPolice.thirdPartyCookieEnabled()) {
      // For shopper profile purposes, we will treat a received site-auth token as a successful login.
      // We will then associate the encrypted user id embedded in the token with the BVID of the current
      // browser (assuming we have a BVID). This correlation will take place on the back end, so all that
      // is required here is to send an event. -CFJ
      $BV.setUser(userToken);
    }
  }

  function isValidState (bvState) {
    if (!_.isObject(bvState)) {
      return false;
    }

    try {
      api.noun(bvState.ct);
    }
    catch (e) {
      // Bad content type
      return false;
    }

    return _.isNumber(bvState.pg);
  }

  var oldSEOTransforms = {
    // For `bvrrp` and `bvqap`, the `page` route of the app router used to do
    // most of the work, but the drawback was that only one component could
    // respond to it. Instead, let's adapt these to the new `bvstate` syntax
    // and that way everything can share a code path.
    //
    // Ignore unsupported content types like stories (`bvsyp`)
    bvrrp: _(oldSEOToBVState).partial('review'),

    bvqap: _(oldSEOToBVState).partial('question')
  };

  // These keys should be all lowercase.
  var routes = {

    bv_authtoken: function (token) {
      var APIConfig = ENV.get('config').apiconfig;
      APIConfig.authToken = token;
      // Wait for DOM ready to inject authUser
      $(function () {
        $BV.ui(
          'global',
          'auth_user',
          APIConfig
        );
      });
    },

    bvdata: function (data) {
      // Wait one tick so any user configuration from client API calls on the page is available
      setTimeout(function () {

        var apiConfig = ENV.get('config').apiconfig;
        var actionBaseConfig;
        var actionConfig;
        var actionParams;
        var actionType;
        var subAction;
        var actionSubType;
        var actionTargetType;

        data = url.toQueryParams(data);
        data = _.extend({}, apiConfig, normalizeParams(data));

        // Query actions have no knowledge of client api configuration on the page, other than what was passed
        // in the query string. To preserve any client defined callback functions, we lookup the client config
        // in baseConfig for whatever action the query string prescribes, then extend the existing config with the
        // query-derived config.
        actionParams = data.action ? data.action.split('_') : [];
        if (actionParams.length === 3) {
          // Parse out the ui call parts from the action string.
          // ex: 'rr_submit_review' --> actionType: 'rr', subAction: 'submit_review',
          // actionSubType: 'submit', actionTargetType: 'review'
          actionType = actionParams[0];
          subAction = _(actionParams).rest(1).join('_');
          actionSubType = actionParams[1];
          actionTargetType = actionParams[2];
          actionBaseConfig = ((baseConfig[actionType] || {})._actions) || {};
          actionConfig = actionBaseConfig[subAction];

          // Submission can be triggered from the "show_reviews/questions" ui call, so if there is no
          // explicit config for "submit_reviews" we should copy over the doShowContent function (if any) from
          // the "show" config to preserve the same behavior we'd get from clicking a button.
          if (!actionConfig && actionSubType === 'submit') {
            actionConfig = actionBaseConfig['show_' + api.nouns(actionTargetType)] || {};
            // Only copy important function properties in this case
            actionConfig = {
              doShowContent: actionConfig.doShowContent
            };
          }
        }
        data = _.extend({}, actionConfig, data);
        triggerLoginEvent(data.userToken);
        $BV.ui(data.scope, data.action, data);
      }, 0);
    },

    bvuserToken: function (userToken) {
      triggerLoginEvent(userToken);
    }
  };

  return {
    start: function () {
      ENVConfig = ENV.get('config');
      var queryParams = UrlState.queryParams();
      var self = this;

      function invokeIfQueried (fn, key) {
        var routeVal = queryParams[key];
        if (routeVal) {
          return fn.call(self, routeVal);
        }
      }

      function applySeoTransform (bvState, key) {
        var state = invokeIfQueried(oldSEOTransforms[key], key);
        return _(bvState).extend(state);
      }

      // Ensure bvrrp (reviews) has precedence when applied to bvstate by invoking last
      var oldSEORoutes = ['bvqap', 'bvrrp'];

      // Transform bvqap and bvrrp to a bvstate format
      var bvstate = _(oldSEORoutes).reduce(applySeoTransform, {});

      // Invoke all routes
      _(routes).forEach(invokeIfQueried);

      // Apply the `bvstate` param in the URL to the object here. If present,
      // it will override the inferred state from old SEO params.
      //
      // The `bvstate` parameter can be in the URL in several different ways.
      // Handle it separately.
      var stateFromParam = BVState.parseURL(window.location.toString());
      if (isValidState(stateFromParam)) {
        bvstate = stateFromParam;
      }

      // If a `bvstate` parameter is present, we should make sure that there
      // is a `link[rel=canonical]` tag and we should make sure that tag's HREF
      // includes the information in the `bvstate` parameter. Otherwise, for
      // instance, each separate page of reviews will get indexed by
      // Googlebot as all pointing to the same PDP URL.
      //
      // This feature is enabled by default in Config Hub.
      if (ENVConfig.queryRouter &&
           ENVConfig.queryRouter.editCanonicalTags &&
           !_.isEmpty(bvstate)) {
        ensureCanonicalLinkExists(bvstate);
        ensureCanonicalLinkValid(bvstate);
      }

      triggerBVState(bvstate);

      BVStateManager.start();
    }
  };

});

/**
 * This file is the vendor wrapper code provided by the analytics.js sdk and
 * should only be updated when the analytics.js source has been updated.
 * Current version: 3.1.2
 * https://github.com/bazaarvoice/analytics.js/blob/master/src/wrappers/analytics.js
 *
 * Again DO NOT MODIFY BELOW THIS COMMENT BLOCK.
 */

// Canonical wrapper for analytics.js.
//
// It's annoying to keep calling `window._bvaq.push`, so instead a consuming
// app may choose to include this small wrapper in their built JS. The
// wrapper doesn't need to know whether analytics.js is loaded, since all it
// does is call through to `window._bvaq.push`.
(function (root, factory) {
  if (typeof BV.define === 'function' && BV.define.amd) {
    // AMD. Register as an anonymous module.
    BV.define('vendor/bvAnalyticsWrapper',[], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // If imported via script tag in a browser, attach the constructor
    // as a global at window.bvaWrapper
    root.bvaWrapper = factory();
  }
}(this, function () {
  /**
   * Wrapper Constructor
   *
   * Creates a new wrapper.
   *
   * The `name` property is required. If `new Wrapper` is called a second time
   * with the same `name`, it will apply the given `config` to the existing
   * tracker. But be advised: that tracker will have existing state you may not
   * have anticipated.
   *
   * @param {[type]} config Object containing any tracker properties you want
   *   to create at setup. The `name` property is optional and will default to
   *   a unique ID if not given.
   */
  function Wrapper (config) {
    config = config || {};

    if (!config.name || typeof config.name !== 'string') {
      throw new TypeError('config.name is required and must be string');
    }

    this.name = config.name;

    // Data that is added to each event that is sent.
    this.commonData = config.commonData || {};

    this._verify();

    // We have to first push the call to `create` to ensure any other options
    // passed with config are also set synchronously after creation.
    this.q.push(['create', config]);

    // If passed other (one-word) options, go ahead and set those properties.
    var properties = ['Staging', 'Audience', 'Anonymous'];

    for (var i = 0, property, configProp; i < properties.length; i++) {
      property = properties[i];

      configProp = config[property.toLowerCase()];
      // If passed one of the various properties in config, call the setter now.
      // This is a convenience for users of the config.
      if (configProp || config.hasOwnProperty(property.toLowerCase())) {
        this['set' + property](configProp);
      }
    }

    if (config.validationCallback) {
      this.enableValidation(config.validationCallback);
    }

    if (config.timing === false) {
      this.disableTiming();
    }

    if (config.brandDomain) {
      this.setBrandDomain(config.brandDomain);
    }

    if (config.eventClassFilter) {
      this.setEventClassFilter(config.eventClassFilter);
    }
  }

  (function () {

    function extend (/*destination, ...sources*/) {
      var args = toArray(arguments);
      for (var i = 1; i < args.length; i++) {
        if (args[i] !== null && typeof args[i] === 'object') {
          for (var prop in args[i]) {
            if (args[i].hasOwnProperty(prop)) {
              args[0][prop] = args[i][prop];
            }
          }
        }
      }
      return args[0];
    }

    function toArray (obj) {
      return Array.prototype.slice.call(obj);
    }

    /**
     * Throttle the given function to execute only once
     * after the threshold has passed.
     *
     * Defaults to throttle to 4 executions/second.
     */
    function throttle(fn, threshhold, scope) {
      var wait = threshhold || 250;
      var last;
      var deferTimer;
      return function () {
        var context = scope || this;

        var now = +new Date;
        var args = arguments;
        if (last && now < last + wait) {
          // hold on to it
          clearTimeout(deferTimer);
          deferTimer = setTimeout(function () {
            last = now;
            fn.apply(context, args);
          }, wait);
        } else {
          last = now;
          fn.apply(context, args);
        }
      };
    }

    var SETTER_METHODS = [
      'setClient',
      'setDisplay',
      'setAnonymous',
      'setBrandDomain',
      'setSource',
      'setEnvironment',
      'setAudience',
      'setStaging',
      'setEventClassFilter',
      'setEU'
    ];

    var instanceMethods = {};

    function makeSetter (method) {
      return function () {
        // Ensure that we have a reference window._bvaq
        this._verify();
        var args = toArray(arguments);
        // Method name goes at the front.
        args.unshift(method);
        // Tracker name goes at the back.
        args.push(this.name);

        this.q.push(args);
      };
    }

    for (var i = 0, method; i < SETTER_METHODS.length; i++) {
      method = SETTER_METHODS[i];
      instanceMethods[method] = makeSetter(method);
    }

    extend(instanceMethods, {
      // Ensure that window._bvaq still exists. We do this because if we save a
      // reference to window._bvaq at initialization time, we may incorrectly
      // retain a reference to the plain array even after it gets replaced by
      // the array-like object.
      //
      // We could just refer to window._bvaq within each method, but this way
      // we consolidate the error checking up front instead of having an error
      // thrown inside of each method.
      _verify: function () {
        window._bvaq = window._bvaq || [];
        this.q = window._bvaq;
      },

      _flushBatch: throttle(function () {
        this._verify();
        this.q.push(['flushBatch', this.name]);
      }),

      /**
       * Load analytics.js asynchronously. Should only be necessary to call this once.
       * Pass a semver version number to load a specific version of the analytics script,
       * otherwise it defaults to latest.
       */
      loadScript: function (version) {
        // Default to latest.
        var VERSION = version || 'latest';

        // Create a script tag to inject bv-analytics.js
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.async = true;

        var protocol = 'http:';
        if (window.location.protocol === 'https:') {
          protocol = 'https:';
        }

        var host = 'analytics-static.ugc.bazaarvoice.com';
        script.src = protocol + '//' + host + '/prod/static/' + VERSION + '/bv-analytics.js';

        // Inject script.
        var firstScript = document.getElementsByTagName('script')[0];
        firstScript.parentNode.insertBefore(script, firstScript);
      },

      /**
       * If you know you need to pass some data with every event, you can define it here.
       * @param {[type]} data common data object. Will overwrite data properties
       */
      setCommonData: function (data) {
        extend(this.commonData, data);
      },

      /**
       * Registers WAI/SCI callbacks on the named tracker.
       * If the named tracker doesn't exist, it will register the callbacks on 'default'
       * See https://github.com/bazaarvoice/analytics.js/blob/master/doc/sci.md
       */
      configureSCIProvider: function (name, config) {
        this._verify();
        this.q.push(['configureSCIProvider', name, config, this.name]);
      },

      enableValidation: function (validationCallback) {
        this._verify();
        this.q.push(['enableValidation', validationCallback, this.name]);
      },

      disableValidation: function () {
        this._verify();
        this.q.push(['disableValidation', this.name]);
      },

      enableTiming: function () {
        this._verify();
        this.q.push(['enableTiming', this.name]);
      },

      disableTiming: function () {
        this._verify();
        this.q.push(['disableTiming', this.name]);
      },

      addMeta: function (name, data) {
        this._verify();
        this.q.push(['addMeta', name, extend({}, this.commonData, data), this.name]);
      },

      removeMeta: function (name) {
        this._verify();
        this.q.push(['removeMeta', name, this.name]);
      },

      trackEvent: function (eventType, data) {
        this._verify();
        this.q.push(['addBatchItem', eventType, extend({}, this.commonData, data), this.name]);
        this._flushBatch();
      },

      trackPageView: function (data) {
        this._verify();
        this.q.push(['trackPageView', extend({}, this.commonData, data), this.name]);
      },

      trackError: function (data) {
        this._verify();
        this.q.push(['trackEvent', 'Error', extend({}, this.commonData, data), this.name]);
      },

      trackConversion: function (data) {
        this._verify();
        this.q.push(['trackConversion', extend({}, this.commonData, data), this.name]);
      },

      trackImpression: function (data) {
        this._verify();
        this.trackEvent('Impression', extend({}, this.commonData, data), this.name);
      }
    });

    extend(Wrapper.prototype, instanceMethods);

  })();

  return Wrapper;
}));

/**
 * @fileOverview Provides the bv-analytics.js vendor
 */
BV.define('bv/analytics/bvAnalyticsIntegration',[
  'ENV',
  'underscore',
  'bv/util/domainPolice',
  'framework/util/bvreporter',
  'bv/util/isDev',
  'vendor/bvAnalyticsWrapper',
  'window'
], function analyticsIntegration (ENV, _, domainPolice, BVReporter, isDev, BVAnalyticsWrapper, window) {

  var AJS_VERSION = '3';
  var config;
  var isStaging;
  var analyticsWrapper;
  var currentVersion;
  /*
   * A necessary hack because serverrender can't handle references to window,
   * which the AJS wrapper contains. So if this is a serverrender route,
   * don't bother initializing. -srugh
   */
  if (typeof window === 'undefined' || window.BV.serverRender) {
    return;
  }

  config = ENV.get('config');
  // Any workspace or environment besides production should be considered staging.
  // For a qa client, environment will be production, so we have to check
  // workspace. For prod clients, we have to check environment since workpace
  // will always be production.
  isStaging = config.workspace !== 'production' || config.environment !== 'production';

  analyticsWrapper = new BVAnalyticsWrapper({
    name: 'firebird',
    source: 'firebird',
    client: config.clientname,
    display: config.displaycode,
    staging: isStaging,
    timing: false,
    anonymous: !domainPolice.thirdPartyCookieEnabled(),
    commonData: {
      locale: config.locale,
      deploymentZone: config.siteId
    },
    brandDomain: domainPolice.firstPartyCookieEnabled() ? domainPolice.allowedDomain() : null
  });

  // Configure third-party vendors and their "Web Analytics Provider"
  // For details: https://github.com/bazaarvoice/analytics.js/blob/master/doc/sci.md
  if (config.sci && config.sci.enabled && config.sci.waps.length) {
    _(config.sci.waps).forEach(function configureSCIProvider (wapConfig) {
      analyticsWrapper.configureSCIProvider(wapConfig.name, wapConfig);
    });
  }

  // Enable validation of events in development.
  if (isDev) {
    analyticsWrapper.enableValidation(function validationCallback (resp, event) {
      if (resp.error) {
        _.each(resp.details, function logDetail (detail) {
          // If we didn't get a message or the message is just a regurgitated
          // Firebird error, ignore it.
          if (detail.message && !detail.message.match('Error:firebird')) {
            BVReporter.warn('Magpie validation issue:', detail.message, event);
          }
        });
      }
    });
  }

  // As per EU law, any PII collected in the EU must stay within the EU. In
  // order to accomodate this, we must check whether or not we are in the EU and
  // notify analytics accordingly.
  if (config.piiDataRegion === 'europe') {
    analyticsWrapper.setEU(true);
  }

  // Only load the analytics sdk if it hasn't been loaded yet
  // or if the current version is lower than the expected
  // AJS_VERSION.
  currentVersion = window._bva && window._bva.version.split('.')[0];
  if (!currentVersion || currentVersion < AJS_VERSION) {
    // load analytics.js
    analyticsWrapper.loadScript(AJS_VERSION);
  }

  return analyticsWrapper;
});

BV.define('util/performance',[
  'window',
  'underscore',
  'jquery',
  'backbone'
], function (window, _, $, Backbone) {
  /**
   * For more information:
   * http://www.html5rocks.com/en/tutorials/webperformance/basics/#events
   */

  var windowPerformance = window.performance       ||
                          window.webkitPerformance ||
                          window.mozPerformance    ||
                          window.oPerformance      ||
                          window.msPerformance     ||
                          false;

  // Timing properties in order of occurrence.
  var props = [
    'navigationStart',
    'unloadEventStart',
    'unloadEventEnd',
    'redirectStart',
    'redirectEnd',
    'fetchStart',
    'domainLookupStart',
    'domainLookupEnd',
    'connectStart',
    'connectEnd',
    'secureConnectionStart',
    'requestStart',
    'responseStart',
    'responseEnd',
    'domLoading',
    'domInteractive',
    'domContentLoadedEventStart',
    'domContentLoadedEventEnd',
    'domComplete',
    'loadEventStart',
    'loadEventEnd'
  ];

  var performance = _.extend({
    supported : windowPerformance !== false,
    ready : false,
    timing : {},
    timingArray : []
  }, Backbone.Events);

  function ready () {
    var data = [];
    _(props).forEach(function (prop) {
      data.push(windowPerformance.timing[prop]);
    });

    performance.timing = windowPerformance.timing;
    performance.timingArray = data;
    performance.ready = true;
    performance.trigger('ready');
  }

  if (windowPerformance !== false) {
    $(window).on('load', function () {
      // In order to capture all data plus the 'loadEventEnd', wait until after
      // the onload callback ends.
      setTimeout(ready, 0);
    });
  }

  return performance;
});

/**
 * @fileOverview Set up BVTracker listeners that emit analytics data
 */
BV.define('bv/analytics',[
  'ENV',
  'window',
  'underscore',
  'bv/analytics/bvAnalyticsIntegration',
  'bv/util/contentType',
  'bv/util/productInfo',
  'util/performance',
  'framework/util/bvtracker',
  'framework/util/bvreporter',
  'framework/clientEvents'
], function (ENV, window, _, bvAnalytics, ContentType, ProductInfo, performance, BVTracker, BVReporter, ClientEvents) {
  var options = ENV.get('config');

  /**
   * Add instances of analytics vendors to the vendors array.
   * Each event triggered by BVTracker will be forwarded to each
   * vendor provided.
   *
   * @type {Array}
   */
  var vendors = [
    bvAnalytics
  ];

  var uiVersion = { bvProductVersion: window.BV._internal.uiVersion };

  /**
   * Invoke a method to all enabled vendors.
   *
   * @param {String} method The name of the method to invoke.
   * @param {Mixed[]} args Arguments to pass to the method.
   *
   * @returns {Mixed[]} An array containing the return values of each
   *   invoked method.
   */
  function invokeVendors (method) {
    var ret = [];
    var args = _.toArray(arguments).slice(1);

    _(vendors).each(function (vendor) {
      if (_(vendor[method]).isFunction()) {
        try {
          ret.push(vendor[method].apply(vendor, args));
        }
        catch (e) {
          BVReporter.error('Unable to invoke vendor method: ' + method, e);
        }
      }
    });

    return ret;
  }

  /**
   * Retrieve common data that should accompany all analytics events. If an
   * event is firing *really* early the app model may not have been created
   * yet.
   *
   * TODO: Should we queue analytics events that happen before a certain time,
   * or just make sure that none do?
   *
   * @returns {Object} An object containing data relevant to all analytics events.
   */
  function commonData () {
    var common = {};

    // TODO: These need abstraction.
    common.version = '2.0';
    common.context = 'Read';

    // Include the site ID if it exists.
    if (options.siteId) {
      common.siteId = options.siteId;
    }

    return common;
  }

  /**
   * Retrieve analytics data related to AB testing.
   *
   * @return {Object} An object containing data relevant to ab testing.
   */
  function abTestingData () {
    var data = {};

    // Include the testId (used to track A/B tests) if it exists.
    if (options.testId) {
      data.testId = options.testId;
    }

    return data;
  }

  /**
   * Fire the 'error' event for all vendors.
   *
   * @param  {Object} Error data
   */
  BVTracker.on('error', function (data) {
    data = _(data).defaults({
      // FIXME: this does not work, as Error instances will have a `name`
      name: data instanceof Error ? data.message : 'Exception',
      type: 'firebird'
    }, uiVersion);

    return invokeVendors('trackError', data);
  });

  /**
   * Fire the 'event' event for all vendors.
   *
   * @param  {String} cl   The class of the event.
   * @param  {[type]} data Event data.
   */
  BVTracker.on('event', function (cl, data) {
    _(data).defaults(commonData(), abTestingData(), uiVersion);
    return invokeVendors('trackEvent', cl, data);
  });

  /**
   * Fire the 'feature' event for all vendors.
   *
   * @param  {String} cl   The class of the event.
   * @param  {[type]} data Event data.
   */
  BVTracker.on('feature', function (data) {
    _(data).defaults(commonData(), abTestingData(), uiVersion);
    // Private event.
    ClientEvents.trigger('_feature', data);
    return invokeVendors('trackEvent', 'Feature', data);
  });

  /**
   * Fire the 'impression' event for all vendors.
   *
   * @param  {Object} data Event data.
   */
  BVTracker.on('impression', function (data, model) {
    var contentItem, reference;
    _(data).defaults(commonData(), abTestingData(), uiVersion);
    if (!data.brand && data.type === 'UGC') {
      contentItem = model.get('Type') === 'comment' ? model.get('parentContentItem') : model;
      reference = contentItem && contentItem.get('Reference');
      if (reference && reference.Brand && reference.Brand.Name) {
        data.brand = reference.Brand.Name;
      }
    }
    // Private event.
    ClientEvents.trigger('_impression', data);
    return invokeVendors('trackImpression', data);
  });

  /**
   * Fire the 'conversion' event for all vendors.
   *
   * @param  {Object} data Event data.
   */
  BVTracker.on('conversion', function (data) {
    _(data).defaults(commonData(), uiVersion);
    return invokeVendors('trackConversion', data);
  });

  _(['Rendered', 'Loaded', 'Completed', 'Waited']).each(function (evt) {
    BVTracker.on(evt.toLowerCase(), function (data) {
      BVReporter.assert(_.isNumber(data.elapsedMs), 'elapsedMs property set for event');

      data = _(data).defaults({
        type: 'Used',
        interaction: false
      }, uiVersion);

      data.name = evt + ': ' + data.name;

      return invokeVendors('trackEvent', 'Feature', data);
    });
  });

  BVTracker.on('pageview', function (data, model) {
    var subject, modelJSON, product, stats;

    _(data).defaults(commonData(), abTestingData(), uiVersion);

    // Make sure the very first page view event carries the 'initial' flag.
    data.initial = ENV.get('initialPageViewHappened') !== true;
    if (ENV.get('initialPageViewHappened') !== true) {
      ENV.set('initialPageViewHappened', true);
    }

    if (model) {
      _(data).defaults({
        pages: model.get('numPages'),
        currentPage: model.get('currentPage')
      });

      subject = model.getSubject();

      data.subjectType = ContentType.Noun(subject.type);
      data.subjectId = subject.id;
      data.contentType = ContentType.Noun(subject.contentType);

      // Add product specific data only if we're on a product page.
      if (subject.type === 'product') {
        modelJSON = model.toJSON();
        product = modelJSON.Product;
        stats = (!product || !product.PrimaryContent) ? {} : (product.PrimaryContent.Statistics || {});

        if (product.Brand && product.Brand.Name) {
          data.brand = data.brand || product.Brand.Name;
        }

        if (subject.contentType === 'Reviews') {
          _(data).defaults({
            numReviews: stats.TotalCount,
            numRatingsOnlyReviews: stats.RatingsOnlyCount || 0,
            /*
             * FIXME: !product is never true, as that would result in an error on
             *        line 206
            */
            percentRecommend: (((stats.RecommendedCount || 0) / (!product ? 0 : product.TotalCount)) * 100).toFixed(2),
            avgRating: stats.AverageOverallRating || 0
          });
        }

        _(data).defaults({
          /*
           * FIXME: !product is never true, as that would result in an error on
           *        line 206
          */
          categoryId: !product ? null : product.CategoryId
        });
      }
    }

    if (performance.supported && performance.ready) {
      data.t = performance.timingArray;
    }

    return invokeVendors('trackPageView', data);
  });

  BVTracker.on('viewedUGC', function (data, component) {
    data = _(data).defaults({
      type: 'Used',
      name: 'viewedUGC',
      interaction: true,
      bvProduct: ProductInfo.getType(component),
      categoryId: ProductInfo.getCategoryId(component),
      productId: ProductInfo.getId(component)
    }, uiVersion);

    // Private event.
    ClientEvents.trigger('_viewedUGC', data);
    return invokeVendors('trackEvent', 'Feature', data);
  });

  BVTracker.on('inView', function (data, component) {
    data = _(data).defaults({
      type: 'Used',
      name: 'InView',
      interaction: true,
      bvProduct: ProductInfo.getType(component),
      categoryId: ProductInfo.getCategoryId(component),
      productId: ProductInfo.getId(component)
    }, uiVersion);

    // Private event.
    ClientEvents.trigger('_inView', data);
    return invokeVendors('trackEvent', 'Feature', data);
  });

  BVTracker.on('performance', function (data) {
    _(data).defaults({
      type: 'Performance'
    }, uiVersion);

    return invokeVendors('trackEvent', 'Diagnostic', data);
  });

});

/**
 * bv/ugc/init
 *
 * Initialization path for a ugc app
 */
BV.define('bv/ugc/init',[
  'ENV',
  'components!',
  'mappings!nonsubmission',
  'mappings!submission/models',
  'backbone',
  'framework/bview',
  'framework/approuter',
  'framework/bcomponent',
  'framework/componentManager',
  'framework/uiActionResolver',
  'bv/util/queryrouter',
  'bv/util/contentType',
  'bv/api/fetch',
  'bv/prefetch',
  'jquery',
  'underscore',
  'bv/util/focusManager',
  'bv/ugc/postInjectTriggers',
  'body',
  'bv/analytics',
  'bv/util/loadingOverlay'
],
function (
  ENV,
  components,
  mappings,
  submissionModelMappings,
  Backbone,
  BView,
  BVRouter,
  BComponent,
  ComponentManager,
  UIActionResolver,
  queryRouter,
  ContentType,
  api,
  prefetch,
  $,
  _,
  focusManager,
  postInjectTriggers,
  body
) {
  var triggerActionCount = 0;

  // Create an application wide router for handling hash fragments.
  function initRouter (components, clientAPIConfig) {
    // Find 'BVRouter' type components.
    // For now, we only support 1 'BVRouter' component.
    var bvRouter = new BVRouter(components.getRouter(clientAPIConfig));
    ENV.set('appRouter', bvRouter);
  }

  // Trigger models to fetch for the data.
  function triggerAction (renderComponents, pageNum) {
    prefetch.setAPI(api);
    prefetch.startPrefetch(triggerActionCount);

    _(renderComponents).forEach(function (c) {
      c.triggerAction(pageNum);
    });

    return prefetch.endPrefetch(triggerActionCount++);
  }

  function componentsFromComponentData (components, serverRender) {
    return new ComponentManager(components, serverRender);
  }

  // This function takes the app options and creates the models
  // (views are not created here, they will be created in actionInit).
  function initialize (clientAPIConfig) {
    // only call initialize() once
    if (!ENV.get('appInitialized')) {
      var config = ENV.get('config');
      var existingMappings = ENV.get('mappings') || {};
      var componentManager = componentsFromComponentData(components);

      // init router
      // create appRouter instance for each 'BVRouter' components.
      // for now, we only support 1 'BVRouter' component.
      initRouter(componentManager, clientAPIConfig);

      focusManager.init();

      ENV.set({
        componentManager: componentManager,
        mappings: $.extend(true, {}, existingMappings, submissionModelMappings, mappings),
        modelsInitializedDfds: {},
        appInitialized: true
      });
    }

    // Now that the app is marked as initialized, we should try to start the
    // routers. If we do this before `appInitialized` is true, we run the
    // risk of a stack overflow, because responding to a route can trigger a
    // BV.ui call, which will re-call `initialize`... and so on.
    startRouters();
  }

  function startRouters () {
    function _startRouters () {
      if (Backbone.history && !Backbone.history.started) {
        // Start the app router; this may cause a request for data.
        //
        //
        // We set the `started` flag _before_ we start the router. We can't
        // set it afterward because starting the router may synchronously
        // trigger a route, and routes can result in BV.ui calls, which in
        // this case would try to start the router again because we haven't
        // yet set the `started` flag. Good times. -APD
        Backbone.history.started = true;
        Backbone.history.start();
        // Start the query router.
        queryRouter.start();
      }
    }

    // If <body> exists, start listening right away, otherwise, wait for doc
    // ready. Backbone requires the <body> to exist before listening for some IEs.
    if (body()) {
      _startRouters();
    }
    else {
      $(_startRouters);
    }
  }

  // This function takes the app options and creates views
  // once views are created, it sets the model dataReadyCallback handle to
  // render the view then it triggers the action.
  function actionInit (method, clientAPIConfig, isSubmission) {
    var modelInitializedDfds = ENV.get('modelsInitializedDfds');
    modelInitializedDfds[method] = $.Deferred();

    var config = ENV.get('config');
    var components = ENV.get('componentManager') || componentsFromComponentData(components);
    var requiredComponents = components.getClientRenderComponents(method, config.uiActions);

    components.updateContainers(method, config, clientAPIConfig);
    components.initModels(method, config, clientAPIConfig);
    if (isSubmission) { return; }
    components.prepareInjectionZones(method, config);

    // create needed views
    modelInitializedDfds[method].done(function () {
      new UIActionResolver({
        method: method,
        clientAPIConfig: clientAPIConfig,
        initViewsPromise: components.initViews(method, config, clientAPIConfig)
      });

      triggerAction(requiredComponents);
    });
  }

  // the functions below are to support the api that init.js
  // needs to expose to serverrender-worker. you should tread
  // carefully when messing with them, or with the object that's
  // returned below.

  function getRenderComponents (components) {
    var manager = ENV.get('componentManager') || componentsFromComponentData(components, true);
    return manager.getServerRenderComponents();
  }

  function initModel (component, apiConfig, initData) {
    return component.initModel(apiConfig, initData);
  }

  function initView (component, model, index) {
    component.model = model;
    return component.createView(index);
  }

  function updateContainer (component, view, config, apiConfig) {
    component.updateContainer(config, apiConfig);
  }

  function getUniqId (component) {
    return component.uniqueId;
  }

  return {
    initialize: initialize,
    actionInit: actionInit,
    startRouters: startRouters,
    triggerAction: triggerAction,
    componentsFromComponentData: componentsFromComponentData,

    getRenderComponents: getRenderComponents,
    initModel: initModel,
    initView: initView,
    updateContainer: updateContainer,
    getUniqId: getUniqId
  };
});

/**
 * @fileOverview A model that supports the seoCanary view,
 * setting various values that will be used in its template.
 * Note that this is a standard Backbone model, not a BModel.
 */
BV.define('bv/c2013/model/seoCanary',[
  'ENV',
  'window',
  'backbone',
  'BV',
  'bv/api',
  'bv/util/bvstateManager',
  'framework/util/bvreporter',
  'util/lookup',
  'vendor/moment',
  'underscore'
], function (ENV, window, Backbone, BV, api, BVStateManager, BVReporter, lookup, moment, _) {

  // A map from state content types to the shorted versions
  // we need to put on the page.
  var contentTypeToBVProductMap = {
    'review': 'rr',
    'question': 'qa'
  };

  // A map from content types to their default sort algorithms.
  var contentTypetoDefaultSortMap = {
    'reviews': 'mostRecent',
    'questions': 'recentQuestionsFirst'
  };

  var SEOCanaryModel = Backbone.Model.extend({
    name: 'seoCanary',

    /**
     * Set up the data we can determine immediately.
     *
     * We need to subscribe to the bvstate so we can update the
     * product and page info when that comes in.
     *
     * Finally, make sure we have a done callback for the data coming in,
     * so we can update the review/question/answer counts once that data
     * comes in.
     */
    initialize: function () {
      var ENVConfig = ENV.get('config');

      this.set({
        date: this._getDate(),
        env: this._getEnv(ENVConfig),
        firebirdVersion: this._getVersion(),
        locale: ENVConfig.locale,
        subjectId: this._getSubjectId()
      });

      // Listen to the state manager for `bvstate` info.
      BVStateManager.subscribe(this.handleBVState, this);

      BV.extensions.data.get('bvapi')
        .getLast('products')
        .done(_.bind(this.handleResponse, this));
    },

    /**
     * Returns the subject id (usually the product id).
     */
    _getSubjectId: function () {
      var clientAPIConfig = ENV.get('appRouter').clientAPIConfig;
      var subjectType = api.noun(clientAPIConfig.subjectType);
      var subjectId = clientAPIConfig[subjectType + 'Id'];
      return subjectId;
    },

    /**
     * Reports back the data environment as a string.
     * Either 'stg', or 'env'.
     */
    _getEnv: function (ENVConfig) {
      return ENVConfig.environment === 'production' ? 'prd' : 'stg';
    },

    /**
     * Reports back the firebird version as a string.
     * If there is no version, like when we're running against a local server,
     * will return 'unversioned'.
     */
    _getVersion: function () {
      return BV._internal && BV._internal.uiVersion ?
        BV._internal.uiVersion :
        'unversioned';
    },

    /**
     * Get the date as a string that's been formatted appropriately.
     */
    _getDate: function () {
      var date = moment().format('YYYY-MM-DD');
      var time = moment().format('hh:mmZ');
      return date + 'T' + time;
    },

    /**
     * Handles the response from the data API extension,
     * calculating the total count and content count for
     * the content type specified by the model and then
     * triggering events that are used by the view.

     * @param  {Object} data The data that is sent by the data API extension.
     */
    handleResponse: function (data) {
      var config = ENV.get('config');
      var apiData = data.results.Results[0];
      var filteredStats = apiData.Content.Reviews.FilteredStatistics;
      var rawStats = apiData.Content.Reviews.RawStatistics;

      // reviewCount reflects the total number of reviews reflected in the
      // average, including ratings-only and other locale reviews.
      // This will be rendered as 'tv_<reviewCount>'
      var reviewCount;

      // filteredReviewCount reflects the number of
      // displayable (not ratings-only/other locale) reviews
      // This will be rendered as 'tr_<filteredReviewCount>'
      var filteredReviewCount;

      if (config.statistics.onlyShowDisplayedLocaleStatistics) {
        reviewCount = filteredStats.TotalCount;
        filteredReviewCount = reviewCount - filteredStats.RatingsOnlyCount;
      }
      else {
        reviewCount = rawStats.TotalCount;
        filteredReviewCount = filteredStats.TotalCount - filteredStats.RatingsOnlyCount;
      }

      var hasReviews = reviewCount ? 'hasreviews' : 'noreviews';
      var hasQuestions = this._getHasQuestions(apiData);

      this.set({
        hasReviews: hasReviews,
        hasQuestions: hasQuestions,
        reviewCount: reviewCount,
        filteredReviewCount: filteredReviewCount,
        renderContentCount: true
      });

      this.trigger('rerenderView');
    },

    /**
     * Helper method to determine the correct value to put under the
     * questions count area. Moved it out of handleResponse because it was
     * ugly.
     */
    _getHasQuestions: function (actualData) {
      var hasQuestions;
      if (!actualData.TotalQuestionCount) {
        hasQuestions = 'noquestions';
      }
      else if (!actualData.TotalAnswerCount) {
        hasQuestions = 'hasquestions';
      }
      else {
        hasQuestions = 'hasquestionsanswers';
      }
      return hasQuestions;
    },

    /**
     * Update info based on state info
     */
    handleBVState: function (state) {
      // Only update bvstate when the URL actually changes, or if this is the
      // first time the handler is firing. Otherwise we'll end up incorrectly
      // changing this data when the user increments the page.
      if (this._lastUrl && this._lastUrl === window.location.toString()) {
        return;
      }
      this._lastUrl = window.location.toString();

      state = this._setDefaultStateValues(state);
      var bvProduct = contentTypeToBVProductMap[state.ct];
      var bvPage = state.pg === 1 ? 'bvpage1' : 'bvpage2n';

      // Set information from the state to this model.
      this.set({
        bvPage: bvPage,
        bvProduct: contentTypeToBVProductMap[state.ct],
        page: state.pg,
        sortName: this._getSortName(state.ct),
        renderPageAndBVProduct: true
      });

      this.trigger('rerenderView');
    },

    /**
     * This returns an object with the info from state we care about
     * If state is missing ct, we assume reviews.
     * If state is missing pg, we assume page 1.
     */
    _setDefaultStateValues: function (state) {
      var result = {};
      result.ct = state.ct || 'review';
      result.pg = state.pg || 1;
      return result;
    },

    /**
     * Returns the name of the primary sort algorithm used for the content type.
     */
    _getSortName: function (contentType) {
      // Bail if we don't have a contentType.
      if (!contentType) {
        return;
      }

      var ENVConfig = ENV.get('config');
      var sortObject = ENVConfig.sort;
      var nounsContentType = api.nouns(contentType);
      var sort = sortObject[nounsContentType];

      var sortName;
      if (_(sort).isArray()) {
        sortName = sort[0];
      }
      else {
        sortName = sort;
      }

      // Use default values if we don't have anything.
      sortName = sortName || contentTypetoDefaultSortMap[nounsContentType];

      return sortName;
    }
  });

  return SEOCanaryModel;
});

/* START_TEMPLATE */
BV.define('hbs!seoCanary',['hbs','vendor/handlebars/runtime'], function(hbs, Handlebars){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [2,'>= 1.0.0-rc.3'];
helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " <li data-bvseo=\"ps\">bvseo_fps, prod_bv";
  if (stack1 = helpers.bvProduct) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.bvProduct; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", vn_firebird_";
  if (stack1 = helpers.firebirdVersion) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.firebirdVersion; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</li> "
    + " <li data-bvseo=\"cp\">cp_";
  if (stack1 = helpers.page) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.page; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (stack1 = helpers.bvPage) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.bvPage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</li> "
    + " <li data-bvseo=\"cf\">loc_";
  if (stack1 = helpers.locale) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.locale; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (stack1 = helpers.subjectId) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.subjectId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (stack1 = helpers.env) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.env; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", sort_";
  if (stack1 = helpers.sortName) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.sortName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</li> ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + " <li data-bvseo=\"co\">co_";
  if (stack1 = helpers.hasReviews) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.hasReviews; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", co_";
  if (stack1 = helpers.hasQuestions) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.hasQuestions; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", tv_";
  if (stack1 = helpers.reviewCount) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.reviewCount; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ", tr_";
  if (stack1 = helpers.filteredReviewCount) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.filteredReviewCount; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</li> ";
  return buffer;
  }

  buffer += " <ul id=\"BVSEO_meta\"> "
    + " <li data-bvseo=\"bvDateModified\">";
  if (stack1 = helpers.date) { stack1 = stack1.call(depth0, {hash:{}}); }
  else { stack1 = depth0.date; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</li> "
    + " ";
  stack1 = helpers['if'].call(depth0, depth0.renderPageAndBVProduct, {hash:{},inverse:self.noop,fn:self.program(1, program1, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " "
    + " ";
  stack1 = helpers['if'].call(depth0, depth0.renderContentCount, {hash:{},inverse:self.noop,fn:self.program(3, program3, data)});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " </ul> ";
  return buffer;
  });
Handlebars.registerPartial('seoCanary', t);
t.deps = [];
t.tplMountedViews = [];
return t;
});
/* END_TEMPLATE */
;
/**
 * @fileOverview A view for rendering hidden elements into the page
 * that SEO tools can use to monitor the SEO impact of Firebird.
 * Note that this is *not* a typical BView, but rather just a standard
 * Backbone view.
 *
 * This view opts to completely rerender when data updates instead of injecting
 * additional li elements. This keeps the code and template cleaner without
 * really hurting performance.
 */
BV.define('bv/c2013/view/seoCanary',[
  'jquery',
  'body',
  'backbone',
  'underscore',
  'bv/c2013/model/seoCanary',
  'hbs!seoCanary'
], function ($, body, Backbone, _, SEOCanaryModel, tmpl) {
  var SEOCanary = Backbone.View.extend({

    /**
     * This isn't a BView so we need to remember to build the model.
     * We also need to listen to the rerenderView event, so we can render
     * again when the model's data updates.
     */
    initialize: function () {
      this.model = new SEOCanaryModel();
      this.model.on('rerenderView', this.render, this);
    },

    /**
     * Renders the template using the data prepared by the model.
     */
    render: function () {
      // Render the template with our latest data.
      var data = this.model.toJSON();
      var html = tmpl(data);

      if (!this.alreadyAppended) {
        // If this is our first time rendering, we need to create the new $el
        // and append it to the body.
        this.$el = $(html);
        $(body()).append(this.$el);
        this.alreadyAppended = true;
      }
      else {
        // If this is the 2nd+ time rendering, just replace the old html with an
        // element based on the new stuff.
        var $el = $(html);
        this.$el.replaceWith($el);
        this.setElement($el);
      }
    }
  });

  return SEOCanary;
});

/**
 * @fileOverview Module to manage UI method validators
 */
BV.define('bv/util/uiValidators',[
  'ENV'
], function UIValidators (
  ENV
) {

  // UI Method Validators are called in another context (value of this that
  // won't be this object) for backwards compatability reasons, so save a ref
  // to this object in case we need it.
  var uiValidators = {

    /**
     * If Review Submission is allowed, returns nothing.
     * If Review Submission is not allowed (e.g, read-only product page),
     * an object with an error attribute is returned.
     * This is done instead of returning a boolean for backwards compatability
     * reasons: our code base assume validators will return an object with an
     * error string if there is a problem, and will return nothing otherwise.
     *
     * @return {Object}        Undefined if review submission is allowed.
     *                         Otherwise returns an object with an error attritbute.
     */
    assertReviewSubmissionAllowed: function assertReviewSubmissionAllowed () {
      // Read only disables submission on PDP's, but submission is still allowed
      // on container pages.
      if (ENV.get('config').rrReadOnlyEnabled && !ENV.isContainer()) {
        return { error: 'Attempting submission on a read-only page.' };
      }
    }
  };

  return uiValidators;
});

/**
 * @fileOverview Module to manage UI method validators
 */
BV.define('bv/util/filterReviews',[
  'ENV'
], function FilterReviews (
  ENV
) {

  /**
   * This is a map of common nicknames/typos of filter names. The actual ID
   * needed for the filter is usually a bit off from how we usually talk about
   * the filters, such as 'ContentLocale' instead of 'locale'. This is meant
   * to make it easier to implement filters without detailed knowledge of
   * what exactly the filter ID is.
   *
   * @type {Object}
   */
  var commonFiltersMap = {
    rating: 'Rating',
    locale: 'ContentLocale'
  };

  /**
   * This is a list of valid prefixes for filters. Basically, we want users
   * (such as other Display teams) to be able to filter for, say 'Age' instead
   * of 'contextdatavalue_Age'. This array lists all the valid prefixes that
   * we intend to check.
   *
   * @type {Array}
   */
  var validPrefixes = [
    '',
    'contextdatavalue_',
    'additionalfield_',
    'rating_'
  ];

  /**
   * Take the input from the UI call and massage it into a shape that our
   * already extant filtering tools can understand.
   *
   * @param  {Object} filterConfig - A configuration of filters
   * @return {Ojbect} A normalized list of 'filter identifiers'. Includes both
   *                    the ID for the desired filters and the ID of the
   *                    desired options
   */
  function normalizeFilterConfig (filterConfig) {
    var filterKeys = Object.keys(filterConfig);
    var normalizedFilterConfig = filterKeys.reduce(function filterReduce (filterList, _key) {
      var newFilters;
      var key = _key;
      var option = filterConfig[key];

      // Make implementation a little bit easier by allowing a looser naming
      // scheme. 'rating', 'locale', etc. should work.
      key = commonFiltersMap[key] || key;

      // We need to guess whether the filter passed to us is a cdv, af, or
      // rating. The easiest way to do this is to just guess all of them. The
      // code that looks up filters will just ignore any filters it can't find,
      // so this is safe. This map just makes a filter for each possible ID,
      // then passes it along.
      newFilters = validPrefixes.map(function prefixesMap (prefix) {
        return {
          id: prefix + key,
          option: option
        };
      });

      return filterList.concat(newFilters);
    }, []);

    // Here's an odd thing. We want to clear all previous filters. The way to
    // trigger this is to add a 'replace' flag to the first filter's options
    // arg (not to be confused with the optionId).
    normalizedFilterConfig[0].options = { replace: true };

    return normalizedFilterConfig;
  }

  /**
   * Trigger a filter event on the Review Content List.
   *
   * The code in contentFilter.js that we're making use of already waits for
   * data ready, so we don't need to worry about stalling.
   *
   * @param  {Object} filterConfig - The configuration passed to the UI call
   */
  function filterReviews (filterConfig) {
    var normalizedFilterConfig = normalizeFilterConfig(filterConfig);
    var reviewContentListModel = ENV.get('componentManager').find('reviewContentList1').model;

    normalizedFilterConfig.forEach(function triggerFilter (filter) {
      reviewContentListModel.trigger(
        'filtercontent',
        filter.id,
        filter.option,
        filter.disabled,
        filter.options
      );
    });
  }

  return filterReviews;
});

/* global console:false */
/**
 * @fileOverview Configuration for methods supported by $BV.ui.
 * See docs in bv/clientapi/defineMethod, which generates methods
 * from these method configurations.
 */
BV.define('bv/c2013/methods',[
  'underscore',
  'bv/c2013/view/seoCanary',
  'bv/util/uiValidators',
  'bv/util/filterReviews',
  'ENV'
], function Methods (
  _,
  SEOCanary,
  uiValidators,
  filterReviews,
  ENV
) {

  function consoleError () {
    if (window.console && console.error) {
      console.error.apply(console, arguments);
    }
  }

  function productIdRequired (config) {
    if (_(config.productId).isEmpty()) {
      return {
        error: 'BV: IMPL: No productId is defined',
        type: 'IMPLEMENTATION'
      };
    }
  }

  /**
   * Make sure we create the seo metadata view, but only once.
   */
  // eslint-disable-next-line vars-on-top
  var seoCanary = _.once(function seoCanaryOnce () {
    var s = new SEOCanary();
    s.render();
  });

  return [
    {
      method: 'global_auth_user',
      only: function globalAuthUserOnce (config) {
        BV.require(['secondary'], function requireSecondaryCallback (app) {
          app.AuthUser(config);
        });
      }
    },
    {
      method: 'global_unsubscribe_user',
      only: function globalUnsubscribeUserOnce (config) {
        BV.require(['secondary'], function requireSecondaryCallback (app) {
          app.UnsubscribeUser(config);
        });
      }
    },
    {
      method: 'rr_show_reviews',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      },
      after: function rrShowReviewsAfter () {
        seoCanary();
      },
      validate: productIdRequired
    },
    {
      method: 'rr_filter',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      },
      only: filterReviews
    },
    {
      method: 'rr_submit_review',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      },
      validate: uiValidators.assertReviewSubmissionAllowed,
      after: function rrSubmitReviewAfter (config, appSubmit) {
        appSubmit(config, 'products', config.productId, 'rr_submit_review');
      },
      isSubmission: true
    },

    {
      method: 'rr_submit_comment',
      configProps: {
        contentType: 'comment',
        subjectType: 'product'
      },
      after: function rrSubmitCommentAfter (config, appSubmit) {
        appSubmit(config, 'reviews', config.reviewId, 'rr_submit_comment');
      },
      isSubmission: true
    },

    {
      method: 'rr_submit_generic',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      }
    },

    {
      method: 'rr_inline_ratings',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      },
      validate: function rrInlineRatingsValidate (config) {
        // Dimsum Inline Preview doesn't used productIds. Instead it will pass
        // just a productId property so we need to overwrite productIds if its
        // undefined with the given productId
        if (config.productId) {
          config.productIds = config.productIds || [config.productId];
        }
        // The categoryId value doesn't seem to be used for inline_ratings but I
        // left it in the conditional out of fear that somewhere in this mess of
        // code we were utilizing it.
        if (_(config.productIds).isEmpty() && _(config.categoryId).isEmpty()) {
          return {
            error: 'BV: IMPL: Neither categoryId nor productIds is defined.',
            type: 'IMPLEMENTATION'
          };
        }
      }
    },

    {
      method: 'qa_show_summary',
      configProps: {
        contentType: 'question',
        subjectType: 'product'
      },
      validate: productIdRequired,
      after: function qaShowSummaryAfter (config, appSubmit, clientAPI) {
        // TODO: Remove once we actually implement this.
        clientAPI.SI_trackProductPageView(config.productId);
      },
      inactive: true
    },

    {
      method: 'qa_show_questions',
      configProps: {
        contentType: 'question',
        subjectType: 'product'
      },
      after: function qaShowQuestionsAfter () {
        seoCanary();
      },
      validate: productIdRequired
    },

    {
      method: 'qa_submit_question',
      configProps: {
        contentType: 'question',
        subjectType: 'product'
      },
      isSubmission: true,
      after: function qaSubmitQuestionAfter (config, appSubmit) {
        appSubmit(config, 'products', config.productId, 'qa_submit_question');
      }
    },

    {
      method: 'qa_submit_answer',
      configProps: {
        contentType: 'answer',
        subjectType: 'product'
      },
      isSubmission: true,
      after: function qaSubmitAnswerAfter (config, appSubmit) {
        appSubmit(config, 'questions', config.questionId, 'qa_submit_answer');
      }
    },

    {
      method: 'cp_show_profile',
      configProps: {
        contentType: 'author',
        subjectType: 'author',
        silentMode: true
      }
    },

    {
      method: 'rr_submission_guidelines',
      configProps: {
        contentType: 'review',
        subjectType: 'product'
      }
    },

    {
      method: 'loy_show_leaderboard',
      validate: function cpShowProfileValidate () {
        consoleError('Loyalty is no longer supported');
      }
    }
  ];
});

/**
 * @fileOverview A function for logging errors to the console,
 * if the console object is available.
 */
BV.define('util/consoleError',[
  'window'
], function (window) {
  function consoleError () {
    var console = window.console;

    if (console && console.error) {
      console.error.apply(console, arguments);
    }
  }

  return consoleError;
});

/**
 *  @fileOverview A function that redirects to the container page for submission.
 */
BV.define('bv/ugc/submit/redirectToContainer',[
  'bv/api/fetch',
  'underscore',
  'jquery',
  'window',
  'bv/util/loadingOverlay'
], function (api, _, $, window, LoadingOverlay) {

  function redirectToContainer (params, opts) {
    var userToken;
    var subjectType = api.noun(opts.subject);
    var containerParams = _.extend({
      bvaction: opts.action,
      bvsubjectType: opts.modelSubject,
      bvcampaignId: opts.clientAPIConfig.campaignId
    }, params);

    // Hide the loading overlay to protect against a bug where Safari was
    // showing it when we go back. See CCS-7294.
    LoadingOverlay.hide();

    // If we have a user token, we need to include it in the container
    // page URL for site auth.
    if (opts.submissionModel) {
      userToken = opts.submissionModel.get('user');
      if (userToken) {
        containerParams.bvuserToken = userToken;
      }
    }

    containerParams['bv' + subjectType + 'Id'] = opts.id;
    window.location.href = opts.containerPageUrl + $.param(containerParams);
  }

  return redirectToContainer;

});

/**
 * @fileOverview A module that creates the redirectUrl
 * containing bvdata and optional bvinjecteddata
 */
BV.define('bv/ugc/submit/getRedirectUrl',[
  'util/url'
], function (url) {

  return function (opts) {
    var redirectUrl = opts.redirectUrl;
    var bvdata = opts.bvdata;
    var bvinjecteddata = opts.bvinjecteddata;

    // We used to append bvdata as a URL hash, but url #'s aren't
    // guaranteed to survive 301 redirects in browsers, and we should
    // treat the URL hash as hands-off anyway.
    var newUrl = [
      url.caboose(redirectUrl),
      'bvdata=' + encodeURIComponent(url.stringifyObject(bvdata))
    ];
    // CCS-2866: We need to check if there is some passed injected data
    // and if so, append it to the redirecturl
    if (bvinjecteddata) {
      newUrl.push('&bvinjecteddata=' + encodeURIComponent(bvinjecteddata));
    }

    newUrl.push(url.hash(redirectUrl));

    return newUrl.join('');
  };
});

BV.define('bv/ugc/submit',[
  'ENV',
  'jquery',
  'underscore',
  'bv/api/fetch',
  'util/url',
  'window',
  'BV',
  'bv/ugc/init',
  'framework/bcomponent',
  'bv/util/urlstate',
  'bv/util/user',
  'bv/util/session',
  'bv/ugc/auth',
  'bv/ui-core/modestbox',
  'bv/util/submissionSubviews',
  'mf!bv/c2013/messages/submission',
  'bv/ugc/submit/redirectToContainer',
  'bv/ugc/submit/getRedirectUrl'
],
function (ENV, $, _, api, url, window, BV, appInit, BComponent, UrlState, User, Session, Auth, ModestBox, SubmissionSubviews, msgPack, redirectToContainer, getRedirectUrl) {

  function copyExistingCallbacks (model, clientAPIConfig) {
    var existingClientAPIConfig = model.get('clientAPIConfig') || {};
    _(['doShowContent', 'doLogin']).forEach(function (fn) {
      if (existingClientAPIConfig[fn]) {
        // If we don't have this callback defined, use existingClientAPIConfig's version
        clientAPIConfig[fn] = clientAPIConfig[fn] || existingClientAPIConfig[fn];
      }
    });
  }

  function appSubmit (clientAPIConfig, subject, id, action) {

    var modelsInitializedDfd = ENV.get('modelsInitializedDfds')[action];
    if (!modelsInitializedDfd) {
      throw new Error('No model has not been initialized yet.');
    }

    function findSubmissionModel (subjectType, contentType, componentId) {
      var component;
      var components = ENV.get('componentManager');

      if (componentId) {
        // Use commentSubmission2 component in the Full Review modal window. See UIA-9222.
        if (contentType = 'comment' && $('body').find('#bv-mboxzone-lightbox').length && componentId === 'commentSubmission1_inline') {
          componentId = 'commentSubmission2';
        }
        // Find or create the model
        component = components.find(componentId);
        if (component) {
          component.clientAPIConfig = clientAPIConfig;
          return component.initModel();
        }
      }
      return _(components.models()).find(function (m) {
        return (
          m &&
          m.name === 'submission' &&
          api.noun(m.get('subjectType')) === api.noun(subjectType) &&
          api.noun(m.get('contentType')) === api.noun(contentType)
        );
      });
    }

    // This is a work in progress...
    function _appSubmit () {
      var apiHolder;
      var clientUserToken;
      var userToken;
      var containerRedirectOptions;
      var isMobile = BV._internal.mobile || navigator.userAgent.match(/(iPhone|iPod|Android|BlackBerry)/);
      var submissionModel;
      var ENVConfig = ENV.get('config');
      var containerPageUrl = url.caboose(clientAPIConfig.containerPageUrl) || ENVConfig.container.url;
      var componentId = clientAPIConfig.componentId;
      var modelSubject = api.noun(clientAPIConfig.subjectType);
      var apiSubject = api.noun(subject);
      var secondaryContentSubmission = modelSubject !== apiSubject;
      var isSafari = navigator.userAgent.match(/Version\/[\d\.]+.*Safari/i);
      var components = ENV.get('componentManager');
      var component;
      var msgView;
      delete clientAPIConfig.componentId;

      function loadSubmission (model) {
        BV.require(['secondary'], function (app) {
          app.Submission.lightbox(model, clientAPIConfig);
        });
      }

      // When users are redirected to a login page, we record the page we need to bring
      // the user back to finish the submisssion after they successfully login. Clients
      // can specify this URL via the integration code, if none is specified we default
      // we use the current page. NOTE mobile users submit on the container page first,
      // and than are redirected to the returnUrl if they close the modal box.
      function getReturnUrl () {
        var l;
        if (clientAPIConfig.loginReturnUrl) {
          return clientAPIConfig.loginReturnUrl;
        }

        l = window.location;
        return l.protocol + '//' + l.host + l.pathname + (l.search ? l.search : '') + (l.hash ? l.hash : '');
      }

      function redirectToClientLogin (cId) {
        var eventId;
        var apiSubjectKey;
        var eventData;
        var containerParams;
        var loginUrl;

        if (!ENVConfig.loginPage) {
          throw new Error('Login page not defined');
        }

        eventId = new Date().getTime().toString(16);
        apiSubjectKey = apiSubject + 'Id';
        eventData = {
          action: action,
          subjectType: modelSubject,
          campaignId: clientAPIConfig.campaignId,
          isContainer: !!BV._internal.container,
          returnUrl: getReturnUrl()
        };
        eventData[apiSubjectKey] = clientAPIConfig[apiSubjectKey];
        containerParams = {
          bveventid: eventId
        };
        loginUrl = url.caboose(ENVConfig.loginPage) + $.param(containerParams);

        Session.set(eventId, eventData,
          // Function that will be called when successfully setting session data
          function () {
            // Once we've saved the event to the session, redirect to the login page
            window.location.href = loginUrl;
          },
          // Function that will be called when there's an error with setting session data
          function (e) {
            var messageView;

            if (e.message.indexOf('QuotaExceededError') === -1) {
              throw e;
            }
            else {
              messageView = new SubmissionSubviews.SubmissionMessageView({
                componentId: cId,
                message: msgPack.error_ERROR_PRIVATE_BROWSING_MODE(),
                classList: ['unknown-error'],
                icon: '&#x2718;'
              });

              ModestBox.get('lightbox').pushOrOpen({ view: messageView });
            }
          }
        );
      }

      function handleData (response) {
        var redirectUrl;
        var data = response.data;
        var returnSubject;
        var hashParams;

        try {
          returnSubject = data.Results[0];
          returnSubject.Id = returnSubject.Id || id;
          redirectUrl = returnSubject.Url;
          ENV.get('references').set(returnSubject.Type, returnSubject.Id, returnSubject);
        }
        catch (e) {}

        // If we have a product page, redirect there, deep-linking to submission
        if (redirectUrl) {

          hashParams = {
            action: action,
            campaignId: clientAPIConfig.campaignId,
            userToken: clientAPIConfig.userToken,

            // Attach other data necessary for the bv notifications event attribution (PIE).
            // notificationId and contentId/questionId are sent automatically by the below forEach.
            // These values can be undefined.
            messageType: clientAPIConfig.messageType,
            recipientDomain: clientAPIConfig.recipientDomain
          };

          // Send along any IDs.
          _(clientAPIConfig).forEach(function (value, key) {
            if (key.match(/Id$/) && clientAPIConfig[key]) {
              hashParams[key] = clientAPIConfig[key];
            }
          });

          window.location = getRedirectUrl({
            redirectUrl: redirectUrl,
            bvdata: hashParams,
            bvinjecteddata: clientAPIConfig && clientAPIConfig.injecteddata ? clientAPIConfig.injecteddata : null
          });
        }
        else if (!BV._internal.container && containerPageUrl) {
          redirectToContainer({}, containerRedirectOptions);
        }
        // If we don't, just pop up submission lightbox
        else {
          loadSubmission(submissionModel);
        }
      }

      // wrapping this code in a function so it can be called asynchronously once a client has handled same container login
      function handleSubmission () {
        // If we're a second level submission (comment, answer, etc.), it's too crazy to do redirects
        // and stuff, so just load immediately for now.
        if (secondaryContentSubmission) {
          // Change the subject for secondary content
          submissionModel.set({
            subjectType: apiSubject,
            subjectId: id
          });
          loadSubmission(submissionModel);
          return;
        }

        // If we're on a container and subjectRedirect is disabled or mobile device, load submission immediately
        if (BV._internal.container && (isMobile || !ENVConfig.container.subjectRedirect)) {
          loadSubmission(submissionModel);
          return;
        }

        // If we're doing a generic review submission/GWAR then load submission immediately
        if (clientAPIConfig.isGenericSubmission) {
          loadSubmission(submissionModel);
          return;
        }

        // If we're on a mobile device, and mobileRedirect is allowed, and the client has a container page
        // and we're not already on it, redirect to it.
        if (isMobile && containerPageUrl && !BV._internal.container && clientAPIConfig.mobileRedirect) {
          redirectToContainer({ bvmobile: true }, containerRedirectOptions);
          return;
        }

        // If we're not a container, and on the right product already, load immediately
        if (!BV._internal.container && submissionModel && !_.isUndefined(id) && submissionModel.getSubject().id === id) {
          loadSubmission(submissionModel);
          return;
        }

        // If we're on the container, or trying to submit for a different top-level subject, try
        // to redirect to the right page and deep-link.
        apiHolder = api.get(subject, id).limitTo(1);
        apiHolder.fetch('subject').done(handleData);
      }
      // If we don't have a componentId, guess one based on subject/content type
      submissionModel = findSubmissionModel(clientAPIConfig.subjectType, clientAPIConfig.contentType, componentId);

      // We couldn't find a model for this submission. Do nothing.
      if (!submissionModel) {
        return;
      }

      // Gather these variables into a bundle. The `redirectToContainer` function
      // needs them in order to do its thing.
      containerRedirectOptions = {
        id: id,
        subject: subject,
        action: action,
        modelSubject: modelSubject,
        clientAPIConfig: clientAPIConfig,
        submissionModel: submissionModel,
        containerPageUrl: containerPageUrl
      };

      copyExistingCallbacks(submissionModel, clientAPIConfig);
      submissionModel.reset({ clientAPIConfig: clientAPIConfig });

      // Check if this product (RR, QA) is configured for Site Auth (user has to login
      // before they can submit content).
      if (ENVConfig.siteAuth[clientAPIConfig.contentType] === true) {
        // Check to see if we were passed in an auth token via URL or the UI call
        userToken = clientAPIConfig.userToken || UrlState.get('userToken', 'bv');
        if (userToken) {
          // TODO: We potentially don't need these. Revisit in the future.
          User.set({ token: userToken });
          submissionModel.set('user', userToken);
        }
        else {
          if (clientAPIConfig.doLogin) {
            clientAPIConfig.doLogin(
              // pass 'successCallback' for clients who perform login on the current page
              function (clientOptions) {
                // Setup Callbacks
                if (clientOptions.error) {
                  Auth.on('error', clientOptions.error);
                }

                clientUserToken = clientOptions.userToken;

                if (!clientUserToken) {
                  Auth.error(new Error('Bazaarvoice: Empty authentication credentials'));
                  return;
                }

                try {
                  // TODO: We potentially don't need these. Revisit in the future.
                  User.set({ token: clientUserToken });
                  submissionModel.set('user', clientUserToken);
                  $BV.configure('global', { userToken: clientUserToken }); // Store this in the global config so it's available for subsequent page actions.
                  // Start Submission Flow
                  handleSubmission();
                }
                catch (e) {
                  Auth.error(new Error('Bazaarvoice: Wrong authentication credentials'));
                }
              }
            );
            return;
          }
          else {
            // if the Safari Private Mode is detected, should not be redirected to the login page. Error message should be shown. See CCS-31826
            component = components.find(function (comp) {
              return comp.type === 'submission';
            });
            if (isSafari) {
              try {
                window.openDatabase(null, null, null, null);
              }
              catch (err) {
                if (err.name === 'SecurityError') {
                  msgView = new SubmissionSubviews.SubmissionMessageView({
                    componentId: component.componentId,
                    message: msgPack.error_ERROR_PRIVATE_BROWSING_MODE(),
                    classList: ['unknown-error'],
                    icon: '&#x2718;'
                  });

                  ModestBox.get('lightbox').pushOrOpen({ view: msgView });
                  return;
                }
              }
            }
            redirectToClientLogin(componentId);
            return;
          }
        }
      }

      handleSubmission();
    }

    modelsInitializedDfd.done(_appSubmit);
  }

  return appSubmit;
});

/**
 * @fileOverview This module provides a function that is used for defining
 * $BV.ui methods. The function receives a configuration object that is used
 * to determine how the resulting $BV.ui method should behave.
 */
BV.define('bv/clientapi/defineMethod',[
  'underscore',
  '$BV',
  'bv/ugc/submit',
  'bv/ugc/init',
  'bv/util/baseConfig',
  'util/consoleError',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'bv/strings'
], function DefineMethod (
  _,
  $BV,
  appSubmit,
  appInit,
  baseConfig,
  consoleError,
  BVReporter,
  BVTracker,
  str
) {
  function setUiActionConfig (scope, method, config) {
    var actionConfig = baseConfig[scope]._actions = baseConfig[scope]._actions || {};
    actionConfig[method] = config;
  }

  function extendConfig (config, methodConfig) {
    if (methodConfig.configProps) {
      return _(config).extend(methodConfig.configProps);
    }
    return config;
  }

  /**
   * The method definition function. This function consumes a configuration
   * object and the clientAPI object ($BV).
   *
   * @param  {object} methodConfig The configuration for the $BV.ui method
   * to be created.
   * @param {Function} methodConfig.only A function to be run without running
   * any validation or any other action.
   * @param {Function} methodConfig.validate A function to validate the configuration
   * provided to the method before taking any action. This function should return
   * false if there are no validation issues; it should return an object with a
   * `warning` property if there is a warning; and it should return an object with an
   * `error` property if there is an error.
   * @param {Boolean} methodConfig.inactive True if the method is inactive.
   * @param {Function} methodConfig.after A function to execute after the core method
   * has been executed. Receives the config, a function for handling submission, and
   * a boolean argument indicating whether the method is a submission method.
   * @param {Boolean} methodConfig.isSubmission Set to true to indicate the method
   * is a submission method.
   * @param  {object} clientAPI    A reference to the clientAPI, which may be
   * needed by some methods.
   * @return {Function}            The function that will be executed when the
   * $BV.ui method corresponding to the methodConfig is called.
   */
  return function defineMethod (methodConfig, clientAPI) {
    var method = methodConfig.method;
    var parts = method.split('_');
    var scope = parts[0];
    var action = parts.slice(1).join('_');
    var errorMsg;
    var errorType;

    // This is the function that actualy executes when a $BV.ui "method"
    // is called. It receives as its only argument the configuration that
    // was passed to $BV.ui. So, for example, if a customer calls
    //
    //   $BV.ui('rr', 'show_reviews', {
    //     productId : 'product1'
    //   });
    //
    // ... then this function receives the { productId : 'product1' }
    // object as its argument.
    return function actualMethod (_config) {
      // The methodConfig may provide some default values on its
      // configProps property. Extend the customer-provided config
      // with these defaults.
      var bvjsAppsScout;
      var didHandle;
      var validated;
      var config = extendConfig(_config || {}, methodConfig);

      // We are starting to break off pieces of Firebird into their own
      // standalone apps. Some of these will need to spy on Firebird UI calls
      // and act in their stead.
      //
      // Thus: if the bv-loader scoutfile is on the page, we should give it
      // dibs on this UI call. It may want to do its own thing.
      //

      // If this property is present on $BV, it means that the
      // bvjs-apps-scoutfile was here before us.
      bvjsAppsScout = $BV && $BV._bvjsAppsScoutfile;
      if ( bvjsAppsScout && _.isFunction(bvjsAppsScout.triggerUICall) ) {
        BVReporter.info('The bvjs-apps scoutfile wants to handle this UI ' +
          'call.', scope, action, config);
        didHandle = bvjsAppsScout.triggerUICall(scope, action, config);
        if (didHandle) {
          BVReporter.info('The bvjs-apps scoutfile successfully handled ' +
          'this UI call, so we can ignore it.');
          // If bvjs-apps handled it, we don't need to do anything. It'll get
          // removed from the queue.
          return;
        }
        else {
          BVReporter.info('The bvjs-apps scoutfile either did not recognize ' +
          'this UI call or failed at handling it. Firebird will continue ' +
          'to process it.');
        }
      }

      // If the methodConfig defines an "only" function, execute it
      // and be done.
      if (methodConfig.only) {
        methodConfig.only(config);
        return;
      }

      // If the methodConfig defines a "validate" function, execute it
      // and handle any errors. The "validate" function is intended to
      // catch implementation errors -- such as failing to pass a product
      // ID when one is required -- and so we will assume that any error
      // of an undefined type is an implementation error.
      //
      // If the validate function does detect an error, it gets logged,
      // and nothing further happens with this call to $BV.ui.
      //
      // Note that if the validate method itself throws an error, it will
      // be caught by clientapi, not handled here.
      if (_(methodConfig.validate).isFunction()) {
        validated = methodConfig.validate(config);

        if (validated && validated.error) {
          errorMsg = validated.error + ' (scope: ' + method + ')';
          errorType = validated.type || 'IMPLEMENTATION';

          BVTracker.error({
            name: str.errors[errorType],
            detail1: errorMsg
          });

          consoleError(errorMsg);
          return;
        }
      }

      // Make sure the methodConfig doesn't say the method is inactive.
      if (!methodConfig.inactive) {
        // Store the config in a global-ish object.
        setUiActionConfig(scope, action, config);

        // Initiate the action associated with the method.
        appInit.actionInit(method, config, methodConfig.isSubmission);
      }

      // Execute any after function specified by the methodConfig.
      // Actions executed here won't interfere with the "core" behavior
      // of the $BV.ui method.
      if (_(methodConfig.after).isFunction()) {
        methodConfig.after(config, appSubmit, clientAPI);
      }
    };

  };
});

/**
 * @fileOverview Connect registered UI extensions with $BV.ui. This does
 * *not* deal with Conversations core UI methods; rather, this facilitates
 * the addition of new $BV.ui methods via the Firebird Extensions API.
 */
BV.define('bv/clientapi/extensions',[
  'BV',
  'underscore',
  'framework/util/bvreporter'
], function (BV, _, BVReporter) {
  var uiExtensionAPI = BV.extensions && BV.extensions.ui;

  function init (uiMethods) {
    // Make already-registered UI extensions full-fledged UI methods.
    // The definition of the UI method will simply be to call the
    // extension's init method, which in turn triggers its 'call' event
    // with the provided config. Do not allow existing UI methods to
    // be redefined.
    _(uiExtensionAPI.getAll()).each(function (uiExtensionName) {
      if (uiMethods[uiExtensionName]) {
        return;
      }

      var ext = uiExtensionAPI.get(uiExtensionName);
      uiMethods[uiExtensionName] = function (clientAPIConfig) {
        ext.init({ config: clientAPIConfig });
      };
    });

    // Listen for future UI extensions to be registered, and also
    // make them full-fledged UI methods. As above, the UI method
    // simply calls the extension's init method, which in turn triggers
    // its 'call' event with the provided config. Do not allow
    // extisting UI methods to be redefined.
    uiExtensionAPI.on('register', function (ext) {
      if (!ext.name) {
        BVReporter.warn('Tried to register extension without a name.');
        return;
      }

      if (!_.isFunction(ext.init)) {
        BVReporter.warn('Tried to register extension without an init method');
        return;
      }

      if (uiMethods[ext.name]) {
        BVReporter.warn('Tried to register extension ' + ext.name + ' but it is already registered.');
        return;
      }

      uiMethods[ext.name] = function (clientAPIConfig) {
        ext.init({ config: clientAPIConfig });
      };
    });

    return uiMethods;
  }

  return {
    init: init
  };
});

/**
 * @fileOverview This file sanitizes a customer-provided configuration.
 * Specifically, it: removes properties from the config object whose values
 * are empty; wraps a provided doShowContent method in error handling;
 * and sanitizes product IDs.
 */
BV.define('bv/clientapi/sanitizeConfig',[
  'underscore',
  'jquery',
  'framework/util/bvtracker',
  'bv/strings'
], function (_, $, BVTracker, str) {
  // Regex for non-alphanumeric character except _ and -
  var nonAlphExpr = /[^a-zA-Z0-9_\-]/ig;

  function throwError (type, id) {
    var errorMessage = [
      'IMPL:',
      type,
      'for inline ratings should not contain non-alphanumeric characters except underscore and dash.'
    ].join(' ');

    BVTracker.error({
      name: str.errors.IMPLEMENTATION,
      detail1: errorMessage,
      detail2: id
    });

    throw new Error(errorMessage);
  }

  function deleteWhitespaceValues (config) {
    // Delete any keys that are just whitespace
    _(config).forEach(function (value, key) {
      if (_(value).isString() && $.trim(value) === '') {
        delete config[key];
      }
    });

    return config;
  }

  function wrapDoShowContent (config) {
    // If a customer puts bad code in their doShowContent, we want those
    // errors to be clearly labeled in magpie so we know they are implementation
    // errors, not our errors.
    if (!_(config.doShowContent).isFunction()) {
      return config;
    }

    var oldDoShowContent = config.doShowContent;

    config.doShowContent = function () {
      try {
        return oldDoShowContent.apply(config, arguments);
      }
      catch (e) {
        throw new Error('IMPL: doShowContent: ' + e.toString());
      }
    };

    return config;
  }

  function cleanProductIds (config) {
    if (!config.productIds) {
      return config;
    }

    // For inline-rating, if a product id contains non-alphanumeric characters (except _ and -)
    // they must provide a containerId for this product.
    // Otherwise, we shall throw an implementation error.

    _(config.productIds).each(function (product, pid) {
      if (!product) {
        return;
      }

      var cleanPid;

      if (_(product).isObject()) {
        // We're dealing with something that looks something like this:
        //
        // {
        //   productIds : {
        //     product1 : {
        //       containerId : 'foo'
        //     }
        //   }
        // }
        cleanPid = $.trim(pid.toLowerCase());

        // Throw error if cleaned pid isn't alphanumeric
        // and either there is no containerId or the containerId
        // is not alphanumeric.
        if (
          nonAlphExpr.test(cleanPid) &&
          (
            _(product.containerId).isEmpty() ||
            nonAlphExpr.test(product.containerId)
          )
        ) {
          throwError('productId', cleanPid);
        }

        // Throw error if there is a containerId but it's
        // not alphanumeric.
        if (
          !_(product.containerId).isEmpty() &&
          nonAlphExpr.test(product.containerId)
        ) {
          throwError('containerId', product.containerId);
        }

        // Use the cleaned pid if it's different from the original
        if (cleanPid !== pid) {
          // UIA-3594: Preserve the original product ID,
          // used when rendering inline reviews
          product._origId = $.trim(pid);

          config.productIds[cleanPid] = product;
          delete config.productIds[pid];
        }
      }
      else {
        // We're dealing with something that looks something like this:
        //
        // {
        //   productIds : [ 'product1', 'product2' ]
        // }
        cleanPid = $.trim((product + '').toLowerCase());

        if (nonAlphExpr.test(cleanPid)) {
          throwError('productId', cleanPid);
        }

        config.productIds[pid] = $.trim(product);
      }
    });

    return config;
  }

  var sanitizeConfig = {
    sanitize: function (config) {
      // These are called this way so they can be stubbed in tests;
      // don't replace them with the raw function names.
      config = sanitizeConfig.deleteWhitespaceValues(config);
      config = sanitizeConfig.wrapDoShowContent(config);
      config = sanitizeConfig.cleanProductIds(config);

      return config;
    },

    // These are exposed only for testing purposes
    wrapDoShowContent: wrapDoShowContent,
    cleanProductIds: cleanProductIds,
    deleteWhitespaceValues: deleteWhitespaceValues
  };

  return sanitizeConfig;
});

/**
 * @fileOverview This function is used by the main clientapi file to
 * measure the performance of individual $BV.ui calls.
 */
BV.define('bv/clientapi/performanceMeasurements',[
  'underscore',
  'framework/performance',
  'framework/util/bvreporter',
  'framework/util/bvtracker',
  'window',
  'BV'
], function PerformanceMeasurements (
  _,
  performance,
  BVReporter,
  BVTracker,
  window,
  BV
) {

  return function _clientAPI (clientAPI) {

    function _callTimelineEnd () {
      // Explicitly fallback to `false` where not supported, as IE8
      // is known to do weird things when invoking methods against
      // the console object, and Verizon breaks console in IE11.
      var timelineEnd = false;
      if (window.console) {
        if (window.console.timeEnd) {
          timelineEnd = window.console.timeEnd;
        }
        else if (window.console.timelineEnd) {
          timelineEnd = window.console.timelineEnd;
        }
      }

      if (timelineEnd) {
        timelineEnd.call(window.console, 'scout-to-render');
      }
    }

    return function _method (method) {
      var timings;
      var internalTiming;
      var renderData;
      var completedData;
      var markName;

      BVReporter.timeEnd('UI method render ' + method);

      if (method === 'rr_show_reviews') {
        _callTimelineEnd();
      }

      timings = clientAPI._timings[method];

      internalTiming = BV._internal.timing = BV._internal.timing || { ui: {} };
      timings.init = internalTiming.ui[method] && internalTiming.ui[method].init;
      timings.end = new Date().getTime();

      renderData = {
        name: '$BV.ui ' + method,
        elapsedMs: timings.end - timings.start
      };

      completedData = {
        name: '$BV.ui ' + method,
        elapsedMs: timings.end - timings.init
      };

      _(['productId', 'categoryId']).forEach(function forEachProp (prop) {
        renderData[prop] = timings.config[prop];
        completedData[prop] = internalTiming.ui[method] && internalTiming.ui[method].config[prop];
      });

      // The bv-rendered event measures the time from when the core app file
      // (bv-primary) was loaded to the time when the results of the ui method
      // appeared on the page.
      if (performance.getEntriesByName('primaryStart').length > 0) {
        performance.log.warn('bv-' + method + '-rendered', 'primaryStart');
      }

      // The bv-completed event measures the time from when the $BV.ui call was
      // first made to the time the results of the ui method appeared on the
      // page. This accounts for the possibility that a customer made a $BV.ui
      // call after the scout file was loaded, but before bv-primary was loaded,
      // while *also* accounting for the possibility that a customer didn't make
      // a $BV.ui call until some later time. See also bv/bootstrap/slowPath.js.
      markName = method + '-call';
      if (performance.getEntriesByName(markName).length > 0) {
        performance.log.warn('bv-' + method + '-completed', markName);
      }

      // If preload timing is available and we have not emitted it yet, do so.
      if (performance.getEntriesByName('bv-preload-start').length > 0 &&
        performance.getEntriesByName('bv-preload-end').length > 0 &&
        performance.getEntriesByName('bv-preload').length < 1
      ) {
        performance.
          log.warn('bv-preload', 'bv-preload-start', 'bv-preload-end');
      }
    };
  };
});

/**
 * @fileOverview This module provides the function that should
 * be called on the first $BV.ui call.
 */
BV.define('bv/clientapi/firstUI',[
  'underscore',
  'ENV',
  'bv/clientapi/performanceMeasurements'
], function (_, ENV, performanceMeasurements) {
  return _.once(function (clientAPIConfig, clientAPI) {
    ENV.trigger('firstUI', clientAPIConfig);
    ENV.on('init:viewsRendered', performanceMeasurements(clientAPI));
  });
});

/**
 * @fileOverview This module is used by bv/clientapi to
 * set the user token based on the clientAPIConfig.
 */
BV.define('bv/clientapi/checkUserToken',[
  'bv/util/user'
], function (User) {
  return function (clientAPIConfig) {
    var userToken = clientAPIConfig.userToken || clientAPIConfig.authToken;
    if (userToken) {
      User.set({ token: userToken });
    }
  };
});

BV.define('bv/clientapi/normalizeTransactionData',[
  'underscore'
], function (_) {
  return function (trans) {
    // Clone trans object (since we're going to modify it).
    trans = _.extend({}, trans || {});

    // Legacy remap transaction_id -> orderId.
    if (_(trans).has('transaction_id')) {
      trans.orderId = trans.transaction_id;
      delete trans.transaction_id;
    }

    // Legacy remap products -> items.
    if (_(trans).has('products')) {
      trans.items = trans.products;
      delete trans.products;
    }

    if (_.isArray(trans.items)) {
      var x;
      var len;
      for (x = 0, len = trans.items.length; x < len; x++) {
        trans.items[x].orderId = trans.orderId;

        // Legacy remap product_id -> sku.
        if (_(trans.items[x]).has('product_id')) {
          trans.items[x].sku = trans.items[x].product_id;
          delete trans.items[x].product_id;
        }
      }
    }

    _(trans).defaults({
      type: 'Transaction',
      label: 'TransactionThankYou',
      value: null
    });

    return trans;
  };
});

/*global console:false */

/**
 * @fileOverview This file creates the functionality that is
 * exposed on $BV, which is how customers integrate and interact
 * with the Conversations user interface application.
 */
BV.define('bv/clientapi',[
  'ENV',
  'jquery',
  'window',
  'underscore',
  'BV',

  'bv/clientAPISetup',
  'bv/ugc/init',
  'bv/util/domainPolice',
  'bv/util/productInfo',
  'bv/strings',
  'framework/clientEvents',
  'framework/util/bvreporter',
  'framework/util/extensionsRegistry',
  'bv/util/baseConfig',
  'framework/util/bvtracker',
  'bv/c2013/methods',
  'bv/util/isDev',
  'util/consoleError',
  'bv/util/bvLocal',

  'bv/clientapi/defineMethod',
  'bv/clientapi/extensions',
  'bv/clientapi/sanitizeConfig',
  'bv/clientapi/performanceMeasurements',
  'bv/clientapi/firstUI',
  'bv/clientapi/checkUserToken',
  'bv/clientapi/normalizeTransactionData'
],
function (
  ENV,
  $,
  window,
  _,
  BV,

  clientAPISetup,
  appInit,
  DomainPolice,
  ProductInfo,
  str,
  ClientEvents,
  BVReporter,
  extensionsRegistry,
  baseConfig,
  BVTracker,
  C2013Methods,
  isDev,
  consoleError,
  bvLocal,

  defineMethod,
  uiExtensionAPI,
  sanitize,
  performanceMeasurements,
  firstUI,
  checkUserToken,
  normalizeTransactionData
) {
  var options = ENV.get('config');
  sanitize = sanitize.sanitize;

  // Mapping from firebird config to $BV config - may want to refactor this
  // later so we don't have to do this.
  var defaultConfig = {
    categoryId: options.categoryId,
    productIds: options.productIds,
    productId: options.productId
  };

  clientAPISetup();

  var ui_methods = {};
  var methodConfigs = C2013Methods;

  _(methodConfigs).each(function (methodConfig) {
    var method = methodConfig.method;
    ui_methods[method] = defineMethod(methodConfig, clientAPI);
  });

  ui_methods = uiExtensionAPI.init(ui_methods);

  var clientAPI = {

    _timings: {},

    ui: function () {
      // Check the whitelist for the current domain.
      var allowed = bvLocal.config.isLocalNode || !!DomainPolice.allowedDomain();
      if (!allowed) {
        return consoleError('Bazaarvoice is not configured for this domain: ' + window.location.host);
      }

      var args = [].slice.call(arguments);
      var clientAPIConfig = args[args.length - 1];
      var scope = args[0];
      var method = [];
      var methodName;

      var config = $.extend({}, defaultConfig, baseConfig.global, baseConfig[scope], clientAPIConfig);
      if (scope) {
        method.push(scope);
      }
      if (args.length > 2) {
        method.push(args[1]);
      }

      methodName = method.join('_').toLowerCase();

      var ext = extensionsRegistry['ui.' + methodName];

      if (ext && clientAPI.queueProcessed) {
        ext.trigger('call', config);
      }

      sanitize(config);
      checkUserToken(config);
      firstUI(config, clientAPI);
      appInit.initialize(config);

      if (ext) {
        ext.trigger('invoke', config);
      }

      BVReporter.group(BVReporter.INFO, 'UI method', methodName);
      BVReporter.time('UI method render ' + methodName);

      clientAPI._timings[methodName] = {
        start: new Date().getTime(),
        config: clientAPIConfig
      };

      function callUIMethod () {
        ui_methods[methodName](config);
      }

      // Allow useful stack traces when on localhost.bazaarvoice.com
      if (isDev && !config.logUncaughtExceptions) {
        callUIMethod();
        BVReporter.groupEnd(BVReporter.INFO, 'UI method', methodName);
        return;
      }

      try {
        callUIMethod();
      }
      catch (e) {
        var errorMessage = [
          'BV:',
          _(e).isString() ? e : e.message,
          '(' + ((args.length === 2) ? ('method: ' + args[0]) : ('scope: ' + args[0] + ' method: ' + args[1])) + ')'
        ].join(' ');

        BVTracker.error({
          name: str.errors.UNCAUGHT,
          detail1: errorMessage
        });
      }

    },

    startRouters: function () {
      appInit.startRouters();
    },

    container: function (scope, clientAPIConfig) {
      sanitize(clientAPIConfig);
      _.extend(BV._internal, {
        preload: null,
        container: true
      });
      BV.require(['secondary'], function (app) {
        app.Container.init(clientAPIConfig);
      });
    },

    configure: function (scope, clientAPIConfig) {
      sanitize(clientAPIConfig);
      $.extend(baseConfig[scope], clientAPIConfig);

      var err;

      if (clientAPIConfig.events) {
        if (scope !== 'global') {
          err = new Error('IMPL: event handlers can only be set in global config');
          BVTracker.error({
            name: str.errors.IMPLEMENTATION,
            detail1: err.message
          });
          throw err;
        }

        if (!_(clientAPIConfig.events).isObject()) {
          err = new Error('IMPL: events property in global config must be an object');
          BVTracker.error({
            name: str.errors.IMPLEMENTATION,
            detail1: err.message
          });
          throw err;
        }

        ClientEvents.register(clientAPIConfig.events);
      }
    },

    ready: function (callback) {
      if (_.isFunction(callback)) {
        callback();
      }
    },

    SI_trackProductPageView: function (pid) {
      BVTracker.pageview({
        type: 'Product',
        label: 'Default',
        subjectType: 'product',
        subjectId: pid,

        // TODO: this is always going to be null presently;
        // not sure whether that's what's intended or not. -RM
        productId: ProductInfo.getId(this)
      });
    },

    SI_trackGenericPageView: function () {
      BVTracker.pageview({
        type: 'Product',
        label: 'Default',

        // TODO: this is always going to be null presently;
        // not sure whether that's what's intended or not. -RM
        productId: ProductInfo.getId(this)
      });
    },

    SI_trackTransactionPageView: function (trans) {
      trans = normalizeTransactionData(trans);
      BVTracker.conversion(trans);
    },

    SI_trackConversion: function (conversion) {
      var data = {};

      // Peel off common properties.
      _(['type', 'label', 'value']).each(function (prop) {
        if (_(conversion).has(prop)) {
          data[prop] = conversion[prop];
          delete conversion[prop];
        }
      });

      BVTracker.conversion(data, conversion);
    },

    // Deprecated, but here for backwards compat.
    SI_disable: function () {},
    SI_enable: function () {},
    SI_setDebugEnabled: function (value) {},

    product: null,

    DSI_trackBVPageView: function () {
      if (clientAPI.product) {
        clientAPI.SI_trackProductPageView(clientAPI.product);
      }
      else {
        clientAPI.SI_trackGenericPageView();
      }
    },

    DSI_trackProduct: function (pid) {
      clientAPI.product = pid;
    },

    DSI_trackTransaction: function (data) {
      clientAPI.SI_trackTransactionPageView(data);
    }
  };

  return clientAPI;
});

/**
 * @fileOverview This file processes a queued $BV method call
 * and passes it to the actual $BV method. This is used by
 * bv/bootstrap/slowPath.
 */
BV.define('bv/bootstrap/callHandler',[
  'client!$BV',
  'BV',
  'bv/clientapi'
], function ($BV, BV, clientAPI) {
  return function (apiCall) {
    // TODO: make this better... need to handle analytics too.
    var apiFn = apiCall.shift();
    // Add scope to args (ex: 'rr').
    var args = [apiCall.shift()];

    if (apiFn === 'ui') {
      // Add method to args (ex: 'show_reviews').
      args.push(apiCall.shift());
    }

    // Add config to args (ex: { productId: 'test1' }).
    args.push(apiCall.shift() || {});

    if (apiFn === 'ui') {
      // If the api call queue has already been processed,
      // we need to start tracking timings for
      // API calls, just like we do in the scout file.
      if (!$BV._apiQueue && BV._internal.timing) {
        BV._internal.timing.ui[args.slice(0, 2).join('_')] = {
          init: new Date().getTime(),
          config: args[args.length - 1]
        };
      }
    }

    clientAPI[apiFn].apply(clientAPI, args);
  };
});

BV.define('util/pluralform!',['vendor/messageformat'], function (MessageFormat) {
MessageFormat.locale.en = function ( n ) {
  if ( n === 1 ) {
    return "one";
  }
  return "other";
};
   return MessageFormat;
});
/**
 * @fileOverview This file loads the "core" of the Firebird app,
 * and kicks off any queued $BV.ui calls.
 */
BV.define('bv/bootstrap/slowPath',[
  'vendor/jquery/importantizer',
  'underscore',
  'util/has',
  'ENV',
  'bv/clientapi',
  'client!bv/util/cssLoadCheck',
  'window',
  'client!$BV',
  'BV',
  'framework/util/bvtracker',
  'framework/performance',
  'bv/bootstrap/callHandler',
  'util/pluralform!'
], function (
  $,
  _,
  has,
  ENV,
  clientAPI,
  cssLoadCheck,
  window,
  $BV,
  BV,
  BVTracker,
  performance,
  callHandler,
  MessageFormat
) {
  var now = new Date();
  var _internal = BV._internal;
  var perfResults = _internal.perfResults = {};

  performance.mark('slowPathStart');

  // We will not attempt to record timing data for unbuilt clients or during
  // server render.
  if (!BV.serverRender &&
    performance.getEntriesByName('primaryStart').length > 0
  ) {
    _.defer(function () {
      // time elapsed until start of scout file
      var scoutStart = performance.getEntriesByName('scoutStart')[0];
      performance.track({
        name: 'bv-scout-start',
        startTime: 0,
        duration: scoutStart.startTime
      });

      // time elapsed from start of scout file to start of bv-primary
      performance.log.warn('bv-primary-ready', 'scoutStart', 'primaryStart');

      // time elapsed for bv-primary to run to completion
      performance.log.warn('bv-primary-run', 'primaryStart', 'primaryEnd');

      // time elapsed from start of bv-primary until now
      performance.log.
        warn('bv-slow-path-ready', 'primaryStart', 'slowPathStart');

      // time elapsed from start of scout file until now
      performance.log.warn('bv-core-app', 'scoutStart', 'slowPathStart');

      // time elapsed from start of scout file until load
      //
      // This metric is only emitted in browsers that implement the Navigation
      // Timing API. In other browsers, load timing data cannot be accurately
      // calculated.
      if (window.performance && window.performance.timing) {
        if (window.performance.timing.loadEventStart) {
          performance.log.warn('bv-host-load', 'scoutStart', 'loadEventStart');
        }
        else {
          $(window).on('load', function () {
            performance.log.warn(
              'bv-host-load', 'scoutStart', 'loadEventStart');
          });
        }
      }
    });
  }

  return function () {
    var options = BV.options || {};

    ENV.set('cssLoaded', cssLoadCheck);

    // Loop through queued $BV API calls and pass them on to actual client API.
    performance.mark('queued-ui-calls-start');
    performance.measure(
      'queued-ui-calls-ready', 'scoutStart', 'queued-ui-calls-start'
    );

    while ($BV._apiQueue && $BV._apiQueue.length) {
      callHandler($BV._apiQueue.shift());
    }

    performance.mark('queued-ui-calls-end');
    performance.measure(
      'queued-ui-calls-run', 'queued-ui-calls-start', 'queued-ui-calls-end'
    );

    // Kill queue
    delete $BV._apiQueue;

    // From now on, instead of pushing onto queue, just do it.
    $BV.push = callHandler;
    clientAPI.queueProcessed = true;

    _(options.has).forEach(function (res, name) {
      has.add(name, function () {
        return res;
      });
    });
  };
});

(function () {

  if (BV.serverRender) {
    return;
  }

  BV.require({
    baseUrl: BV._internal ? BV._internal.baseUrl + '/scripts/' : '/',
    context: (typeof window.DimSum !== 'undefined') ? '_' : '_BV',
    paths: {
      template: '../template',

      underscore: 'vendor/_',
      backbone: 'vendor/backbone',
      jquery: 'vendor/jquery',

      // We put our requirejs plugins in a separate dir for sanity. If you add a plugin,
      // you should also put it in the appropriate dir (static/dev/scripts/require_plugins)
      // -- don't just put it in the root, please!
      //
      // When adding a requirejs plugin, or updating our require config you need
      // to update FOUR places:
      // - static/dev/scripts/primary.js
      // - config/app.build.base.js
      // - test/unit-node.js
      // - server/lib/views/test/unitTestsModule.hbs
      hbs: 'require_plugins/hbs',
      mf: 'require_plugins/mf',
      components: 'require_plugins/components',
      views: 'require_plugins/views',
      client: 'require_plugins/client',
      text: 'require_plugins/text',
      serverFetch: 'require_plugins/serverFetch',
      dimsumFields: 'require_plugins/dimsumFields',
      cssdata: 'require_plugins/cssdata',
      mappings: 'require_plugins/mappings',
      ratingIconCharMap: 'require_plugins/ratingIconCharMap',
      badges: 'require_plugins/badges',
      staticAssets: 'require_plugins/staticAssetService',

      // This is required by Dimsum Inline preview
      // RequireJS has a baseUrl of:
      //   domain/static/<clientName>/<siteId>/<firebirdVersion>/default/<locale>/scripts/
      // Doing this, causes:
      //   https://preview.bazaarvoice.com/static/testcustomer-configui/main_site/0/default/en_US/scripts/../../../../../../../dimsum.js
      // Thus:
      //   https://preview.bazaarvoice.com/dimsum.js
      dimsum: '../../../../../../../dimsum'
    },

    components: BV.options.components,
    style: BV.options.style,
    has: BV.options.has,
    locale: BV.options.locale,
    locales: BV.options.locales,
    contentLocales: BV.options.contentLocales,
    views: BV.options.views,
    siteConfig: BV.options.siteConfig,
    dimsumFields: BV.options.dimsumFields,

    
    fqhn: BV.options.fqhn,
    exists: BV.options.exists,
    waitSeconds: 20

  }, [
    'require',
    'bv/bootstrap/slowPath' /* ,
    'bv/bootstrap/fastPath' */
  ], function (require, slowPath /* , fastPath */) {
    BV.require = require;
    slowPath();

    // if (typeof window.DimSum === 'undefined') {
    //   fastPath();
    // }

    // BV.require(['app'], function (slowPath) {
    //   slowPath();
    // });
  });

})();

BV.define("primary",[], function(){});


  if (!window.BV.serverRender) {
    window.BV.performance.mark('primaryEnd');
    window.BV._internal.primaryEndTime = new Date();
  }
})();
